var tipuesearch = {"pages":[{"title":" BROWNPAK ","text":"BROWNPAK Developer Info Sarit Dutta","tags":"home","loc":"index.html"},{"title":"aabbtree_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~aabbtree_m.f90~~EfferentGraph sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~aabbtree_m.f90->sourcefile~constants_m.f90 sourcefile~aabb_m.fpp aabb_m.fpp sourcefile~aabbtree_m.f90->sourcefile~aabb_m.fpp sourcefile~vector_m.f90 vector_m.f90 sourcefile~aabbtree_m.f90->sourcefile~vector_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~aabbtree_m.f90->sourcefile~strings_m.f90 sourcefile~aabb_m.fpp->sourcefile~constants_m.f90 sourcefile~aabb_m.fpp->sourcefile~strings_m.f90 sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~aabbtree_m.f90~~AfferentGraph sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~aabbtree_sm.fpp aabbtree_sm.fpp sourcefile~aabbtree_sm.fpp->sourcefile~aabbtree_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~pairtab_m.fpp->sourcefile~aabbtree_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules aabbtree_m Source Code aabbtree_m.f90 Source Code ! This code is adapted from the C++ implementation by ! [Lester Hedges](http://lesterhedges.net). The original ! C++ implementation can be found [here](https://github.com/lohedges/aabbcc#readme). ! !****************************************************************************! !                                                                            ! ! The zlib/libpng License (Zlib)                                             ! !                                                                            ! ! Copyright (c) 2009 Erin Catto http://www.box2d.org                         ! ! Copyright (c) 2016 Lester Hedges <lester.hedges+aabbcc@gmail.com>          ! !                                                                            ! ! This software is provided 'as-is', without any express or implied          ! ! warranty. In no event will the authors be held liable for any damages      ! ! arising from the use of this software.                                     ! !                                                                            ! ! Permission is granted to anyone to use this software for any purpose,      ! ! including commercial applications, and to alter it and redistribute it     ! ! freely, subject to the following restrictions:                             ! !                                                                            ! ! 1. The origin of this software must not be misrepresented; you must not    ! !    claim that you wrote the original software. If you use this software    ! !    in a product, an acknowledgment in the product documentation would be   ! !    appreciated but is not required.                                        ! !                                                                            ! ! 2. Altered source versions must be plainly marked as such, and must not be ! !    misrepresented as being the original software.                          ! !                                                                            ! ! 3. This notice may not be removed or altered from any source distribution. ! !                                                                            ! ! This code was adapted from parts of the Box2D Physics Engine,              ! ! http://www.box2d.org                                                       ! !                                                                            ! !****************************************************************************! module aabbtree_m !! Implements an axis-aligned bounding box (AABB) tree. !! This code is adapted from the C++ implementation by !! [Lester Hedges](http://lesterhedges.net). The original !! C++ implementation can be found [here](https://github.com/lohedges/aabbcc#readme). use constants_m use strings_m use vector_m use aabb_m implicit none private public :: aabbtree_t integer , parameter :: NULL_NODE = 0 type node_t integer :: next = NULL_NODE integer :: parent = NULL_NODE integer :: left = NULL_NODE integer :: right = NULL_NODE integer :: height = - 1 integer :: atom = 0 type ( aabb_t ) :: aabb contains procedure :: init => node_init procedure :: isleaf => node_isleaf procedure :: asstr => node_asstr end type node_t type ( ivector_t ) :: stack type aabbtree_t type ( node_t ), dimension (:), allocatable :: nodes integer , dimension (:), allocatable :: atnd_tab !! Atom -> node map. integer :: capacity !! Maximum number of nodes that the tree can currently handle. This may !! increase as more atoms are inserted. integer :: freestore !! Pointer to head to the free store. integer :: size !! Number of nodes in the tree. integer :: root !! Pointer to the tree root. real ( rp ) :: tskin !! Thickness of the skin for fattened AABBs, as a fraction of the AABB !! base length. contains procedure :: init procedure :: print procedure :: clear procedure :: delete procedure :: insert procedure :: remove procedure :: remove_all procedure :: update_fatm procedure :: update_fatmaabb generic :: update => update_fatm , update_fatmaabb procedure :: query_watm procedure :: query_waabb procedure :: query_watmaabb generic :: query => query_watm , query_waabb , query_watmaabb procedure :: get_num_atoms procedure :: get_aabb procedure :: get_height procedure :: get_max_balance procedure :: get_srfarea_ratio procedure :: rebuild procedure :: validate procedure , private :: insert_leaf procedure , private :: remove_leaf procedure , private :: balance procedure , private :: calc_height procedure , private :: fs_acquire procedure , private :: fs_return procedure , private :: validate_structure procedure , private :: validate_metrics end type aabbtree_t interface module subroutine node_init ( this ) !! Initializes a node. class ( node_t ), intent ( out ) :: this !! A *node_t* instance. end subroutine module function node_isleaf ( this ) result ( res ) !! Is this a leaf node? class ( node_t ), intent ( in ) :: this !! A *node_t* instance. logical :: res !! *true* if this is a leaf node, *false* otherwise. end function module function node_asstr ( this , frmt ) result ( buf ) !! Returns a string representation of a node. class ( node_t ), intent ( in ) :: this !! A *node_t* instance. character ( len =* ), intent ( in ), optional :: frmt !! Format string for real numbers, e.g. '(f15.6)'. Default: *(g0.6)*. character ( len = :), allocatable :: buf !! Return value end function module subroutine init ( this , natoms , tskin ) !! Initializes an AABB tree. class ( aabbtree_t ), intent ( out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: natoms !! Estimated number of atoms to be handled by this tree. real ( rp ), intent ( in ) :: tskin !! Thickness of the skin for fattened AABBs, as a fraction of the !! AABB base length. end subroutine module recursive subroutine print ( this , p ) !! Prints a subtree of an AABB tree rooted at `p` in order. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ), optional :: p !! Pointer to the root of the subtree. Default is the root of the !! whole tree. end subroutine module subroutine clear ( this ) !! Clears an AABB tree. Associated memory is not deallocated. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. end subroutine module subroutine delete ( this ) !! Deletes an AABB tree. All associated memory is deallocated. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. end subroutine module subroutine insert ( this , ia , pos , radius ) !! Inserts an atom into an AABB tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index real ( rp ), dimension ( 3 ), intent ( in ) :: pos !! Atom position real ( rp ), intent ( in ) :: radius !! Atom radius (or cutoff distance for point particles) end subroutine module subroutine remove ( this , ia ) !! Removes an atom from an AABB tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index end subroutine module subroutine remove_all ( this ) !! Removes all atoms from an AABB tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. end subroutine module subroutine update_fatm ( this , ia , pos , radius , lstat ) !! Updates an AABB tree for the case when an atom leaves its fattened !! AABB. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index real ( rp ), dimension ( 3 ), intent ( in ) :: pos !! Atom position real ( rp ), intent ( in ) :: radius !! Atom radius (or cutoff distance for point particles) logical , intent ( out ) :: lstat !! *true* if the atom was reinserted, *false* otherwise. end subroutine module subroutine update_fatmaabb ( this , ia , lbnd , ubnd , lstat ) !! Updates an AABB tree for the case when an atom leaves its fattened !! AABB, with the bounds of the new AABB for the atom as input. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index real ( rp ), dimension ( 3 ), intent ( in ) :: lbnd !! Lower bound of atom AABB real ( rp ), dimension ( 3 ), intent ( in ) :: ubnd !! Upper bound of atom AABB logical , intent ( out ) :: lstat !! *true* if the atom was reinserted, *false* otherwise. end subroutine module subroutine query_watm ( this , ia , nbrs ) !! Query an AABB tree for a set of potential neighbors of an atom. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index type ( ivector_t ), intent ( in out ) :: nbrs !! List of potential neighbors. end subroutine module subroutine query_watmaabb ( this , ia , aabb , nbrs ) !! Query an AABB tree for a set of potential neighbors of an atom & its !! bounding AABB. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index. type ( aabb_t ), intent ( in ) :: aabb !! Bounding AABB for atom with index `ia`. type ( ivector_t ), intent ( in out ) :: nbrs !! List of potential neighbors. end subroutine module subroutine query_waabb ( this , aabb , atms ) !! Query an AABB tree for the set of atoms whose AABBS overlap with !! `aabb`. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. type ( aabb_t ), intent ( in ) :: aabb !! An *aabb_t* instance. type ( ivector_t ), intent ( in out ) :: atms !! List of potential neighbors. end subroutine module function get_num_atoms ( this ) result ( na ) !! Returns the number of atoms in an AABB tree. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer :: na !! Return value end function module function get_aabb ( this , ia ) result ( aabb ) !! Returns a copy of the AABB associated with atom with index `ia`. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index. type ( aabb_t ) :: aabb !! AABB of atom `ia`. end function module function get_height ( this ) result ( height ) !! Returns the height of an AABB tree. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer :: height !! Return value. end function module function get_max_balance ( this ) result ( max_balance ) !! Returns the maximum difference between the height of two children !! of a node. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer :: max_balance !! Return value. end function module function get_srfarea_ratio ( this ) result ( saratio ) !! Returns the ratio of the sum of the node surface area to the surface !! area of the root node. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. real ( rp ) :: saratio !! Return value. end function module subroutine rebuild ( this ) !! Rebuilds an optimal AABB tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. end subroutine module subroutine validate ( this ) !! Validates an AABB tree. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. end subroutine module subroutine insert_leaf ( this , leaf ) !! Inserts a leaf node into a tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: leaf !! Pointer to a leaf node end subroutine module subroutine remove_leaf ( this , leaf ) !! Removes a leaf node from a tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: leaf !! Pointer to a leaf node end subroutine module function balance ( this , p ) result ( q ) !! Balances an AABB tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: p !! Node index integer :: q end function module recursive function calc_height ( this , p ) result ( height ) !! Calculates the height of a subtree. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ), optional :: p !! Pointer to the root of the subtree. Default: Root of the whole !! tree. integer :: height !! Return value end function module function fs_acquire ( this ) result ( p ) !! Acquires a new node from the free store and returns a pointer to it. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer :: p !! Return value end function module subroutine fs_return ( this , p ) !! Returns a node to the free store. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: p !! Node pointer. end subroutine module recursive subroutine validate_structure ( this , p ) !! Asserts that an AABB subtree has a valid structure. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: p !! Pointer to the root of the subtree. end subroutine module recursive subroutine validate_metrics ( this , p ) !! Asserts that an AABB subtree has a valid metric. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: p !! Pointer to the root of the subtree. end subroutine end interface !******************************************************************************* end module aabbtree_m","tags":"","loc":"sourcefile/aabbtree_m.f90.html"},{"title":"cell_list_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~cell_list_m.f90~~EfferentGraph sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~cell_list_m.f90->sourcefile~simbox_m.f90 sourcefile~vector_m.f90 vector_m.f90 sourcefile~cell_list_m.f90->sourcefile~vector_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~cell_list_m.f90->sourcefile~constants_m.f90 sourcefile~simbox_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90 random_m.f90 sourcefile~simbox_m.f90->sourcefile~random_m.f90 sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~cell_list_m.f90~~AfferentGraph sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~pairtab_m.fpp->sourcefile~cell_list_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules cell_list_m Source Code cell_list_m.f90 Source Code module cell_list_m !! Sorts atoms using a cell list. !! !! The algorithm to build the cell list partially follows the techniques in Watanabe et !! al, 2011, “Efficient Implementations of Molecular Dynamics Simulations for !! Lennard-Jones Systems,” Prog. Theor. Phys. 126, 203–235. !! !! The pairlist is not explicitly built, rather the cells are directly !! looped over during force calculation. use constants_m use vector_m use simbox_m implicit none private public :: cl_init , cl_delete , cl_print , & cl_set_cell_size , cl_build , cl_build_cell_nbrs , & cl_get_num_cells , cl_get_contents , cl_get_nbr_cells real ( rp ), dimension ( 3 ) :: cell_size = 0.0_rp !! Cell size along *x*, *y*, & *z*. integer , dimension ( 3 ) :: nc_max = 0 !! Maximum number of cells along *x*, *y*, & *z*. integer , dimension ( 3 ) :: nc = 0 !! Number of cells along *x*, *y*, & *z*. integer :: nct_max = 0 !! Maximum total number of cells. integer :: nct = 0 !! Total of cells. integer , dimension (:), allocatable , target :: cells !! *(na_max,)* array. Listing atoms in each cell. integer , dimension (:), allocatable :: cells_pos !! *(0:nct_max,)* index array. Note: 0-based indexing. type ( ivector_t ) :: cell_nbrs !! Lists neighbor cells for each cell. integer , dimension (:), allocatable :: cell_nbrs_pos !! *(0:nct_max,)* index array. Note: 0-based indexing. integer , dimension (:), allocatable :: host_cells !! *(na_max,)* array. *host_cells(i)* stores the linear index of the cell !! containing atom *i*. *na_max* is the total number of atoms under consideration. integer , dimension (:), allocatable :: cell_pop !! *(0:nct_max-1,)* array storing population of each cell. Note: 0-based indexing. integer , dimension ( 3 , 13 ), parameter :: d = reshape ( [ & & 1 , 0 , 0 , & & 1 , 1 , 0 , - 1 , 1 , 0 , 0 , 1 , 0 , & & 0 , 0 , 1 , - 1 , 0 , 1 , 1 , 0 , 1 , & & - 1 , - 1 , 1 , 0 , - 1 , 1 , 1 , - 1 , 1 , & & - 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 ], [ 3 , 13 ] ) contains !****************************************************************************** subroutine cl_init ( na_max , cs_min , simbox ) !! Initializes a cell list. integer , intent ( in ) :: na_max !! Maximum number of atoms to be handled. real ( rp ), intent ( in ) :: cs_min !! Minimum size (i.e. length) of a cell. type ( smbx_t ), intent ( in ) :: simbox !! Simulation box integer :: nelem !The following defines an upper bound on the number of cells nc_max ( 1 ) = ceiling ( simbox % basis ( 1 , 1 ) / cs_min ) nc_max ( 2 ) = ceiling ( simbox % basis ( 2 , 2 ) / cs_min ) nc_max ( 3 ) = ceiling ( simbox % basis ( 3 , 3 ) / cs_min ) nct_max = product ( nc_max ) allocate ( cells ( na_max )) allocate ( cells_pos ( 0 : nct_max )) allocate ( host_cells ( na_max )) allocate ( cell_pop ( 0 : nct_max - 1 )) !Provisional allocation with nelem (arbitrary) elements, !will expand/contract later. nelem = 8 call ivector_init ( cell_nbrs , nelem ) allocate ( cell_nbrs_pos ( 0 : nelem )) end subroutine !****************************************************************************** subroutine cl_set_cell_size ( cs , simbox ) !! Sets the cell size. The actual cell size may be slightly larger. real ( rp ), intent ( in ) :: cs type ( smbx_t ), intent ( in ) :: simbox nc ( 1 ) = floor ( simbox % basis ( 1 , 1 ) / cs ) nc ( 2 ) = floor ( simbox % basis ( 2 , 2 ) / cs ) nc ( 3 ) = floor ( simbox % basis ( 3 , 3 ) / cs ) nct = product ( nc ) cell_size ( 1 ) = simbox % basis ( 1 , 1 ) / nc ( 1 ) cell_size ( 2 ) = simbox % basis ( 2 , 2 ) / nc ( 2 ) cell_size ( 3 ) = simbox % basis ( 3 , 3 ) / nc ( 3 ) end subroutine !****************************************************************************** subroutine cl_build_cell_nbrs () !! Makes a table of neighboring cells. integer :: j integer :: ncx , ncy , ncz integer :: icx , icy , icz , ic integer :: jcx , jcy , jcz , jc if ( size ( cell_nbrs_pos ) < ( nct + 1 ) ) then deallocate ( cell_nbrs_pos ) allocate ( cell_nbrs_pos ( 0 : nct )) end if ncx = nc ( 1 ); ncy = nc ( 2 ); ncz = nc ( 3 ) cell_nbrs_pos ( 0 ) = 1 do icz = 0 , ncz - 1 do icy = 0 , ncy - 1 do icx = 0 , ncx - 1 ic = icz * ncx * ncy + icy * ncx + icx cell_nbrs_pos ( ic + 1 ) = cell_nbrs_pos ( ic ) do j = 1 , 13 jcx = modulo ( icx + d ( 1 , j ), ncx ) jcy = modulo ( icy + d ( 2 , j ), ncy ) jcz = modulo ( icz + d ( 3 , j ), ncz ) jc = jcz * ncx * ncy + jcy * ncx + jcx call cell_nbrs % append ( jc ) cell_nbrs_pos ( ic + 1 ) = cell_nbrs_pos ( ic + 1 ) + 1 end do end do end do end do call cell_nbrs % shrink_to_fit () end subroutine !****************************************************************************** subroutine cl_delete () !! Deallocates memory allocated in `cl_init`. if ( allocated ( cells )) deallocate ( cells ) if ( allocated ( cells_pos )) deallocate ( cells_pos ) call cell_nbrs % delete () if ( allocated ( cell_nbrs_pos )) deallocate ( cell_nbrs_pos ) if ( allocated ( host_cells )) deallocate ( host_cells ) if ( allocated ( cell_pop )) deallocate ( cell_pop ) cell_size = 0.0_rp nc_max = 0 ; nc = 0 nct_max = 0 ; nct = 0 end subroutine !****************************************************************************** subroutine cl_build ( coords ) !! Sorts atoms into cells for calculating short-range interations real ( rp ), dimension (:,:), intent ( in ) :: coords real ( rp ), dimension ( 3 ) :: ri integer :: na , iatm , j integer :: ncx , ncy , ncz integer :: icx , icy , icz , ic cells = 0 host_cells = 0 cell_pop = 0 ncx = nc ( 1 ); ncy = nc ( 2 ); ncz = nc ( 3 ) na = size ( coords , 2 ) !Loop over particles and put into cells do iatm = 1 , na ri = coords (:, iatm ) icx = int ( ri ( 1 ) / cell_size ( 1 ) ) icy = int ( ri ( 2 ) / cell_size ( 2 ) ) icz = int ( ri ( 3 ) / cell_size ( 3 ) ) if (( icx < 0 ) . or . ( icy < 0 ) . or . ( icz < 0 )) then print * , ri stop end if !If atoms are exactly on the box edge if ( icx > ( ncx - 1 ) ) icx = ncx - 1 if ( icy > ( ncy - 1 ) ) icy = ncy - 1 if ( icz > ( ncz - 1 ) ) icz = ncz - 1 ic = icz * ncx * ncy + icy * ncx + icx host_cells ( iatm ) = ic cell_pop ( ic ) = cell_pop ( ic ) + 1 end do !Loop over all cells to set up pointers cells_pos ( 0 ) = 1 do ic = 0 , ( nct - 1 ) cells_pos ( ic + 1 ) = cells_pos ( ic ) + cell_pop ( ic ) end do !Loop over all atoms do iatm = 1 , na ic = host_cells ( iatm ) j = cells_pos ( ic ) cells ( j ) = iatm cells_pos ( ic ) = cells_pos ( ic ) + 1 end do !Loop over all cells to set up pointers cells_pos ( 0 ) = 1 do ic = 0 , ( nct - 1 ) cells_pos ( ic + 1 ) = cells_pos ( ic ) + cell_pop ( ic ) end do end subroutine !****************************************************************************** function cl_get_num_cells () result ( res ) !! Returns the total number of cells integer :: res res = nct end function !****************************************************************************** subroutine cl_get_contents ( ic , res ) !! Returns a pointer to the entries of cell with linear index *ic*. integer , intent ( in ) :: ic integer , dimension (:), pointer , intent ( out ) :: res integer :: ibeg , iend res => null () ibeg = cells_pos ( ic ); iend = cells_pos ( ic + 1 ) - 1 res => cells ( ibeg : iend ) end subroutine !****************************************************************************** subroutine cl_get_nbr_cells ( ic , res ) !! Returns a pointer to the neighbor cells of cell with linear index *ic*. integer , intent ( in ) :: ic integer , dimension (:), pointer , intent ( out ) :: res integer :: ibeg , iend res => null () ibeg = cell_nbrs_pos ( ic ); iend = cell_nbrs_pos ( ic + 1 ) - 1 call cell_nbrs % get_data ( res , ibeg , iend ) end subroutine !******************************************************************************** subroutine cl_print () !! Prints a cell list integer , dimension (:), pointer :: aic => null () integer , dimension (:), pointer :: nbrc => null () integer :: ncx , ncy , ncz integer :: icx , icy , icz , ic ncx = nc ( 1 ); ncy = nc ( 2 ); ncz = nc ( 3 ) write ( * , '(\"ncx: \", i0, \" ncy: \", i0, \" ncz: \", i0)' ) ncx , ncy , ncz write ( * , '(\"lcx: \", g0.6, \" lcy: \", g0.6, \" lcz: \", g0.6)' ) cell_size write ( * , * ) 'CELL CONTENTS' do icz = 0 , ncz - 1 do icy = 0 , ncy - 1 do icx = 0 , ncx - 1 ic = icz * ncx * ncy + icy * ncx + icx call cl_get_contents ( ic , aic ) if ( size ( aic ) > 0 ) then write ( * , '(\"(\",i0,\",\",i0,\",\",i0,\")[\",i0,\"] \")' , advance = 'no' ) icx , icy , icz , ic write ( * , * ) size ( aic ), aic end if end do end do end do write ( * , * ) write ( * , * ) 'NBR CELLS' do icz = 0 , ncz - 1 do icy = 0 , ncy - 1 do icx = 0 , ncx - 1 ic = icz * ncx * ncy + icy * ncx + icx call cl_get_nbr_cells ( ic , nbrc ) write ( * , '(\"(\",i0,\",\",i0,\",\",i0,\")[\",i0,\"] \")' , advance = 'no' ) icx , icy , icz , ic write ( * , * ) size ( nbrc ), nbrc end do end do end do end subroutine !******************************************************************************** end module cell_list_m","tags":"","loc":"sourcefile/cell_list_m.f90.html"},{"title":"simbox_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~simbox_m.f90~~EfferentGraph sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~random_m.f90 random_m.f90 sourcefile~simbox_m.f90->sourcefile~random_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~simbox_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~simbox_m.f90~~AfferentGraph sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~config_io_m.f90 config_io_m.f90 sourcefile~config_io_m.f90->sourcefile~simbox_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~pairtab_m.fpp->sourcefile~simbox_m.f90 sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~pairtab_m.fpp->sourcefile~cell_list_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~simbox_m.f90 sourcefile~setup_m.f90->sourcefile~config_io_m.f90 sourcefile~stats_m.f90 stats_m.f90 sourcefile~setup_m.f90->sourcefile~stats_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~stats_m.f90->sourcefile~simbox_m.f90 sourcefile~cell_list_m.f90->sourcefile~simbox_m.f90 sourcefile~interaction_m.f90->sourcefile~simbox_m.f90 sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~interaction_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90->sourcefile~config_io_m.f90 sourcefile~bd_solver_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules simbox_m Source Code simbox_m.f90 Source Code module simbox_m !! Implements a simulation box with appropriate boundary conditions. use constants_m use random_m implicit none type smbx_t integer :: imcon real ( rp ), dimension ( 3 , 3 ) :: basis real ( rp ), dimension ( 3 , 3 ) :: dl_basis real ( rp ) :: volume logical :: is_deforming logical :: is_aligned !! Whether the basis vectors are aligned with the laboratory frame contains procedure :: init => smbx_init procedure :: set_basis => smbx_set_basis procedure :: freeze => smbx_freeze procedure :: unfreeze => smbx_unfreeze procedure :: get_image => smbx_get_image procedure :: wrap_all => smbx_wrap_all procedure :: to_center => smbx_to_center procedure :: to_origin => smbx_to_origin procedure :: get_rnd_points => smbx_get_rnd_points end type smbx_t contains !******************************************************************************** subroutine smbx_init ( this , imcon ) !! Initializes an instance of *smbx_t*. Can also be called to reset. class ( smbx_t ), intent ( out ) :: this !! An instance of `smbx_t`. integer , intent ( in ) :: imcon !! Flag specifying boundary conditions on the simulation box. !! !! * *imcon = 0*: Unbounded domain. While not explicitly enforced this !!    is useful only for a single molecule. The dynamics is performed in the !!    c.o.m. frame of reference. !! !! * *imcon = 1*: PBC along *x*, *y*, & *z*. There are no restrictions on !!    the number of molecules. this % imcon = imcon !Initialize to an identity matrix this % basis = 0.0_rp this % basis ( 1 , 1 ) = 1.0_rp this % basis ( 2 , 2 ) = 1.0_rp this % basis ( 3 , 3 ) = 1.0_rp this % volume = 1.0_rp this % dl_basis = this % basis this % is_deforming = . false . this % is_aligned = . true . end subroutine !******************************************************************************** subroutine smbx_set_basis ( this , bv ) !!Sets all three basis vectors. class ( smbx_t ), intent ( in out ) :: this real ( rp ), dimension ( 3 , 3 ), intent ( in ) :: bv real ( rp ), dimension ( 3 ) :: a , b , c this % basis = bv a = this % basis (:, 1 ); b = this % basis (:, 2 ); c = this % basis (:, 3 ) this % volume = a ( 1 ) * ( b ( 2 ) * c ( 3 ) - c ( 2 ) * b ( 3 ) ) - a ( 2 ) * ( b ( 1 ) * c ( 3 ) - c ( 1 ) * b ( 3 ) ) & + a ( 3 ) * ( b ( 1 ) * c ( 2 ) - c ( 1 ) * b ( 2 ) ) end subroutine !******************************************************************************** subroutine smbx_freeze ( this ) !!Specifies *this* as non-deforming. class ( smbx_t ), intent ( in out ) :: this this % is_deforming = . false . end subroutine !******************************************************************************** subroutine smbx_unfreeze ( this ) !!Specifies *this* as deforming. class ( smbx_t ), intent ( in out ) :: this this % is_deforming = . true . end subroutine !******************************************************************************** subroutine smbx_get_image ( this , r ) !!Returns the image of *r* under PBC. !https://scicomp.stackexchange.com/questions/20165/periodic-boundary-conditions-for-triclinic-box class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension ( 3 ), intent ( in out ) :: r real ( rp ), dimension ( 3 ) :: rf if ( this % is_aligned ) then r ( 1 ) = r ( 1 ) - this % basis ( 1 , 1 ) * nint ( r ( 1 ) / this % basis ( 1 , 1 ) ) r ( 2 ) = r ( 2 ) - this % basis ( 2 , 2 ) * nint ( r ( 2 ) / this % basis ( 2 , 2 ) ) r ( 3 ) = r ( 3 ) - this % basis ( 3 , 3 ) * nint ( r ( 3 ) / this % basis ( 3 , 3 ) ) else rf = matmul ( this % dl_basis , r ) rf = rf - nint ( rf ) r = matmul ( this % basis , rf ) end if end subroutine !******************************************************************************** subroutine smbx_wrap_all ( this , coords ) !!Wraps atom positions w.r.t. periodic boundary conditions. !https://scicomp.stackexchange.com/questions/20165/periodic-boundary-conditions-for-triclinic-box class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension (:,:), intent ( in out ) :: coords real ( rp ), dimension ( 3 ) :: rf real ( rp ), dimension ( 3 ) :: diag integer :: n , i n = size ( coords , 2 ) if ( this % is_aligned ) then diag = [ this % basis ( 1 , 1 ), this % basis ( 2 , 2 ), this % basis ( 3 , 3 )] do i = 1 , n coords (:, i ) = coords (:, i ) - diag * floor ( coords (:, i ) / diag ) end do else do i = 1 , n rf = matmul ( this % dl_basis , coords (:, i )) rf = rf - floor ( rf ) coords (:, i ) = matmul ( this % basis , rf ) end do end if end subroutine !******************************************************************************** subroutine smbx_to_center ( this , coords , com ) !!Adjusts atom positions such that the c.o.m. of the atoms is at the center !! of the box. Assumes all atoms to have the same mass and aligned axis. !! Optionally returns the original c.o.m. class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension (:,:), intent ( in out ) :: coords real ( rp ), dimension ( 3 ), intent ( out ), optional :: com real ( rp ), dimension ( 3 ) :: half_diag , com_ integer :: n , i half_diag = 0.5_rp * [ this % basis ( 1 , 1 ), this % basis ( 2 , 2 ), this % basis ( 3 , 3 )] n = size ( coords , 2 ) com_ = sum ( coords , 2 ) / n do i = 1 , n coords (:, i ) = coords (:, i ) - com_ + half_diag end do if ( present ( com )) com = com_ - half_diag end subroutine !******************************************************************************** subroutine smbx_to_origin ( this , coords , com ) !!Adjusts atom positions such that the c.o.m. of the atoms is at the origin. !! Assumes all atoms to have the same mass and aligned axis. !! Optionally returns the original c.o.m. class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension (:,:), intent ( in out ) :: coords real ( rp ), dimension ( 3 ), intent ( out ), optional :: com real ( rp ), dimension ( 3 ) :: com_ integer :: n , i n = size ( coords , 2 ) com_ = sum ( coords , 2 ) / n do i = 1 , n coords (:, i ) = coords (:, i ) - com_ end do if ( present ( com )) com = com_ end subroutine !******************************************************************************** subroutine smbx_get_rnd_points ( this , coords ) !!Returns uniformly distributed points within the box. class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension (:,:), intent ( out ) :: coords real ( rp ), dimension ( 3 ) :: r integer :: n , i n = size ( coords , 2 ) do i = 1 , n call get_rv_uniform ( 0.0_rp , 1.0_rp , r ) coords (:, i ) = matmul ( this % basis , r ) end do end subroutine !******************************************************************************** end module simbox_m","tags":"","loc":"sourcefile/simbox_m.f90.html"},{"title":"ia_external_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~ia_external_m.f90~~EfferentGraph sourcefile~ia_external_m.f90 ia_external_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~ia_external_m.f90->sourcefile~constants_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~ia_external_m.f90->sourcefile~atmcfg_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ia_external_m.f90~~AfferentGraph sourcefile~ia_external_m.f90 ia_external_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_external_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ia_external_m Source Code ia_external_m.f90 Source Code !********************************************************************************! !                                                                                ! ! The MIT License (MIT)                                                          ! !                                                                                ! ! Copyright (c) 2020 Sarit Dutta                                                 ! !                                                                                ! ! Permission is hereby granted, free of charge, to any person obtaining a copy   ! ! of this software and associated documentation files (the \"Software\"), to deal  ! ! in the Software without restriction, including without limitation the rights   ! ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      ! ! copies of the Software, and to permit persons to whom the Software is          ! ! furnished to do so, subject to the following conditions:                       ! !                                                                                ! ! The above copyright notice and this permission notice shall be included in all ! ! copies or substantial portions of the Software.                                ! !                                                                                ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     ! ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       ! ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    ! ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         ! ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  ! ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  ! ! SOFTWARE.                                                                      ! !                                                                                ! !********************************************************************************! module ia_external_m !! External potentials !! !! This module is meant to be a placeholder to any external fields that the user !! wants to add. Accordingly replace/add to the existing routines. The !! subroutines [[ia_external_setup]] and [[ia_add_external_forces]] must remain !! for interfacing to the force calculation driver routine [[ia_calc_forces]]. !! !! * Style 0: None !! * Style 1: Pulling force along +ve x-axis !! * Style 2: Hard planar wall use constants_m use atmcfg_m implicit none private public :: ia_external_setup , ia_add_external_forces contains !****************************************************************************** subroutine ia_external_setup ( num_externals , external_styles , external_params ) !! Sets up parameters for external potentials. Usually there is nothing to !! set for externals, but this acts as a placeholder for special cases. integer , intent ( in ) :: num_externals !! Number of external fields integer , dimension (:), intent ( in ) :: external_styles !! Styles for each field real ( rp ), dimension (:,:), intent ( in out ) :: external_params !! Parameters for each field, depending on style integer :: i , sty !Set external interactions do i = 1 , num_externals sty = external_styles ( i ) select case ( sty ) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_add_external_forces ( num_externals , external_styles , & external_params , coordinates , energy_external , forces , stress , ierr ) !! Calculates the force and energy due to an external field and adds to !! `energy_external`, 'forces`, & `stress`. integer , intent ( in ) :: num_externals !! Number of external fields integer , dimension (:), intent ( in ) :: external_styles !! Styles for each field real ( rp ), dimension (:,:), intent ( in out ) :: external_params !! Parameters for each field, depending on style real ( rp ), dimension (:,:), intent ( in ) :: coordinates real ( rp ), intent ( out ) :: energy_external real ( rp ), dimension (:,:), intent ( in out ) :: forces real ( rp ), dimension ( 3 , 3 ), intent ( in out ) :: stress integer , intent ( out ) :: ierr real ( rp ) :: enrg real ( rp ) :: frcx , v , sn integer :: iext integer :: sty , iatm , m ierr = 0 ; energy_external = 0.0_rp do iext = 1 , num_externals sty = external_styles ( iext ) select case ( sty ) case ( 1 ) ! Pulling force along +ve x-axis. iatm = int ( external_params ( 1 , iext )) frcx = external_params ( 2 , iext ) enrg = - frcx * ( coordinates ( 1 , iatm ) - coordinates ( 1 , 1 )) energy_external = energy_external + enrg forces ( 1 , iatm ) = forces ( 1 , iatm ) + frcx case ( 2 ) ! Rigid walls. Need to modify this (or another case) for repulsive walls. enrg = 0.0_rp m = int ( external_params ( 1 , iext )) v = external_params ( 2 , iext ) sn = external_params ( 3 , iext ) if ( sn > 0.0_rp ) then if ( any ( coordinates ( m ,:) < v ) ) ierr = 1 else if ( any ( coordinates ( m ,:) > v ) ) ierr = 1 end if case default continue end select end do !Need to update stress end subroutine !****************************************************************************** end module ia_external_m","tags":"","loc":"sourcefile/ia_external_m.f90.html"},{"title":"trajectory_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~trajectory_m.f90~~EfferentGraph sourcefile~trajectory_m.f90 trajectory_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~trajectory_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~trajectory_m.f90~~AfferentGraph sourcefile~trajectory_m.f90 trajectory_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~trajectory_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~trajectory_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules trajectory_m Source Code trajectory_m.f90 Source Code !********************************************************************************! !                                                                                ! ! The MIT License (MIT)                                                          ! !                                                                                ! ! Copyright (c) 2020 Sarit Dutta <saridut@gmail.com>                             ! !                                                                                ! ! Permission is hereby granted, free of charge, to any person obtaining a copy   ! ! of this software and associated documentation files (the \"Software\"), to deal  ! ! in the Software without restriction, including without limitation the rights   ! ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      ! ! copies of the Software, and to permit persons to whom the Software is          ! ! furnished to do so, subject to the following conditions:                       ! !                                                                                ! ! The above copyright notice and this permission notice shall be included in all ! ! copies or substantial portions of the Software.                                ! !                                                                                ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     ! ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       ! ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    ! ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         ! ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  ! ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  ! ! SOFTWARE.                                                                      ! !                                                                                ! !********************************************************************************! module trajectory_m !! Routines for reading and writing frames from a trajectory file. use constants_m implicit none private public :: traj type trajectory_t integer :: header_size = 0 integer :: frame_size = 0 integer :: num_atoms = 0 integer , dimension ( 4 ) :: frmcmp = 0 character ( len = :), allocatable :: fn integer :: file_id = 0 integer :: num_frames = 0 logical :: isopen = . false . contains procedure :: create => traj_create procedure :: open => traj_open procedure :: delete => traj_delete procedure :: close => traj_close procedure :: read => traj_read procedure :: append_frame => traj_append_frame procedure :: write_frame => traj_write_frame generic :: init => create , open end type trajectory_t type ( trajectory_t ) :: traj contains !****************************************************************************** subroutine traj_create ( this , fn , na , frmcmp ) !!  Creates a `trajectory_t` object with a new underlying file named `fn`.  If !!  `fn` already exists, it will be truncated.  The file `fn` is opened for both !!  reading and writing. class ( trajectory_t ), intent ( out ) :: this !! *trajectory_t* instance. character ( len =* ), intent ( in ) :: fn !! Name of the underlying trajectory file. integer , intent ( in ) :: na !! Number of atoms integer , dimension ( 4 ), intent ( in ) :: frmcmp !! Binary flags indicating whether that component is present in a frame. !! frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces, !! frmcmp(4): charges integer :: file_id this % num_atoms = na this % frmcmp = frmcmp !Frame components: nts, coordinates, velocities, forces, charge !nts data this % frame_size = sizeof_long_int !Coordinate data if ( frmcmp ( 1 ) /= 0 ) this % frame_size = this % frame_size + 3 * na * sizeof_real !Velocity data if ( frmcmp ( 2 ) /= 0 ) this % frame_size = this % frame_size + 3 * na * sizeof_real !Force data if ( frmcmp ( 3 ) /= 0 ) this % frame_size = this % frame_size + 3 * na * sizeof_real !Charge data if ( frmcmp ( 4 ) /= 0 ) this % frame_size = this % frame_size + na * sizeof_real ! Representation of header: !     * 1 int : `header_size` !     * 1 int : `frame_size` !     * 1 int : `num_atoms` !     * 4 ints: `frmcmp` this % header_size = 7 * sizeof_int !Create trajectory file open ( newunit = file_id , file = fn , access = 'stream' , form = 'unformatted' , & action = 'readwrite' , status = 'replace' ) this % fn = fn this % file_id = file_id this % num_frames = 0 this % isopen = . true . write ( this % file_id ) this % header_size write ( this % file_id ) this % frame_size write ( this % file_id ) this % num_atoms , this % frmcmp end subroutine !****************************************************************************** subroutine traj_open ( this , fn , mode , ierr ) !!  Creates a `trajectory_t` object with a prexisting underlying file named !!  `fn`.  If `fn` does not exist, an error will be generated. If !!  `mode` == 'rw', the file `fn` is opened for both reading and writing. !!  If `mode` == 'r', the file `fn` is opened only for reading. !\"\" class ( trajectory_t ), intent ( out ) :: this character ( len =* ), intent ( in ) :: fn character ( len =* ), intent ( in ) :: mode integer , intent ( out ) :: ierr integer ( ip_long ) :: file_size ierr = 0 this % fn = fn !Readwrite mode if ( mode == 'rw' ) then open ( newunit = this % file_id , file = this % fn , access = 'stream' , & form = 'unformatted' , action = 'readwrite' , status = 'old' ) !Readonly mode else if ( mode == 'r' ) then open ( newunit = this % file_id , file = this % fn , access = 'stream' , & form = 'unformatted' , action = 'read' , status = 'old' ) !Unknown mode else ierr = 1 ; return end if this % isopen = . true . !Get size of the file inquire ( unit = this % file_id , size = file_size ) read ( this % file_id ) this % header_size read ( this % file_id ) this % frame_size read ( this % file_id ) this % num_atoms , this % frmcmp !Integer division to find `num_frames` this % num_frames = int (( file_size - this % header_size ) / this % frame_size , ip ) end subroutine !****************************************************************************** subroutine traj_delete ( this ) !! After a call to this subroutine, all memory within `this` is deallocated, !! all components of `this` are reset to zero, and the underlying file is !! closed (if open). class ( trajectory_t ), intent ( in out ) :: this call this % close () if ( allocated ( this % fn )) deallocate ( this % fn ) this % header_size = 0 this % frame_size = 0 this % num_atoms = 0 this % frmcmp = 0 this % file_id = 0 this % num_frames = 0 end subroutine !****************************************************************************** subroutine traj_close ( this ) !! Closes the underlying file of a `trajectory_t`. class ( trajectory_t ), intent ( in out ) :: this if ( this % isopen ) then close ( this % file_id ) this % isopen = . false . end if end subroutine !****************************************************************************** subroutine traj_read ( this , iframe , nts , ierr , coordinates , velocities , & forces , charge ) !! Read from an open trajectory. class ( trajectory_t ), intent ( in ) :: this integer , intent ( in ) :: iframe !! Frame number integer ( ip_long ), intent ( out ) :: nts !! Time step counter integer , intent ( out ) :: ierr !! Error flag real ( rp ), dimension (:,:), intent ( out ), optional :: coordinates real ( rp ), dimension (:,:), intent ( out ), optional :: velocities real ( rp ), dimension (:,:), intent ( out ), optional :: forces real ( rp ), dimension (:), intent ( out ), optional :: charge integer ( ip_long ) :: offset_frm integer ( ip_long ) :: offset_if integer ( ip_long ) :: offset_tot integer :: na ierr = 0 na = this % num_atoms if ( iframe > this % num_frames ) then write ( * , * ) '`iframe`' , iframe , 'out of bounds for `num_frames`' , this % num_frames ierr = 1 return end if if ( na == 0 ) then write ( * , * ) 'No data' ; ierr = 1 ; return end if offset_frm = this % frame_size offset_frm = ( iframe - 1 ) * offset_frm + this % header_size + 1 read ( this % file_id , pos = offset_frm ) nts if ( present ( coordinates )) then if ( this % frmcmp ( 1 ) /= 1 ) then write ( * , * ) 'No coordinate data in frame' ; ierr = 1 ; return else offset_if = sizeof_long_int offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) coordinates (:, 1 : na ) end if end if if ( present ( velocities )) then if ( this % frmcmp ( 2 ) /= 1 ) then write ( * , * ) 'No velocity data in frame' ; ierr = 1 ; return else offset_if = sizeof_long_int + 3 * na * sizeof_real * this % frmcmp ( 1 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) velocities (:, 1 : na ) end if end if if ( present ( forces )) then if ( this % frmcmp ( 3 ) /= 1 ) then write ( * , * ) 'No force data in frame' ; ierr = 1 ; return else offset_if = sizeof_long_int + 3 * na * sizeof_real * this % frmcmp ( 1 ) & + 3 * na * sizeof_real * this % frmcmp ( 2 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) forces (:, 1 : na ) end if end if if ( present ( charge )) then if ( this % frmcmp ( 4 ) /= 1 ) then write ( * , * ) 'No charge data in frame' ; ierr = 1 ; return else offset_if = sizeof_long_int + 3 * na * sizeof_real * this % frmcmp ( 1 ) & + 3 * na * sizeof_real * this % frmcmp ( 2 ) & + 3 * na * sizeof_real * this % frmcmp ( 3 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) charge ( 1 : na ) end if end if end subroutine !****************************************************************************** subroutine traj_append_frame ( this , nts , coordinates ) !! Write a frame to an open trajectory class ( trajectory_t ), intent ( in out ) :: this integer ( ip_long ), intent ( in ) :: nts real ( rp ), dimension (:,:), intent ( in ) :: coordinates integer :: iframe iframe = this % num_frames + 1 call this % write_frame ( iframe , nts , coordinates ) end subroutine !****************************************************************************** subroutine traj_write_frame ( this , iframe , nts , coordinates ) !! Write a frame to an open trajectory class ( trajectory_t ), intent ( in out ) :: this integer , intent ( in ) :: iframe integer ( ip_long ), intent ( in ) :: nts real ( rp ), dimension (:,:), intent ( in ) :: coordinates integer ( ip_long ) :: offset integer :: na na = this % num_atoms ! Added one to handle appending a frame if ( iframe > this % num_frames + 1 ) then write ( * , * ) '`iframe`' , iframe , 'out of bounds for `num_frames`' , & ( this % num_frames + 1 ) return end if offset = this % frame_size offset = ( iframe - 1 ) * offset + this % header_size + 1 write ( this % file_id , pos = offset ) nts if ( this % frmcmp ( 1 ) == 1 ) then if ( this % num_atoms /= 0 ) then write ( this % file_id ) coordinates (:, 1 : na ) end if end if if ( iframe == this % num_frames + 1 ) this % num_frames = this % num_frames + 1 end subroutine !****************************************************************************** end module trajectory_m","tags":"","loc":"sourcefile/trajectory_m.f90.html"},{"title":"ia_dihedral_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~ia_dihedral_m.f90~~EfferentGraph sourcefile~ia_dihedral_m.f90 ia_dihedral_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~constants_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~atmcfg_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ia_dihedral_m.f90~~AfferentGraph sourcefile~ia_dihedral_m.f90 ia_dihedral_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_dihedral_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ia_dihedral_m Source Code ia_dihedral_m.f90 Source Code module ia_dihedral_m !! Dihedral potentials (none implemented) use constants_m use atmcfg_m implicit none private public :: ia_dihedral_setup , ia_get_dihedral_force contains !****************************************************************************** subroutine ia_dihedral_setup ( num_dihedral_types , dihedral_styles , dihedral_params ) !! Sets up parameters for dihedral potentials integer , intent ( in ) :: num_dihedral_types !! Number of dihedral types integer , dimension (:), intent ( in ) :: dihedral_styles !! Styles for each type real ( rp ), dimension (:,:), intent ( in out ) :: dihedral_params !! Parameters for each type, depending on style integer :: i , sty !Set dihedral interactions do i = 1 , num_dihedral_types sty = dihedral_styles ( i ) select case ( sty ) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_dihedral_force ( q1 , q2 , q3 , sty , params , enrg , fi , fj , fk , fl ) !! Calculates the force & energy due to a dihedral. real ( rp ), dimension ( 3 ), intent ( in ) :: q1 real ( rp ), dimension ( 3 ), intent ( in ) :: q2 real ( rp ), dimension ( 3 ), intent ( in ) :: q3 integer , intent ( in ) :: sty real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), dimension ( 3 ), intent ( out ) :: fi real ( rp ), dimension ( 3 ), intent ( out ) :: fj real ( rp ), dimension ( 3 ), intent ( out ) :: fk real ( rp ), dimension ( 3 ), intent ( out ) :: fl real ( rp ), intent ( out ) :: enrg enrg = 0.0_rp fi = 0.0_rp ; fj = 0.0_rp ; fk = 0.0_rp ; fl = 0.0_rp select case ( sty ) case default continue end select end subroutine !****************************************************************************** end module ia_dihedral_m","tags":"","loc":"sourcefile/ia_dihedral_m.f90.html"},{"title":"qsort_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~qsort_m.f90~~EfferentGraph sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~qsort_m.f90~~AfferentGraph sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90 vector_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~table_m.f90 table_m.f90 sourcefile~table_m.f90->sourcefile~vector_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~pairtab_m.fpp->sourcefile~vector_m.f90 sourcefile~pairtab_m.fpp->sourcefile~table_m.f90 sourcefile~connectivity_m.f90 connectivity_m.f90 sourcefile~pairtab_m.fpp->sourcefile~connectivity_m.f90 sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~aabbtree_m.f90 sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~pairtab_m.fpp->sourcefile~cell_list_m.f90 sourcefile~connectivity_m.f90->sourcefile~vector_m.f90 sourcefile~connectivity_m.f90->sourcefile~table_m.f90 sourcefile~aabbtree_m.f90->sourcefile~vector_m.f90 sourcefile~cell_list_m.f90->sourcefile~vector_m.f90 sourcefile~aabbtree_sm.fpp aabbtree_sm.fpp sourcefile~aabbtree_sm.fpp->sourcefile~aabbtree_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~table_m.f90 sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules qsort_m Source Code qsort_m.f90 Source Code !*************************************************************************! !                                                                         ! ! This is free and unencumbered software released into the public domain. ! !                                                                         ! ! Anyone is free to copy, modify, publish, use, compile, sell, or         ! ! distribute this software, either in source code form or as a compiled   ! ! binary, for any purpose, commercial or non-commercial, and by any       ! ! means.                                                                  ! !                                                                         ! ! In jurisdictions that recognize copyright laws, the author or authors   ! ! of this software dedicate any and all copyright interest in the         ! ! software to the public domain. We make this dedication for the benefit  ! ! of the public at large and to the detriment of our heirs and            ! ! successors. We intend this dedication to be an overt act of             ! ! relinquishment in perpetuity of all present and future rights to this   ! ! software under copyright law.                                           ! !                                                                         ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,         ! ! EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF      ! ! MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  ! ! IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR       ! ! OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   ! ! ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR   ! ! OTHER DEALINGS IN THE SOFTWARE.                                         ! !                                                                         ! ! For more information, please refer to <http://unlicense.org>            ! !                                                                         ! !*************************************************************************! MODULE qsort_m !!  Implements quicksort for a sequence of integers and reals, in combination with !!  insertion sort for very short sequences. !! !! - Quick sort routine from Brainerd, W.S., Goldberg, C.H. & Adams, J.C. (1990) !! \"Programmer's Guide to Fortran 90\", McGraw-Hill  ISBN 0-07-000248-7, pages 149-150. !! - Modified by Alan Miller to include an associated integer array which gives !!   the positions of the elements in the original order. !! - Modified for integer array by Sarit Dutta USE constants_m IMPLICIT NONE CONTAINS !****************************************************************************** RECURSIVE SUBROUTINE iqsort ( list , order ) !!  Sorts a sequence of integers IMPLICIT NONE INTEGER , DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of integers to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE iqsort !****************************************************************************** RECURSIVE SUBROUTINE dqsort ( list , order ) !!  Sorts a sequence of reals !\"\" IMPLICIT NONE REAL ( RP ), DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of reals to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE dqsort !****************************************************************************** END MODULE qsort_m","tags":"","loc":"sourcefile/qsort_m.f90.html"},{"title":"ia_vdw_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~ia_vdw_m.f90~~EfferentGraph sourcefile~ia_vdw_m.f90 ia_vdw_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~constants_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~atmcfg_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ia_vdw_m.f90~~AfferentGraph sourcefile~ia_vdw_m.f90 ia_vdw_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_vdw_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ia_vdw_m Source Code ia_vdw_m.f90 Source Code module ia_vdw_m !! Routines to evaulate pairwise potentials and their derivative. !! !! The following styles are available: !! !! * Style 1. 12-6 LJ. See [[vdw_lj_set]]. !! * Style 2. Gaussian. See [[vdw_gaussian_set]]. !! * Style 3. Cosine. See [[vdw_cosine_set]]. !! * Style 4. Screened Coulomb + LJ. See [[vdw_lj_coul_debye_set]]. !! * Style 5. Coulomb + LJ. See [[vdw_lj_coul_set]]. !! * Style 6. Standard DPD. See [[vdw_dpd_set]]. use constants_m use atmcfg_m implicit none private public :: ia_vdw_setup , ia_get_vdw_force contains !****************************************************************************** subroutine ia_vdw_setup ( num_vdw_types , vdw_styles , vdw_params ) !! Sets up parameters for vdw potentials integer , intent ( in ) :: num_vdw_types !! Number of types of vdw interactions integer , dimension (:), intent ( in ) :: vdw_styles !! Styles for each type real ( rp ), dimension (:,:), intent ( in out ) :: vdw_params !! Parameters for each type, depending on style integer :: i , sty !Set vdw interactions do i = 1 , num_vdw_types sty = vdw_styles ( i ) select case ( sty ) case ( 1 ) call vdw_lj_set ( vdw_params (:, i )) case ( 2 ) call vdw_gaussian_set ( vdw_params (:, i )) case ( 3 ) call vdw_cosine_set ( vdw_params (:, i )) case ( 4 ) call vdw_lj_coul_debye_set ( vdw_params (:, i )) case ( 5 ) call vdw_lj_coul_set ( vdw_params (:, i )) case ( 6 ) call vdw_dpd_set ( vdw_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_vdw_force ( rij_mag , qi , qj , sty , params , enrg , frc , ierr ) !! Calculates the energy & its derivative due to a single interacting pair of atoms. real ( rp ), intent ( in ) :: rij_mag !! Distance between two atoms real ( rp ), intent ( in ) :: qi !! Charge on atom i real ( rp ), intent ( in ) :: qj !! Charge on atom j integer , intent ( in ) :: sty !! Style of vdw interaction real ( rp ), dimension (:), intent ( in ) :: params !! Parameters for vdw interaction real ( rp ), intent ( out ) :: enrg !! Energy real ( rp ), intent ( out ) :: frc !! Derivative of the potential. This is the magnitude of force due to !! this potential. integer , intent ( out ) :: ierr !! Error flag ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp select case ( sty ) case ( 1 ) call vdw_lj ( rij_mag , params , enrg , frc ) case ( 2 ) call vdw_gaussian ( rij_mag , params , enrg , frc ) case ( 3 ) call vdw_cosine ( rij_mag , params , enrg , frc ) case ( 4 ) call vdw_lj_coul_debye ( rij_mag , qi * qj , params , enrg , frc ) case ( 5 ) call vdw_lj_coul ( rij_mag , qi * qj , params , enrg , frc ) case ( 6 ) call vdw_dpd ( rij_mag , params , enrg , frc ) case default continue end select end subroutine !****************************************************************************** subroutine vdw_lj_set ( params , eps , sigma , rcut ) !! Setter for 12-6 LJ (truncated & force-shifted) interaction. !! !! The potential `U` is given by: !!``` !!   V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] !!   U = V - V(rcut) - (r - rcut)*dV/dr, r < rcut, !!       0, r >= rcut !!``` !! where `dV/dr` is evaluated at `r = rcut`. !! !! User-set parameters: !! !! * params(1) = `eps` !! * params(2) = `sigma` !! * params(3) = `rcut` !! !! Internally stored parameters: !! !! * params(4) = `V(rcut)` !! * params(5) = `dV/dr(rcut)` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ), intent ( in ), optional :: rcut real ( rp ) :: eps_ , sigma_ , rcut_ real ( rp ) :: pot_rcut , pot_deriv_rcut real ( rp ) :: sir , sir2 , sir6 , sir12 if ( present ( eps )) params ( 1 ) = eps if ( present ( sigma )) params ( 2 ) = sigma if ( present ( rcut )) params ( 3 ) = rcut eps_ = params ( 1 ); sigma_ = params ( 2 ); rcut_ = params ( 3 ) sir = sigma_ / rcut_ sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 pot_rcut = 4 * eps_ * ( sir12 - sir6 ) pot_deriv_rcut = - 24 * eps_ * ( 2 * sir12 - sir6 ) / rcut_ params ( 4 ) = pot_rcut params ( 5 ) = pot_deriv_rcut end subroutine !****************************************************************************** pure subroutine vdw_lj ( r , params , enrg , frc ) !! Evaluates the potential and its derivative for LJ interaction. See !! [[vdw_lj_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: eps , sigma , rcut real ( rp ) :: pot_rcut , pot_deriv_rcut real ( rp ) :: sir , sir2 , sir6 , sir12 enrg = 0.0_rp ; frc = 0.0_rp eps = params ( 1 ); sigma = params ( 2 ); rcut = params ( 3 ) pot_rcut = params ( 4 ) pot_deriv_rcut = params ( 5 ) if ( r < rcut ) then sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = 4 * eps * ( sir12 - sir6 ) - pot_rcut - ( r - rcut ) * pot_deriv_rcut frc = - 24 * eps * ( 2 * sir12 - sir6 ) / r - pot_deriv_rcut end if end subroutine !****************************************************************************** subroutine vdw_gaussian_set ( params , A , B , rcut ) !! Setter for gaussian interaction. The potential is truncated and !! force-shifted. !! !! The potential `U` is given by: !!``` !!   V = A*exp(-B*r&#94;2) !!   U = V - V(rcut) - (r - rcut)*dV/dr, r < rcut !!       0, r >= rcut, !!``` !! where `dV/dr` is evaluated at `r = rcut`. !! !! User-set parameters: !! !! * params(1) = `A` !! * params(2) = `B` !! * params(3) = `rcut` !! !! Internally stored parameters: !! !! * params(4) = `V(rcut)` !! * params(5) = `dV/dr(rcut)` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: A real ( rp ), intent ( in ), optional :: B real ( rp ), intent ( in ), optional :: rcut real ( rp ) :: pot_rcut , pot_deriv_rcut if ( present ( A )) params ( 1 ) = A if ( present ( B )) params ( 2 ) = B if ( present ( rcut )) params ( 3 ) = rcut pot_rcut = params ( 1 ) * exp ( - params ( 2 ) * params ( 3 ) ** 2 ) pot_deriv_rcut = - 2.0_rp * params ( 1 ) * params ( 2 ) * params ( 3 ) & * exp ( - params ( 2 ) * params ( 3 ) ** 2 ) params ( 4 ) = pot_rcut params ( 5 ) = pot_deriv_rcut end subroutine !****************************************************************************** pure subroutine vdw_gaussian ( r , params , enrg , frc ) !! Calculates energy & its derivative for gaussian interaction. See !! [[vdw_gaussian_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: A , B , rcut , pot_rcut , pot_deriv_rcut real ( rp ) :: exrs enrg = 0.0_rp ; frc = 0.0_rp A = params ( 1 ); B = params ( 2 ); rcut = params ( 3 ) pot_rcut = params ( 4 ); pot_deriv_rcut = params ( 5 ) if ( r < rcut ) then exrs = exp ( - B * r * r ) enrg = A * exrs - pot_rcut - ( r - rcut ) * pot_deriv_rcut frc = - 2 * A * B * r * exrs - pot_deriv_rcut end if end subroutine !****************************************************************************** subroutine vdw_cosine_set ( params , A , rcut ) !! Setter for cosine interaction. !! !! The potential `U` is given by: !!``` !!   U = A*[1 + cos(pi*r/rcut)], r < rcut !!       0, r >= rcut !!``` !! The potential as well as its derivative is zero at `r = rcut`. !! !! User-set parameters: !! !! * params(1) = `A` !! * params(2) = `rcut` !! !! Internally stored parameters: !! !! * None real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: A real ( rp ), intent ( in ), optional :: rcut if ( present ( A )) params ( 1 ) = A if ( present ( rcut )) params ( 2 ) = rcut end subroutine !****************************************************************************** pure subroutine vdw_cosine ( r , params , enrg , frc ) !! Evaluates the potential and its derivative for  cosine interaction. !! See [[vdw_cosine_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: A , rcut , pf , pr enrg = 0.0_rp ; frc = 0.0_rp A = params ( 1 ); rcut = params ( 2 ) pf = math_pi / rcut ; pr = pf * r if ( r < rcut ) then enrg = A * ( 1.0_rp + cos ( pr ) ) frc = - A * pf * sin ( pr ) end if end subroutine !****************************************************************************** subroutine vdw_lj_coul_debye_set ( params , eps , sigma , rcut , rcut_coul , C , kappa ) !! Setter for 12-6 LJ with screened Coulombic interaction. !! !! The potential `U` is given by: !!``` !! V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] !! W = C*qi*qj*exp(-kappa*r)/r !! if rcut_coul > 0: !!     U = V - V(rcut) + W - W(rcut_coul), r < rcut !!         W - W(rcut_coul), rcut <= r < rcut_coul !!         0, r >= rcut_coul !! if rcut_coul <= 0: !!     U = V - V(rcut) + W, r < rcut !!         W, r >= rcut !!``` !! !!- The LJ potential `V` is cut & shifted at `r = rcut`. !!- If `rcut_coul > 0`, the screened Coulombic potential `W` is cut & shifted !! at `r = rcut_coul`. !!- If `rcut_coul <= 0`, no cutoff is applied on `W`. !!- `rcut_coul` must be >= `rcut`. !! !! User-set parameters: !! !! * params(1) = `eps` !! * params(2) = `sigma` !! * params(3) = `rcut` !! * params(4) = `rcut_coul` !! * params(5) = `C` !! * params(6) = `kappa` !! !! Internally stored parameters: !! !! * params(7) = `V(rcut)` !! * params(8) = `C*exp(-kappa*rcut_coul)/rcut_coul` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ), intent ( in ), optional :: rcut real ( rp ), intent ( in ), optional :: rcut_coul real ( rp ), intent ( in ), optional :: C real ( rp ), intent ( in ), optional :: kappa real ( rp ) :: eps_ , sigma_ , rcut_ , rcut_coul_ , C_ , kappa_ real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 if ( present ( eps )) params ( 1 ) = eps if ( present ( sigma )) params ( 2 ) = sigma if ( present ( rcut )) params ( 3 ) = rcut if ( present ( rcut_coul )) params ( 4 ) = rcut_coul if ( present ( C )) params ( 5 ) = C if ( present ( kappa )) params ( 6 ) = kappa eps_ = params ( 1 ); sigma_ = params ( 2 ); rcut_ = params ( 3 ) rcut_coul_ = params ( 4 ); C_ = params ( 5 ); kappa_ = params ( 6 ) sir = sigma_ / rcut_ sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 pot_rcut = 4 * eps_ * ( sir12 - sir6 ) if ( rcut_coul_ > 0.0_rp ) then pot_rcut_coul = C_ * exp ( - kappa_ * rcut_coul_ ) / rcut_coul_ else pot_rcut_coul = 0.0_rp end if params ( 7 ) = pot_rcut params ( 8 ) = pot_rcut_coul end subroutine !****************************************************************************** pure subroutine vdw_lj_coul_debye ( r , qiqj , params , enrg , frc ) !!Evaluates the potential and its derivative for screened Coulombic interaction !!combined with 12-6 LJ (cut & shifted). See [[vdw_lj_coul_debye_set]]. real ( rp ), intent ( in ) :: r real ( rp ), intent ( in ) :: qiqj real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: eps , sigma , rcut , rcut_coul , C , kappa real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 , ekr enrg = 0.0_rp ; frc = 0.0_rp eps = params ( 1 ); sigma = params ( 2 ); rcut = params ( 3 ) rcut_coul = params ( 4 ); C = params ( 5 ); kappa = params ( 6 ) pot_rcut = params ( 7 ); pot_rcut_coul = params ( 8 ) ekr = C * qiqj * exp ( - kappa * r ) / r if ( rcut_coul > 0.0_rp ) then !Coulombic cutoff at rcut_coul if ( r < rcut_coul ) then enrg = ekr - qiqj * pot_rcut_coul frc = - ekr * ( 1 + kappa * r ) / r end if else !No Coulombic cutoff enrg = ekr frc = - ekr * ( 1 + kappa * r ) / r end if if ( r < rcut ) then sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = enrg + 4 * eps * ( sir12 - sir6 ) - pot_rcut frc = frc - 24 * eps * ( 2 * sir12 - sir6 ) / r end if end subroutine !****************************************************************************** subroutine vdw_lj_coul_set ( params , eps , sigma , rcut , rcut_coul , C ) !! Setter for 12-6 LJ with Coulombic interaction. !! !! The potential `U` is given by: !!``` !! V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] !! W = C*qi*qj/r !! if rcut_coul > 0: !!     U = V - V(rcut) + W - W(rcut_coul), r < rcut !!         W - W(rcut_coul), rcut <= r < rcut_coul !!         0, r >= rcut_coul !! if rcut_coul <= 0: !!     U = V - V(rcut) + W, r < rcut !!         W, r >= rcut !!``` !! - The LJ potential `V` is cut & shifted at `r = rcut`. !! - If `rcut_coul > 0`, the Coulombic potential `W` is cut & shifted at `r = rcut_coul`. !! - If `rcut_coul <= 0`, no cutoff is applied on `W`. !! - `rcut_coul` must be >= `rcut`. !! !! User-set parameters: !! !! * params(1) = `eps` !! * params(2) = `sigma` !! * params(3) = `rcut` !! * params(4) = `rcut_coul` !! * params(5) = `C` !! !! Internally stored parameters: !! !! * params(6) = `V(rcut)` !! * params(7) = `C/rcut_coul` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ), intent ( in ), optional :: rcut real ( rp ), intent ( in ), optional :: rcut_coul real ( rp ), intent ( in ), optional :: C real ( rp ) :: eps_ , sigma_ , rcut_ , rcut_coul_ , C_ real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 if ( present ( eps )) params ( 1 ) = eps if ( present ( sigma )) params ( 2 ) = sigma if ( present ( rcut )) params ( 3 ) = rcut if ( present ( rcut_coul )) params ( 4 ) = rcut_coul if ( present ( C )) params ( 5 ) = C eps_ = params ( 1 ); sigma_ = params ( 2 ); rcut_ = params ( 3 ) rcut_coul_ = params ( 4 ); C_ = params ( 5 ) sir = sigma_ / rcut_ sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 pot_rcut = 4 * eps_ * ( sir12 - sir6 ) if ( rcut_coul_ > 0.0_rp ) then pot_rcut_coul = C_ / rcut_coul_ else pot_rcut_coul = 0.0_rp end if params ( 6 ) = pot_rcut params ( 7 ) = pot_rcut_coul end subroutine !****************************************************************************** pure subroutine vdw_lj_coul ( r , qiqj , params , enrg , frc ) !! Evaluates the potential and its derivative for Coulombic interaction !! combined with 12-6 LJ (cut & shifted). See [[vdw_lj_coul_set]]. real ( rp ), intent ( in ) :: r real ( rp ), intent ( in ) :: qiqj real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: eps , sigma , rcut , rcut_coul , C real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 , ekr enrg = 0.0_rp ; frc = 0.0_rp eps = params ( 1 ); sigma = params ( 2 ); rcut = params ( 3 ) rcut_coul = params ( 4 ); C = params ( 5 ) pot_rcut = params ( 6 ); pot_rcut_coul = params ( 7 ) ekr = C * qiqj / r if ( rcut_coul > 0.0_rp ) then !Coulombic cutoff at rcut_coul if ( r < rcut_coul ) then enrg = ekr - qiqj * pot_rcut_coul frc = - ekr / r end if else !No Coulombic cutoff enrg = ekr frc = - ekr / r end if if ( r < rcut ) then sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = enrg + 4 * eps * ( sir12 - sir6 ) - pot_rcut frc = frc - 24 * eps * ( 2 * sir12 - sir6 ) / r end if end subroutine !****************************************************************************** subroutine vdw_dpd_set ( params , A , rcut ) !! Setter for standard DPD interaction. !! !! The potential `U` is given by: !!``` !!   U = (A/2)*rcut*(1 - (r/rcut))&#94;2, r < rcut !        0, r >= rcut !!``` !! !! User-set parameters: !! !! * params(1) = `A` !! * params(2) = `rcut` !! !! Internally stored parameters: !! !! * None real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: A real ( rp ), intent ( in ), optional :: rcut if ( present ( A )) params ( 1 ) = A if ( present ( rcut )) params ( 2 ) = rcut end subroutine !****************************************************************************** pure subroutine vdw_dpd ( r , params , enrg , frc ) !! Evaluates the potential and its derivative for standard DPD interaction. !! See [[vdw_dpd_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: A , rcut , ir enrg = 0.0_rp ; frc = 0.0_rp A = params ( 1 ); rcut = params ( 2 ) ir = 1.0_rp - ( r / rcut ) if ( r < rcut ) then enrg = 0.5_rp * A * rcut * ir * ir frc = - A * ir end if end subroutine !****************************************************************************** end module ia_vdw_m","tags":"","loc":"sourcefile/ia_vdw_m.f90.html"},{"title":"vector_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~vector_m.f90~~EfferentGraph sourcefile~vector_m.f90 vector_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~vector_m.f90~~AfferentGraph sourcefile~vector_m.f90 vector_m.f90 sourcefile~table_m.f90 table_m.f90 sourcefile~table_m.f90->sourcefile~vector_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~pairtab_m.fpp->sourcefile~vector_m.f90 sourcefile~pairtab_m.fpp->sourcefile~table_m.f90 sourcefile~connectivity_m.f90 connectivity_m.f90 sourcefile~pairtab_m.fpp->sourcefile~connectivity_m.f90 sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~aabbtree_m.f90 sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~pairtab_m.fpp->sourcefile~cell_list_m.f90 sourcefile~connectivity_m.f90->sourcefile~vector_m.f90 sourcefile~connectivity_m.f90->sourcefile~table_m.f90 sourcefile~aabbtree_m.f90->sourcefile~vector_m.f90 sourcefile~cell_list_m.f90->sourcefile~vector_m.f90 sourcefile~aabbtree_sm.fpp aabbtree_sm.fpp sourcefile~aabbtree_sm.fpp->sourcefile~aabbtree_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~table_m.f90 sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules vector_m Source Code vector_m.f90 Source Code module vector_m !! Implements a vector as an extendable array. use constants_m use qsort_m implicit none type ivector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init integer , dimension (:), allocatable :: buffer contains procedure :: delete => ivector_delete procedure :: clear => ivector_clear procedure :: get_val => ivector_get_val procedure :: set_val => ivector_set_val procedure :: get_data => ivector_get_data procedure :: append => ivector_append procedure :: pop => ivector_pop procedure :: resize => ivector_resize procedure :: shrink_to_fit => ivector_shrink_to_fit procedure :: sort => ivector_sort procedure :: unique => ivector_unique procedure :: print => ivector_print end type ivector_t type dvector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init real ( rp ), dimension (:), allocatable :: buffer contains procedure :: delete => dvector_delete procedure :: clear => dvector_clear procedure :: get_val => dvector_get_val procedure :: set_val => dvector_set_val procedure :: get_data => dvector_get_data procedure :: append => dvector_append procedure :: pop => dvector_pop procedure :: resize => dvector_resize procedure :: shrink_to_fit => dvector_shrink_to_fit procedure :: sort => dvector_sort procedure :: unique => dvector_unique procedure :: print => dvector_print end type dvector_t interface ivector_init module procedure ivector_init module procedure ivector_from_array end interface interface dvector_init module procedure dvector_init module procedure dvector_from_array end interface interface assignment ( = ) module procedure ivector_assign module procedure dvector_assign module procedure i_dvector_assign end interface contains !****************************************************************************** !> Creates an empty *ivector* with all elements equal to zero. subroutine ivector_init ( this , len_init , ierr ) type ( ivector_t ), intent ( in out ) :: this integer , intent ( in ), optional :: len_init !! Must be > 0 integer , intent ( out ), optional :: ierr integer :: istat if ( present ( ierr )) ierr = 0 if ( present ( len_init )) then if ( len_init > 0 ) this % len_init = len_init this % len_max = 2 * len_init end if allocate ( this % buffer ( this % len_max ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for this%buffer of size' , this % len_max if ( present ( ierr )) ierr = 1 return end if this % buffer = 0 end subroutine !****************************************************************************** !> Creates an empty *dvector* with all elements equal to zero. subroutine dvector_init ( this , len_init , ierr ) type ( dvector_t ), intent ( in out ) :: this integer , intent ( in ), optional :: len_init !! Must be > 0 integer , intent ( out ), optional :: ierr integer :: istat if ( present ( ierr )) ierr = 0 if ( present ( len_init )) then if ( len_init > 0 ) this % len_init = len_init this % len_max = 2 * len_init end if allocate ( this % buffer ( this % len_max ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for this%buffer of size' , this % len_max if ( present ( ierr )) ierr = 1 return end if this % buffer = 0.0_rp end subroutine !****************************************************************************** !> Creates an *ivector* with all elements from an array subroutine ivector_from_array ( this , x ) type ( ivector_t ), intent ( in out ) :: this integer , dimension (:), intent ( in ) :: x integer , dimension (:), allocatable :: temp integer :: n call ivector_init ( this ) n = size ( x , 1 ) if ( this % len_max < n ) then allocate ( temp ( 2 * n )) temp = 0 temp ( 1 : n ) = x call move_alloc ( temp , this % buffer ) this % len = n this % len_max = 2 * n else this % buffer ( 1 : n ) = x this % len = n end if end subroutine !****************************************************************************** !> Creates a *dvector* with all elements from an array subroutine dvector_from_array ( this , x ) type ( dvector_t ), intent ( in out ) :: this real ( rp ), dimension (:), intent ( in ) :: x real ( rp ), dimension (:), allocatable :: temp integer :: n call dvector_init ( this ) n = size ( x , 1 ) if ( this % len_max < n ) then allocate ( temp ( 2 * n )) temp = 0 temp ( 1 : n ) = x call move_alloc ( temp , this % buffer ) this % len = n this % len_max = 2 * n else this % buffer ( 1 : n ) = x this % len = n end if end subroutine !****************************************************************************** !> Deletes an *ivector*. No access is allowed to this object after this call. subroutine ivector_delete ( this ) class ( ivector_t ), intent ( in out ) :: this if ( allocated ( this % buffer )) deallocate ( this % buffer ) this % len = 0 end subroutine !****************************************************************************** !> Deletes a *dvector*. No access is allowed to this object after this call. subroutine dvector_delete ( this ) class ( dvector_t ), intent ( in out ) :: this if ( allocated ( this % buffer )) deallocate ( this % buffer ) this % len = 0 end subroutine !****************************************************************************** !> Clears an *ivector*. Access allowed after a call to clear. subroutine ivector_clear ( this ) class ( ivector_t ), intent ( in out ) :: this this % len = 0 this % buffer = 0 end subroutine !****************************************************************************** !> Clears a *dvector*. Access allowed after a call to clear. subroutine dvector_clear ( this ) class ( dvector_t ), intent ( in out ) :: this this % len = 0 this % buffer = 0.0_rp end subroutine !****************************************************************************** !> Copies the contents of *ivector* `other` to *ivector* `this` !! subroutine ivector_assign ( this , other ) class ( ivector_t ), intent ( in out ) :: this class ( ivector_t ), intent ( in ) :: other integer :: n n = other % len if ( this % len >= n ) then !Copy contents if buffer is large enough this % buffer ( 1 : n ) = other % buffer this % len = n else !Need to enlarge buffer. Reallocate and copy deallocate ( this % buffer ) allocate ( this % buffer , source = other % buffer ( 1 : n )) this % len = n this % len_max = n end if end subroutine !****************************************************************************** !> Copies the contents of *dvector* `other` to *dvector* `this` !! subroutine dvector_assign ( this , other ) class ( dvector_t ), intent ( in out ) :: this class ( dvector_t ), intent ( in ) :: other integer :: n n = other % len if ( this % len >= n ) then !Copy contents if buffer is large enough this % buffer ( 1 : n ) = other % buffer ( 1 : n ) this % len = n else !Need to enlarge buffer. Reallocate and copy deallocate ( this % buffer ) allocate ( this % buffer , source = other % buffer ( 1 : n )) this % len = n this % len_max = n end if end subroutine !****************************************************************************** subroutine i_dvector_assign ( this , other ) !!  Copies the contents of *ivector* `other` to *dvector* `this`. Integers !!  are cast to reals. !\"\" class ( dvector_t ), intent ( in out ) :: this class ( ivector_t ), intent ( in ) :: other integer :: n n = other % len if ( this % len >= n ) then !Copy contents if buffer is large enough this % buffer ( 1 : n ) = dble ( other % buffer ( 1 : n )) this % len = n else !Need to enlarge buffer. Reallocate and copy deallocate ( this % buffer ) allocate ( this % buffer ( n )) this % buffer = dble ( other % buffer ( 1 : n )) this % len = n this % len_max = n end if end subroutine !****************************************************************************** !> Returns the length of an *ivector* function ivector_get_len ( this ) result ( res ) class ( ivector_t ), intent ( in ) :: this integer :: res res = this % len end function !****************************************************************************** !> Returns the length of a *dvector* function dvector_get_len ( this ) result ( res ) class ( dvector_t ), intent ( in ) :: this integer :: res res = this % len end function !****************************************************************************** !> Returns the ith element of an *ivector*. function ivector_get_val ( this , i ) result ( res ) class ( ivector_t ), intent ( in ) :: this integer , intent ( in ) :: i integer :: res if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else res = this % buffer ( i ) end if end function !****************************************************************************** !> Returns the ith element of a *dvector*. function dvector_get_val ( this , i ) result ( res ) class ( dvector_t ), intent ( in ) :: this integer , intent ( in ) :: i real ( rp ) :: res if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else res = this % buffer ( i ) end if end function !****************************************************************************** !> Sets the value of the ith element of an *ivector*. No bounds check is performed. subroutine ivector_set_val ( this , i , val ) class ( ivector_t ), intent ( in out ) :: this integer , intent ( in ) :: i integer , intent ( in ) :: val if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else this % buffer ( i ) = val end if end subroutine !****************************************************************************** !> Sets the value of the ith element of a *dvector*. No bounds check is performed. subroutine dvector_set_val ( this , i , val ) class ( dvector_t ), intent ( in out ) :: this integer , intent ( in ) :: i real ( rp ), intent ( in ) :: val if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else this % buffer ( i ) = val end if end subroutine !****************************************************************************** !> Adds an element to the end of an *ivector*. Reallocation will take place if required. subroutine ivector_append ( this , val ) class ( ivector_t ), intent ( in out ) :: this integer , intent ( in ) :: val integer , dimension (:), allocatable :: temp !Double len_max if current length is equal to len_max if ( this % len == this % len_max ) then allocate ( temp ( 2 * this % len_max )) temp = 0 temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) call move_alloc ( temp , this % buffer ) this % len_max = 2 * this % len_max end if this % buffer ( this % len + 1 ) = val this % len = this % len + 1 end subroutine !****************************************************************************** !> Adds an element to the end of a *dvector*. Reallocation will take place if required. subroutine dvector_append ( this , val ) class ( dvector_t ), intent ( in out ) :: this real ( rp ), intent ( in ) :: val real ( rp ), dimension (:), allocatable :: temp !Double len_max if current length is equal to len_max if ( this % len == this % len_max ) then allocate ( temp ( 2 * this % len_max )) temp = 0 temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) call move_alloc ( temp , this % buffer ) this % len_max = 2 * this % len_max end if this % buffer ( this % len + 1 ) = val this % len = this % len + 1 end subroutine !****************************************************************************** !> Removes the last element and returns it. Calling this method on an empty list ! will generate an error. function ivector_pop ( this ) result ( val ) class ( ivector_t ), intent ( in out ) :: this integer :: val val = this % buffer ( this % len ) this % len = this % len - 1 end function !****************************************************************************** !> Removes the last element and returns it. Calling this method on an empty list ! will generate an error. function dvector_pop ( this ) result ( val ) class ( dvector_t ), intent ( in out ) :: this real ( rp ) :: val val = this % buffer ( this % len ) this % len = this % len - 1 end function !****************************************************************************** !> Returns a pointer to the underlying data of an *ivector* ! No bounds checking is performed subroutine ivector_get_data ( this , res , ibeg , iend ) class ( ivector_t ), target , intent ( in ) :: this integer , dimension (:), pointer , intent ( out ) :: res integer , intent ( in ), optional :: ibeg integer , intent ( in ), optional :: iend integer :: ibeg_ integer :: iend_ res => null () ibeg_ = 1 iend_ = this % len if ( present ( ibeg )) then ibeg_ = ibeg end if if ( present ( iend )) then iend_ = iend end if res => this % buffer ( ibeg_ : iend_ ) end subroutine !****************************************************************************** !> Returns a pointer to the underlying data of a *dvector* ! No bounds checking is performed subroutine dvector_get_data ( this , res , ibeg , iend ) class ( dvector_t ), target , intent ( in ) :: this real ( rp ), dimension (:), pointer , intent ( out ) :: res integer , intent ( in ), optional :: ibeg integer , intent ( in ), optional :: iend integer :: ibeg_ integer :: iend_ res => null () ibeg_ = 1 iend_ = this % len if ( present ( ibeg )) then ibeg_ = ibeg end if if ( present ( iend )) then iend_ = iend end if res => this % buffer ( ibeg_ : iend_ ) end subroutine !****************************************************************************** !> Resizes a vector to a given size. Existing data is truncated if desired size !> is smaller than current size. Otherwise, the empty spaces are filled with !> zero. subroutine ivector_resize ( this , new_size , ierr ) class ( ivector_t ), intent ( in out ) :: this integer , intent ( in ) :: new_size integer , intent ( out ), optional :: ierr integer , dimension (:), allocatable :: temp integer :: istat if ( this % len_max >= new_size ) then this % buffer ( this % len + 1 : new_size ) = 0 this % len = new_size else allocate ( temp ( new_size ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for `temp` from `this%buffer`.' if ( present ( ierr )) ierr = 1 return end if temp = 0 ; temp ( 1 : this % len_max ) = this % buffer call move_alloc ( temp , this % buffer ) this % len_max = new_size ; this % len = new_size end if if ( present ( ierr )) ierr = 0 end subroutine !****************************************************************************** !> Resizes a vector to a given size. Existing data is truncated if desired size !> is smaller than current size. Otherwise, the empty spaces are filled with !> zero. subroutine dvector_resize ( this , new_size , ierr ) class ( dvector_t ), intent ( in out ) :: this integer , intent ( in ) :: new_size integer , intent ( out ), optional :: ierr real ( rp ), dimension (:), allocatable :: temp integer :: istat ierr = 0 if ( this % len_max > new_size ) then this % buffer ( this % len + 1 : new_size ) = 0.0_rp this % len = new_size else allocate ( temp ( new_size ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for `temp` from `this%buffer`.' if ( present ( ierr )) ierr = 1 return end if temp = 0.0_rp ; temp ( 1 : this % len_max ) = this % buffer call move_alloc ( temp , this % buffer ) this % len_max = new_size ; this % len = new_size end if if ( present ( ierr )) ierr = 0 end subroutine !****************************************************************************** !> Releases additional memory to fit underlying data of an *ivector* to a size !> this%len_init. subroutine ivector_shrink_to_fit ( this , ierr ) class ( ivector_t ), intent ( in out ) :: this integer , intent ( out ), optional :: ierr integer , dimension (:), allocatable :: temp integer :: istat if ( present ( ierr )) ierr = 0 if ( this % len > this % len_init ) then allocate ( temp , source = this % buffer ( 1 : this % len ), stat = istat ) else allocate ( temp ( this % len_init ), stat = istat ) temp = 0 temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) end if if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for `temp` from `this%buffer`.' if ( present ( ierr )) ierr = 1 return end if call move_alloc ( temp , this % buffer ) this % len_max = size ( this % buffer ) end subroutine !****************************************************************************** !> Releases additional memory to fit underlying data of a *dvector* to a size !> this%len_init. subroutine dvector_shrink_to_fit ( this , ierr ) class ( dvector_t ), intent ( in out ) :: this integer , intent ( out ), optional :: ierr real ( rp ), dimension (:), allocatable :: temp integer :: istat if ( present ( ierr )) ierr = 0 if ( this % len > this % len_init ) then allocate ( temp , source = this % buffer ( 1 : this % len ), stat = istat ) else allocate ( temp ( this % len_init ), stat = istat ) temp = 0.0_rp temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) end if if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for `temp` from `this%buffer`.' if ( present ( ierr )) ierr = 1 return end if call move_alloc ( temp , this % buffer ) this % len_max = size ( this % buffer ) end subroutine !****************************************************************************** !>  Sorts an *ivector* in ascending order. If `order` is provided, it will contain !!  the sorted indices.  The size of `order` must be at least `this%len`. subroutine ivector_sort ( this , order ) class ( ivector_t ), intent ( in out ) :: this integer , dimension (:), intent ( out ), optional :: order integer :: n n = this % len if ( n > 1 ) then if ( present ( order )) then call iqsort ( this % buffer ( 1 : n ), order ) else call iqsort ( this % buffer ( 1 : n )) end if end if end subroutine !****************************************************************************** !>  Sorts a *dvector* in ascending order. If `order` is provided, it will contain !!  the sorted indices.  The size of `order` must be at least `this%len`. subroutine dvector_sort ( this , order ) class ( dvector_t ), intent ( in out ) :: this integer , dimension (:), intent ( out ), optional :: order integer :: n n = this % len if ( n > 1 ) then if ( present ( order )) then call dqsort ( this % buffer ( 1 : n ), order ) else call dqsort ( this % buffer ( 1 : n )) end if end if end subroutine !****************************************************************************** !> Sorts and removes all duplicate entries of an *ivector*. Note that the internal !! buffer size remains unchanged. To reduce the buffer size, call !! `ivector_shrink_to_fit`. subroutine ivector_unique ( this ) class ( ivector_t ), intent ( in out ) :: this integer , dimension ( this % len ) :: temp integer :: n integer :: i if ( this % len < 2 ) return !Already sorted temp = this % buffer ( 1 : this % len ) call iqsort ( temp ) !The first element is unique by default this % buffer ( 1 ) = temp ( 1 ) n = 1 !Successively copy non-duplicate elements do i = 2 , this % len if ( temp ( i ) /= this % buffer ( n )) then this % buffer ( n + 1 ) = temp ( i ) n = n + 1 end if end do !Set the length to number of unique elements this % len = n end subroutine !****************************************************************************** !> Sorts and removes all duplicate entries of a *dvector*. Note that the internal !! buffer size remains unchanged. To reduce the buffer size, call !! `dvector_shrink_to_fit`. subroutine dvector_unique ( this ) class ( dvector_t ), intent ( in out ) :: this real ( rp ), dimension ( this % len ) :: temp integer :: n integer :: i if ( this % len < 2 ) return !Already sorted temp = this % buffer call dqsort ( temp ) !The first element is unique by default this % buffer ( 1 ) = temp ( 1 ) n = 1 !Successively copy non-duplicate elements do i = 2 , this % len if ( temp ( i ) /= this % buffer ( n )) then this % buffer ( n + 1 ) = temp ( i ) n = n + 1 end if end do !Set the length to number of unique elements this % len = n end subroutine !****************************************************************************** !> Prints an *ivector* subroutine ivector_print ( this ) class ( ivector_t ), intent ( in ) :: this integer :: i do i = 1 , this % len write ( * , '(i0,1x,i0)' ) i , this % buffer ( i ) end do end subroutine !****************************************************************************** !> Prints a *dvector* subroutine dvector_print ( this ) class ( dvector_t ), intent ( in ) :: this integer :: i do i = 1 , this % len write ( * , '(i0,1x,f0.15)' ) i , this % buffer ( i ) end do end subroutine !****************************************************************************** end module vector_m","tags":"","loc":"sourcefile/vector_m.f90.html"},{"title":"timestamp_m.f90 – BROWNPAK","text":"Files dependent on this one sourcefile~~timestamp_m.f90~~AfferentGraph sourcefile~timestamp_m.f90 timestamp_m.f90 sourcefile~logger_m.f90 logger_m.f90 sourcefile~logger_m.f90->sourcefile~timestamp_m.f90 sourcefile~brown_m.f90 brown_m.f90 sourcefile~brown_m.f90->sourcefile~logger_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~logger_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90->sourcefile~logger_m.f90 sourcefile~bd_solver_m.f90->sourcefile~brown_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~ia_bond_m.f90 ia_bond_m.f90 sourcefile~ia_bond_m.f90->sourcefile~logger_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~logger_m.f90 sourcefile~main.f90->sourcefile~setup_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_bond_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules timestamp_m Source Code timestamp_m.f90 Source Code !******************************************************************************! !                                                                              ! ! This library is free software; you can redistribute it and/or                ! ! modify it under the terms of the GNU Lesser General Public                   ! ! License as published by the Free Software Foundation; either                 ! ! version 2.1 of the License, or (at your option) any later version.           ! !                                                                              ! ! This library is distributed in the hope that it will be useful,              ! ! but WITHOUT ANY WARRANTY; without even the implied warranty of               ! ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU            ! ! Lesser General Public License for more details.                              ! !                                                                              ! ! You should have received a copy of the GNU Lesser General Public             ! ! License along with this library; if not, write to the Free Software          ! ! Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA ! !                                                                              ! !******************************************************************************! module timestamp_m implicit none contains !*****************************************************************************80 subroutine hms_current_hms ( h , m , s , mm ) !! HMS_CURRENT_HMS returns the current HMS time as integers. !! !! Example: !! !!   If the current time is 9:45:54.872 AM, then !! !!   H = 9 !!   M = 45 !!   S = 54 !!   MM = 872 !! !! Licensing: !! !!   This code is distributed under the GNU LGPL license. !! !! Modified: !! !!   26 February 2005 !! !! Author: !! !!   John Burkardt !! !! Parameters: !! !!   Output, integer ( kind = 4 ) H, M, S, MM, the current hour, minute, !!   second, and thousandths of a second. implicit none integer ( kind = 4 ) h integer ( kind = 4 ) mm integer ( kind = 4 ) m integer ( kind = 4 ) s integer ( kind = 4 ) values ( 8 ) call date_and_time ( values = values ) h = values ( 5 ) m = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) end subroutine !*****************************************************************************80 subroutine hms_current_print ( string ) !! HMS_CURRENT_PRINT prints the current HMS time, and a user specified string. !! !! Example: !! !!    Wallclock:  9:45:54.872 AM  Started determinant calculation. !!    Wallclock:  9:47:32.738 AM  Finished determinant calculation. !! !! Licensing: !! !!   This code is distributed under the GNU LGPL license. !! !! Modified: !! !!   05 May 2003 !! !! Author: !! !!   John Burkardt !! !! Parameters: !! !!   Input, character ( len = * ) STRING, the string to be printed. implicit none character ( len = 15 ) string2 character ( len = * ) string call hms_current_string ( string2 ) write ( * , '(a,2x,a,2x,a)' ) 'Wallclock:' , string2 , trim ( string ) end subroutine !*****************************************************************************80 subroutine hms_current_string ( string ) !! HMS_CURRENT_STRING writes the current HMS data into a string. !! !!  Example: !! !!    STRING = ' 9:45:54.872 AM' !! !!  Licensing: !! !!    This code is distributed under the GNU LGPL license. !! !!  Modified: !! !!    26 February 2005 !! !!  Author: !! !!    John Burkardt !! !!  Parameters: !! !!    Output, character ( len = * ) STRING, contains the HMS information. !!    A character length of 15 should always be sufficient. implicit none character ( len = 2 ) ampm integer ( kind = 4 ) h integer ( kind = 4 ) mm integer ( kind = 4 ) n integer ( kind = 4 ) s character ( len = * ) string integer ( kind = 4 ) values ( 8 ) call date_and_time ( values = values ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Nn' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Md' else ampm = 'AM' end if end if end if write ( string , '(i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) end subroutine !*****************************************************************************80 subroutine hms_delta_print ( string ) !! HMS_DELTA_PRINT prints the change in HMS time, and a user specified string. !! !!  Example: !! !!    Delta Wallclock:  0:01:37.966 AM  Determinant calculation. !! !!  Licensing: !! !!    This code is distributed under the GNU LGPL license. !! !!  Modified: !! !!    06 May 2003 !! !!  Author: !! !!    John Burkardt !! !!  Parameters: !! !!    Input, character ( len = * ) STRING, the string to be printed. !! implicit none integer ( kind = 4 ), save :: h = - 1 integer ( kind = 4 ) h_del integer ( kind = 4 ) h_old integer ( kind = 4 ), save :: m = 0 integer ( kind = 4 ) m_del integer ( kind = 4 ) m_old integer ( kind = 4 ), save :: mm = 0 integer ( kind = 4 ) mm_del integer ( kind = 4 ) mm_old integer ( kind = 4 ), save :: s = 0 integer ( kind = 4 ) s_del integer ( kind = 4 ) s_old character ( len = * ) string ! !  Back up the previous time. ! if ( h == - 1 ) then call hms_current_hms ( h , m , s , mm ) h_old = h m_old = m s_old = s mm_old = mm else h_old = h m_old = m s_old = s mm_old = mm call hms_current_hms ( h , m , s , mm ) end if h_del = h - h_old m_del = m - m_old s_del = s - s_old mm_del = mm - mm_old if ( mm_del < 0 ) then s_del = s_del - 1 mm_del = mm_del + 1000 end if if ( s_del < 0 ) then m_del = m_del - 1 s_del = s_del + 60 end if if ( m_del < 0 ) then m_del = m_del + 60 h_del = h_del - 1 end if if ( h_del < 0 ) then h_del = h_del + 24 end if write ( * , '(a,i2,a1,i2.2,a1,i2.2,a1,i3.3,2x,a)' ) & 'Delta Wallclock: ' , h_del , ':' , m_del , ':' , s_del , '.' , mm_del , & trim ( string ) end subroutine !*****************************************************************************80 ! subroutine timestamp ( ) !! TIMESTAMP prints the current YMDHMS date as a time stamp. !! !!  Example: !! !!    31 May 2001   9:45:54.872 AM !! !!  Licensing: !! !!    This code is distributed under the GNU LGPL license. !! !!  Modified: !! !!    18 May 2013 !! !!  Author: !! !!    John Burkardt !! !!  Parameters: !! !!    None !! implicit none character ( len = 8 ) ampm integer ( kind = 4 ) d integer ( kind = 4 ) h integer ( kind = 4 ) m integer ( kind = 4 ) mm character ( len = 9 ), parameter , dimension ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) integer ( kind = 4 ) n integer ( kind = 4 ) s integer ( kind = 4 ) values ( 8 ) integer ( kind = 4 ) y call date_and_time ( values = values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( * , '(i2.2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & d , trim ( month ( m ) ), y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) end subroutine !*****************************************************************************80 ! subroutine timestring ( string ) !! TIMESTRING writes the current YMDHMS date into a string. !! !!  Example: !! !!    STRING = '31 May 2001   9:45:54.872 AM' !! !!  Licensing: !! !!    This code is distributed under the GNU LGPL license. !! !!  Modified: !! !!    06 August 2005 !! !!  Author: !! !!    John Burkardt !! !!  Parameters: !! !!    Output, character ( len = * ) STRING, contains the date information. !!    A character length of 40 should always be sufficient. !! implicit none character ( len = 8 ) ampm integer ( kind = 4 ) d integer ( kind = 4 ) h integer ( kind = 4 ) m integer ( kind = 4 ) mm character ( len = 6 ), parameter , dimension ( 12 ) :: month = ( / & 'Jan   ' , 'Feb   ' , 'March ' , 'April ' , & 'May   ' , 'June  ' , 'July  ' , 'Aug   ' , & 'Sept  ' , 'Oct   ' , 'Nov   ' , 'Dec   ' / ) integer ( kind = 4 ) n integer ( kind = 4 ) s character ( len = * ) string integer ( kind = 4 ) values ( 8 ) integer ( kind = 4 ) y call date_and_time ( values = values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( string , '(i2.2,1x,a,1x,i4,1x,i0,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & d , trim ( month ( m ) ), y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) end subroutine !******************************************************************************* end module timestamp_m","tags":"","loc":"sourcefile/timestamp_m.f90.html"},{"title":"interaction_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~interaction_m.f90~~EfferentGraph sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~table_m.f90 table_m.f90 sourcefile~interaction_m.f90->sourcefile~table_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~interaction_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_vdw_m.f90 ia_vdw_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_vdw_m.f90 sourcefile~control_m.f90 control_m.f90 sourcefile~interaction_m.f90->sourcefile~control_m.f90 sourcefile~ia_dihedral_m.f90 ia_dihedral_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_dihedral_m.f90 sourcefile~stats_m.f90 stats_m.f90 sourcefile~interaction_m.f90->sourcefile~stats_m.f90 sourcefile~ia_external_m.f90 ia_external_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_external_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~interaction_m.f90->sourcefile~constants_m.f90 sourcefile~ia_angle_m.f90 ia_angle_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_angle_m.f90 sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~interaction_m.f90->sourcefile~simbox_m.f90 sourcefile~ia_tether_m.f90 ia_tether_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_tether_m.f90 sourcefile~ia_bond_m.f90 ia_bond_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_bond_m.f90 sourcefile~table_m.f90->sourcefile~constants_m.f90 sourcefile~vector_m.f90 vector_m.f90 sourcefile~table_m.f90->sourcefile~vector_m.f90 sourcefile~pairtab_m.fpp->sourcefile~table_m.f90 sourcefile~pairtab_m.fpp->sourcefile~atmcfg_m.f90 sourcefile~pairtab_m.fpp->sourcefile~constants_m.f90 sourcefile~pairtab_m.fpp->sourcefile~simbox_m.f90 sourcefile~connectivity_m.f90 connectivity_m.f90 sourcefile~pairtab_m.fpp->sourcefile~connectivity_m.f90 sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~aabbtree_m.f90 sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~pairtab_m.fpp->sourcefile~cell_list_m.f90 sourcefile~pairtab_m.fpp->sourcefile~vector_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~constants_m.f90 sourcefile~control_m.f90->sourcefile~constants_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~control_m.f90->sourcefile~strings_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~constants_m.f90 sourcefile~stats_m.f90->sourcefile~atmcfg_m.f90 sourcefile~stats_m.f90->sourcefile~control_m.f90 sourcefile~stats_m.f90->sourcefile~constants_m.f90 sourcefile~stats_m.f90->sourcefile~simbox_m.f90 sourcefile~stats_m.f90->sourcefile~strings_m.f90 sourcefile~ia_external_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_external_m.f90->sourcefile~constants_m.f90 sourcefile~ia_angle_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_angle_m.f90->sourcefile~constants_m.f90 sourcefile~simbox_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90 random_m.f90 sourcefile~simbox_m.f90->sourcefile~random_m.f90 sourcefile~ia_tether_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_tether_m.f90->sourcefile~constants_m.f90 sourcefile~ia_bond_m.f90->sourcefile~constants_m.f90 sourcefile~logger_m.f90 logger_m.f90 sourcefile~ia_bond_m.f90->sourcefile~logger_m.f90 sourcefile~ia_bond_m.f90->sourcefile~strings_m.f90 sourcefile~timestamp_m.f90 timestamp_m.f90 sourcefile~logger_m.f90->sourcefile~timestamp_m.f90 sourcefile~connectivity_m.f90->sourcefile~table_m.f90 sourcefile~connectivity_m.f90->sourcefile~constants_m.f90 sourcefile~connectivity_m.f90->sourcefile~vector_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 sourcefile~aabbtree_m.f90->sourcefile~constants_m.f90 sourcefile~aabbtree_m.f90->sourcefile~strings_m.f90 sourcefile~aabbtree_m.f90->sourcefile~vector_m.f90 sourcefile~aabb_m.fpp aabb_m.fpp sourcefile~aabbtree_m.f90->sourcefile~aabb_m.fpp sourcefile~cell_list_m.f90->sourcefile~constants_m.f90 sourcefile~cell_list_m.f90->sourcefile~simbox_m.f90 sourcefile~cell_list_m.f90->sourcefile~vector_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~aabb_m.fpp->sourcefile~constants_m.f90 sourcefile~aabb_m.fpp->sourcefile~strings_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~interaction_m.f90~~AfferentGraph sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules interaction_m Source Code interaction_m.f90 Source Code module interaction_m !! Driver routines for force & energy calculation. use constants_m use table_m use simbox_m use pairtab_m use ia_bond_m use ia_angle_m use ia_dihedral_m use ia_vdw_m use ia_tether_m use ia_external_m use control_m use atmcfg_m use stats_m implicit none private public :: ia_setup , ia_finish , ia_calc_forces type ( itable_t ) :: pair_tab logical :: lvdw contains !****************************************************************************** subroutine ia_setup ( cpar , simbox , atc ) !! Builds necessary neighbor tables and sets up parameters for potentials. type ( ctrlpar_t ), intent ( in ) :: cpar type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in out ) :: atc lvdw = . true . if ( (. not . cpar % lvdw ) . or . ( atc % num_vdw_types == 0 ) ) lvdw = . false . if ( lvdw ) then call pt_init ( cpar % mth_ptgen , atc % num_atoms , cpar % excluded_atoms , & cpar % rcutoff , cpar % tskin , atc % bonds , simbox , pair_tab ) call ia_vdw_setup ( atc % num_vdw_types , atc % vdw_styles , atc % vdw_params ) end if if ( atc % num_bonds > 0 ) then call ia_bond_setup ( atc % num_bond_types , atc % bond_styles , atc % bond_params ) end if if ( atc % num_angles > 0 ) then call ia_angle_setup ( atc % num_angle_types , atc % angle_styles , & atc % angle_params ) end if if ( atc % num_dihedrals > 0 ) then call ia_dihedral_setup ( atc % num_dihedral_types , atc % dihedral_styles , & atc % dihedral_params ) end if if ( atc % num_tethers > 0 ) then call ia_tether_setup ( atc % num_tether_types , atc % tether_styles , & atc % tether_params ) end if if ( atc % num_externals > 0 ) then call ia_external_setup ( atc % num_externals , atc % external_styles , & atc % external_params ) end if end subroutine !****************************************************************************** subroutine ia_finish () !! Cleanup routine for interaction calculation. call pt_delete ( pair_tab ) end subroutine !****************************************************************************** subroutine ia_calc_forces ( simbox , atc , ierr ) !! Calculates total forces and energies type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in out ) :: atc integer , intent ( out ) :: ierr ierr = 0 !Zeroing out force, energies, & bond length atc % forces = 0.0_rp energy_bond = 0.0_rp energy_angle = 0.0_rp energy_dihedral = 0.0_rp energy_tether = 0.0_rp energy_vdw = 0.0_rp energy_external = 0.0_rp energy_tot = 0.0_rp stress = 0.0_rp !Calculation of bonded interactions if ( atc % num_bonds > 0 ) then bndlen = 0.0_rp bndlen_min = huge ( 0.0_rp ) bndlen_max = 0.0_rp call ia_add_bond_forces ( simbox , atc , ierr ) if ( ierr /= 0 ) return end if !Calculation of angular interactions if ( atc % num_angles > 0 ) call ia_add_angle_forces ( simbox , atc ) !Calculation of dihedral interactions if ( atc % num_dihedrals > 0 ) call ia_add_dihedral_forces ( simbox , atc ) !Calculation of tether interactions if ( atc % num_tethers > 0 ) then call ia_add_tether_forces ( atc , ierr ) if ( ierr /= 0 ) return end if !Calculation for pairwise interactions if ( lvdw ) then call ia_add_vdw_forces ( simbox , atc , ierr ) if ( ierr /= 0 ) return end if !Calculation of external interactions if ( atc % num_externals > 0 ) then call ia_add_external_forces ( atc % num_externals , atc % external_styles , & atc % external_params , atc % coordinates , energy_external , & atc % forces , stress , ierr ) if ( ierr /= 0 ) return end if !Calculate total energy energy_tot = energy_bond + energy_angle + energy_dihedral + energy_vdw & + energy_tether + energy_external !Update stress considering volume for finite concentration if ( simbox % imcon /= 0 ) stress = stress / simbox % volume end subroutine !******************************************************************************** subroutine ia_add_vdw_forces ( simbox , atc , ierr ) !! Calculates force and energy due to all short-ranged non-bonded pairwise !! interactions based on `pair_tab`. type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in out ) :: atc integer , intent ( out ) :: ierr integer , dimension (:), pointer :: pnbrs => null () real ( rp ), dimension ( 3 ) :: ri , rj , rij , fi real ( rp ) :: rij_mag real ( rp ) :: qi , qj real ( rp ) :: enrg , frc integer :: i , j , k , at_i , at_j , typ ierr = 0 call pt_build ( simbox , atc % coordinates , pair_tab ) do i = 1 , atc % num_atoms ri = atc % coordinates (:, i ) qi = atc % charge ( i ) at_i = atc % atoms ( i ) !Getting list of neighbors of atom i using pointer pnbrs call pair_tab % get_row ( i , pnbrs ) do k = 1 , size ( pnbrs ) j = pnbrs ( k ) rj = atc % coordinates (:, j ) qj = atc % charge ( j ) at_j = atc % atoms ( j ) if ( at_i < at_j ) then typ = at_j + ( 2 * atc % num_atom_types - at_i ) * ( at_i - 1 ) / 2 else typ = at_i + ( 2 * atc % num_atom_types - at_j ) * ( at_j - 1 ) / 2 end if rij = rj - ri if ( simbox % imcon /= 0 ) call simbox % get_image ( rij ) rij_mag = norm2 ( rij ) call ia_get_vdw_force ( rij_mag , qi , qj , atc % vdw_styles ( typ ), & atc % vdw_params (:, typ ), enrg , frc , ierr ) if ( ierr /= 0 ) return energy_vdw = energy_vdw + enrg fi = frc * rij / rij_mag !Update forces atc % forces (:, i ) = atc % forces (:, i ) + fi atc % forces (:, j ) = atc % forces (:, j ) - fi !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - rij ( 1 ) * fi ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - rij ( 2 ) * fi ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - rij ( 3 ) * fi ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - rij ( 1 ) * fi ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - rij ( 2 ) * fi ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - rij ( 3 ) * fi ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - rij ( 1 ) * fi ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - rij ( 2 ) * fi ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - rij ( 3 ) * fi ( 3 ) end do end do end subroutine !******************************************************************************** subroutine ia_add_bond_forces ( simbox , atc , ierr ) !! Calculates forces & energy due to all bonds. Will add to !! `energy_bond` & and 'forces` in module `m_globals`. type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in out ) :: atc integer , intent ( out ) :: ierr real ( rp ), dimension ( 3 ) :: ri , rj , rij , fi real ( rp ) :: rij_mag real ( rp ) :: enrg , frc integer :: ibnd , typ integer :: i , j ierr = 0 do ibnd = 1 , atc % num_bonds typ = atc % bonds ( 1 , ibnd ) i = atc % bonds ( 2 , ibnd ) j = atc % bonds ( 3 , ibnd ) ri = atc % coordinates (:, i ) rj = atc % coordinates (:, j ) rij = rj - ri if ( simbox % imcon /= 0 ) call simbox % get_image ( rij ) rij_mag = norm2 ( rij ) bndlen = bndlen + rij_mag bndlen_min = min ( bndlen_min , rij_mag ) bndlen_max = max ( bndlen_max , rij_mag ) call ia_get_bond_force ( rij_mag , atc % bond_styles ( typ ), & atc % bond_params (:, typ ), enrg , frc , ierr ) if ( ierr /= 0 ) return energy_bond = energy_bond + enrg fi = frc * rij / rij_mag atc % forces (:, i ) = atc % forces (:, i ) + fi atc % forces (:, j ) = atc % forces (:, j ) - fi !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - rij ( 1 ) * fi ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - rij ( 2 ) * fi ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - rij ( 3 ) * fi ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - rij ( 1 ) * fi ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - rij ( 2 ) * fi ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - rij ( 3 ) * fi ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - rij ( 1 ) * fi ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - rij ( 2 ) * fi ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - rij ( 3 ) * fi ( 3 ) end do bndlen = bndlen / atc % num_bonds end subroutine !******************************************************************************** subroutine ia_add_angle_forces ( simbox , atc ) !! Calculates forces & energy due to all angles. Will add to !! `energy_angle` & 'forces`. type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in out ) :: atc real ( rp ), dimension ( 3 ) :: rim1 , ri , rip1 , q1 , q2 real ( rp ), dimension ( 3 ) :: fim1 , fi , fip1 real ( rp ) :: enrg integer :: iang integer :: typ integer :: i , im1 , ip1 do iang = 1 , atc % num_angles typ = atc % angles ( 1 , iang ) im1 = atc % angles ( 2 , iang ) i = atc % angles ( 3 , iang ) ip1 = atc % angles ( 4 , iang ) rim1 = atc % coordinates (:, im1 ) ri = atc % coordinates (:, i ) rip1 = atc % coordinates (:, ip1 ) q1 = ri - rim1 ; q2 = rip1 - ri if ( simbox % imcon /= 0 ) call simbox % get_image ( q1 ) if ( simbox % imcon /= 0 ) call simbox % get_image ( q2 ) call ia_get_angle_force ( q1 , q2 , atc % angle_styles ( typ ), & atc % angle_params (:, typ ), enrg , fim1 , fi , fip1 ) energy_angle = energy_angle + enrg !Update forces atc % forces (:, im1 ) = atc % forces (:, im1 ) + fim1 atc % forces (:, i ) = atc % forces (:, i ) + fi atc % forces (:, ip1 ) = atc % forces (:, ip1 ) + fip1 !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - q1 ( 1 ) * fim1 ( 1 ) + q2 ( 1 ) * fip1 ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - q1 ( 2 ) * fim1 ( 1 ) + q2 ( 2 ) * fip1 ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - q1 ( 3 ) * fim1 ( 1 ) + q2 ( 3 ) * fip1 ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - q1 ( 1 ) * fim1 ( 2 ) + q2 ( 1 ) * fip1 ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - q1 ( 2 ) * fim1 ( 2 ) + q2 ( 2 ) * fip1 ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - q1 ( 3 ) * fim1 ( 2 ) + q2 ( 3 ) * fip1 ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - q1 ( 1 ) * fim1 ( 3 ) + q2 ( 1 ) * fip1 ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - q1 ( 2 ) * fim1 ( 3 ) + q2 ( 2 ) * fip1 ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - q1 ( 3 ) * fim1 ( 3 ) + q2 ( 3 ) * fip1 ( 3 ) end do end subroutine !******************************************************************************** subroutine ia_add_dihedral_forces ( simbox , atc ) !! Calculates forces & energy due to all dihedrals. Will add to !! `energy_dihedral` & 'forces`. type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in out ) :: atc real ( rp ), dimension ( 3 ) :: ri , rj , rk , rl real ( rp ), dimension ( 3 ) :: q1 , q2 , q3 real ( rp ), dimension ( 3 ) :: fi , fj , fk , fl real ( rp ) :: enrg integer :: idhd integer :: typ integer :: i , j , k , l do idhd = 1 , atc % num_dihedrals typ = atc % dihedrals ( 1 , idhd ) i = atc % dihedrals ( 2 , idhd ) j = atc % dihedrals ( 3 , idhd ) k = atc % dihedrals ( 4 , idhd ) l = atc % dihedrals ( 5 , idhd ) ri = atc % coordinates (:, i ) rj = atc % coordinates (:, j ) rk = atc % coordinates (:, k ) rl = atc % coordinates (:, l ) q1 = rj - ri ; q2 = rk - rj ; q3 = rl - rk if ( simbox % imcon /= 0 ) call simbox % get_image ( q1 ) if ( simbox % imcon /= 0 ) call simbox % get_image ( q2 ) if ( simbox % imcon /= 0 ) call simbox % get_image ( q3 ) call ia_get_dihedral_force ( q1 , q2 , q3 , atc % dihedral_styles ( typ ), & atc % dihedral_params (:, typ ), enrg , fi , fj , fk , fl ) energy_dihedral = energy_dihedral + enrg atc % forces (:, i ) = atc % forces (:, i ) + fi atc % forces (:, j ) = atc % forces (:, j ) + fj atc % forces (:, k ) = atc % forces (:, k ) + fk atc % forces (:, l ) = atc % forces (:, l ) + fl !TODO: Add the contribution to stress here. end do end subroutine !******************************************************************************** subroutine ia_add_tether_forces ( atc , ierr ) !! Calculates forces & energy due to all tethers. Will add to `energy_tether` & !! 'forces`. Tether forces are not subject to periodic boundary conditions. type ( atmcfg_t ), intent ( in out ) :: atc integer , intent ( out ) :: ierr real ( rp ), dimension ( 3 ) :: r , tp , q , fj real ( rp ) :: qmag real ( rp ) :: enrg , frc integer :: iteth , typ , teth_iatm ierr = 0 do iteth = 1 , atc % num_tethers typ = atc % tethers ( 1 , iteth ) teth_iatm = atc % tethers ( 2 , iteth ) !Index of the tethered atom tp = atc % tether_points (:, iteth ) r = atc % coordinates (:, teth_iatm ) q = r - tp qmag = norm2 ( q ) call ia_get_tether_force ( qmag , atc % tether_styles ( typ ), & atc % tether_params (:, typ ), enrg , frc , ierr ) if ( ierr /= 0 ) return fj = - frc * q / qmag energy_tether = energy_tether + enrg atc % forces (:, teth_iatm ) = atc % forces (:, teth_iatm ) + fj !Update stress !Sign flipped since fj, not fi is involved stress ( 1 , 1 ) = stress ( 1 , 1 ) + q ( 1 ) * fj ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) + q ( 2 ) * fj ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) + q ( 3 ) * fj ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) + q ( 1 ) * fj ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) + q ( 2 ) * fj ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) + q ( 3 ) * fj ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) + q ( 1 ) * fj ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) + q ( 2 ) * fj ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) + q ( 3 ) * fj ( 3 ) end do end subroutine !****************************************************************************** end module interaction_m","tags":"","loc":"sourcefile/interaction_m.f90.html"},{"title":"utils_math_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~utils_math_m.f90~~EfferentGraph sourcefile~utils_math_m.f90 utils_math_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~utils_math_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules utils_math_m Source Code utils_math_m.f90 Source Code !********************************************************************************! !                                                                                ! ! The MIT License (MIT)                                                          ! !                                                                                ! ! Copyright (c) 2020 Sarit Dutta                                                 ! !                                                                                ! ! Permission is hereby granted, free of charge, to any person obtaining a copy   ! ! of this software and associated documentation files (the \"Software\"), to deal  ! ! in the Software without restriction, including without limitation the rights   ! ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      ! ! copies of the Software, and to permit persons to whom the Software is          ! ! furnished to do so, subject to the following conditions:                       ! !                                                                                ! ! The above copyright notice and this permission notice shall be included in all ! ! copies or substantial portions of the Software.                                ! !                                                                                ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     ! ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       ! ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    ! ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         ! ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  ! ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  ! ! SOFTWARE.                                                                      ! !                                                                                ! !********************************************************************************! module utils_math_m !!Various (mostly linear algebra) functions, particularly for use with small !!matrices. use , intrinsic :: ieee_arithmetic , only : ieee_is_nan , ieee_is_finite use constants_m implicit none interface allclose !! Checks if two arrays are elementwise close within tolerance module procedure allclose_rank1 module procedure allclose_rank2 module procedure allclose_rank3 end interface interface swap !! Swaps two arrays module procedure swap_integer module procedure swap_real module procedure swap_complex end interface swap contains !************************************************************************ elemental subroutine rad2deg ( rad , deg ) real ( rp ), intent ( in ) :: rad real ( rp ), intent ( out ) :: deg deg = ( 18 0.0_rp / math_pi ) * rad end subroutine !************************************************************************ elemental subroutine deg2rad ( deg , rad ) real ( rp ), intent ( in ) :: deg real ( rp ), intent ( out ) :: rad rad = ( math_pi / 18 0.0_rp ) * deg end subroutine !************************************************************************ subroutine cross ( a , b , c ) !!  Calculates the cross product between two 3-element vectors real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( in ) :: b real ( rp ), dimension ( 3 ), intent ( out ) :: c !! Cross product of `a` and `b`; **c** = **a** x **b** c ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end subroutine !****************************************************************************** subroutine cross_mat ( a , mat ) !! Calculates the cross product matrix of a 3-element vector. The cross !! product matrix **A** of **a** is defined as **a** x **b** = **A** . **b**, !! where **b** is another 3-element vector. real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 , 3 ), intent ( out ) :: mat !! Cross product matrix of `a` mat = 0.0_rp mat ( 2 , 1 ) = a ( 3 ) mat ( 3 , 1 ) = - a ( 2 ) mat ( 1 , 2 ) = - a ( 3 ) mat ( 3 , 2 ) = a ( 1 ) mat ( 1 , 3 ) = a ( 2 ) mat ( 2 , 3 ) = - a ( 1 ) end subroutine !****************************************************************************** subroutine outer ( a , b , c ) !! Calculates the outer product of two vectors, c_{ij} = a_i  b_j. real ( rp ), dimension (:), intent ( in ) :: a !! (m,) array real ( rp ), dimension (:), intent ( in ) :: b !! (n,) array real ( rp ), dimension (:,:), intent ( out ) :: c !! (m,n) array; Outer product integer :: m , n integer :: i , j m = size ( a ) n = size ( b ) do j = 1 , n do i = 1 , m c ( i , j ) = a ( i ) * b ( j ) end do end do end subroutine !****************************************************************************** function scalar_triple_product ( a , b , c ) result ( res ) !! Returns the scalar triple product **a**.(**b** x **c**) real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( in ) :: b real ( rp ), dimension ( 3 ), intent ( in ) :: c real ( rp ) :: res res = a ( 1 ) * ( b ( 2 ) * c ( 3 ) - c ( 2 ) * b ( 3 ) ) - a ( 2 ) * ( b ( 1 ) * c ( 3 ) - c ( 1 ) * b ( 3 ) ) & + a ( 3 ) * ( b ( 1 ) * c ( 2 ) - c ( 1 ) * b ( 2 ) ) end function !****************************************************************************** subroutine vector_triple_product ( a , b , c , d ) !! Returns the vector triple product **d** = **a** x (**b** x **c**) real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( in ) :: b real ( rp ), dimension ( 3 ), intent ( in ) :: c real ( rp ), dimension ( 3 ), intent ( out ) :: d !! Vector triple product d = b * ( a ( 1 ) * c ( 1 ) + a ( 2 ) * c ( 2 ) + a ( 3 ) * c ( 3 ) ) & - c * ( a ( 1 ) * b ( 1 ) + a ( 2 ) * b ( 2 ) + a ( 3 ) * b ( 3 ) ) end subroutine !****************************************************************************** function det ( A ) result ( res ) !!  Returns the determinant of an (N x N) matrix, where N = 2, 3, or 4. !! !!  Original routine by [David Simpson](http://www.davidgsimpson.com/software.html) !!  @note For a general NxN matrix do an LU decomp !\"\" real ( rp ), dimension (:,:), intent ( in ) :: A !! (N,N) array, where N = 2, 3, or 4. real ( rp ) :: res integer :: nrows nrows = size ( A , 1 ) if ( nrows == 2 ) then res = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) else if ( nrows == 3 ) then res = A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 1 , 1 ) * A ( 2 , 3 ) * A ( 3 , 2 ) & - A ( 1 , 2 ) * A ( 2 , 1 ) * A ( 3 , 3 ) + A ( 1 , 2 ) * A ( 2 , 3 ) * A ( 3 , 1 ) & + A ( 1 , 3 ) * A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 1 , 3 ) * A ( 2 , 2 ) * A ( 3 , 1 ) else if ( nrows == 4 ) then res = A ( 1 , 1 ) * ( A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) & + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) & + A ( 2 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) ) & - A ( 1 , 2 ) * ( A ( 2 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) & + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) & + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 )) ) & + A ( 1 , 3 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) & + A ( 2 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) & + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )) ) & - A ( 1 , 4 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) & + A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 )) & + A ( 2 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )) ) else stop 'matrix size must be 2, 3, or 4' end if end function !****************************************************************************** function trace ( mat ) result ( res ) !! Returns the trace of a square matrix real ( rp ), intent ( in ) :: mat (:,:) !! (N,N) array real ( rp ) :: res integer :: nrows integer :: i nrows = size ( mat , 1 ) res = 0.0_rp do i = 1 , nrows res = res + mat ( i , i ) end do end function !****************************************************************************** elemental logical function isclose ( a , b , rel_tol , abs_tol ) !!  Checks if two floating point numbers of type double are close within !!  tolerance. !! !!  Based on python implementation at !!  <https://github.com/PythonCHB/close_pep/blob/master/is_close.py>. !!  The *method='weak'* option is used here. !\"\" real ( rp ), intent ( in ) :: a real ( rp ), intent ( in ) :: b real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance, `rel_tol` >= 0, default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance, `abs_tol` >= 0, default 0.0 real ( rp ) :: rel_tol_ real ( rp ) :: abs_tol_ real ( rp ) :: diff rel_tol_ = 1e-10_rp abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol if ( a == b ) then ! short-circuit exact equality isclose = . true . end if if ((. not . ieee_is_finite ( a )) . or . (. not . ieee_is_finite ( b ))) then ! Includes the case of two infinities of opposite sign, or ! one infinity and one finite number. Two infinities of opposite sign ! would otherwise have an infinite relative tolerance. isclose = . false . end if diff = abs ( b - a ) isclose = ( (( diff <= abs ( rel_tol_ * b )) . or . ( diff <= abs ( rel_tol_ * a ))) & . or . ( diff <= abs_tol_ ) ) end function !****************************************************************************** logical function allclose_rank1 ( a , b , rel_tol , abs_tol ) !!  Checks if two rank-1 floating point arrays of type double are close within !!  tolerance. !\"\" real ( rp ), dimension (:), intent ( in ) :: a !! (m,) array real ( rp ), dimension (:), intent ( in ) :: b !! (m,) array real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance; default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance; default 0.0 real ( rp ) :: rel_tol_ = 1e-10_rp real ( rp ) :: abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol allclose_rank1 = all ( isclose ( a , b , rel_tol_ , abs_tol_ )) end function logical function allclose_rank2 ( a , b , rel_tol , abs_tol ) !!  Checks if two rank-2 floating point arrays of type double are close within !!  tolerance. !\"\" real ( rp ), dimension (:,:), intent ( in ) :: a !! (m,n) array real ( rp ), dimension (:,:), intent ( in ) :: b !! (m,n) array real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance; default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance; default 0.0 real ( rp ) :: rel_tol_ = 1e-10_rp real ( rp ) :: abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol allclose_rank2 = all ( isclose ( a , b , rel_tol_ , abs_tol_ )) end function logical function allclose_rank3 ( a , b , rel_tol , abs_tol ) !!  Checks if two rank-3 floating point arrays of type double are close within !!  tolerance. !\"\" real ( rp ), dimension (:,:,:), intent ( in ) :: a !! (m,n,p) array real ( rp ), dimension (:,:,:), intent ( in ) :: b !! (m,n,p) array real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance; default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance; default 0.0 real ( rp ) :: rel_tol_ = 1e-10_rp real ( rp ) :: abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol allclose_rank3 = all ( isclose ( a , b , rel_tol_ , abs_tol_ )) end function !****************************************************************************** elemental subroutine swap_integer ( a , b ) integer , intent ( in out ) :: a integer , intent ( in out ) :: b integer :: temp temp = a a = b b = temp end subroutine elemental subroutine swap_real ( a , b ) real ( rp ), intent ( in out ) :: a real ( rp ), intent ( in out ) :: b real ( rp ) :: temp temp = a a = b b = temp end subroutine elemental subroutine swap_complex ( a , b ) complex ( rp ), intent ( in out ) :: a complex ( rp ), intent ( in out ) :: b complex ( rp ) :: temp temp = a a = b b = temp end subroutine !****************************************************************************** subroutine unitize ( a ) !! Normalizes a vector in-place. If the magnitude of the vector is nearly !! zero, no normalization takes place and the vector is returned as is with !! a warning message. real ( rp ), dimension (:), intent ( in out ) :: a !! (m,) array real ( rp ) :: norm norm = norm2 ( a ) if ( isclose ( norm , 0.0_rp , rel_tol = 1.e-15_rp , abs_tol = 0.0_rp )) then write ( * , * ) '[unitize] norm close to zero' else a = a / norm2 ( a ) end if end subroutine !****************************************************************************** subroutine linspace ( start , finish , num , val , step ) !! Generates evenly spaced numbers over a specified interval. Both end !! points are included. If `start` < `finish`, the returned step size (if !! `step` is present) will be negative. !\"\" real ( rp ), intent ( in ) :: start !! Starting point real ( rp ), intent ( in ) :: finish !! Ending point, `finish` /= `start` integer , intent ( in ) :: num !! Number of values to generate, `num >= 2` real ( rp ), dimension (:), intent ( out ) :: val !! (`num`,) array; Generated values real ( rp ), intent ( out ), optional :: step !! Step size real ( rp ) :: step_ integer :: i if ( num < 2 ) then write ( * , * ) '[linspace] `num` must be >= 2' stop end if if ( num < size ( val )) then write ( * , * ) '[linspace] `size(val)` must be >= `num`' stop end if if ( start == finish ) then write ( * , * ) '[linspace] `start` must not be equal to `finish`' stop end if val = 0.0_rp step_ = ( finish - start ) / ( num - 1 ) if ( present ( step )) step = step_ val ( 1 ) = start val ( num ) = finish do i = 2 , ( num - 1 ) val ( i ) = start + ( i - 1 ) * step_ end do end subroutine !****************************************************************************** subroutine logspace ( start , finish , num , val , base ) !!  Generates numbers spaced evenly on a log scale. !!  In linear space, the sequence starts at `base ** start` !!  (`base` to the power of `start`) and ends with `base ** stop` !\"\" real ( rp ), intent ( in ) :: start !! Starting point, `base ** start` is the starting value real ( rp ), intent ( in ) :: finish !! Ending point, `finish` /= `start`,  `base ** start` !! is the ending value integer , intent ( in ) :: num !! Number of values to generate, `num >= 2` real ( rp ), dimension (:), intent ( out ) :: val !! (`num`,) array; Generated values real ( rp ), intent ( in ), optional :: base !! Base of the logspace, default 10 real ( rp ) :: base_ integer :: i if ( num < 2 ) then write ( * , * ) 'logspace `num` must be >= 2' stop end if if ( num < size ( val )) then write ( * , * ) 'logspace `size(val)` must be >= `num`' stop end if if ( start == finish ) then write ( * , * ) 'logspace `start` must not be equal to `finish`' stop end if val = 0.0_rp base_ = 1 0.0_rp if ( present ( base )) base_ = base call linspace ( start , finish , num , val ) do i = 1 , num val ( i ) = base_ ** val ( i ) end do end subroutine !****************************************************************************** subroutine identity ( mat_eye ) !! Creates an identity matrix of size n x n. real ( rp ), dimension (:,:), intent ( out ) :: mat_eye !! (n,n) array integer :: nrows integer :: i nrows = size ( mat_eye , 1 ) mat_eye = 0.0_rp do i = 1 , nrows mat_eye ( i , i ) = 1.0_rp end do end subroutine !****************************************************************************** subroutine get_diagonal ( mat , d ) !! Returns the diagonal elements of a square matrix. real ( rp ), dimension (:,:), intent ( in ) :: mat !! (n,n) array real ( rp ), dimension (:), intent ( out ) :: d !! (n,) array; contains the entries of the main diagonal integer :: n integer :: i n = size ( mat , 1 ) do i = 1 , n d ( i ) = mat ( i , i ) end do end subroutine !****************************************************************************** subroutine add_transpose ( mat ) !! Adds a square matrix and its transpose in place: A_{ij} = A_{ij } + A_{ji} real ( rp ), dimension (:,:), intent ( in out ) :: mat !! (n,n) array integer :: n integer :: i integer :: j n = size ( mat , 1 ) !Dealing with the upper triangular part (including diagonal) do j = 1 , n do i = 1 , j mat ( i , j ) = mat ( i , j ) + mat ( j , i ) end do end do !Dealing with the strictly lower triangular part (i.e. excluding diagonal) do j = 1 , ( n - 1 ) do i = ( j + 1 ), n mat ( i , j ) = mat ( j , i ) end do end do end subroutine !****************************************************************************** subroutine subtract_transpose ( mat ) !! Calculates the difference of a square matrix and its transpose in place: !! A_{ij} = A_{ij } - A_{ji} real ( rp ), dimension (:,:), intent ( in out ) :: mat integer :: n integer :: i integer :: j n = size ( mat , 1 ) !Dealing with the strictly upper triangular part (i.e. excluding diagonal) do j = 2 , n do i = 1 , ( j - 1 ) mat ( i , j ) = mat ( i , j ) - mat ( j , i ) end do end do !Dealing with the strictly lower triangular part (i.e. excluding diagonal) do j = 1 , ( n - 1 ) do i = ( j + 1 ), n mat ( i , j ) = - mat ( j , i ) end do end do !Putting the diagonal to zero do i = 1 , n mat ( i , j ) = 0.0_rp end do end subroutine !****************************************************************************** subroutine multiply_transpose ( A , B ) !! Multiplies a matrix with its transpose: !! \\mathbf{\\mathrm{B}} = \\mathbf{\\mathrm{A}} \\cdot \\mathbf{\\mathrm{A}}&#94;T !\"\" real ( rp ), dimension (:,:), intent ( in ) :: A !! (m,n) array real ( rp ), dimension (:,:), intent ( out ) :: B !! (m,m) array !A is m x n, A&#94;T is n x m, so B is m x m B = matmul ( A , transpose ( A )) end subroutine !****************************************************************************** function get_quad_form ( A , x ) result ( res ) !!  Calculates the quadratic form *x&#94;T A x*, where A is an *n x n* matrix and *x* is a !!  vector of length *n* !\"\" real ( rp ), dimension (:,:), intent ( in ) :: A !! (n,n) array real ( rp ), dimension (:), intent ( in ) :: x !! (n,) array real ( rp ) :: res integer :: n integer :: i , j n = size ( A , 2 ) res = 0.0_rp do j = 1 , n do i = 1 , n res = res + A ( i , j ) * x ( j ) * x ( i ) end do end do end function !****************************************************************************** subroutine orth ( a ) !! Orthogonalizes a set of vectors in-place using Gram-Schmidt orthonormalization !! !! *Reference:* Golub and Van Loan, Matrix Computations, 3rd edition, Section 5.2.8, !! Algorithm 5.2.5, p. 231. real ( rp ), dimension (:,:), intent ( in out ) :: a !! (m,n) array, where m <= n. The first m columns of the matrix are !!  overwritten with the orthogonal basis vectors. integer :: m integer :: i , j m = size ( a , 1 ) do i = 1 , m a ( i ,:) = a ( i ,:) / norm2 ( a ( i ,:)) do j = ( i + 1 ), m a ( j ,:) = a ( j ,:) - dot_product ( a ( j ,:), a ( i ,:)) * a ( i ,:) end do end do end subroutine !****************************************************************************** subroutine invert_mat33 ( a , inv_a ) !! Inverts a 3x3 matrix. !! !!*Reference:* https://www.geometrictools.com/Documentation/LaplaceExpansionTheorem.pdf real ( rp ), dimension ( 3 , 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 , 3 ), intent ( out ) :: inv_a real ( rp ) :: det_a inv_a ( 1 , 1 ) = a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 ) inv_a ( 2 , 1 ) = - ( a ( 2 , 1 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 1 )) inv_a ( 3 , 1 ) = a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 ) inv_a ( 1 , 2 ) = - ( a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 2 )) inv_a ( 2 , 2 ) = a ( 1 , 1 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 1 ) inv_a ( 3 , 2 ) = - ( a ( 1 , 1 ) * a ( 3 , 2 ) - a ( 1 , 2 ) * a ( 3 , 1 )) inv_a ( 1 , 3 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ) inv_a ( 2 , 3 ) = - ( a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 1 )) inv_a ( 3 , 3 ) = a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 ) !Determinant det_a = a ( 1 , 1 ) * inv_a ( 1 , 1 ) + a ( 1 , 2 ) * inv_a ( 2 , 1 ) + a ( 1 , 3 ) * inv_a ( 3 , 1 ) inv_a = inv_a / det_a end subroutine !****************************************************************************** subroutine eigval_33rsym ( a , ev ) !! Calculates the eigenvalues of a 3 x 3 real symmetric matrix. The !! eigenvalues calculated are in decreasing order. Only the diagonal and !! lower triangular part of the matrix is accessed. !! !! *Reference:* https://en.wikipedia.org/wiki/Eigenvalue_algorithm#cite_note-Smith-12 !! !! See also David Eberly's notes and implementation at !! https://www.geometrictools.com/Documentation/RobustEigenSymmetric3x3.pdf real ( rp ), dimension ( 3 , 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( out ) :: ev real ( rp ), dimension ( 3 , 3 ) :: eye real ( rp ), dimension ( 3 , 3 ) :: b real ( rp ) :: p , q , r real ( rp ) :: p1 , p2 real ( rp ) :: phi !Sum of the elements in the lower triangular part p1 = a ( 2 , 1 ) ** 2 + a ( 3 , 1 ) ** 2 + a ( 3 , 2 ) ** 2 if ( isclose ( p1 , 0.0_rp ) ) then !Matrix a is diagonal ev ( 1 ) = a ( 1 , 1 ); ev ( 2 ) = a ( 2 , 2 ); ev ( 3 ) = a ( 3 , 3 ) return else q = ( a ( 1 , 1 ) + a ( 2 , 2 ) + a ( 3 , 3 )) / 3.0_rp p2 = ( a ( 1 , 1 ) - q ) ** 2 + ( a ( 2 , 2 ) - q ) ** 2 + ( a ( 3 , 3 ) - q ) ** 2 + 2 * p1 p = sqrt ( p2 / 6.0_rp ) call identity ( eye ) b = ( a - q * eye ) / p r = 0.5_rp * det ( b ) !r must be within [-1, 1] in exact computation; but need to handle !slightly out of range in computation. if ( r <= - 1.0_rp ) then phi = math_pi / 3.0_rp else if ( r >= 1.0_rp ) then phi = 0.0_rp else phi = acos ( r ) / 3.0_rp end if !Eigen values are ordered as ev(3) <= ev(2) <= ev(1) ev ( 1 ) = q + 2 * p * cos ( phi ) ev ( 3 ) = q + 2 * p * cos ( phi + ( 2 * math_pi / 3.0_rp )) ev ( 2 ) = 3 * q - ev ( 1 ) - ev ( 3 ) end if end subroutine !****************************************************************************** subroutine dsyevc3 ( a , w ) !!author: Joachim Kopp !!date: 2006 !! !! Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's !! analytical algorithm. !! Only the diagonal and upper triangular parts of A are accessed. The access !! is read-only. !! !! Copyright (C) 2006  Joachim Kopp !  https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html ! ---------------------------------------------------------------------------- ! Parameters: !   A: The symmetric input matrix !   W: Storage buffer for eigenvalues ! ---------------------------------------------------------------------------- ! .. Arguments .. REAL ( RP ), DIMENSION ( 3 , 3 ), INTENT ( IN ) :: A REAL ( RP ), DIMENSION ( 3 ), INTENT ( OUT ) :: W ( 3 ) !.. Local Variables .. REAL ( RP ) :: M , C1 , C0 REAL ( RP ) :: DE , DD , EE , FF REAL ( RP ) :: P , SQRTP , Q , C , S , PHI !Determine coefficients of characteristic poynomial. We write !      | A   D   F  | ! A =  | D*  B   E  | !      | F*  E*  C  | DE = A ( 1 , 2 ) * A ( 2 , 3 ) DD = A ( 1 , 2 ) ** 2 EE = A ( 2 , 3 ) ** 2 FF = A ( 1 , 3 ) ** 2 M = A ( 1 , 1 ) + A ( 2 , 2 ) + A ( 3 , 3 ) C1 = ( A ( 1 , 1 ) * A ( 2 , 2 ) + A ( 1 , 1 ) * A ( 3 , 3 ) + A ( 2 , 2 ) * A ( 3 , 3 ) ) & - ( DD + EE + FF ) C0 = A ( 3 , 3 ) * DD + A ( 1 , 1 ) * EE + A ( 2 , 2 ) * FF - A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) & - 2.0_RP * A ( 1 , 3 ) * DE P = M ** 2 - 3.0_RP * C1 Q = M * ( P - ( 3.0_RP / 2.0_RP ) * C1 ) - ( 2 7.0_RP / 2.0_RP ) * C0 SQRTP = SQRT ( ABS ( P )) PHI = 2 7.0_RP * ( 0.25_RP * C1 ** 2 * ( P - C1 ) & + C0 * ( Q + ( 2 7.0_RP / 4.0_RP ) * C0 ) ) PHI = ( 1.0_RP / 3.0_RP ) * ATAN2 ( SQRT ( ABS ( PHI )), Q ) C = SQRTP * COS ( PHI ) S = ( 1.0_RP / MATH_SQRT3 ) * SQRTP * SIN ( PHI ) W ( 2 ) = ( 1.0_RP / 3.0_RP ) * ( M - C ) W ( 3 ) = W ( 2 ) + S W ( 1 ) = W ( 2 ) + C W ( 2 ) = W ( 2 ) - S END SUBROUTINE !****************************************************************************** end module utils_math_m","tags":"","loc":"sourcefile/utils_math_m.f90.html"},{"title":"setup_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~setup_m.f90~~EfferentGraph sourcefile~setup_m.f90 setup_m.f90 sourcefile~config_io_m.f90 config_io_m.f90 sourcefile~setup_m.f90->sourcefile~config_io_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~setup_m.f90->sourcefile~atmcfg_m.f90 sourcefile~logger_m.f90 logger_m.f90 sourcefile~setup_m.f90->sourcefile~logger_m.f90 sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~setup_m.f90->sourcefile~simbox_m.f90 sourcefile~control_m.f90 control_m.f90 sourcefile~setup_m.f90->sourcefile~control_m.f90 sourcefile~stats_m.f90 stats_m.f90 sourcefile~setup_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~trajectory_m.f90 trajectory_m.f90 sourcefile~setup_m.f90->sourcefile~trajectory_m.f90 sourcefile~random_m.f90 random_m.f90 sourcefile~setup_m.f90->sourcefile~random_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~setup_m.f90->sourcefile~constants_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~setup_m.f90->sourcefile~strings_m.f90 sourcefile~config_io_m.f90->sourcefile~atmcfg_m.f90 sourcefile~config_io_m.f90->sourcefile~simbox_m.f90 sourcefile~config_io_m.f90->sourcefile~constants_m.f90 sourcefile~config_io_m.f90->sourcefile~strings_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 sourcefile~timestamp_m.f90 timestamp_m.f90 sourcefile~logger_m.f90->sourcefile~timestamp_m.f90 sourcefile~simbox_m.f90->sourcefile~random_m.f90 sourcefile~simbox_m.f90->sourcefile~constants_m.f90 sourcefile~control_m.f90->sourcefile~constants_m.f90 sourcefile~control_m.f90->sourcefile~strings_m.f90 sourcefile~stats_m.f90->sourcefile~atmcfg_m.f90 sourcefile~stats_m.f90->sourcefile~simbox_m.f90 sourcefile~stats_m.f90->sourcefile~control_m.f90 sourcefile~stats_m.f90->sourcefile~constants_m.f90 sourcefile~stats_m.f90->sourcefile~strings_m.f90 sourcefile~bd_solver_m.f90->sourcefile~config_io_m.f90 sourcefile~bd_solver_m.f90->sourcefile~atmcfg_m.f90 sourcefile~bd_solver_m.f90->sourcefile~logger_m.f90 sourcefile~bd_solver_m.f90->sourcefile~control_m.f90 sourcefile~bd_solver_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90->sourcefile~trajectory_m.f90 sourcefile~bd_solver_m.f90->sourcefile~constants_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~brown_m.f90 brown_m.f90 sourcefile~bd_solver_m.f90->sourcefile~brown_m.f90 sourcefile~trajectory_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 sourcefile~interaction_m.f90->sourcefile~atmcfg_m.f90 sourcefile~interaction_m.f90->sourcefile~simbox_m.f90 sourcefile~interaction_m.f90->sourcefile~control_m.f90 sourcefile~interaction_m.f90->sourcefile~stats_m.f90 sourcefile~interaction_m.f90->sourcefile~constants_m.f90 sourcefile~table_m.f90 table_m.f90 sourcefile~interaction_m.f90->sourcefile~table_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~ia_vdw_m.f90 ia_vdw_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_vdw_m.f90 sourcefile~ia_bond_m.f90 ia_bond_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_bond_m.f90 sourcefile~ia_dihedral_m.f90 ia_dihedral_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_dihedral_m.f90 sourcefile~ia_external_m.f90 ia_external_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_external_m.f90 sourcefile~ia_angle_m.f90 ia_angle_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_angle_m.f90 sourcefile~ia_tether_m.f90 ia_tether_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_tether_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 sourcefile~table_m.f90->sourcefile~constants_m.f90 sourcefile~vector_m.f90 vector_m.f90 sourcefile~table_m.f90->sourcefile~vector_m.f90 sourcefile~pairtab_m.fpp->sourcefile~atmcfg_m.f90 sourcefile~pairtab_m.fpp->sourcefile~simbox_m.f90 sourcefile~pairtab_m.fpp->sourcefile~constants_m.f90 sourcefile~pairtab_m.fpp->sourcefile~table_m.f90 sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~pairtab_m.fpp->sourcefile~cell_list_m.f90 sourcefile~connectivity_m.f90 connectivity_m.f90 sourcefile~pairtab_m.fpp->sourcefile~connectivity_m.f90 sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~vector_m.f90 sourcefile~brown_m.f90->sourcefile~logger_m.f90 sourcefile~brown_m.f90->sourcefile~random_m.f90 sourcefile~brown_m.f90->sourcefile~constants_m.f90 sourcefile~brown_m.f90->sourcefile~strings_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~constants_m.f90 sourcefile~ia_bond_m.f90->sourcefile~logger_m.f90 sourcefile~ia_bond_m.f90->sourcefile~constants_m.f90 sourcefile~ia_bond_m.f90->sourcefile~strings_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~constants_m.f90 sourcefile~ia_external_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_external_m.f90->sourcefile~constants_m.f90 sourcefile~ia_angle_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_angle_m.f90->sourcefile~constants_m.f90 sourcefile~ia_tether_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_tether_m.f90->sourcefile~constants_m.f90 sourcefile~cell_list_m.f90->sourcefile~simbox_m.f90 sourcefile~cell_list_m.f90->sourcefile~constants_m.f90 sourcefile~cell_list_m.f90->sourcefile~vector_m.f90 sourcefile~connectivity_m.f90->sourcefile~constants_m.f90 sourcefile~connectivity_m.f90->sourcefile~table_m.f90 sourcefile~connectivity_m.f90->sourcefile~vector_m.f90 sourcefile~aabbtree_m.f90->sourcefile~constants_m.f90 sourcefile~aabbtree_m.f90->sourcefile~strings_m.f90 sourcefile~aabbtree_m.f90->sourcefile~vector_m.f90 sourcefile~aabb_m.fpp aabb_m.fpp sourcefile~aabbtree_m.f90->sourcefile~aabb_m.fpp sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~aabb_m.fpp->sourcefile~constants_m.f90 sourcefile~aabb_m.fpp->sourcefile~strings_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~setup_m.f90~~AfferentGraph sourcefile~setup_m.f90 setup_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules setup_m Source Code setup_m.f90 Source Code module setup_m !! Routines for doing allocation, etc. in preparation for simulation run. use constants_m use strings_m use random_m use logger_m use simbox_m use atmcfg_m use config_io_m use control_m use stats_m use interaction_m use trajectory_m use bd_solver_m implicit none contains !******************************************************************************* subroutine run ( cpar , job_tag ) type ( ctrlpar_t ), intent ( in ) :: cpar character ( len =* ), intent ( in ) :: job_tag !! This string will be used as is, i.e. if there are leading or trailing !! white spaces, they will appear in any I/O file names. character ( len = :), allocatable :: fn character ( len = 128 ) :: msg integer ( ip_long ) :: ccbeg , ccend , crate integer ( ip_long ) :: nts type ( smbx_t ) :: simbox type ( atmcfg_t ) :: atc integer :: ierr logical :: lexists ierr = 0 !Read configuration from appropriate files. !Note: Reading from file includes initialization of the simulation box and !atom configuration. if ( cpar % lrevive ) then !Restarting simulation: Read revive file fn = cpar % fn_revive // job_tag call read_dump ( nts , simbox , atc , fn ) call logger % log_msg ( 'read revive file `' // fn // '`' ) else !New simulation: Read initial configuration file fn = cpar % fn_cfg // job_tag call read_config ( simbox , atc , fn ) call logger % log_msg ( 'read config file `' // fn // '`' ) nts = 0 end if !Allocate memory for forces. Forces are not saved in revive file or !in config file as they can be calculated from position data. allocate ( atc % forces ( 3 , atc % num_atoms ) ) atc % forces = 0.0_rp !Initialize stats collection call stats_init ( cpar , simbox , atc , job_tag ) call logger % log_msg ( 'initialized stats collection' ) !Set up interactions call ia_setup ( cpar , simbox , atc ) call logger % log_msg ( 'set up interaction params' ) !Set up trajectory if necessary. There can be only one trajectory per !simulation. if ( cpar % write_traj ) then fn = cpar % fn_traj // job_tag if ( cpar % lrevive ) then !Append/write to existing/new trajectory file !Check if trajectory file exists inquire ( file = fn , exist = lexists ) if ( lexists ) then !Open existing file for appending call traj % init ( fn , 'rw' , ierr ) if ( ierr /= 0 ) then call logger % log_msg ( 'failed to open trajectory file ' & // '`' // fn // '`' ) call finish ( atc ); return else call logger % log_msg ( 'trajectory file opened' ) end if else !Create new trajectory file call traj % init ( fn , atc % num_atoms , [ integer :: 1 , 0 , 0 , 0 ]) call logger % log_msg ( 'trajectory file created' ) end if else !Create new trajectory file call traj % init ( fn , atc % num_atoms , [ integer :: 1 , 0 , 0 , 0 ]) call logger % log_msg ( 'trajectory file created' ) end if end if !Initialize random number generator if ( cpar % read_seed ) then call init_stream ( 'random_seed.txt' // job_tag ) else call init_stream ( '' ) end if if ( cpar % write_seed ) call save_seed ( 'random_seed.txt' // job_tag ) call logger % log_msg ( 'rng initialized' ) !Set up solver. call bds_init ( cpar , atc % num_atoms , job_tag , ierr ) if ( ierr /= 0 ) then call logger % log_msg ( 'bd solver initialization failed' ) call finish ( atc ); return end if call logger % log_msg ( 'bd solver initialized' ) call system_clock ( ccbeg , crate ) call bds_run ( nts , simbox , atc , ierr ) call system_clock ( ccend , crate ) write ( msg , '(a,es12.5)' ) 'execution time(s) = ' , ( ccend - ccbeg ) / real ( crate , rp ) call logger % log_msg ( msg ) call finish ( atc ) end subroutine !******************************************************************************* subroutine finish ( atc ) type ( atmcfg_t ), intent ( in out ) :: atc call bds_finish () call traj % delete () call ia_finish () call stats_finish () call atmcfg_delete ( atc ) end subroutine !******************************************************************************* end module setup_m","tags":"","loc":"sourcefile/setup_m.f90.html"},{"title":"config_io_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~config_io_m.f90~~EfferentGraph sourcefile~config_io_m.f90 config_io_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~config_io_m.f90->sourcefile~constants_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~config_io_m.f90->sourcefile~atmcfg_m.f90 sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~config_io_m.f90->sourcefile~simbox_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~config_io_m.f90->sourcefile~strings_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 sourcefile~simbox_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90 random_m.f90 sourcefile~simbox_m.f90->sourcefile~random_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~config_io_m.f90~~AfferentGraph sourcefile~config_io_m.f90 config_io_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~config_io_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~config_io_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules config_io_m Source Code config_io_m.f90 Source Code module config_io_m !! Routines for IO of config and dump files. use constants_m use strings_m use simbox_m use atmcfg_m implicit none contains !****************************************************************************** subroutine read_dump ( nts , simbox , atc , fn ) !! Reads from DUMP file integer ( ip_long ), intent ( out ) :: nts type ( smbx_t ), intent ( out ) :: simbox type ( atmcfg_t ), intent ( out ) :: atc character ( len =* ), intent ( in ) :: fn real ( rp ), dimension ( 3 , 3 ) :: mat integer :: fu , nt , n open ( newunit = fu , file = fn , access = 'stream' , form = 'unformatted' , & action = 'read' , status = 'old' ) read ( fu ) nts read ( fu ) n , mat call simbox % init ( n ) call simbox % set_basis ( mat ) !Atom types data read ( fu ) nt atc % num_atom_types = nt allocate ( atc % atom_names ( nt )) allocate ( atc % atom_styles ( nt )) allocate ( atc % atom_mass ( nt )) read ( fu ) atc % atom_names , atc % atom_styles , atc % atom_mass !Atom data read ( fu ) n atc % num_atoms = n allocate ( atc % atoms ( n )); allocate ( atc % coordinates ( 3 , n )) allocate ( atc % charge ( n )) read ( fu ) atc % atoms , atc % coordinates , atc % charge !Bond types data read ( fu ) nt atc % num_bond_types = nt if ( nt > 0 ) then allocate ( atc % bond_styles ( nt )) allocate ( atc % bond_params ( mxparam , nt )) read ( fu ) atc % bond_styles , atc % bond_params end if !Bond data read ( fu ) n atc % num_bonds = n if ( n > 0 ) then allocate ( atc % bonds ( 3 , n )) read ( fu ) atc % bonds end if !Angle types data read ( fu ) nt atc % num_angle_types = nt if ( nt > 0 ) then allocate ( atc % angle_styles ( nt )) allocate ( atc % angle_params ( mxparam , nt )) read ( fu ) atc % angle_styles , atc % angle_params end if !Angles data read ( fu ) n atc % num_angles = n if ( n > 0 ) then allocate ( atc % angles ( 4 , n )) read ( fu ) atc % angles end if !Dihedral types data read ( fu ) nt atc % num_dihedral_types = nt if ( nt > 0 ) then allocate ( atc % dihedral_styles ( nt )) allocate ( atc % dihedral_params ( mxparam , nt )) read ( fu ) atc % dihedral_styles , atc % dihedral_params end if !Dihedral data read ( fu ) n atc % num_dihedrals = n if ( n > 0 ) then allocate ( atc % dihedrals ( 5 , n )) read ( fu ) atc % dihedrals end if !Branches data read ( fu ) n atc % num_branches = n if ( n > 0 ) then allocate ( atc % branches ( 3 , n )) read ( fu ) atc % branches end if !Molecule types data read ( fu ) nt atc % num_molecule_types = nt allocate ( atc % molecule_names ( nt )) allocate ( atc % molecule_pop ( nt )) read ( fu ) atc % molecule_names , atc % molecule_pop !Molecule data read ( fu ) n atc % num_molecules = n allocate ( atc % molecules ( 9 , n )) read ( fu ) atc % molecules !Tether types data read ( fu ) nt atc % num_tether_types = nt if ( nt > 0 ) then allocate ( atc % tether_styles ( nt )) allocate ( atc % tether_params ( mxparam , nt )) read ( fu ) atc % tether_styles , atc % tether_params end if !Tether data read ( fu ) n atc % num_tethers = n if ( n > 0 ) then allocate ( atc % tethers ( 2 , n )) allocate ( atc % tether_points ( 3 , n )) read ( fu ) atc % tethers , atc % tether_points end if !vdw types data read ( fu ) nt atc % num_vdw_types = nt if ( nt > 0 ) then allocate ( atc % vdw_styles ( nt )) allocate ( atc % vdw_pairs ( 2 , nt )) allocate ( atc % vdw_params ( mxparam , nt )) read ( fu ) atc % vdw_pairs , atc % vdw_styles , atc % vdw_params end if !External field data read ( fu ) n atc % num_externals = n if ( n > 0 ) then allocate ( atc % external_styles ( n )) allocate ( atc % external_params ( mxparam , n )) read ( fu ) atc % external_styles , atc % external_params end if !Flow field data read ( fu ) atc % flow_style if ( atc % flow_style /= 0 ) then allocate ( atc % flow_params ( mxparam )) read ( fu ) atc % flow_params end if if ( ( atc % num_tethers == 0 ) . and . ( simbox % imcon == 0 ) ) then read ( fu ) atc % molecule_com end if close ( fu ) end subroutine !****************************************************************************** subroutine write_dump ( nts , simbox , atc , fn ) !! Writes to DUMP file. integer ( ip_long ), intent ( in ) :: nts type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in ) :: atc character ( len =* ), intent ( in ) :: fn integer :: fu open ( newunit = fu , file = fn , access = 'stream' , form = 'unformatted' , & action = 'write' , status = 'replace' ) write ( fu ) nts write ( fu ) simbox % imcon write ( fu ) simbox % basis write ( fu ) atc % num_atom_types write ( fu ) atc % atom_names , atc % atom_styles , atc % atom_mass write ( fu ) atc % num_atoms write ( fu ) atc % atoms , atc % coordinates , atc % charge write ( fu ) atc % num_bond_types if ( atc % num_bond_types > 0 ) write ( fu ) atc % bond_styles , atc % bond_params write ( fu ) atc % num_bonds if ( atc % num_bonds > 0 ) write ( fu ) atc % bonds write ( fu ) atc % num_angle_types if ( atc % num_angle_types > 0 ) write ( fu ) atc % angle_styles , atc % angle_params write ( fu ) atc % num_angles if ( atc % num_angles > 0 ) write ( fu ) atc % angles write ( fu ) atc % num_dihedral_types if ( atc % num_dihedral_types > 0 ) & write ( fu ) atc % dihedral_styles , atc % dihedral_params write ( fu ) atc % num_dihedrals if ( atc % num_dihedrals > 0 ) write ( fu ) atc % dihedrals write ( fu ) atc % num_branches if ( atc % num_branches > 0 ) write ( fu ) atc % branches write ( fu ) atc % num_molecule_types write ( fu ) atc % molecule_names , atc % molecule_pop write ( fu ) atc % num_molecules write ( fu ) atc % molecules write ( fu ) atc % num_tether_types if ( atc % num_tether_types > 0 ) write ( fu ) atc % tether_styles , atc % tether_params write ( fu ) atc % num_tethers if ( atc % num_tethers > 0 ) write ( fu ) atc % tethers , atc % tether_points write ( fu ) atc % num_vdw_types if ( atc % num_vdw_types > 0 ) write ( fu ) atc % vdw_pairs , atc % vdw_styles , & atc % vdw_params write ( fu ) atc % num_externals if ( atc % num_externals > 0 ) write ( fu ) atc % external_styles , atc % external_params write ( fu ) atc % flow_style if ( atc % flow_style /= 0 ) write ( fu ) atc % flow_params if ( ( atc % num_tethers == 0 ) . and . ( simbox % imcon == 0 ) ) write ( fu ) atc % molecule_com close ( fu ) end subroutine !****************************************************************************** subroutine read_config ( simbox , atc , fn ) !! Read from CONFIG file type ( smbx_t ), intent ( out ) :: simbox type ( atmcfg_t ), intent ( out ) :: atc character ( len =* ), intent ( in ) :: fn integer , parameter :: mxrdln = 128 character ( len = mxrdln ) :: line character ( len = :), allocatable :: word real ( rp ), dimension ( 3 , 3 ) :: mat integer :: i , it , npar , ibr , n , nt integer :: fu , ios open ( newunit = fu , file = fn , action = 'read' , status = 'old' ) do call readline ( fu , line , '#' , ios ) if ( ios /= 0 ) exit line = adjustl ( line ) if ( str_startswith ( line , 'SIMBOX' )) then !Read box boundary condition call str_split ( line , ' ' , word ) if ( len_trim ( line ) == 0 ) then !Read simulation box size into lattice vectors defining the box read ( fu , * ) mat (:, 1 ) read ( fu , * ) mat (:, 2 ) read ( fu , * ) mat (:, 3 ) read ( fu , * ) call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) n = str_to_i ( line ) call simbox % init ( n ) call simbox % set_basis ( mat ) else n = str_to_i ( line ) call simbox % init ( n ) !Read simulation box size into lattice vectors defining the box read ( fu , * ) mat (:, 1 ) read ( fu , * ) mat (:, 2 ) read ( fu , * ) mat (:, 3 ) call simbox % set_basis ( mat ) end if end if if ( str_startswith ( line , 'ATOM_TYPES' )) then call str_split ( line , ' ' , word ) nt = str_to_i ( line ) atc % num_atom_types = nt allocate ( atc % atom_names ( nt )) allocate ( atc % atom_styles ( nt )) allocate ( atc % atom_mass ( nt )) do it = 1 , nt read ( fu , * ) atc % atom_names ( it ), atc % atom_styles ( it ), & atc % atom_mass ( it ) end do end if if ( str_startswith ( line , 'ATOMS' )) then call str_split ( line , ' ' , word ) n = str_to_i ( line ) atc % num_atoms = n allocate ( atc % atoms ( n )) allocate ( atc % charge ( n )) allocate ( atc % coordinates ( 3 , n )) do i = 1 , n read ( fu , * ) atc % atoms ( i ), atc % charge ( i ), atc % coordinates (:, i ) end do end if if ( str_startswith ( line , 'BOND_TYPES' )) then call str_split ( line , ' ' , word ) nt = str_to_i ( line ) atc % num_bond_types = nt allocate ( atc % bond_styles ( nt )) allocate ( atc % bond_params ( mxparam , nt )) atc % bond_params = 0.0_rp do it = 1 , nt call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) atc % bond_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) atc % bond_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'BONDS' )) then call str_split ( line , ' ' , word ) n = str_to_i ( line ) atc % num_bonds = n allocate ( atc % bonds ( 3 , n )) do i = 1 , n read ( fu , * ) atc % bonds (:, i ) end do end if if ( str_startswith ( line , 'ANGLE_TYPES' )) then call str_split ( line , ' ' , word ) nt = str_to_i ( line ) atc % num_angle_types = nt allocate ( atc % angle_styles ( nt )) allocate ( atc % angle_params ( mxparam , nt )) atc % angle_params = 0.0_rp do it = 1 , nt call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) atc % angle_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) atc % angle_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'ANGLES' )) then call str_split ( line , ' ' , word ) n = str_to_i ( line ) atc % num_angles = n allocate ( atc % angles ( 4 , n )) do i = 1 , n read ( fu , * ) atc % angles (:, i ) end do end if if ( str_startswith ( line , 'DIHEDRAL_TYPES' )) then call str_split ( line , ' ' , word ) nt = str_to_i ( line ) atc % num_dihedral_types = nt allocate ( atc % dihedral_styles ( nt )) allocate ( atc % dihedral_params ( mxparam , nt )) atc % dihedral_params = 0.0_rp do it = 1 , nt call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) atc % dihedral_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) atc % dihedral_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'DIHEDRALS' )) then call str_split ( line , ' ' , word ) n = str_to_i ( line ) atc % num_dihedrals = n allocate ( atc % dihedrals ( 5 , n )) do i = 1 , n read ( fu , * ) atc % dihedrals (:, i ) end do end if if ( str_startswith ( line , 'BRANCHES' )) then call str_split ( line , ' ' , word ) n = str_to_i ( line ) atc % num_branches = n allocate ( atc % branches ( 3 , n )) do ibr = 1 , n read ( fu , * ) atc % branches (:, ibr ) end do end if if ( str_startswith ( line , 'MOLECULE_TYPES' )) then call str_split ( line , ' ' , word ) nt = str_to_i ( line ) atc % num_molecule_types = nt allocate ( atc % molecule_names ( nt )) allocate ( atc % molecule_pop ( nt )) do it = 1 , nt read ( fu , * ) atc % molecule_names ( it ), atc % molecule_pop ( it ) end do end if if ( str_startswith ( line , 'MOLECULES' )) then call str_split ( line , ' ' , word ) n = str_to_i ( line ) atc % num_molecules = n allocate ( atc % molecules ( 9 , n )) do i = 1 , n read ( fu , * ) atc % molecules (:, i ) end do end if if ( str_startswith ( line , 'TETHER_TYPES' )) then call str_split ( line , ' ' , word ) nt = str_to_i ( line ) atc % num_tether_types = nt allocate ( atc % tether_styles ( nt )) allocate ( atc % tether_params ( mxparam , nt )) atc % tether_params = 0.0_rp do it = 1 , nt call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) atc % tether_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) atc % tether_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'TETHERS' )) then call str_split ( line , ' ' , word ) n = str_to_i ( line ) atc % num_tethers = n allocate ( atc % tethers ( 2 , n )) allocate ( atc % tether_points ( 3 , n )) do i = 1 , n read ( fu , * ) atc % tethers (:, i ), atc % tether_points (:, i ) end do end if if ( str_startswith ( line , 'VDW' )) then call str_split ( line , ' ' , word ) nt = str_to_i ( line ) atc % num_vdw_types = nt allocate ( atc % vdw_styles ( nt )) allocate ( atc % vdw_pairs ( 2 , nt )) allocate ( atc % vdw_params ( mxparam , nt )) atc % vdw_params = 0.0_rp do it = 1 , nt call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) atc % vdw_pairs ( 1 , it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) atc % vdw_pairs ( 2 , it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) atc % vdw_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) atc % vdw_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'EXTERNAL' )) then call str_split ( line , ' ' , word ) n = str_to_i ( line ) atc % num_externals = n allocate ( atc % external_styles ( n )) allocate ( atc % external_params ( mxparam , n )) atc % external_params = 0.0_rp do it = 1 , n call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) atc % external_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) atc % external_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'FLOW_FIELD' )) then allocate ( atc % flow_params ( mxparam )) atc % flow_params = 0.0_rp call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) atc % flow_style = str_to_i ( word ) if ( atc % flow_style > 0 ) then call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) atc % flow_params ( 1 : npar ) end if end if end if end do close ( fu ) end subroutine !******************************************************************************* subroutine write_config ( simbox , atc , fn , title ) !! Write to cfg file type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in ) :: atc character ( len =* ), intent ( in ) :: fn character ( len =* ), intent ( in ) :: title integer :: fu integer :: i , it open ( newunit = fu , file = fn , action = 'write' , status = 'replace' ) write ( fu , '(a)' ) '#' // trim ( adjustl ( title )) write ( fu , '(a)' ) 'version 2.0' write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'SIMBOX' , simbox % imcon write ( fu , '(3(g0.8,2x))' ) simbox % basis (:, 1 ) write ( fu , '(3(g0.8,2x))' ) simbox % basis (:, 2 ) write ( fu , '(3(g0.8,2x))' ) simbox % basis (:, 3 ) write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ATOM_TYPES' , atc % num_atom_types do it = 1 , atc % num_atom_types write ( fu , '(a,2x,i0,2x,g0.6)' ) trim ( adjustl ( atc % atom_names ( it ))), & atc % atom_styles ( it ), atc % atom_mass ( it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ATOMS' , atc % num_atoms do i = 1 , atc % num_atoms write ( fu , '(i0,2x,*(g0.14,2x))' ) atc % atoms ( i ), atc % charge ( i ), & atc % coordinates (:, i ) end do if ( atc % num_bonds > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'BOND_TYPES' , atc % num_bond_types do it = 1 , atc % num_bond_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) atc % bond_styles ( it ), & size ( atc % bond_params , 1 ), atc % bond_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'BONDS' , atc % num_bonds do i = 1 , atc % num_bonds write ( fu , '(*(i0,2x))' ) atc % bonds (:, i ) end do end if if ( atc % num_angles > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ANGLE_TYPES' , atc % num_angle_types do it = 1 , atc % num_angle_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) atc % angle_styles ( it ), & size ( atc % angle_params , 1 ), atc % angle_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ANGLES' , atc % num_angles do i = 1 , atc % num_angles write ( fu , '(*(i0,2x))' ) atc % angles (:, i ) end do end if if ( atc % num_dihedrals > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'DIHEDRAL_TYPES' , atc % num_dihedral_types do it = 1 , atc % num_dihedral_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) atc % dihedral_styles ( it ), & size ( atc % dihedral_params , 1 ), atc % dihedral_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'DIHEDRALS' , atc % num_dihedrals do i = 1 , atc % num_dihedrals write ( fu , '(*(i0,2x))' ) atc % dihedrals (:, i ) end do end if if ( atc % num_branches > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'BRANCHES' , atc % num_branches do i = 1 , atc % num_branches write ( fu , '(*(i0,2x))' ) atc % branches (:, i ) end do end if write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'MOLECULE_TYPES' , atc % num_molecule_types do it = 1 , atc % num_molecule_types write ( fu , '(a,2x,i0)' ) trim ( adjustl ( atc % molecule_names ( it ))), & atc % molecule_pop ( it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'MOLECULES' , atc % num_molecules do i = 1 , atc % num_molecules write ( fu , '(*(i0,2x))' ) atc % molecules (:, i ) end do if ( atc % num_tethers > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'TETHER_TYPES' , atc % num_tether_types do it = 1 , atc % num_tether_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) atc % tether_styles ( it ), & size ( atc % tether_params , 1 ), atc % tether_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'TETHERS' , atc % num_tethers do i = 1 , atc % num_tethers write ( fu , '(2(i0,2x),3(g0.6,2x))' ) atc % tethers (:, i ), & atc % tether_points (:, i ) end do end if if ( atc % num_vdw_types > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'VDW' , atc % num_vdw_types do it = 1 , atc % num_vdw_types write ( fu , '(2(i0,2x),i0,2x,i0,2x,*(g0.6,2x))' ) atc % vdw_pairs (:, it ), & atc % vdw_styles ( it ), size ( atc % vdw_params , 1 ), atc % vdw_params (:, it ) end do end if if ( atc % num_externals > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'EXTERNAL' , atc % num_externals do it = 1 , atc % num_externals write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) atc % external_styles ( it ), & size ( atc % external_params , 1 ), atc % external_params (:, it ) end do end if write ( fu , * ) write ( fu , '(a)' ) 'FLOW_FIELD' write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' , advance = 'no' ) atc % flow_style if ( atc % flow_style > 0 ) then write ( fu , '(i0,2x,*(g0.6,2x))' ) size ( atc % flow_params ), atc % flow_params else write ( fu , * ) end if close ( fu ) end subroutine !****************************************************************************** subroutine write_ldf ( simbox , atc , fn_ld , title ) !! Write to a LAMMPS data file. type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in ) :: atc character ( len =* ), intent ( in ) :: fn_ld !! Name of the file character ( len =* ), intent ( in ) :: title !! Title of the configuation real ( rp ), dimension ( 3 ) :: tilt_factors integer :: fu_ld integer :: cntr_atm , iatm_beg , natm integer :: i , iatm , imol open ( newunit = fu_ld , file = fn_ld , action = 'write' ) !Header write ( fu_ld , '(a)' ) '#' // trim ( adjustl ( title )) write ( fu_ld , '(i0,2x,a)' ) atc % num_atoms , 'atoms' write ( fu_ld , '(i0,2x,a)' ) atc % num_atom_types , 'atom types' if ( atc % num_bonds > 0 ) then write ( fu_ld , '(i0,2x,a)' ) atc % num_bonds , 'bonds' write ( fu_ld , '(i0,2x,a)' ) atc % num_bond_types , 'bond types' end if if ( atc % num_angles > 0 ) then write ( fu_ld , '(i0,2x,a)' ) atc % num_angles , 'angles' write ( fu_ld , '(i0,2x,a)' ) atc % num_angle_types , 'angle types' end if if ( atc % num_dihedrals > 0 ) then write ( fu_ld , '(i0,2x,a)' ) atc % num_dihedrals , 'dihedrals' write ( fu_ld , '(i0,2x,a)' ) atc % num_dihedral_types , 'dihedral types' end if !Simulation box & tilt factors write ( fu_ld , '(a,2x,g0.6,2x,a)' ) '0.0' , simbox % basis ( 1 , 1 ), 'xlo xhi' write ( fu_ld , '(a,2x,g0.6,2x,a)' ) '0.0' , simbox % basis ( 2 , 2 ), 'ylo yhi' write ( fu_ld , '(a,2x,g0.6,2x,a)' ) '0.0' , simbox % basis ( 3 , 3 ), 'zlo zhi' write ( fu_ld , '(a)' ) '0.0 0.0 0.0 xy xz yz' !TODO: Triclinic box !   tilt_factors(1) = dot_product(simbox%basis(:,1)/norm2(simbox%basis(:,1)), & !       simbox%basis(:,2)/norm2(simbox%basis(:,2))) !   tilt_factors(2) = dot_product(simbox%basis(:,1)/norm2(simbox%basis(:,1)), & !       simbox%basis(:,3)/norm2(simbox%basis(:,3))) !   tilt_factors(3) = dot_product(simbox%basis(:,2)/norm2(simbox%basis(:,2)), & !       simbox%basis(:,3)/norm2(simbox%basis(:,3))) !   tilt_factors = acos(tilt_factors) !   write(fu_ld,'(3(g0.6,2x),a)') tilt_factors, 'xy xz yz' !Body: Atoms write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Atoms # full' write ( fu_ld , * ) cntr_atm = 1 do imol = 1 , atc % num_molecules natm = atc % molecules ( 2 , imol ) iatm_beg = atc % molecules ( 3 , imol ) do i = 1 , natm iatm = iatm_beg + i - 1 write ( fu_ld , '(i0,2x,i0,2x,i0,2x,4(g0.8,2x))' ) cntr_atm , imol , & atc % atoms ( iatm ), atc % charge ( iatm ), atc % coordinates (:, iatm ) cntr_atm = cntr_atm + 1 end do end do !Body: Bonds if ( atc % num_bonds > 0 ) then write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Bonds' write ( fu_ld , * ) do i = 1 , atc % num_bonds write ( fu_ld , '(i0,2x,3(i0,2x))' ) i , atc % bonds (:, i ) end do end if !Body: Angles if ( atc % num_angles > 0 ) then write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Angles' write ( fu_ld , * ) do i = 1 , atc % num_angles write ( fu_ld , '(i0,2x,4(i0,2x))' ) i , atc % angles (:, i ) end do end if !Body: Dihedrals if ( atc % num_dihedrals > 0 ) then write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Dihedrals' write ( fu_ld , * ) do i = 1 , atc % num_dihedrals write ( fu_ld , '(i0,2x,5(i0,2x))' ) i , atc % dihedrals (:, i ) end do end if close ( fu_ld ) end subroutine !******************************************************************************* subroutine write_xyz ( atc , fn_xyz , title ) !! Write to an XYZ file. type ( atmcfg_t ), intent ( in ) :: atc character ( len =* ), intent ( in ) :: fn_xyz !! Name of the XYZ file character ( len =* ), intent ( in ) :: title !! Title (for the configuration) integer :: iatm integer :: na integer :: fu_xyz na = atc % num_atoms open ( newunit = fu_xyz , file = fn_xyz , action = 'write' ) write ( fu_xyz , '(i0)' ) na write ( fu_xyz , '(a)' ) title do iatm = 1 , na write ( fu_xyz , '(3(es24.15,2x))' ) atc % coordinates (:, iatm ) end do close ( fu_xyz ) end subroutine !******************************************************************************* end module config_io_m","tags":"","loc":"sourcefile/config_io_m.f90.html"},{"title":"stats_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~stats_m.f90~~EfferentGraph sourcefile~stats_m.f90 stats_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~stats_m.f90->sourcefile~atmcfg_m.f90 sourcefile~control_m.f90 control_m.f90 sourcefile~stats_m.f90->sourcefile~control_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~stats_m.f90->sourcefile~strings_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~stats_m.f90->sourcefile~constants_m.f90 sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~stats_m.f90->sourcefile~simbox_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 sourcefile~control_m.f90->sourcefile~strings_m.f90 sourcefile~control_m.f90->sourcefile~constants_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 sourcefile~simbox_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90 random_m.f90 sourcefile~simbox_m.f90->sourcefile~random_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stats_m.f90~~AfferentGraph sourcefile~stats_m.f90 stats_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~stats_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~stats_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stats_m Source Code stats_m.f90 Source Code module stats_m !! Computes and writes properties calculated during simulation. use constants_m use strings_m use control_m use simbox_m use atmcfg_m implicit none private public :: stats_init , stats_finish , stats_write , stats_accumulate , & bndlen , bndlen_min , bndlen_max , energy_bond , energy_angle , & energy_dihedral , energy_vdw , energy_tether , energy_external , & energy_tot , stress character ( len = :), allocatable :: fn_stats integer :: fu_stats integer :: bnsiz , bnsiz_stress integer :: bnpop , bnpop_stress real ( rp ) :: bndlen real ( rp ) :: bndlen_min real ( rp ) :: bndlen_max real ( rp ) :: energy_bond , energy_bond_accu real ( rp ) :: energy_angle , energy_angle_accu real ( rp ) :: energy_dihedral , energy_dihedral_accu real ( rp ) :: energy_vdw , energy_vdw_accu real ( rp ) :: energy_tether , energy_tether_accu real ( rp ) :: energy_external , energy_external_accu real ( rp ) :: energy_tot , energy_tot_accu real ( rp ), dimension ( 3 , 3 ) :: stress , stress_accu real ( rp ) :: rgsq , rgsq_accu real ( rp ) :: reedsq , reedsq_accu real ( rp ), dimension ( 3 ) :: span , span_accu real ( rp ) :: rgsq_bbone , rgsq_bbone_accu real ( rp ) :: rgsq_sc , rgsq_sc_accu real ( rp ) :: reedsq_sc , reedsq_sc_accu real ( rp ), dimension ( 3 ) :: span_bbone , span_bbone_accu real ( rp ), dimension ( 3 ) :: reev real ( rp ), dimension (:,:), allocatable :: molbuf ! Buffer for the largest molecule in the system logical :: lvdw contains !****************************************************************************** subroutine stats_init ( cpar , simbox , atc , job_tag ) !! Set up for stats collection type ( ctrlpar_t ), intent ( in ) :: cpar type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in ) :: atc character ( len =* ), intent ( in ) :: job_tag logical :: lexists integer :: n bnsiz = cpar % stats_binsize ( 1 ); bnsiz_stress = cpar % stats_binsize ( 2 ) lvdw = . true . if ( (. not . cpar % lvdw ) . or . ( atc % num_vdw_types == 0 ) ) lvdw = . false . !Open/create file for writing statistics fn_stats = cpar % fn_stats // job_tag if ( cpar % lrevive ) then !Restarting simulation !Check if file exists inquire ( file = fn_stats , exist = lexists ) if ( lexists ) then !Open existing file for appending statistics open ( newunit = fu_stats , file = fn_stats , action = 'write' , & position = 'append' , status = 'old' ) else !Open new file for writing statistics open ( newunit = fu_stats , file = fn_stats , action = 'write' , status = 'new' ) !Write header call write_hdr ( simbox , atc ) end if else !New simulation !Open file for writing production (or relaxation) statistics open ( newunit = fu_stats , file = fn_stats , action = 'write' , status = 'replace' ) !Write header call write_hdr ( simbox , atc ) end if !Allocate space for unwrapping molecule under PBC if ( ( simbox % imcon /= 0 ) . and . ( atc % num_molecules > 0 ) ) then n = maxval ( atc % molecules ( 2 ,:)) if ( n > 1 ) allocate ( molbuf ( 3 , n ) ) end if call zero_out () end subroutine !****************************************************************************** subroutine stats_finish () !! Clean up for stats collection. logical :: lopened if ( allocated ( fn_stats )) then inquire ( file = fn_stats , number = fu_stats , opened = lopened ) if ( lopened ) close ( fu_stats ) deallocate ( fn_stats ) end if if ( allocated ( molbuf )) deallocate ( molbuf ) call zero_out () end subroutine !****************************************************************************** subroutine zero_out () bnpop = 0 ; bnpop_stress = 0 bndlen = 0.0_rp bndlen_min = 0.0_rp bndlen_max = 0.0_rp energy_bond = 0.0_rp ; energy_bond_accu = 0.0_rp energy_angle = 0.0_rp ; energy_angle_accu = 0.0_rp energy_dihedral = 0.0_rp ; energy_dihedral_accu = 0.0_rp energy_vdw = 0.0_rp ; energy_vdw_accu = 0.0_rp energy_tether = 0.0_rp ; energy_tether_accu = 0.0_rp energy_external = 0.0_rp ; energy_external_accu = 0.0_rp energy_tot = 0.0_rp ; energy_tot_accu = 0.0_rp stress = 0.0_rp ; stress_accu = 0.0_rp rgsq = 0.0_rp ; rgsq_accu = 0.0_rp reedsq = 0.0_rp ; reedsq_accu = 0.0_rp span = 0.0_rp ; span_accu = 0.0_rp rgsq_bbone = 0.0_rp ; rgsq_bbone_accu = 0.0_rp rgsq_sc = 0.0_rp ; rgsq_sc_accu = 0.0_rp reedsq_sc = 0.0_rp ; reedsq_sc_accu = 0.0_rp span_bbone = 0.0_rp ; span_bbone_accu = 0.0_rp reev = 0.0_rp end subroutine !****************************************************************************** subroutine write_hdr ( simbox , atc ) !! Writes header of the file `fn_stats`. type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in ) :: atc write ( fu_stats , '(a12)' , advance = 'no' ) 'nts' if ( atc % num_bonds > 0 ) then write ( fu_stats , 200 , advance = 'no' ) & 'bndlen_avg' , 'bndlen_min' , 'bndlen_max' , 'enrg_bnd' end if if ( atc % num_angles > 0 ) then write ( fu_stats , 100 , advance = 'no' ) 'enrg_ang' end if if ( atc % num_dihedrals > 0 ) then write ( fu_stats , 100 , advance = 'no' ) 'enrg_dhd' end if if ( lvdw ) then write ( fu_stats , 100 , advance = 'no' ) 'enrg_vdw' end if if ( atc % num_tethers > 0 ) then write ( fu_stats , 100 , advance = 'no' ) 'enrg_teth' end if if ( atc % num_externals > 0 ) then write ( fu_stats , 100 , advance = 'no' ) 'enrg_ext' end if write ( fu_stats , 100 , advance = 'no' ) 'enrg_tot' !Stress if ( atc % num_atoms > 0 ) then write ( fu_stats , 200 , advance = 'no' ) 'sxx' , 'syx' , 'szx' , & 'syy' , 'szy' , 'szz' end if !Structural properties: Size if ( atc % num_bonds > 0 ) then write ( fu_stats , 200 , advance = 'no' ) 'rgsq' , 'reedsq' , & 'spanx' , 'spany' , 'spanz' end if !Further structural properties (for single molecule in unbounded domain) if ( ( simbox % imcon == 0 ) . and . ( atc % num_bonds > 0 ) ) then write ( fu_stats , 200 , advance = 'no' ) 'reevx' , 'reevy' , 'reevz' if ( atc % num_branches > 0 ) then write ( fu_stats , 200 , advance = 'no' ) 'rgsq_bbone' , & 'rgsq_sc' , 'reedsq_sc' , 'span_bbone_x' , 'span_bbone_y' ,& 'span_bbone_z' end if if ( atc % flow_style == 0 ) then write ( fu_stats , 200 , advance = 'no' ) 'comx' , 'comy' , 'comz' end if end if write ( fu_stats , * ) 100 format ( 1 x , a14 ) 200 format ( * ( 1 x , a14 )) end subroutine !****************************************************************************** subroutine stats_write ( nts , simbox , atc ) !! Writes statistics to `fn_stats`. integer ( ip_long ), intent ( in ) :: nts type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in ) :: atc write ( fu_stats , '(i12)' , advance = 'no' ) nts if ( atc % num_bonds > 0 ) then write ( fu_stats , 200 , advance = 'no' ) & bndlen , bndlen_min , bndlen_max , energy_bond_accu end if if ( atc % num_angles > 0 ) then write ( fu_stats , 100 , advance = 'no' ) energy_angle_accu end if if ( atc % num_dihedrals > 0 ) then write ( fu_stats , 100 , advance = 'no' ) energy_dihedral_accu end if if ( lvdw ) then write ( fu_stats , 100 , advance = 'no' ) energy_vdw_accu end if if ( atc % num_tethers > 0 ) then write ( fu_stats , 100 , advance = 'no' ) energy_tether_accu end if if ( atc % num_externals > 0 ) then write ( fu_stats , 100 , advance = 'no' ) energy_external_accu end if write ( fu_stats , 100 , advance = 'no' ) energy_tot_accu !Stress (calculated only during production run) if ( atc % num_atoms > 0 ) then write ( fu_stats , 200 , advance = 'no' ) stress_accu ( 1 , 1 ), & stress_accu ( 2 , 1 ), stress_accu ( 3 , 1 ), stress_accu ( 2 , 2 ), & stress_accu ( 3 , 2 ), stress_accu ( 3 , 3 ) end if !Structural properties: Size if ( atc % num_bonds > 0 ) then write ( fu_stats , 200 , advance = 'no' ) rgsq_accu , & reedsq_accu , span_accu end if !Further structural properties (for single molecule in unbounded domain) if ( ( simbox % imcon == 0 ) . and . ( atc % num_bonds > 0 ) ) then write ( fu_stats , 200 , advance = 'no' ) reev if ( atc % num_branches > 0 ) then write ( fu_stats , 200 , advance = 'no' ) rgsq_bbone_accu , & rgsq_sc_accu , reedsq_sc_accu , span_bbone_accu end if if ( atc % flow_style == 0 ) then write ( fu_stats , 200 , advance = 'no' ) atc % molecule_com end if end if write ( fu_stats , * ) 100 format ( 1 x , es14 . 6 ) 200 format ( * ( 1 x , es14 . 6 )) end subroutine !****************************************************************************** subroutine stats_accumulate ( simbox , atc ) !! Accumulates statistics. type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in ) :: atc if ( simbox % imcon == 0 ) then call compute_ic0 ( atc ) else call compute_ic1 ( simbox , atc ) end if if ( bnpop == bnsiz ) then bnpop = 0 energy_bond_accu = 0.0_rp energy_angle_accu = 0.0_rp energy_dihedral_accu = 0.0_rp energy_vdw_accu = 0.0_rp energy_tether_accu = 0.0_rp energy_external_accu = 0.0_rp energy_tot_accu = 0.0_rp rgsq_accu = 0.0_rp reedsq_accu = 0.0_rp span_accu = 0.0_rp rgsq_bbone_accu = 0.0_rp rgsq_sc_accu = 0.0_rp reedsq_sc_accu = 0.0_rp span_bbone_accu = 0.0_rp end if bnpop = bnpop + 1 energy_bond_accu = energy_bond_accu & + (( energy_bond - energy_bond_accu ) / bnpop ) energy_angle_accu = energy_angle_accu & + (( energy_angle - energy_angle_accu ) / bnpop ) energy_dihedral_accu = energy_dihedral_accu & + (( energy_dihedral - energy_dihedral_accu ) / bnpop ) energy_vdw_accu = energy_vdw_accu & + (( energy_vdw - energy_vdw_accu ) / bnpop ) energy_tether_accu = energy_tether_accu & + (( energy_tether - energy_tether_accu ) / bnpop ) energy_external_accu = energy_external_accu & + (( energy_external - energy_external_accu ) / bnpop ) energy_tot_accu = energy_tot_accu & + (( energy_tot - energy_tot_accu ) / bnpop ) rgsq_accu = rgsq_accu + (( rgsq - rgsq_accu ) / bnpop ) reedsq_accu = reedsq_accu + (( reedsq - reedsq_accu ) / bnpop ) span_accu = span_accu + (( span - span_accu ) / bnpop ) rgsq_bbone_accu = rgsq_bbone_accu + (( rgsq_bbone - rgsq_bbone_accu ) / bnpop ) rgsq_sc_accu = rgsq_sc_accu + (( rgsq_sc - rgsq_sc_accu ) / bnpop ) reedsq_sc_accu = reedsq_sc_accu + (( reedsq_sc - reedsq_sc_accu ) / bnpop ) span_bbone_accu = span_bbone_accu + (( span_bbone - span_bbone_accu ) / bnpop ) if ( bnpop_stress == bnsiz_stress ) then bnpop_stress = 0 stress_accu = 0.0_rp end if bnpop_stress = bnpop_stress + 1 stress_accu = stress_accu + ( ( stress - stress_accu ) / bnpop_stress ) end subroutine !****************************************************************************** subroutine compute_ic1 ( simbox , atc ) !! Computes statistics for possibly multiple chains in a periodic domain. type ( smbx_t ), intent ( in ) :: simbox type ( atmcfg_t ), intent ( in ) :: atc real ( rp ), dimension ( 3 ) :: com real ( rp ) :: rgsq_im integer :: natm , nmol integer :: i , imol , ibeg rgsq = 0.0_rp ; reedsq = 0.0_rp ; span = 0.0_rp do imol = 1 , atc % num_molecules natm = atc % molecules ( 2 , imol ) if ( natm > 1 ) then molbuf = 0.0_rp ibeg = atc % molecules ( 3 , imol ) do i = 1 , natm molbuf (:, i ) = atc % coordinates (:, ibeg + i - 1 ) end do do i = 1 , natm molbuf (:, i ) = molbuf (:, i ) - molbuf (:, 1 ) call simbox % get_image ( molbuf (:, i )) end do span = span + maxval ( molbuf (:, 1 : natm ), 2 ) - minval ( molbuf (:, 1 : natm ), 2 ) reev = molbuf (:, natm ) reedsq = reedsq + sum ( reev ** 2 ) rgsq_im = 0.0_rp com = sum ( molbuf (:, 1 : natm ), 2 ) / natm do i = 1 , natm rgsq_im = rgsq_im + sum (( molbuf (:, i ) - com ) ** 2 ) end do rgsq = rgsq + rgsq_im / natm end if end do nmol = count ( atc % molecules ( 2 ,:) > 1 ) span = span / nmol ; reedsq = reedsq / nmol ; rgsq = rgsq / nmol end subroutine !****************************************************************************** subroutine compute_ic0 ( atc ) !! Computes statistics for a single chain in unbounded domain. type ( atmcfg_t ), intent ( in ) :: atc real ( rp ), dimension ( 3 ) :: ri real ( rp ), dimension ( 3 ) :: com , com_bbone , com_sc real ( rp ), dimension ( 3 ) :: r_tp real ( rp ) :: rgsq_isc integer :: n_sc , na_bbone , na_sc integer :: i , ibr , ia_beg , ia_end !Number of backbone atoms if ( atc % num_branches == 0 ) then na_bbone = atc % num_atoms n_sc = 0 !Number of side chains else na_bbone = atc % branches ( 2 , 1 ) n_sc = atc % num_branches - 1 !Number of side chains end if !Zero out rgsq = 0.0_rp ; reedsq = 0.0_rp ; span = 0.0_rp rgsq_bbone = 0.0_rp ; rgsq_sc = 0.0_rp ; reedsq_sc = 0.0_rp span_bbone = 0.0_rp reev = 0.0_rp span = maxval ( atc % coordinates , 2 ) - minval ( atc % coordinates , 2 ) span_bbone = maxval ( atc % coordinates (:, 1 : na_bbone ), 2 ) & - minval ( atc % coordinates (:, 1 : na_bbone ), 2 ) reev = atc % coordinates (:, na_bbone ) - atc % coordinates (:, 1 ) reedsq = sum ( reev ** 2 ) com = sum ( atc % coordinates , 2 ) / atc % num_atoms do i = 1 , atc % num_atoms ri = atc % coordinates (:, i ) - com rgsq = rgsq + sum ( ri ** 2 ) end do rgsq = rgsq / atc % num_atoms com_bbone = sum ( atc % coordinates (:, 1 : na_bbone ), 2 ) / na_bbone do i = 1 , na_bbone rgsq_bbone = rgsq_bbone + sum (( atc % coordinates (:, i ) - com_bbone ) ** 2 ) end do rgsq_bbone = rgsq_bbone / na_bbone do ibr = 2 , atc % num_branches ia_beg = atc % branches ( 3 , ibr ) ia_end = ia_beg + atc % branches ( 2 , ibr ) - 1 r_tp = atc % coordinates (:, atc % branches ( 1 , ibr )) !Add end-to-end distance squared of this side chain reedsq_sc = reedsq_sc + sum (( atc % coordinates (:, ia_end ) - r_tp ) ** 2 ) !Number of side chain atoms. Adding 1 for the tether point na_sc = atc % branches ( 2 , ibr ) + 1 !Get side chain c.o.m. com_sc = r_tp + sum ( atc % coordinates (:, ia_beg : ia_end ), 2 ) com_sc = com_sc / na_sc !Get radius of gyration squared of this side chain rgsq_isc = 0.0_rp ri = r_tp - com_sc rgsq_isc = rgsq_isc + sum ( ri ** 2 ) do i = ia_beg , ia_end ri = atc % coordinates (:, i ) - com_sc rgsq_isc = rgsq_isc + sum ( ri ** 2 ) end do rgsq_isc = rgsq_isc / na_sc !Add radius of gyration of this side chain rgsq_sc = rgsq_sc + rgsq_isc end do if ( n_sc > 0 ) then rgsq_sc = rgsq_sc / n_sc reedsq_sc = reedsq_sc / n_sc end if end subroutine !****************************************************************************** end module stats_m","tags":"","loc":"sourcefile/stats_m.f90.html"},{"title":"connectivity_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~connectivity_m.f90~~EfferentGraph sourcefile~connectivity_m.f90 connectivity_m.f90 sourcefile~table_m.f90 table_m.f90 sourcefile~connectivity_m.f90->sourcefile~table_m.f90 sourcefile~vector_m.f90 vector_m.f90 sourcefile~connectivity_m.f90->sourcefile~vector_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~connectivity_m.f90->sourcefile~constants_m.f90 sourcefile~table_m.f90->sourcefile~vector_m.f90 sourcefile~table_m.f90->sourcefile~constants_m.f90 sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~connectivity_m.f90~~AfferentGraph sourcefile~connectivity_m.f90 connectivity_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~pairtab_m.fpp->sourcefile~connectivity_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules connectivity_m Source Code connectivity_m.f90 Source Code !********************************************************************************! ! The MIT License (MIT)                                                          ! !                                                                                ! ! Copyright (c) 2020 Sarit Dutta <saridut@gmail.com>                             ! !                                                                                ! ! Permission is hereby granted, free of charge, to any person obtaining a copy   ! ! of this software and associated documentation files (the \"Software\"), to deal  ! ! in the Software without restriction, including without limitation the rights   ! ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      ! ! copies of the Software, and to permit persons to whom the Software is          ! ! furnished to do so, subject to the following conditions:                       ! !                                                                                ! ! The above copyright notice and this permission notice shall be included in all ! ! copies or substantial portions of the Software.                                ! !                                                                                ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     ! ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       ! ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    ! ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         ! ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  ! ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  ! ! SOFTWARE.                                                                      ! !********************************************************************************! module connectivity_m !! Routines for building atom->bond, atom->angle, etc. tables and excluded !! atoms table. use constants_m use vector_m use table_m implicit none private public :: atbo_build , atat_build , atan_build , atdh_build , exat_build contains !******************************************************************************** subroutine atbo_build ( num_atoms , num_bonds , bonds , atbo_tab ) integer , intent ( in ) :: num_atoms integer , intent ( in ) :: num_bonds integer , dimension (:,:), intent ( in ) :: bonds type ( itable_t ), intent ( out ) :: atbo_tab !! Atoms -> bonds table type ( ivector_t ), dimension (:), allocatable :: buf_map integer :: iatm , jatm , ibnd integer :: j !Build table as list of lists allocate ( buf_map ( num_atoms )) do iatm = 1 , num_atoms call ivector_init ( buf_map ( iatm )) end do do ibnd = 1 , num_bonds iatm = bonds ( 2 , ibnd ) jatm = bonds ( 3 , ibnd ) call buf_map ( iatm )% append ( ibnd ) call buf_map ( jatm )% append ( ibnd ) end do !Sort in ascending order do iatm = 1 , num_atoms if ( buf_map ( iatm )% len > 1 ) call buf_map ( iatm )% sort () end do !Copy over to table call itbl_init ( atbo_tab , num_atoms ) do iatm = 1 , num_atoms do j = 1 , buf_map ( iatm )% len jatm = buf_map ( iatm )% get_val ( j ) call atbo_tab % append ( iatm , jatm ) end do end do !Delete list of lists table do iatm = 1 , num_atoms call buf_map ( iatm )% delete () end do deallocate ( buf_map ) !Release additional memory call atbo_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine atan_build ( num_atoms , num_angles , angles , atan_tab ) integer , intent ( in ) :: num_atoms integer , intent ( in ) :: num_angles integer , dimension (:,:), intent ( in ) :: angles type ( itable_t ), intent ( out ) :: atan_tab !! Atoms -> angles table type ( ivector_t ), dimension (:), allocatable :: buf_map integer :: iatm , jatm , katm , iang integer :: j !Build table as list of lists allocate ( buf_map ( num_atoms )) do iatm = 1 , num_atoms call ivector_init ( buf_map ( iatm )) end do do iang = 1 , num_angles iatm = angles ( 2 , iang ) jatm = angles ( 3 , iang ) katm = angles ( 4 , iang ) call buf_map ( iatm )% append ( iang ) call buf_map ( jatm )% append ( iang ) call buf_map ( katm )% append ( iang ) end do !Sort in ascending order do iatm = 1 , num_atoms if ( buf_map ( iatm )% len > 1 ) call buf_map ( iatm )% sort () end do !Copy over to table call itbl_init ( atan_tab , num_atoms ) do iatm = 1 , num_atoms do j = 1 , buf_map ( iatm )% len jatm = buf_map ( iatm )% get_val ( j ) call atan_tab % append ( iatm , jatm ) end do end do !Delete list of lists table do iatm = 1 , num_atoms call buf_map ( iatm )% delete () end do deallocate ( buf_map ) !Release additional memory call atan_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine atdh_build ( num_atoms , num_dihedrals , dihedrals , atdh_tab ) integer , intent ( in ) :: num_atoms integer , intent ( in ) :: num_dihedrals integer , dimension (:,:), intent ( in ) :: dihedrals type ( itable_t ), intent ( out ) :: atdh_tab !! Atoms -> dihedrals table type ( ivector_t ), dimension (:), allocatable :: buf_map integer :: iatm , jatm , katm , latm , idhd integer :: j !Build table as list of lists allocate ( buf_map ( num_atoms )) do iatm = 1 , num_atoms call ivector_init ( buf_map ( iatm )) end do do idhd = 1 , num_dihedrals iatm = dihedrals ( 2 , idhd ) jatm = dihedrals ( 3 , idhd ) katm = dihedrals ( 4 , idhd ) latm = dihedrals ( 5 , idhd ) call buf_map ( iatm )% append ( idhd ) call buf_map ( jatm )% append ( idhd ) call buf_map ( katm )% append ( idhd ) call buf_map ( latm )% append ( idhd ) end do !Sort in ascending order do iatm = 1 , num_atoms if ( buf_map ( iatm )% len > 1 ) call buf_map ( iatm )% sort () end do !Copy over to table call itbl_init ( atdh_tab , num_atoms ) do iatm = 1 , num_atoms do j = 1 , buf_map ( iatm )% len jatm = buf_map ( iatm )% get_val ( j ) call atdh_tab % append ( iatm , jatm ) end do end do !Delete list of lists table do iatm = 1 , num_atoms call buf_map ( iatm )% delete () end do deallocate ( buf_map ) !Release additional memory call atdh_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine atat_build ( num_atoms , bonds , atbo_tab , atat_tab ) integer , intent ( in ) :: num_atoms integer , dimension (:,:), intent ( in ) :: bonds type ( itable_t ), intent ( in ) :: atbo_tab !! Atoms -> bonds table type ( itable_t ), intent ( out ) :: atat_tab !! Atoms -> bonded atoms table (1-ring) integer , dimension (:), pointer :: inc_bonds => null () type ( ivector_t ) :: excl_atms integer :: iatm , jatm , jbnd , jbnd_atm1 , jbnd_atm2 integer :: j !Initialize table call itbl_init ( atat_tab , num_atoms ) !List of excluded atoms call ivector_init ( excl_atms ) do iatm = 1 , num_atoms call excl_atms % clear () !Get incident bonds call atbo_tab % get_row ( iatm , inc_bonds ) !Add atoms from each of the incident bonds, excluding iatom do j = 1 , size ( inc_bonds ) jbnd = inc_bonds ( j ) jbnd_atm1 = bonds ( 2 , jbnd ) jbnd_atm2 = bonds ( 3 , jbnd ) if ( jbnd_atm1 /= iatm ) call excl_atms % append ( jbnd_atm1 ) if ( jbnd_atm2 /= iatm ) call excl_atms % append ( jbnd_atm2 ) end do !Sort and remove duplicates. These are the atoms in the 1-ring. call excl_atms % unique () !Add to atat_tab. Note that iatm does not appear in the atat table !for iatm. do j = 1 , excl_atms % len jatm = excl_atms % get_val ( j ) call atat_tab % append ( iatm , jatm ) end do end do !Release additional memory call atat_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine exat_build ( num_atoms , excluded_atoms , atat_tab , exat_tab ) !! Before a call to this first build atbo_tab. integer , intent ( in ) :: num_atoms integer , intent ( in ) :: excluded_atoms type ( itable_t ), intent ( in ) :: atat_tab !! Atoms -> bonded atoms table type ( itable_t ), intent ( out ) :: exat_tab !! Atoms -> excluded (from vdw calculation) atoms table integer , dimension (:), pointer :: nbr_atms => null () integer , dimension (:), pointer :: nbr2_atms => null () integer , dimension (:), pointer :: nbr3_atms => null () type ( ivector_t ) :: excl_atms integer :: iatm , jatm , j2atm , j3atm integer :: j , j2 , j3 !Initialize table call itbl_init ( exat_tab , num_atoms ) !List of excluded atoms call ivector_init ( excl_atms ) do iatm = 1 , num_atoms call excl_atms % clear () if ( excluded_atoms > 0 ) then !Get atoms in 1-ring neighborhood call atat_tab % get_row ( iatm , nbr_atms ) !Add atoms to excluded atoms list. First adding iatm itself. call excl_atms % append ( iatm ) do j = 1 , size ( nbr_atms ) jatm = nbr_atms ( j ) call excl_atms % append ( jatm ) !Atoms for second ring neighbors if ( excluded_atoms > 1 ) then call atat_tab % get_row ( jatm , nbr2_atms ) do j2 = 1 , size ( nbr2_atms ) j2atm = nbr2_atms ( j2 ) call excl_atms % append ( j2atm ) !Atoms for third ring neighbors if ( excluded_atoms > 2 ) then call atat_tab % get_row ( j2atm , nbr3_atms ) do j3 = 1 , size ( nbr3_atms ) j3atm = nbr3_atms ( j3 ) call excl_atms % append ( j3atm ) end do !Finished adding all third ring neighbors end if end do !Finished adding all second ring neighbors end if !Finished adding all first ring neighbors end do end if !Sort and remove duplicates call excl_atms % unique () !Add to exat_tab. Note that iatom appears in the excluded atoms list for !iatom. do j = 1 , excl_atms % len jatm = excl_atms % get_val ( j ) call exat_tab % append ( iatm , jatm ) end do end do !Release additional memory call exat_tab % shrink_to_fit () end subroutine !******************************************************************************** end module connectivity_m","tags":"","loc":"sourcefile/connectivity_m.f90.html"},{"title":"bd_solver_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~bd_solver_m.f90~~EfferentGraph sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~config_io_m.f90 config_io_m.f90 sourcefile~bd_solver_m.f90->sourcefile~config_io_m.f90 sourcefile~brown_m.f90 brown_m.f90 sourcefile~bd_solver_m.f90->sourcefile~brown_m.f90 sourcefile~logger_m.f90 logger_m.f90 sourcefile~bd_solver_m.f90->sourcefile~logger_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~bd_solver_m.f90->sourcefile~atmcfg_m.f90 sourcefile~control_m.f90 control_m.f90 sourcefile~bd_solver_m.f90->sourcefile~control_m.f90 sourcefile~stats_m.f90 stats_m.f90 sourcefile~bd_solver_m.f90->sourcefile~stats_m.f90 sourcefile~trajectory_m.f90 trajectory_m.f90 sourcefile~bd_solver_m.f90->sourcefile~trajectory_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~bd_solver_m.f90->sourcefile~constants_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~config_io_m.f90->sourcefile~atmcfg_m.f90 sourcefile~config_io_m.f90->sourcefile~constants_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~config_io_m.f90->sourcefile~strings_m.f90 sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~config_io_m.f90->sourcefile~simbox_m.f90 sourcefile~brown_m.f90->sourcefile~logger_m.f90 sourcefile~brown_m.f90->sourcefile~constants_m.f90 sourcefile~brown_m.f90->sourcefile~strings_m.f90 sourcefile~random_m.f90 random_m.f90 sourcefile~brown_m.f90->sourcefile~random_m.f90 sourcefile~timestamp_m.f90 timestamp_m.f90 sourcefile~logger_m.f90->sourcefile~timestamp_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 sourcefile~control_m.f90->sourcefile~constants_m.f90 sourcefile~control_m.f90->sourcefile~strings_m.f90 sourcefile~stats_m.f90->sourcefile~atmcfg_m.f90 sourcefile~stats_m.f90->sourcefile~control_m.f90 sourcefile~stats_m.f90->sourcefile~constants_m.f90 sourcefile~stats_m.f90->sourcefile~strings_m.f90 sourcefile~stats_m.f90->sourcefile~simbox_m.f90 sourcefile~trajectory_m.f90->sourcefile~constants_m.f90 sourcefile~interaction_m.f90->sourcefile~atmcfg_m.f90 sourcefile~interaction_m.f90->sourcefile~control_m.f90 sourcefile~interaction_m.f90->sourcefile~stats_m.f90 sourcefile~interaction_m.f90->sourcefile~constants_m.f90 sourcefile~table_m.f90 table_m.f90 sourcefile~interaction_m.f90->sourcefile~table_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~ia_vdw_m.f90 ia_vdw_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_vdw_m.f90 sourcefile~ia_bond_m.f90 ia_bond_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_bond_m.f90 sourcefile~ia_dihedral_m.f90 ia_dihedral_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_dihedral_m.f90 sourcefile~ia_external_m.f90 ia_external_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_external_m.f90 sourcefile~ia_angle_m.f90 ia_angle_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_angle_m.f90 sourcefile~interaction_m.f90->sourcefile~simbox_m.f90 sourcefile~ia_tether_m.f90 ia_tether_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_tether_m.f90 sourcefile~table_m.f90->sourcefile~constants_m.f90 sourcefile~vector_m.f90 vector_m.f90 sourcefile~table_m.f90->sourcefile~vector_m.f90 sourcefile~pairtab_m.fpp->sourcefile~atmcfg_m.f90 sourcefile~pairtab_m.fpp->sourcefile~constants_m.f90 sourcefile~pairtab_m.fpp->sourcefile~table_m.f90 sourcefile~pairtab_m.fpp->sourcefile~simbox_m.f90 sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~pairtab_m.fpp->sourcefile~cell_list_m.f90 sourcefile~connectivity_m.f90 connectivity_m.f90 sourcefile~pairtab_m.fpp->sourcefile~connectivity_m.f90 sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~vector_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~constants_m.f90 sourcefile~ia_bond_m.f90->sourcefile~logger_m.f90 sourcefile~ia_bond_m.f90->sourcefile~constants_m.f90 sourcefile~ia_bond_m.f90->sourcefile~strings_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~constants_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 sourcefile~ia_external_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_external_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 sourcefile~ia_angle_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_angle_m.f90->sourcefile~constants_m.f90 sourcefile~simbox_m.f90->sourcefile~constants_m.f90 sourcefile~simbox_m.f90->sourcefile~random_m.f90 sourcefile~ia_tether_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_tether_m.f90->sourcefile~constants_m.f90 sourcefile~cell_list_m.f90->sourcefile~constants_m.f90 sourcefile~cell_list_m.f90->sourcefile~simbox_m.f90 sourcefile~cell_list_m.f90->sourcefile~vector_m.f90 sourcefile~connectivity_m.f90->sourcefile~constants_m.f90 sourcefile~connectivity_m.f90->sourcefile~table_m.f90 sourcefile~connectivity_m.f90->sourcefile~vector_m.f90 sourcefile~aabbtree_m.f90->sourcefile~constants_m.f90 sourcefile~aabbtree_m.f90->sourcefile~strings_m.f90 sourcefile~aabbtree_m.f90->sourcefile~vector_m.f90 sourcefile~aabb_m.fpp aabb_m.fpp sourcefile~aabbtree_m.f90->sourcefile~aabb_m.fpp sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~aabb_m.fpp->sourcefile~constants_m.f90 sourcefile~aabb_m.fpp->sourcefile~strings_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~bd_solver_m.f90~~AfferentGraph sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules bd_solver_m Source Code bd_solver_m.f90 Source Code module bd_solver_m !! Routines implementing Brownian Dynamics (BD) solver. use iso_c_binding , only : c_loc , c_ptr , c_f_pointer use mkl_blas !use mkl_rci use constants_m use logger_m use control_m use atmcfg_m use interaction_m use brown_m use stats_m use config_io_m use trajectory_m implicit none private public :: bds_init , bds_run , bds_finish , se_fval , se_jacv logical :: lhdia , write_traj integer :: lanc_mxitr , nlmxitr , kdmax , nts_mobsam real ( rp ) :: tim_stp , lanc_tol , ftol , stptol integer ( ip_long ) :: nts , nts_sim , nts_dump , nts_samp , nts_log character ( len = 4 ) :: mob_fctr , bdintg character ( len = :), allocatable :: fn_revive type ( smbx_t ), pointer :: psmbx => null () type ( atmcfg_t ), pointer :: patc => null () integer :: cntr_mobsam real ( rp ) :: sqrt_two_dt real ( rp ), dimension (: ), allocatable :: drift real ( rp ), dimension (:,:), allocatable :: diffusion real ( rp ), dimension (:,:), allocatable :: mob real ( rp ), dimension (:), allocatable :: crd0 real ( rp ), dimension (:), allocatable :: sol real ( rp ), dimension (:), allocatable :: nitsol_rwork real ( rp ), dimension (:), pointer :: pvcrd => null () real ( rp ), dimension (:), pointer :: pvfrc => null () contains !******************************************************************************* subroutine bds_init ( cpar , num_atoms , job_tag , ierr ) !! Initializes the BD solver. type ( ctrlpar_t ), intent ( in ) :: cpar integer , intent ( in ) :: num_atoms character ( len =* ), intent ( in ) :: job_tag integer , intent ( out ) :: ierr integer :: lrwrk ierr = 0 lhdia = cpar % lhdia ; write_traj = cpar % write_traj nts_sim = cpar % nts_sim ; nts_dump = cpar % nts_dump nts_samp = cpar % nts_samp ; nts_log = cpar % nts_log mob_fctr = cpar % mob_fctr ; bdintg = cpar % bdintg nts_mobsam = cpar % nts_mobsam tim_stp = cpar % tim_stp if ( mob_fctr == 'LANC' ) then lanc_mxitr = cpar % lanc_mxitr lanc_tol = cpar % lanc_tol end if if ( bdintg == 'SE' ) then nlmxitr = cpar % se_nlmxitr ; kdmax = cpar % se_kdmax ftol = cpar % se_tol ( 1 ); stptol = cpar % se_tol ( 2 ) end if fn_revive = cpar % fn_revive // job_tag sqrt_two_dt = sqrt ( 2.0_rp * tim_stp ) !Allocate memory for BD drift-diffusion SDE allocate ( drift ( 3 * num_atoms )) if ( lhdia ) then allocate ( mob ( 3 * num_atoms , 3 * num_atoms )) allocate ( diffusion ( 3 * num_atoms , nts_mobsam )) if ( mob_fctr == 'CHOL' ) then call brn_init ( 3 * num_atoms , nts_mobsam , mob_fctr ) else if ( mob_fctr == 'LANC' ) then call brn_init ( 3 * num_atoms , nts_mobsam , mob_fctr , & lanc_mxitr , lanc_tol ) end if cntr_mobsam = 0 else allocate ( diffusion ( 3 * num_atoms , 1 )) end if if ( bdintg == 'SE' ) then allocate ( crd0 ( 3 * num_atoms )) allocate ( sol ( 3 * num_atoms )) lrwrk = 3 * num_atoms * ( kdmax + 5 ) + kdmax * ( kdmax + 3 ) allocate ( nitsol_rwork ( lrwrk )) end if end subroutine !****************************************************************************** subroutine bds_finish () !! Clears up memory allocated in [[bds_init]]. call brn_finish () if ( allocated ( mob )) deallocate ( mob ) if ( allocated ( drift )) deallocate ( drift ) if ( allocated ( diffusion )) deallocate ( diffusion ) if ( allocated ( crd0 )) deallocate ( crd0 ) if ( allocated ( sol )) deallocate ( sol ) if ( allocated ( nitsol_rwork )) deallocate ( nitsol_rwork ) pvcrd => null (); pvfrc => null () psmbx => null (); patc => null () end subroutine !****************************************************************************** subroutine bds_run ( nts_beg , simbox , atc , ierr ) !! Driver for BD integrator. !! !! Repeatedly calls [[integrate_em]] or [[integrate_se]] to update atom !! positions. integer ( ip_long ), intent ( in ) :: nts_beg type ( smbx_t ), intent ( in ), target :: simbox type ( atmcfg_t ), intent ( in out ), target :: atc integer , intent ( out ) :: ierr !! Error flag integer ( ip_long ) :: nts real ( rp ), dimension ( 3 ) :: com type ( c_ptr ) :: loc logical :: limud nts = nts_beg ; ierr = 0 !Assign pointers psmbx => simbox ; patc => atc loc = c_loc ( patc % coordinates ) call c_f_pointer ( loc , pvcrd , [ 3 * patc % num_atoms ]) loc = c_loc ( patc % forces ) call c_f_pointer ( loc , pvfrc , [ 3 * patc % num_atoms ]) !Is this an isolated untethered molecule in an unbounded domain? if ( ( patc % num_tethers == 0 ) . and . ( psmbx % imcon == 0 ) ) then limud = . true . else limud = . false . end if !For isolated untethered molecule, ensure c.o.m. is at the origin. if ( limud ) call psmbx % to_origin ( atc % coordinates ) !Log & dump starting configuration call logger % log_msg ( 'nts = ' // str_from_num ( nts )) call write_dump ( nts , psmbx , patc , fn_revive ) do if ( nts > nts_sim ) exit if ( bdintg == 'EM' ) then call integrate_em ( ierr ) else if ( bdintg == 'SE' ) then call integrate_se ( ierr ) end if if ( ierr /= 0 ) return nts = nts + 1 !Apply boundary conditions: For isolated untethered molecule, !update molecule_com & bring c.o.m. to the center of the box. if ( limud ) then call psmbx % to_origin ( patc % coordinates , com ) patc % molecule_com = patc % molecule_com + com end if !For PBC, wrap atom positions if ( psmbx % imcon /= 0 ) call psmbx % wrap_all ( patc % coordinates ) !Accumulate statistics call stats_accumulate ( psmbx , patc ) !Logging if ( mod ( nts , nts_log ) == 0 ) then call logger % log_msg ( 'nts = ' // str_from_num ( nts )) end if !Dump revive file if ( mod ( nts , nts_dump ) == 0 ) then call write_dump ( nts , psmbx , patc , fn_revive ) end if if ( mod ( nts , nts_samp ) == 0 ) then !Write stats call stats_write ( nts , psmbx , atc ) !Write traj if ( write_traj ) call traj % append_frame ( nts , patc % coordinates ) end if end do !Dump the final configuration call write_dump ( nts , psmbx , patc , fn_revive ) end subroutine !****************************************************************************** subroutine integrate_em ( ierr ) !! Performs one step of BD integration using explicit Euler-Maruyama scheme. integer , intent ( out ) :: ierr ierr = 0 !Calculate the diffusion term call calc_diffusion ( ierr ) if ( ierr /= 0 ) return !Calculate the drift term call calc_drift ( ierr ) if ( ierr /= 0 ) return !Update positions if ( lhdia ) then pvcrd = pvcrd + drift + diffusion (:, cntr_mobsam ) if ( cntr_mobsam == nts_mobsam ) cntr_mobsam = 0 else pvcrd = pvcrd + drift + diffusion (:, 1 ) end if end subroutine !****************************************************************************** subroutine integrate_se ( ierr ) !! Performs one step of BD integration using semi-implicit Euler scheme. integer , intent ( out ) :: ierr real ( rp ), dimension ( 0 ) :: rpar !Dummy arg, 0-dim array integer , dimension ( 0 ) :: ipar !Dummy arg, 0-dim array integer , dimension ( 10 ) :: input integer , dimension ( 6 ) :: info integer :: n character ( len = 256 ) :: msg !integer :: iplvl, ipunit !common /nitprint/ iplvl, ipunit external nitsol ierr = 0 ; n = 3 * patc % num_atoms rpar = 0.0_rp ; ipar = 0 input = 0 input ( 1 ) = nlmxitr ; input ( 4 ) = kdmax ; input ( 5 ) = 0 input ( 7 ) = 1 !iplvl = 0; ipunit = logger%fu !Calculate the diffusion term call calc_diffusion ( ierr ) if ( ierr /= 0 ) return !Evaluate the nonlinear function arising out of discretizing the SDE in !semi-implicit form crd0 = pvcrd !Coordinates at the end of last time step sol = pvcrd !Initial guess call nitsol ( n , sol , se_fval , se_jacv , ftol , stptol , input , & info , nitsol_rwork , rpar , ipar , ierr , ddot , dnrm2 ) msg = '' select case ( ierr ) case (: - 1 ) write ( msg , '(a,i0,a)' ) 'illegal value in input(' , abs ( ierr ), ')' case ( 1 ) write ( msg , '(a)' ) 'max nonlinear iterations reached' case ( 2 ) write ( msg , '(a)' ) 'failed to evaluate nonlinear function' case ( 3 ) write ( msg , '(a)' ) 'failed to evaluate J*v' case ( 4 ) write ( msg , '(a)' ) 'failed to evaluate P&#94;{-1}*v' case ( 5 ) write ( msg , '(a)' ) 'insufficient initial norm reduction' case ( 6 ) write ( msg , '(a)' ) 'failed to reach an acceptable step by backtracking' end select if ( len_trim ( msg ) > 0 ) then call logger % log_msg ( msg ) return end if !Comment out for verbose output from nitsol. !write(msg, '(4(a,i0))') 'nfe = ', info(1), ', nli = ', info(4), & !    ', nni = ', info(5), ', nbktrk = ', info(6) !call logger%log_msg(msg) pvcrd = sol if ( lhdia ) then if ( cntr_mobsam == nts_mobsam ) cntr_mobsam = 0 end if end subroutine !****************************************************************************** subroutine se_fval ( n , xcur , fcur , rpar , ipar , ierr ) !! Calculates the nonlinear function. integer , intent ( in ) :: n real ( rp ), dimension ( * ), intent ( in ) :: xcur real ( rp ), dimension ( * ), intent ( out ) :: fcur real ( rp ), dimension ( * ), intent ( in ) :: rpar integer , dimension ( * ), intent ( in ) :: ipar integer , intent ( out ) :: ierr ierr = 0 ; fcur ( 1 : n ) = 0.0_rp ; pvcrd = xcur ( 1 : n ) call calc_drift ( ierr ) if ( ierr /= 0 ) return if ( lhdia ) then fcur ( 1 : n ) = pvcrd - drift - crd0 - diffusion (:, cntr_mobsam ) else fcur ( 1 : n ) = pvcrd - drift - crd0 - diffusion (:, 1 ) end if end subroutine !****************************************************************************** subroutine se_jacv ( n , xcur , fcur , ijob , v , z , rpar , ipar , ierr ) !! Calculates jacobian times vector product. This is a dummy subroutine. integer , intent ( in ) :: n real ( rp ), dimension (:), intent ( in ) :: xcur real ( rp ), dimension (:), intent ( in ) :: fcur integer , intent ( in ) :: ijob real ( rp ), dimension (:), intent ( in ) :: v real ( rp ), dimension (:), intent ( out ) :: z real ( rp ), dimension (:), intent ( in ) :: rpar integer , dimension (:), intent ( in ) :: ipar integer , intent ( out ) :: ierr ierr = 0 end subroutine !****************************************************************************** subroutine calc_diffusion ( ierr ) !! Calculates the diffusion term of the SDE. Updates module variables !!`diffusion` and `cntr_mobsam`. integer , intent ( out ) :: ierr integer :: j , f logical :: lconv character ( len = 256 ) :: msg diffusion = 0.0_rp ; ierr = 0 !Early return for no HI if (. not . lhdia ) then !Calculate standard Gaussian vectors call brn_calc_dw ( diffusion ) diffusion = sqrt_two_dt * diffusion return end if !Diffusion term with HI if ( cntr_mobsam == 0 ) then !Calculate the mobility matrix call calc_rpy_tensor ( patc % coordinates , mob ) !Calculate standard Gaussian vectors call brn_calc_dw ( diffusion ) !Calculate the Brownian vectors if ( mob_fctr == 'CHOL' ) then call brn_calc_bdw ( mob , diffusion , ierr ) if ( ierr /= 0 ) return !Cholesky decomposition overwrites the upper triangular part of mob !with the factorization result U. Putting the diagonal elements !back to unity (for RPY) as U is no longer needed. The lower !triangular part of mob will be used in calculating drift. do j = 1 , size ( mob , 2 ) mob ( j , j ) = 1.0_rp end do else if ( mob_fctr == 'LANC' ) then call brn_calc_bdw ( mob , diffusion , ierr , lconv , f ) if ( ierr /= 0 ) return if (. not . lconv ) then write ( msg , '(a,i0)' ) '<brn_calc_bdw> not converged. nts = ' , nts call logger % log_msg ( msg ) end if end if diffusion = sqrt_two_dt * diffusion end if cntr_mobsam = cntr_mobsam + 1 end subroutine !****************************************************************************** subroutine calc_drift ( ierr ) !! Calculates the drift term of the SDE. integer , intent ( out ) :: ierr integer :: i drift = 0.0_rp ; ierr = 0 !Update forces call ia_calc_forces ( psmbx , patc , ierr ) if ( ierr /= 0 ) return !Calculate ambient flow velocity at the atom locations. select case ( patc % flow_style ) case ( 1 ) !Steady simple shear: Flow along x, gradient along y do i = 1 , patc % num_atoms drift ( 3 * i - 2 ) = patc % flow_params ( 1 ) * patc % coordinates ( 2 , i ) end do case ( 2 ) !Steady planar extension in x-y plane do i = 1 , patc % num_atoms drift ( 3 * i - 2 ) = patc % flow_params ( 1 ) * patc % coordinates ( 1 , i ) drift ( 3 * i - 1 ) = - patc % flow_params ( 1 ) * patc % coordinates ( 2 , i ) end do case ( 3 ) !Steady uniaxial extension along x do i = 1 , patc % num_atoms drift ( 3 * i - 2 ) = patc % flow_params ( 1 ) * patc % coordinates ( 1 , i ) drift ( 3 * i - 1 ) = - 0.5_rp * patc % flow_params ( 1 ) * patc % coordinates ( 2 , i ) drift ( 3 * i ) = - 0.5_rp * patc % flow_params ( 1 ) * patc % coordinates ( 3 , i ) end do case default continue end select !drift <- mob * forces + drift. Only the lower triangular part of !mob is accessed. if ( lhdia ) then call dsymv ( 'L' , 3 * patc % num_atoms , 1.0_rp , mob , 3 * patc % num_atoms , & pvfrc , 1 , 1.0_rp , drift , 1 ) else drift = drift + pvfrc end if drift = tim_stp * drift end subroutine !****************************************************************************** subroutine calc_rpy_tensor ( coordinates , mob ) !! Calculates the RPY approximation to the mobility tensor. real ( rp ), dimension (:,:), intent ( in ) :: coordinates !! (3, num_atoms*) matrix; stores the atom positions. real ( rp ), dimension (:,:), intent ( out ) :: mob !! (3*num_atoms*, 3*num_atoms*) matrix; stores the mobility tensor. real ( rp ), dimension ( 3 ) :: ri , rj , rij real ( rp ), dimension ( 3 , 3 ) :: matrpy real ( rp ) :: rijm , irijm , irijm2 real ( rp ) :: c1 , c2 , consij integer :: i , j , num_atoms num_atoms = size ( coordinates , 2 ) mob = 0.0_rp !Calculate the RPY tensor (in strictly upper triangular form) do j = 2 , num_atoms rj = coordinates (:, j ) do i = 1 , ( j - 1 ) ri = coordinates (:, i ) rij = rj - ri rijm = norm2 ( rij ) irijm = 1.0_rp / rijm irijm2 = irijm * irijm if ( rijm >= 2.0_rp ) then C1 = 1.0_rp + ( 2.0_rp / 3.0_rp ) * irijm2 C2 = 1.0_rp - 2.0_rp * irijm2 consij = 0.75_rp * irijm else C1 = 1.0_rp - 9.0_rp * rijm / ( 3 2.0_rp ) C2 = 3.0_rp * rijm / ( 3 2.0_rp ) consij = 1.0_rp end if matrpy ( 1 , 1 ) = consij * ( C1 + C2 * rij ( 1 ) * rij ( 1 ) * irijm2 ) matrpy ( 2 , 1 ) = consij * ( C2 * rij ( 2 ) * rij ( 1 ) * irijm2 ) matrpy ( 3 , 1 ) = consij * ( C2 * rij ( 3 ) * rij ( 1 ) * irijm2 ) matrpy ( 1 , 2 ) = consij * ( C2 * rij ( 1 ) * rij ( 2 ) * irijm2 ) matrpy ( 2 , 2 ) = consij * ( C1 + C2 * rij ( 2 ) * rij ( 2 ) * irijm2 ) matrpy ( 3 , 2 ) = consij * ( C2 * rij ( 3 ) * rij ( 2 ) * irijm2 ) matrpy ( 1 , 3 ) = consij * ( C2 * rij ( 1 ) * rij ( 3 ) * irijm2 ) matrpy ( 2 , 3 ) = consij * ( C2 * rij ( 2 ) * rij ( 3 ) * irijm2 ) matrpy ( 3 , 3 ) = consij * ( C1 + C2 * rij ( 3 ) * rij ( 3 ) * irijm2 ) mob ( 3 * i - 2 : 3 * i , 3 * j - 2 : 3 * j ) = matrpy end do end do !Copy strictly upper triangular part to strictly lower triangular part. do j = 2 , 3 * num_atoms do i = 1 , j - 1 mob ( j , i ) = mob ( i , j ) end do end do !Put one on the diagonal. do j = 1 , 3 * num_atoms mob ( j , j ) = 1.0_rp end do end subroutine !****************************************************************************** end module bd_solver_m","tags":"","loc":"sourcefile/bd_solver_m.f90.html"},{"title":"pairtab_m.fpp – BROWNPAK","text":"This file depends on sourcefile~~pairtab_m.fpp~~EfferentGraph sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~table_m.f90 table_m.f90 sourcefile~pairtab_m.fpp->sourcefile~table_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~pairtab_m.fpp->sourcefile~atmcfg_m.f90 sourcefile~connectivity_m.f90 connectivity_m.f90 sourcefile~pairtab_m.fpp->sourcefile~connectivity_m.f90 sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~aabbtree_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~pairtab_m.fpp->sourcefile~constants_m.f90 sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~pairtab_m.fpp->sourcefile~cell_list_m.f90 sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~pairtab_m.fpp->sourcefile~simbox_m.f90 sourcefile~vector_m.f90 vector_m.f90 sourcefile~pairtab_m.fpp->sourcefile~vector_m.f90 sourcefile~table_m.f90->sourcefile~constants_m.f90 sourcefile~table_m.f90->sourcefile~vector_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 sourcefile~connectivity_m.f90->sourcefile~table_m.f90 sourcefile~connectivity_m.f90->sourcefile~constants_m.f90 sourcefile~connectivity_m.f90->sourcefile~vector_m.f90 sourcefile~aabbtree_m.f90->sourcefile~constants_m.f90 sourcefile~aabbtree_m.f90->sourcefile~vector_m.f90 sourcefile~aabb_m.fpp aabb_m.fpp sourcefile~aabbtree_m.f90->sourcefile~aabb_m.fpp sourcefile~strings_m.f90 strings_m.f90 sourcefile~aabbtree_m.f90->sourcefile~strings_m.f90 sourcefile~cell_list_m.f90->sourcefile~constants_m.f90 sourcefile~cell_list_m.f90->sourcefile~simbox_m.f90 sourcefile~cell_list_m.f90->sourcefile~vector_m.f90 sourcefile~simbox_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90 random_m.f90 sourcefile~simbox_m.f90->sourcefile~random_m.f90 sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~aabb_m.fpp->sourcefile~constants_m.f90 sourcefile~aabb_m.fpp->sourcefile~strings_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~pairtab_m.fpp~~AfferentGraph sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules pairtab_m Source Code pairtab_m.fpp Source Code #: include 'asserts.fypp' module pairtab_m use constants_m use vector_m use table_m use simbox_m use aabbtree_m use cell_list_m use atmcfg_m use connectivity_m implicit none private public :: pt_init , pt_delete , pt_build real ( rp ) :: rcutoff = 0.0_rp real ( rp ) :: tskin = 0.0_rp real ( rp ) :: rskin_sq = 0.0_rp real ( rp ) :: tskin_sq = 0.0_rp character ( len = :), allocatable :: mth_ptgen !! Pair table generation method: {'DIR', 'VER', 'AABBT', 'CL'} type ( itable_t ) :: exat_tab type ( aabbtree_t ) :: tree real ( rp ), dimension (:,:), allocatable :: coordinates_save !!  (3, *num_atoms*) array real ( rp ), dimension (:,:), allocatable :: coordinates_dr !!  (3, *num_atoms*) array contains !******************************************************************************* subroutine pt_init ( mth , num_atoms , excl_atoms , rcut , tskn , bonds , & simbox , pair_tab ) !! Performs initial setup for building a pair list. character ( len =* ), intent ( in ) :: mth integer , intent ( in ) :: num_atoms integer , intent ( in ) :: excl_atoms real ( rp ), intent ( in ) :: rcut real ( rp ), intent ( in ) :: tskn integer , dimension (:,:), intent ( in ) :: bonds type ( smbx_t ), intent ( in ) :: simbox type ( itable_t ), intent ( in out ) :: pair_tab type ( itable_t ) :: atbo_tab type ( itable_t ) :: atat_tab mth_ptgen = mth ; rcutoff = rcut ; tskin = tskn !Build atom -> bond table call atbo_build ( num_atoms , size ( bonds , 2 ), bonds , atbo_tab ) !Build atm -> bonded atoms table call atat_build ( num_atoms , bonds , atbo_tab , atat_tab ) !Build excluded atoms table call exat_build ( num_atoms , excl_atoms , atat_tab , exat_tab ) !Delete tables no longer needed. call atbo_tab % delete () call atat_tab % delete () !Initialize the pair table call itbl_init ( pair_tab , num_atoms ) !The last row of pair_tab will remain empty due to Newton's third law; !this will be used in an assert statement. select case ( mth_ptgen ) case ( 'VER' ) !Setup the verlet scheme rskin_sq = ( rcutoff + tskin ) ** 2 ; tskin_sq = tskin ** 2 allocate ( coordinates_save ( 3 , num_atoms ) ) allocate ( coordinates_dr ( 3 , num_atoms ) ) !Initializing to zero coordinates_save = 0.0_rp coordinates_dr = 0.0_rp case ( 'AABBT' ) !Setup an AABB tree and insert the atoms call tree % init ( num_atoms , tskin / rcutoff ) case ( 'CL' ) !Setup a cell list ! For relaxation/BD simulation the cell list is used for short range ! force calculation. call cl_init ( num_atoms , rcutoff , simbox ) call cl_set_cell_size ( rcutoff , simbox ) call cl_build_cell_nbrs () case default !Perform a direct N&#94;2 calculation rskin_sq = rcutoff ** 2 end select end subroutine !******************************************************************************* subroutine pt_delete ( pair_tab ) !! Cleanup for pair list calculation. type ( itable_t ), intent ( in out ) :: pair_tab select case ( mth_ptgen ) case ( 'VER' ) if ( allocated ( coordinates_save )) deallocate ( coordinates_save ) if ( allocated ( coordinates_dr ) ) deallocate ( coordinates_dr ) rskin_sq = 0.0_rp ; tskin_sq = 0.0_rp case ( 'AABBT' ) call tree % delete () case ( 'CL' ) call cl_delete () case default rskin_sq = 0.0_rp end select rcutoff = 0.0_rp ; tskin = 0.0_rp call pair_tab % delete () call exat_tab % delete () end subroutine !******************************************************************************* subroutine pt_build ( simbox , coordinates , pair_tab ) !! Builds a pair table. The resulting table is stored in the module variable !! `pair_tab`. type ( smbx_t ), intent ( in ) :: simbox real ( rp ), dimension (:,:), intent ( in ) :: coordinates type ( itable_t ), intent ( in out ) :: pair_tab select case ( mth_ptgen ) case ( 'VER' ) call build_pt_verlet ( simbox , coordinates , pair_tab ) case ( 'AABBT' ) call build_pt_aabbtree ( simbox , coordinates , pair_tab ) case ( 'CL' ) call build_pt_cell_list ( simbox , coordinates , pair_tab ) case default call build_pt_n2 ( simbox , coordinates , pair_tab ) end select end subroutine !****************************************************************************** subroutine build_pt_n2 ( simbox , coordinates , pair_tab ) !! Builds a pair table using direct N&#94;2 looping over all pairs. type ( smbx_t ), intent ( in ) :: simbox real ( rp ), dimension (:,:), intent ( in ) :: coordinates type ( itable_t ), intent ( in out ) :: pair_tab integer , dimension (:), pointer :: pnbrs => null () real ( rp ), dimension ( 3 ) :: ri real ( rp ), dimension ( 3 ) :: rj real ( rp ), dimension ( 3 ) :: rij real ( rp ) :: rij_sq integer :: i , j , num_atoms !Clear out the pair table call pair_tab % clear () num_atoms = size ( coordinates , 2 ) !Loop over all pairs to build list do i = 1 , num_atoms - 1 ri = coordinates (:, i ) do j = i + 1 , num_atoms !Check if atom j is an excluded atom for atom i if ( exat_tab % is_in ( i , j ) ) cycle rj = coordinates (:, j ) rij = rj - ri if ( simbox % imcon /= 0 ) call simbox % get_image ( rij ) rij_sq = sum ( rij ** 2 ) if ( rij_sq < rskin_sq ) call pair_tab % append ( i , j ) end do end do call pair_tab % get_row ( num_atoms , pnbrs ) @ : ASSERT ( size ( pnbrs ) == 0 ) !Release additional memory call pair_tab % shrink_to_fit () end subroutine !****************************************************************************** subroutine build_pt_verlet ( simbox , coordinates , pair_tab ) !! Builds a pair table using the Verlet scheme. type ( smbx_t ), intent ( in ) :: simbox real ( rp ), dimension (:,:), intent ( in ) :: coordinates type ( itable_t ), intent ( in out ) :: pair_tab integer , dimension (:), pointer :: pnbrs => null () real ( rp ), dimension ( 3 ) :: ri real ( rp ), dimension ( 3 ) :: rj real ( rp ), dimension ( 3 ) :: rij real ( rp ) :: dr_sq_max real ( rp ) :: rij_sq logical , save :: first_call = . true . integer :: i , j , num_atoms num_atoms = size ( coordinates , 2 ) !On first call no check for rebuilding if (. not . first_call ) then !Check whether rebuilding the list is necessary coordinates_dr = coordinates (:, 1 : num_atoms ) - coordinates_save if ( simbox % imcon /= 0 ) then do i = 1 , num_atoms call simbox % get_image ( coordinates_dr (:, i )) end do end if dr_sq_max = maxval ( sum ( coordinates_dr ** 2 , dim = 1 )) if ( 4 * dr_sq_max < tskin_sq ) return end if first_call = . false . !Clear out the pair table call pair_tab % clear () !Loop over all pairs to build list do i = 1 , num_atoms - 1 ri = coordinates (:, i ) do j = i + 1 , num_atoms !Check if atom j is an excluded atom for atom i if ( exat_tab % is_in ( i , j ) ) cycle rj = coordinates (:, j ) rij = rj - ri if ( simbox % imcon /= 0 ) call simbox % get_image ( rij ) rij_sq = sum ( rij ** 2 ) if ( rij_sq < rskin_sq ) call pair_tab % append ( i , j ) end do end do call pair_tab % get_row ( num_atoms , pnbrs ) @ : ASSERT ( size ( pnbrs ) == 0 ) !Release additional memory call pair_tab % shrink_to_fit () !Back up positions coordinates_save = coordinates end subroutine !******************************************************************************* subroutine build_pt_aabbtree ( simbox , coordinates , pair_tab ) type ( smbx_t ), intent ( in ) :: simbox real ( rp ), dimension (:,:), intent ( in ) :: coordinates type ( itable_t ), intent ( in out ) :: pair_tab type ( ivector_t ) :: nbrs integer , dimension (:), pointer :: pnbrs => null () integer :: ia , inbr , ia_nbr , num_atoms num_atoms = size ( coordinates , 2 ) !Clear out the pair table call pair_tab % clear () !Clear out the AABB tree call tree % clear () !Insert atoms into the tree do ia = 1 , num_atoms call tree % insert ( ia , coordinates (:, ia ), rcutoff ) end do !Loop over all atoms to find neighbors and insert into pair_tab. call ivector_init ( nbrs ) do ia = 1 , num_atoms call tree % query ( ia , nbrs ) call nbrs % sort () call nbrs % get_data ( pnbrs ) do inbr = 1 , size ( pnbrs ) ia_nbr = pnbrs ( inbr ) !Check if atom ia_nbr is an excluded atom for atom ia if ( exat_tab % is_in ( ia , ia_nbr ) ) cycle if (. not . pair_tab % is_in ( ia_nbr , ia )) then call pair_tab % append ( ia , ia_nbr ) end if end do end do call pair_tab % get_row ( num_atoms , pnbrs ) @ : ASSERT ( size ( pnbrs ) == 0 ) call nbrs % delete () !Release additional memory call pair_tab % shrink_to_fit () end subroutine !****************************************************************************** subroutine build_pt_cell_list ( simbox , coordinates , pair_tab ) !! Builds a pair table using cell list. type ( smbx_t ), intent ( in ) :: simbox real ( rp ), dimension (:,:), intent ( in ) :: coordinates type ( itable_t ), intent ( in out ) :: pair_tab type ( ivector_t ), dimension (:), allocatable :: ptaov !Pair table as an array of vectors. integer , dimension (:), pointer :: aic => null () integer , dimension (:), pointer :: ainc => null () integer , dimension (:), pointer :: nbr_cells => null () integer , dimension (:), pointer :: pnbrs => null () integer :: num_cells , num_atoms integer :: icell , jcell , iatm , jatm integer :: i , j , k num_atoms = size ( coordinates , 2 ) !Clear out the pair table call pair_tab % clear () !Initialize ptaov allocate ( ptaov ( num_atoms )) do i = 1 , size ( ptaov ) call ivector_init ( ptaov ( i )) end do call cl_build ( coordinates ) num_cells = cl_get_num_cells () do icell = 0 , ( num_cells - 1 ) call cl_get_contents ( icell , aic ) call cl_get_nbr_cells ( icell , nbr_cells ) !Interaction with particles within the cell do i = 1 , size ( aic ) - 1 iatm = aic ( i ) do j = i + 1 , size ( aic ) jatm = aic ( j ) !Check if atom jatm is an excluded atom for atom iatm if ( exat_tab % is_in ( iatm , jatm ) ) cycle call ptaov ( iatm )% append ( jatm ) end do end do !Interaction with particles belonging to neighboring cells do i = 1 , size ( aic ) iatm = aic ( i ) do j = 1 , size ( nbr_cells ) jcell = nbr_cells ( j ) call cl_get_contents ( jcell , ainc ) do k = 1 , size ( ainc ) jatm = ainc ( k ) !Check if atom jatm is an excluded atom for atom iatm if ( exat_tab % is_in ( iatm , jatm ) ) cycle call ptaov ( iatm )% append ( jatm ) end do end do end do end do !Copy the entries in ptaov to pair_tab do iatm = 1 , num_atoms call ptaov ( iatm )% get_data ( pnbrs ) do j = 1 , size ( pnbrs ) call pair_tab % append ( iatm , pnbrs ( j )) end do end do call pair_tab % get_row ( num_atoms , pnbrs ) @ : ASSERT ( size ( pnbrs ) == 0 ) !Release additional memory call pair_tab % shrink_to_fit () do i = 1 , size ( ptaov ) call ptaov ( i )% delete () end do deallocate ( ptaov ) end subroutine !******************************************************************************* end module pairtab_m","tags":"","loc":"sourcefile/pairtab_m.fpp.html"},{"title":"brown_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~brown_m.f90~~EfferentGraph sourcefile~brown_m.f90 brown_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~brown_m.f90->sourcefile~constants_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~brown_m.f90->sourcefile~strings_m.f90 sourcefile~random_m.f90 random_m.f90 sourcefile~brown_m.f90->sourcefile~random_m.f90 sourcefile~logger_m.f90 logger_m.f90 sourcefile~brown_m.f90->sourcefile~logger_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 sourcefile~timestamp_m.f90 timestamp_m.f90 sourcefile~logger_m.f90->sourcefile~timestamp_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~brown_m.f90~~AfferentGraph sourcefile~brown_m.f90 brown_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~brown_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules brown_m Source Code brown_m.f90 Source Code module brown_m !! Contains routines for evaluating **B**._d_**W** in the SDE for Brownian Dynamics !! simulation. use iso_c_binding , only : c_loc , c_ptr , c_f_pointer use mkl_blas use mkl_lapack use constants_m use random_m use strings_m use logger_m implicit none private public :: brn_init , brn_finish , brn_calc_dw , brn_calc_bdw character ( 4 ) :: meth !!Method to use for generating Brownian terms. Possible values are !!'CHOL' or 'LANC'. integer :: sizm !!Size of the mobility matrix integer :: s !!Number of Brownian vectors to be generated; equivalent to block size in the !!block Lanczos algorithm. integer :: dimk_min = 2 !!Minimum dimension of KSP integer :: dimk_max !!Maximum dimension of KSP real ( rp ) :: ethres = 1.0e-3_rp !!Error threshold for KSP-based method. real ( rp ), dimension (:,:), allocatable :: bdw_old !!(`sizm`, `s`) array. Stores B.dw at previous iteration. real ( rp ), dimension (:,:), allocatable :: lncv !!(`sizm`, `s*dimk_max`) array. Stores the Lanczos vectors. real ( rp ), dimension (:), allocatable :: eigvlh !!(`s*dimk_max`,) array. Eigenvalues of the tridiagonal/block triadiagonal !! matrix H generated by the Lanczos algorithm. real ( rp ), dimension (:,:), allocatable :: eigvch !!(`s*dimk_max`, `s*dimk_max`) array. Eigenvectors of the matrix H. real ( rp ), dimension (:,:), allocatable :: w !!(`sizm`, `s`) array. Used for generating the Lanczos vectors. real ( rp ), dimension (:), allocatable :: h_d !!(`dimk_max`,) array. Diagonal of the symmetric tridiagonal matrix H !! generated in case of `s = 1`. real ( rp ), dimension (:), allocatable :: h_sd !!(`dimk_max`,) array. Subdiagonal of the symmetric tridiagonal matrix H !! generated in case of `s = 1`. real ( rp ), dimension (:), allocatable :: tau !! (`s`,) array. Used in the QR decomposition of `w`. real ( rp ), dimension (:,:), allocatable :: matr !! (`s`,`s`) array. Used in the QR decomposition of `w`. real ( rp ), dimension (:,:), allocatable :: h_bd !!(`s`, `s*dimk_max`) array. Diagonal blocks of the matrix H. !!Used for KSP with `s > 1`. real ( rp ), dimension (:,:), allocatable :: h_bsd !!(`s`, `s*dimk_max`) array. Subdiagonal blocks of the matrix H. !!Used for KSP with `s > 1`. real ( rp ), dimension (:,:), allocatable :: h_bnd !!(`2*s`, `s*dimk_max`) array. Matrix H in banded storage. !!Used for KSP with `s > 1`. real ( rp ), dimension (:,:), allocatable :: tmp !!(`s*dimk_max`, `2*s`) array used as temporary storage space. real ( rp ), dimension (:), allocatable :: work !!Workspace array for LAPACK routines. integer , dimension (:), allocatable :: iwork !!Workspace array for LAPACK routines. contains !******************************************************************************* subroutine brn_init ( n , nblks , mth , f , e ) !! Performs initial setup. integer , intent ( in ) :: n !! Size of the mobility matrix. integer , intent ( in ) :: nblks !! Number of **B**._d_**W** vectors to generate for the same mobility matrix. !! `1 <= nblks < n`. character ( 4 ), intent ( in ) :: mth !! Method for calculating the Brownian terms. `mth = 'CHOL'` for !! Cholesky decomposition; `mth = 'LANC'` for KSP-based method. integer , intent ( in ), optional :: f !! For KSP-based method, maximum number of iterations. !! Must be present if `mth = 'LANC'`. `f` must be less than `n`. real ( rp ), intent ( in ), optional :: e !! For KSP-based method, error threshold for convergence. !! Must be present if `mth = 'LANC'`. sizm = n ; s = nblks ; meth = mth if ( meth == 'CHOL' ) then !Nothing to do here. else if ( meth == 'LANC' ) then dimk_max = max ( dimk_min , f ) + 1 !Adding 1 to ensure dimk_max > dimk_min ethres = e allocate ( bdw_old ( sizm , s ) ) allocate ( lncv ( sizm , s * dimk_max ) ) allocate ( eigvlh ( s * dimk_max ) ) allocate ( eigvch ( s * dimk_max , s * dimk_max ) ) allocate ( w ( sizm , s )) allocate ( tmp ( s * dimk_max , 2 * s )) if ( s == 1 ) then allocate ( h_d ( dimk_max ) ) allocate ( h_sd ( dimk_max ) ) else allocate ( tau ( s )) allocate ( matr ( s , s )) allocate ( h_bd ( s , s * dimk_max ) ) allocate ( h_bsd ( s , s * dimk_max ) ) allocate ( h_bnd ( 2 * s , s * dimk_max )) end if end if end subroutine !******************************************************************************* subroutine brn_finish () !! Performs cleanup. if ( allocated ( bdw_old )) deallocate ( bdw_old ) if ( allocated ( lncv )) deallocate ( lncv ) if ( allocated ( eigvlh )) deallocate ( eigvlh ) if ( allocated ( eigvch )) deallocate ( eigvch ) if ( allocated ( w )) deallocate ( w ) if ( allocated ( tmp )) deallocate ( tmp ) if ( allocated ( h_d )) deallocate ( h_d ) if ( allocated ( h_sd )) deallocate ( h_sd ) if ( allocated ( tau )) deallocate ( tau ) if ( allocated ( matr )) deallocate ( matr ) if ( allocated ( h_bd )) deallocate ( h_bd ) if ( allocated ( h_bsd )) deallocate ( h_bsd ) if ( allocated ( h_bnd )) deallocate ( h_bnd ) if ( allocated ( work )) deallocate ( work ) if ( allocated ( iwork )) deallocate ( iwork ) end subroutine !******************************************************************************* subroutine brn_calc_bdw ( mob , bdw , ierr , lconv , f ) !! Main driver routine for calculating **B**._d_**W**. real ( rp ), dimension (:,:), intent ( in out ) :: mob !! (`sizm`,`sizm`) symmetric positive definite matrix. !! On _entry_, contains the mobility matrix.  On _return_, if `meth = 'CHOL'`, !! the upper triangular part is overwritten with the result of Cholesky !! decomposition.  The strictly lower triangular part is left intact. real ( rp ), dimension (:,:), intent ( in out ) :: bdw !! (`sizm`,`s`) matrix. !! On _entry_, contains `s` column vectors drawn from standard normal !! distribution. On _return_, the `s` columns are overwritten with the !! result of **B**.d**W**. integer , intent ( out ) :: ierr !! Error flag. logical , intent ( out ), optional :: lconv !! If `meth = 'LANC'`, returns *true* if converged, *false* otherwise. integer , intent ( out ), optional :: f !! If `meth = 'LANC'`, the number of iterations performed. integer :: f_ logical :: lconv_ if ( meth == 'CHOL' ) then call calc_bdw_cholesky ( mob , bdw , ierr ) else if ( meth == 'LANC' ) then if ( s == 1 ) then call calc_bdw_lanc ( mob , bdw , lconv_ , f_ , ierr ) else call calc_bdw_blanc ( mob , bdw , lconv_ , f_ , ierr ) end if end if if ( present ( lconv )) lconv = lconv_ if ( present ( f )) f = f_ end subroutine !******************************************************************************* subroutine calc_bdw_lanc ( mob , bdw , lconv , f , ierr ) !! Implements Lanczos algorithm for calculating **B**._d_**W**. real ( rp ), dimension (:,:), intent ( in ) :: mob !! (`sizm`,`sizm`) symmetric positive definite matrix. real ( rp ), dimension (:,:), intent ( in out ) :: bdw !! (`sizm`,1) array. !! On _entry_, contains a vector drawn from standard normal !! distribution. On _return_, is overwritten with the result of !! **B**._d_**W**. logical , intent ( out ) :: lconv !! Returns *true* if converged, *false* otherwise. integer , intent ( out ) :: f !! The number of iterations performed. integer , intent ( out ) :: ierr !! Error flag. integer :: j , info , lwork , liwork real ( rp ), dimension ( 1 ) :: qwork !Size 1 array for workspace query. integer , dimension ( 1 ) :: qiwork !Size 1 array for workspace query. real ( rp ) :: normz , err character ( len = 256 ) :: msg lconv = . false .; ierr = 0 ; f = 0 lncv = 0.0_rp ; h_d = 0.0_rp ; h_sd = 0.0_rp eigvlh = 0.0_rp ; eigvch = 0.0_rp w = 0.0_rp ; tmp = 0.0_rp ; bdw_old = 0.0_rp !Workspace query if ((. not . allocated ( work )) . or . (. not . allocated ( iwork ))) then call dstevd ( 'V' , dimk_max , eigvlh , tmp ( 1 : dimk_max , 1 ), eigvch , dimk_max , & qwork , - 1 , qiwork , - 1 , info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_lanc> dstevd err = ' , info , & ' on workspace query' call logger % log_msg ( msg ) ierr = 1 ; return end if lwork = int ( qwork ( 1 )); liwork = qiwork ( 1 ) allocate ( work ( lwork ) ); allocate ( iwork ( liwork ) ) end if !Lanczos process normz = norm2 ( bdw (:, 1 )) lncv (:, 1 ) = bdw (:, 1 ) / normz do j = 1 , dimk_max f = f + 1 !Iteration count call dsymv ( 'L' , sizm , 1.0_rp , mob , sizm , lncv (:, j ), 1 , 0.0_rp , w (:, 1 ), 1 ) if ( j > 1 ) then w (:, 1 ) = w (:, 1 ) - h_sd ( j - 1 ) * lncv (:, j - 1 ) end if h_d ( j ) = dot_product ( w (:, 1 ), lncv (:, j )) if ( j < dimk_max ) then w (:, 1 ) = w (:, 1 ) - h_d ( j ) * lncv (:, j ) h_sd ( j ) = norm2 ( w (:, 1 )) lncv (:, j + 1 ) = w (:, 1 ) / h_sd ( j ) end if !Calculate B.dW and check for convergence if ( j >= dimk_min ) then eigvlh ( 1 : j ) = h_d ( 1 : j ) tmp ( 1 : j , 1 ) = h_sd ( 1 : j ) !Eigen decomposition of H = P * d * P&#94;T !eigvlh[1:j] <- d; eigvch[1:j,1:j] <- P call dstevd ( 'V' , j , eigvlh ( 1 : j ), tmp ( 1 : j , 1 ), eigvch , dimk_max , & work , size ( work ), iwork , size ( iwork ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a,i0)' ) '<calc_bdw_lanc> dstevd err = ' , info , & ' on iteration ' , j call logger % log_msg ( msg ) ierr = 1 ; return end if !eigvlh(1:j) <- d&#94;(1/2) eigvlh ( 1 : j ) = sqrt ( eigvlh ( 1 : j )) !tmp[1:j,1] <- d&#94;(1/2) * P&#94;T * e_1, where e_1 if the first column of !an identity matrix of size j. tmp ( 1 : j , 1 ) = eigvch ( 1 , 1 : j ) tmp ( 1 : j , 1 ) = eigvlh ( 1 : j ) * tmp ( 1 : j , 1 ) !tmp[1:j,2] <- P * tmp[1:j,1] call dgemv ( 'N' , j , j , 1.0_rp , eigvch , dimk_max , tmp ( 1 : j , 1 ), 1 , & 0.0_rp , tmp ( 1 : j , 2 ), 1 ) !bdw <- normz * lncv[:,1:j] * tmp[1:j,2] call dgemv ( 'N' , sizm , j , normz , lncv , sizm , tmp ( 1 : j , 2 ), 1 , & 0.0_rp , bdw , 1 ) !Error calculation for j > dimk_min. For j = dimk_min just save !bdw for error calculation in the next iteration. if ( j > dimk_min ) then err = norm2 ( bdw (:, 1 ) - bdw_old (:, 1 )) / norm2 ( bdw_old (:, 1 )) if ( err <= ethres ) then lconv = . true .; exit end if end if bdw_old = bdw end if end do end subroutine !******************************************************************************* subroutine calc_bdw_blanc ( mob , bdw , lconv , f , ierr ) !! Implements block Lanczos algorithm for calculating **B**._d_**W**. real ( rp ), dimension (:,:), intent ( in ) :: mob !! (`sizm`,`sizm`) symmetric positive definite matrix. real ( rp ), dimension (:,:), intent ( in out ) :: bdw !! (`sizm`,`s`) matrix. !! On _entry_, contains `s` column vectors drawn from standard normal !! distribution. On _return_, the `s` columns are overwritten with the !! result of **B**._d_**W**. logical , intent ( out ) :: lconv !! Returns *true* if converged, *false* otherwise. integer , intent ( out ) :: f !! The number of iterations performed. integer , intent ( out ) :: ierr !! Error flag. real ( rp ) :: err integer :: j , jb , irow , jcol integer :: jgbeg , jgend , igbeg , ig , jg integer :: info , lwork , liwork real ( rp ), dimension ( 1 ) :: qwork integer , dimension ( 1 ) :: qiwork character ( len = 256 ) :: msg lconv = . false .; ierr = 0 ; f = 0 lncv = 0.0_rp ; h_bd = 0.0_rp ; h_bsd = 0.0_rp eigvlh = 0.0_rp ; eigvch = 0.0_rp w = 0.0_rp ; tmp = 0.0_rp ; bdw_old = 0.0_rp tau = 0.0_rp ; matr = 0.0_rp ; h_bnd = 0.0_rp !Workspace query if (. not . allocated ( work )) then call dgeqp3 ( sizm , s , bdw , sizm , qiwork , tau , qwork , - 1 , info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_blanc> dgeqp3 err = ' , info , & ' on workspace query' call logger % log_msg ( msg ) ierr = 1 ; return end if lwork = int ( qwork ( 1 ) ) call dorgqr ( sizm , s , s , bdw , sizm , tau , qwork , - 1 , info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_blanc> dorgqr err = ' , info , & ' on workspace query' call logger % log_msg ( msg ) ierr = 1 ; return end if lwork = max ( lwork , int ( qwork ( 1 )) ) call dsbevd ( 'V' , 'L' , dimk_max * s , 2 * s - 1 , h_bnd , 2 * s , & eigvlh , eigvch , s * dimk_max , qwork , - 1 , qiwork , - 1 , info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_blanc> dsbevd err = ' , info , & ' on workspace query' call logger % log_msg ( msg ) ierr = 1 ; return end if lwork = max ( lwork , int ( qwork ( 1 )) ) liwork = qiwork ( 1 ) allocate ( work ( lwork )); allocate ( iwork ( liwork )) end if !Lanczos process !Reduced QR factorization of bdw with pivoting. The results overwrite bdw. iwork = 0 ; qwork = 0.0_rp call dgeqp3 ( sizm , s , bdw , sizm , iwork , tau , work , size ( work ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_blanc> dgeqp3 err = ' , info , & ' on iteration 0' call logger % log_msg ( msg ) ierr = 1 ; return end if !Extract the (s,s) permuted upper triangular matrix R and store it in matr. do jcol = 1 , s matr ( 1 : jcol , iwork ( jcol )) = bdw ( 1 : jcol , jcol ) end do !Extract the (sizm,s) matrix Q and store it in lncv[:,1:s]. call dorgqr ( sizm , s , s , bdw , sizm , tau , work , size ( work ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_blanc> dorgqr err = ' , info , & ' on iteration 0' call logger % log_msg ( msg ) ierr = 1 ; return end if lncv (:, 1 : s ) = bdw do j = 1 , dimk_max f = f + 1 !Iteration count !W <- mob * V_j jgbeg = ( j - 1 ) * s + 1 ; jgend = j * s call dsymm ( 'L' , 'L' , sizm , s , 1.0_rp , mob , sizm , & lncv (:, jgbeg : jgend ), sizm , 0.0_rp , w , sizm ) if ( j > 1 ) then !W -> W - V_(j-1) * H_(j-1,j) !   = W - V_(j-1) * H_(j,j-1)&#94;T, using the subdiagonal block jgbeg = ( j - 2 ) * s + 1 ; jgend = ( j - 1 ) * s call dgemm ( 'N' , 'T' , sizm , s , s , - 1.0_rp , lncv (:, jgbeg : jgend ), sizm , & h_bsd (:, jgbeg : jgend ), s , 1.0_rp , w , sizm ) end if !H_(j,j) <- V_j&#94;T * W jgbeg = ( j - 1 ) * s + 1 ; jgend = j * s call dgemm ( 'T' , 'N' , s , s , sizm , 1.0_rp , lncv (:, jgbeg : jgend ), sizm , & w , sizm , 0.0_rp , h_bd (:, jgbeg : jgend ), s ) if ( j < dimk_max ) then !W -> W - V_(j) * H_(j,j) !Note: H_(j,j) is symmetric. jgbeg = ( j - 1 ) * s + 1 ; jgend = j * s call dsymm ( 'R' , 'L' , sizm , s , - 1.0_rp , h_bd (:, jgbeg : jgend ), & s , lncv (:, jgbeg : jgend ), sizm , 1.0_rp , w , sizm ) !Reduced QR factorization of w. iwork = 0 call dgeqp3 ( sizm , s , w , sizm , iwork , tau , work , size ( work ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a,i0)' ) '<calc_bdw_blanc> dgeqp3 err = ' , info , & ' on iteration ' , j call logger % log_msg ( msg ) ierr = 1 ; return end if !Extract the (s,s) permuted upper triangular matrix R and store !it in H_(j+1,j). do jcol = 1 , s h_bsd ( 1 : jcol , ( j - 1 ) * s + iwork ( jcol )) = w ( 1 : jcol , jcol ) end do !Extract the (sizm,s) matrix Q and store it in V_(j+1). call dorgqr ( sizm , s , s , w , sizm , tau , work , size ( work ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a,i0)' ) '<calc_bdw_blanc> dorgqr err = ' , info , & ' on iteration ' , j call logger % log_msg ( msg ) ierr = 1 ; return end if jgbeg = j * s + 1 ; jgend = ( j + 1 ) * s lncv (:, jgbeg : jgend ) = w end if !Calculate B.dW and check for convergence if ( j >= dimk_min ) then jgbeg = ( j - 1 ) * s + 1 ; jgend = j * s !Create matrix H in band storage format, in preparation for eigen !decomposition with symmetric band matrix routine. h_bnd = 0.0_rp do jb = 1 , j jgbeg = ( jb - 1 ) * s ; igbeg = jgbeg do jcol = 1 , s jg = jgbeg + jcol do irow = jcol , s ig = igbeg + irow h_bnd ( ig - jg + 1 , jg ) = h_bd ( irow , jg ) end do end do end do do jb = 1 , ( j - 1 ) jgbeg = ( jb - 1 ) * s ; igbeg = jb * s do jcol = 1 , s jg = jgbeg + jcol do irow = 1 , s ig = igbeg + irow h_bnd ( ig - jg + 1 , jg ) = h_bsd ( irow , jg ) end do end do end do !Eigen decomposition of H = P * d * P&#94;T !eigvlh <- d; eigvch <- P call dsbevd ( 'V' , 'L' , j * s , 2 * s - 1 , h_bnd (:, 1 : j * s ), 2 * s , eigvlh , & eigvch , s * dimk_max , work , size ( work ), iwork , & size ( iwork ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a,i0)' ) '<calc_bdw_blanc> dsbevd err = ' , info , & ' on iteration ' , j call logger % log_msg ( msg ) ierr = 1 ; return end if !Square root of the eigen values eigvlh ( 1 : j * s ) = sqrt ( eigvlh ( 1 : j * s )) !tmp[1:j*s,1:s] <- eigvch[1:s,1:j*s]&#94;T * matr call dgemm ( 'T' , 'N' , j * s , s , s , 1.0_rp , eigvch , s * dimk_max , & matr , s , 0.0_rp , tmp (:, 1 : s ), s * dimk_max ) !tmp[1:j*s,1:s] <- eigvlh[1:j*s] * tmp[1:j*s,1:s] do jcol = 1 , s tmp ( 1 : j * s , jcol ) = eigvlh ( 1 : j * s ) * tmp ( 1 : j * s , jcol ) end do !tmp[1:j*s,s+1:2*s] <- eigvch[1:j*s,1:j*s] * tmp[1:j*s,1:s] call dgemm ( 'N' , 'N' , j * s , s , j * s , 1.0_rp , eigvch , s * dimk_max , & tmp (:, 1 : s ), s * dimk_max , 0.0_rp , tmp (:, s + 1 : 2 * s ), s * dimk_max ) !bdw <- lncv[:,1:j*s] * tmp[1:j*s,s+1:2*s] call dgemm ( 'N' , 'N' , sizm , s , j * s , 1.0_rp , lncv , sizm , & tmp (:, s + 1 : 2 * s ), s * dimk_max , 0.0_rp , bdw , sizm ) !Error calculation for j > dimk_min. For j == dimk_min just save !bdw for error calculation in the next iteration. Using 1-norm as !the matrix norm here. if ( j > dimk_min ) then err = maxval ( sum ( abs ( bdw - bdw_old ), 1 )) & / maxval ( sum ( abs ( bdw_old ), 1 )) if ( err <= ethres ) then lconv = . true .; f = j exit end if end if bdw_old = bdw end if end do end subroutine !****************************************************************************** subroutine calc_bdw_cholesky ( mob , bdw , ierr ) !! Calculates **B**._d_**W** using Cholesky decomposition. real ( rp ), dimension (:,:), intent ( in out ) :: mob !! (`sizm`,`sizm`) symmetric positive definite matrix. !! On _entry_, contains the mobility matrix.  On _return_, !! the upper triangular part is overwritten with the result of Cholesky !! decomposition.  The strictly lower triangular part is left intact. real ( rp ), dimension (:,:), intent ( in out ) :: bdw !! (`sizm`,`s`) matrix. !! On _entry_, contains `s` column vectors drawn from standard normal !! distribution. On _return_, the `s` columns are overwritten with the !! result of **B**._d_**W**. integer , intent ( out ) :: ierr !! Error flag. integer :: info character ( len = 256 ) :: msg ierr = 0 !Cholesky decomposition: mob = U&#94;T * U. The upper triangular part of mob is !overwritten with U. The strictly lower triangular part of mob is not !accessed. call dpotrf ( 'U' , sizm , mob , sizm , info ) if ( info /= 0 ) then write ( msg , '(a,i0)' ) '<calc_bdw_cholesky> dpotrf err = ' , info call logger % log_msg ( msg ) ierr = 1 ; return end if !Product of U (stored in the upper triangular part of mob) with each of the !random vectors: bdw = U*bdw if ( s == 1 ) then call dtrmv ( 'U' , 'N' , 'N' , sizm , mob , sizm , bdw (:, 1 ), 1 ) else call dtrmm ( 'L' , 'U' , 'N' , 'N' , sizm , s , 1.0_rp , mob , sizm , bdw , sizm ) end if end subroutine !******************************************************************************* subroutine brn_calc_dw ( dw ) !! Calculates standard normally distributed random vectors. real ( rp ), dimension (:,:), target , intent ( out ) :: dw !! (`n`,`m`) array. real ( rp ), dimension (:), pointer :: vec_dw type ( c_ptr ) :: loc_dw integer :: n , m n = size ( dw , 1 ); m = size ( dw , 2 ) dw = 0.0_rp loc_dw = c_loc ( dw ) call c_f_pointer ( loc_dw , vec_dw , [ n * m ]) call get_rv_gaussian ( 0.0_rp , 1.0_rp , vec_dw , 1000000 ) end subroutine !******************************************************************************* subroutine calc_bdw_lanc_sor ( mob , bdw , lconv , f , ierr ) real ( rp ), dimension (:,:), intent ( in ) :: mob !! (`sizm`,`sizm`) symmetric positive definite matrix. real ( rp ), dimension (:,:), intent ( in out ) :: bdw !! (`sizm`,1) array. !! On _entry_, contains a vector drawn from standard normal !! distribution. On _return_, is overwritten with the result of !! **B**.d**W**. logical , intent ( out ) :: lconv !! Returns *true* if converged, *false* otherwise. integer , intent ( out ) :: f !! The number of iterations performed. integer , intent ( out ) :: ierr !! Error flag. integer :: j , info , lwork , liwork , k real ( rp ), dimension ( 1 ) :: qwork !Size 1 array for workspace query. integer , dimension ( 1 ) :: qiwork !Size 1 array for workspace query. real ( rp ), dimension ( dimk_max ) :: errbnd real ( rp ), dimension ( sizm ) :: ritzv real ( rp ) :: normz , err , normm character ( len = 256 ) :: msg lconv = . false .; ierr = 0 ; f = 0 tmp = 0.0_rp ; eigvlh = 0.0_rp ; eigvch = 0.0_rp h_d = 0.0_rp ; h_sd = 0.0_rp bdw_old = 0.0_rp ; lncv = 0.0_rp ; w = 0.0_rp !Workspace query if ((. not . allocated ( work )) . or . (. not . allocated ( iwork ))) then call dstevd ( 'V' , dimk_max , eigvlh , tmp ( 1 : dimk_max , 1 ), eigvch , dimk_max , & qwork , - 1 , qiwork , - 1 , info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_lanc_sor> dstevd err = ' , info , & ' on workspace query' call logger % log_msg ( msg ) ierr = 1 ; return end if lwork = int ( qwork ( 1 )); liwork = qiwork ( 1 ) allocate ( work ( lwork ) ); allocate ( iwork ( liwork ) ) end if !Lanczos process normz = norm2 ( bdw (:, 1 )) normm = maxval ( sum ( abs ( mob ), 1 )) lncv (:, 1 ) = bdw (:, 1 ) / normz do j = 1 , dimk_max f = f + 1 !Iteration count call dsymv ( 'L' , sizm , 1.0_rp , mob , sizm , lncv (:, j ), 1 , 0.0_rp , w (:, 1 ), 1 ) if ( j > 1 ) then w (:, 1 ) = w (:, 1 ) - h_sd ( j - 1 ) * lncv (:, j - 1 ) end if h_d ( j ) = dot_product ( w (:, 1 ), lncv (:, j )) if ( j < dimk_max ) then w (:, 1 ) = w (:, 1 ) - h_d ( j ) * lncv (:, j ) do k = 1 , j if ( errbnd ( k ) < sqrt ( epsilon ( 1.0_rp ) * normm )) then call dgemv ( 'N' , sizm , j , 1.0_rp , lncv , sizm , eigvch (:, k ), 1 , & 0.0_rp , ritzv , 1 ) w (:, 1 ) = w (:, 1 ) - dot_product ( ritzv , w (:, 1 )) * ritzv end if end do h_sd ( j ) = norm2 ( w (:, 1 )) lncv (:, j + 1 ) = w (:, 1 ) / h_sd ( j ) end if !Compute eigenvalues, eigenvectors and error bounds for H if ( j > 1 ) then eigvlh ( 1 : j ) = h_d ( 1 : j ) tmp ( 1 : j , 1 ) = h_sd ( 1 : j ) !Eigen decomposition of H = P * d * P&#94;T !eigvlh[1:j] <- d; eigvch[1:j,1:j] <- P call dstevd ( 'V' , j , eigvlh ( 1 : j ), tmp ( 1 : j , 1 ), eigvch , dimk_max , & work , size ( work ), iwork , size ( iwork ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a,i0)' ) '<calc_bdw_lanc_sor> dstevd err = ' , info , & ' on iteration ' , j call logger % log_msg ( msg ) ierr = 1 ; return end if errbnd ( 1 : j ) = abs ( h_sd ( j )) * eigvch ( j , 1 : j ) end if !Calculate B.dW and check for convergence if ( j >= dimk_min ) then !eigvlh(1:j) <- d&#94;(1/2) eigvlh ( 1 : j ) = sqrt ( eigvlh ( 1 : j )) !tmp[1:j,1] <- d&#94;(1/2) * P&#94;T * e_1, where e_1 if the first column of !an identity matrix of size j. tmp ( 1 : j , 1 ) = eigvch ( 1 , 1 : j ) tmp ( 1 : j , 1 ) = eigvlh ( 1 : j ) * tmp ( 1 : j , 1 ) !tmp[1:j,2] <- P * tmp[1:j,1] call dgemv ( 'N' , j , j , 1.0_rp , eigvch , dimk_max , tmp ( 1 : j , 1 ), 1 , & 0.0_rp , tmp ( 1 : j , 2 ), 1 ) !bdw <- normz * lncv[:,1:j] * tmp[1:j,2] call dgemv ( 'N' , sizm , j , normz , lncv , sizm , tmp ( 1 : j , 2 ), 1 , & 0.0_rp , bdw , 1 ) !Error calculation for j > dimk_min. For j = dimk_min just save !bdw for error calculation in the next iteration. if ( j > dimk_min ) then err = norm2 ( bdw (:, 1 ) - bdw_old (:, 1 )) / norm2 ( bdw_old (:, 1 )) !write(*,*) j, 'err = ', err if ( err <= ethres ) then lconv = . true . exit end if end if bdw_old = bdw end if end do end subroutine !******************************************************************************* end module brown_m","tags":"","loc":"sourcefile/brown_m.f90.html"},{"title":"random_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~random_m.f90~~EfferentGraph sourcefile~random_m.f90 random_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~random_m.f90~~AfferentGraph sourcefile~random_m.f90 random_m.f90 sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~simbox_m.f90->sourcefile~random_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~random_m.f90 sourcefile~setup_m.f90->sourcefile~simbox_m.f90 sourcefile~config_io_m.f90 config_io_m.f90 sourcefile~setup_m.f90->sourcefile~config_io_m.f90 sourcefile~stats_m.f90 stats_m.f90 sourcefile~setup_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~brown_m.f90 brown_m.f90 sourcefile~brown_m.f90->sourcefile~random_m.f90 sourcefile~config_io_m.f90->sourcefile~simbox_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~pairtab_m.fpp->sourcefile~simbox_m.f90 sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~pairtab_m.fpp->sourcefile~cell_list_m.f90 sourcefile~stats_m.f90->sourcefile~simbox_m.f90 sourcefile~bd_solver_m.f90->sourcefile~brown_m.f90 sourcefile~bd_solver_m.f90->sourcefile~config_io_m.f90 sourcefile~bd_solver_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~cell_list_m.f90->sourcefile~simbox_m.f90 sourcefile~interaction_m.f90->sourcefile~simbox_m.f90 sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~interaction_m.f90->sourcefile~stats_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules random_m Source Code random_m.f90 Source Code !********************************************************************************! ! The MIT License (MIT)                                                          ! !                                                                                ! ! Copyright (c) 2020 Sarit Dutta <saridut@gmail.com>                             ! !                                                                                ! ! Permission is hereby granted, free of charge, to any person obtaining a copy   ! ! of this software and associated documentation files (the \"Software\"), to deal  ! ! in the Software without restriction, including without limitation the rights   ! ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      ! ! copies of the Software, and to permit persons to whom the Software is          ! ! furnished to do so, subject to the following conditions:                       ! !                                                                                ! ! The above copyright notice and this permission notice shall be included in all ! ! copies or substantial portions of the Software.                                ! !                                                                                ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     ! ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       ! ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    ! ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         ! ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  ! ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  ! ! SOFTWARE.                                                                      ! !********************************************************************************! module random_m !!  Provides random number generation procedures, mostly calling !! routine from Intel MKL VSL. use constants_m use mkl_vsl_type use mkl_vsl implicit none private public :: & init_stream , & delete_stream , & load_stream , & save_stream , & save_seed , & get_iuniform , & get_rv_iuniform , & get_uniform , & get_rv_uniform , & get_rv_gaussian , & ransphere integer ( ip ), save :: seed type ( VSL_STREAM_STATE ), save :: stream contains !******************************************************************* subroutine init_stream ( fn ) !! Initializes a BRNG stream. !! The stream is initialized with a seed from the file `fn`. If !! `fn` is an empty string, the seed is obtained from `/dev/urandom`. character ( len =* ) :: fn !! Name of the file containing the RNG seed. integer ( ip ) :: fu integer ( ip ) :: stat if ( len_trim ( fn ) == 0 ) then open ( newunit = fu , file = '/dev/urandom' , action = 'read' , & form = 'unformatted' , access = 'stream' , status = 'old' ) read ( fu ) seed close ( fu ) seed = abs ( seed ) else open ( newunit = fu , file = fn , action = 'read' , status = 'old' ) read ( fu , * ) seed close ( fu ) end if stat = vslNewStream ( stream , VSL_BRNG_MT19937 , seed ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslNewStream' end if end subroutine !******************************************************************* subroutine delete_stream () !! Deletes a BRNG stream. integer ( ip ) :: stat stat = vslDeleteStream ( stream ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslDeleteStream' end if end subroutine !******************************************************************* subroutine load_stream ( fn ) !! Loads a BRNG stream from file `fn`. character ( len =* ), intent ( in ) :: fn integer ( ip ) :: stat stat = vslLoadStreamF ( stream , fn ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslLoadStream' end if end subroutine !******************************************************************* subroutine save_seed ( fn ) !! Saves the RNG seed to file `fn`. character ( len =* ), intent ( in ) :: fn integer ( ip ) :: fu open ( newunit = fu , file = fn , action = 'write' , status = 'replace' ) write ( fu , * ) seed close ( fu ) end subroutine !******************************************************************* subroutine save_stream ( fn ) !! Saves a BRNG stream to file `fn`. character ( len =* ), intent ( in ) :: fn integer ( ip ) :: stat stat = vslSaveStreamF ( stream , fn ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslSaveStream' end if end subroutine !******************************************************************* function get_uniform ( lb , ub ) result ( res ) !! Returns a random number from a uniform distribution. real ( rp ), intent ( in ) :: lb !! Lower bound real ( rp ), intent ( in ) :: ub !! Upper bound real ( rp ) :: res real ( rp ), dimension ( 1 ) :: rv integer ( ip ) :: stat stat = vdrnguniform ( VSL_RNG_METHOD_UNIFORM_STD_ACCURATE , stream , & 1 , rv , lb , ub ) res = rv ( 1 ) end function !******************************************************************* subroutine get_rv_uniform ( lb , ub , rv , block_size ) !! Returns a random vector from a uniform distribution. !! If a `block_size > 0` is provided, it fills `rv` in blocks of !! size `block_size`. real ( rp ), intent ( in ) :: lb !! Lower bound real ( rp ), intent ( in ) :: ub !! Upper bound real ( rp ), dimension (:), intent ( out ) :: rv integer ( ip ), intent ( in ), optional :: block_size integer ( ip ) :: stat integer ( ip ) :: num_blocks integer ( ip ) :: size_rv integer ( ip ) :: ini integer ( ip ) :: fin integer ( ip ) :: n if (. not . present ( block_size )) then stat = vdrnguniform ( VSL_RNG_METHOD_UNIFORM_STD_ACCURATE , stream , & size ( rv ), rv , lb , ub ) else size_rv = size ( rv ) num_blocks = ceiling ( size_rv / real ( block_size )) ini = 0 fin = 0 do if ( fin >= size_rv ) then exit end if if ( size_rv <= block_size ) then n = size_rv else if (( size_rv - fin ) < block_size ) then n = size_rv - fin else n = block_size end if ini = fin + 1 fin = fin + n stat = vdrnguniform ( VSL_RNG_METHOD_UNIFORM_STD_ACCURATE , stream , & n , rv ( ini : fin ), lb , ub ) end do end if end subroutine !******************************************************************* function get_iuniform ( lb , ub ) result ( res ) !! Returns a random integer from a uniform distribution. integer ( ip ), intent ( in ) :: lb integer ( ip ), intent ( in ) :: ub integer ( ip ) :: res integer ( ip ), dimension ( 1 ) :: rv integer ( ip ) :: stat stat = virnguniform ( VSL_RNG_METHOD_UNIFORM_STD , stream , & 1 , rv , lb , ub ) res = rv ( 1 ) end function !******************************************************************* subroutine get_rv_iuniform ( lb , ub , rv , block_size ) !! Returns a random vector of integers from a uniform distribution. integer ( ip ), intent ( in ) :: lb integer ( ip ), intent ( in ) :: ub integer ( ip ), dimension (:), intent ( out ) :: rv integer ( ip ), intent ( in ), optional :: block_size integer ( ip ) :: stat integer ( ip ) :: num_blocks integer ( ip ) :: size_rv integer ( ip ) :: ini integer ( ip ) :: fin integer ( ip ) :: n if (. not . present ( block_size )) then stat = virnguniform ( VSL_RNG_METHOD_UNIFORM_STD , stream , & size ( rv ), rv , lb , ub ) else size_rv = size ( rv ) num_blocks = ceiling ( size_rv / real ( block_size )) ini = 0 fin = 0 do if ( fin >= size_rv ) then exit end if if ( size_rv <= block_size ) then n = size_rv else if (( size_rv - fin ) < block_size ) then n = size_rv - fin else n = block_size end if ini = fin + 1 fin = fin + n stat = virnguniform ( VSL_RNG_METHOD_UNIFORM_STD , stream , & n , rv ( ini : fin ), lb , ub ) end do end if end subroutine !******************************************************************* subroutine get_rv_gaussian ( mean , std_dev , rv , block_size ) !! Generates a random vector of integers from a gaussian distribution. real ( rp ), intent ( in ) :: mean real ( rp ), intent ( in ) :: std_dev real ( rp ), dimension (:), intent ( out ) :: rv integer ( ip ), intent ( in ), optional :: block_size integer ( ip ) :: stat integer ( ip ) :: num_blocks integer ( ip ) :: size_rv integer ( ip ) :: ini integer ( ip ) :: fin integer ( ip ) :: n if (. not . present ( block_size )) then stat = vdrnggaussian ( VSL_RNG_METHOD_GAUSSIAN_BOXMULLER , stream , & size ( rv ), rv , mean , std_dev ) else size_rv = size ( rv ) num_blocks = ceiling ( size_rv / real ( block_size )) ini = 0 fin = 0 do if ( fin >= size_rv ) then exit end if if ( size_rv <= block_size ) then n = size_rv else if (( size_rv - fin ) < block_size ) then n = size_rv - fin else n = block_size end if ini = fin + 1 fin = fin + n stat = vdrnggaussian ( VSL_RNG_METHOD_GAUSSIAN_BOXMULLER , stream , & n , rv ( ini : fin ), mean , std_dev ) end do end if end subroutine !******************************************************************* subroutine ransphere ( r ) !! Generates a random vector from the surface of a unit sphere. !! !! Algorithm from Allen & Tildesley (ed 1) p. 349. real ( rp ), dimension ( 3 ), intent ( out ) :: r ( 3 ) real ( rp ), dimension ( 2 ) :: zeta real ( rp ) :: zetasq real ( rp ) :: rt r = 0.0_rp zetasq = 2.0_rp ! Any value greater than 1 do call get_rv_uniform ( - 1.0_rp , 1.0_rp , zeta ) zetasq = zeta ( 1 ) * zeta ( 1 ) + zeta ( 2 ) * zeta ( 2 ) rt = sqrt ( 1.0_rp - zetasq ) r ( 1 ) = 2.0_rp * zeta ( 1 ) * rt r ( 2 ) = 2.0_rp * zeta ( 2 ) * rt r ( 3 ) = 1.0_rp - 2.0_rp * zetasq if ( zetasq <= 1.0_rp ) exit end do end subroutine !******************************************************************* end module random_m","tags":"","loc":"sourcefile/random_m.f90.html"},{"title":"constants_m.f90 – BROWNPAK","text":"Files dependent on this one sourcefile~~constants_m.f90~~AfferentGraph sourcefile~constants_m.f90 constants_m.f90 sourcefile~config_io_m.f90 config_io_m.f90 sourcefile~config_io_m.f90->sourcefile~constants_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~config_io_m.f90->sourcefile~atmcfg_m.f90 sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~config_io_m.f90->sourcefile~simbox_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~config_io_m.f90->sourcefile~strings_m.f90 sourcefile~stats_m.f90 stats_m.f90 sourcefile~stats_m.f90->sourcefile~constants_m.f90 sourcefile~stats_m.f90->sourcefile~atmcfg_m.f90 sourcefile~stats_m.f90->sourcefile~simbox_m.f90 sourcefile~control_m.f90 control_m.f90 sourcefile~stats_m.f90->sourcefile~control_m.f90 sourcefile~stats_m.f90->sourcefile~strings_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~constants_m.f90 sourcefile~bd_solver_m.f90->sourcefile~config_io_m.f90 sourcefile~bd_solver_m.f90->sourcefile~stats_m.f90 sourcefile~trajectory_m.f90 trajectory_m.f90 sourcefile~bd_solver_m.f90->sourcefile~trajectory_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~brown_m.f90 brown_m.f90 sourcefile~bd_solver_m.f90->sourcefile~brown_m.f90 sourcefile~bd_solver_m.f90->sourcefile~atmcfg_m.f90 sourcefile~bd_solver_m.f90->sourcefile~control_m.f90 sourcefile~trajectory_m.f90->sourcefile~constants_m.f90 sourcefile~ia_external_m.f90 ia_external_m.f90 sourcefile~ia_external_m.f90->sourcefile~constants_m.f90 sourcefile~ia_external_m.f90->sourcefile~atmcfg_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 sourcefile~ia_angle_m.f90 ia_angle_m.f90 sourcefile~ia_angle_m.f90->sourcefile~constants_m.f90 sourcefile~ia_angle_m.f90->sourcefile~atmcfg_m.f90 sourcefile~interaction_m.f90->sourcefile~constants_m.f90 sourcefile~interaction_m.f90->sourcefile~stats_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_external_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_angle_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~ia_vdw_m.f90 ia_vdw_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_vdw_m.f90 sourcefile~table_m.f90 table_m.f90 sourcefile~interaction_m.f90->sourcefile~table_m.f90 sourcefile~interaction_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_dihedral_m.f90 ia_dihedral_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_dihedral_m.f90 sourcefile~interaction_m.f90->sourcefile~simbox_m.f90 sourcefile~interaction_m.f90->sourcefile~control_m.f90 sourcefile~ia_tether_m.f90 ia_tether_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_tether_m.f90 sourcefile~ia_bond_m.f90 ia_bond_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_bond_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~constants_m.f90 sourcefile~main.f90->sourcefile~control_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~main.f90->sourcefile~setup_m.f90 sourcefile~main.f90->sourcefile~strings_m.f90 sourcefile~pairtab_m.fpp->sourcefile~constants_m.f90 sourcefile~connectivity_m.f90 connectivity_m.f90 sourcefile~pairtab_m.fpp->sourcefile~connectivity_m.f90 sourcefile~pairtab_m.fpp->sourcefile~table_m.f90 sourcefile~pairtab_m.fpp->sourcefile~atmcfg_m.f90 sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~simbox_m.f90 sourcefile~vector_m.f90 vector_m.f90 sourcefile~pairtab_m.fpp->sourcefile~vector_m.f90 sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~pairtab_m.fpp->sourcefile~cell_list_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~constants_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~atmcfg_m.f90 sourcefile~connectivity_m.f90->sourcefile~constants_m.f90 sourcefile~connectivity_m.f90->sourcefile~table_m.f90 sourcefile~connectivity_m.f90->sourcefile~vector_m.f90 sourcefile~table_m.f90->sourcefile~constants_m.f90 sourcefile~table_m.f90->sourcefile~vector_m.f90 sourcefile~brown_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90 random_m.f90 sourcefile~brown_m.f90->sourcefile~random_m.f90 sourcefile~brown_m.f90->sourcefile~strings_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 sourcefile~utils_math_m.f90 utils_math_m.f90 sourcefile~utils_math_m.f90->sourcefile~constants_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~constants_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~atmcfg_m.f90 sourcefile~aabbtree_m.f90->sourcefile~constants_m.f90 sourcefile~aabb_m.fpp aabb_m.fpp sourcefile~aabbtree_m.f90->sourcefile~aabb_m.fpp sourcefile~aabbtree_m.f90->sourcefile~vector_m.f90 sourcefile~aabbtree_m.f90->sourcefile~strings_m.f90 sourcefile~aabb_m.fpp->sourcefile~constants_m.f90 sourcefile~aabb_m.fpp->sourcefile~strings_m.f90 sourcefile~simbox_m.f90->sourcefile~constants_m.f90 sourcefile~simbox_m.f90->sourcefile~random_m.f90 sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~control_m.f90->sourcefile~constants_m.f90 sourcefile~control_m.f90->sourcefile~strings_m.f90 sourcefile~setup_m.f90->sourcefile~constants_m.f90 sourcefile~setup_m.f90->sourcefile~config_io_m.f90 sourcefile~setup_m.f90->sourcefile~stats_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~trajectory_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~setup_m.f90->sourcefile~atmcfg_m.f90 sourcefile~setup_m.f90->sourcefile~simbox_m.f90 sourcefile~setup_m.f90->sourcefile~control_m.f90 sourcefile~setup_m.f90->sourcefile~random_m.f90 sourcefile~setup_m.f90->sourcefile~strings_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 sourcefile~cell_list_m.f90->sourcefile~constants_m.f90 sourcefile~cell_list_m.f90->sourcefile~simbox_m.f90 sourcefile~cell_list_m.f90->sourcefile~vector_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 sourcefile~ia_tether_m.f90->sourcefile~constants_m.f90 sourcefile~ia_tether_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_bond_m.f90->sourcefile~constants_m.f90 sourcefile~ia_bond_m.f90->sourcefile~strings_m.f90 sourcefile~aabbtree_sm.fpp aabbtree_sm.fpp sourcefile~aabbtree_sm.fpp->sourcefile~aabbtree_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules constants_m Source Code constants_m.f90 Source Code module constants_m !! Various math constants. use , intrinsic :: iso_fortran_env , only : int32 , int64 , real64 implicit none integer , parameter :: ip = int32 !! Default integer precision integer , parameter :: ip_long = int64 !! Default long integer precision integer , parameter :: rp = real64 !! Default real precision integer , parameter :: sizeof_char = 1 !! Size of a char in bytes integer , parameter :: sizeof_int = 4 !! Size of a default int in bytes integer , parameter :: sizeof_long_int = 8 !! Size of a default long int in bytes integer , parameter :: sizeof_real = 8 !! Size of a default real in bytes real ( rp ), parameter :: math_third = 0.333333333333333_rp !>pi real ( rp ), parameter :: math_pi = 3.1415926535897931_rp !>pi divided by two real ( rp ), parameter :: math_pi_2 = 1.5707963267948966_rp !>pi divided by four real ( rp ), parameter :: math_pi_4 = 0.78539816339744828_rp !>reciprocal of pi real ( rp ), parameter :: math_1_pi = 0.31830988618379069_rp !>two times reciprocal of pi real ( rp ), parameter :: math_2_pi = 0.63661977236758138_rp !>two times the reciprocal of the square root of pi. real ( rp ), parameter :: math_2_sqrtpi = 1.1283791670955126_rp !>square root of two real ( rp ), parameter :: math_sqrt2 = 1.4142135623730951_rp !>cube root of two real ( rp ), parameter :: math_cbrt2 = 1.2599210498948732_rp !>sixth root of two real ( rp ), parameter :: math_sxrt2 = 1.122462048309373_rp !>reciprocal of the square root of two real ( rp ), parameter :: math_sqrt1_2 = 0.70710678118654746_rp !>square root of three real ( rp ), parameter :: math_sqrt3 = 1.7320508075688772_rp !>square root of M_E real ( rp ), parameter :: math_sqrt_e = 1.6487212707001282_rp !>square root of pi real ( rp ), parameter :: math_sqrt_pi = 1.7724538509055159_rp !>The base of natural logarithms real ( rp ), parameter :: math_e = 2.7182818284590451_rp !>The logarithm of M_E to base two real ( rp ), parameter :: math_log2e = 1.4426950408889634_rp !>The logarithm of M_E to base 10 real ( rp ), parameter :: math_log10e = 0.43429448190325182_rp !>The natural logarithm of two real ( rp ), parameter :: math_ln2 = 0.69314718055994529_rp !>The natural logarithm of 10 real ( rp ), parameter :: math_ln10 = 2.3025850929940459_rp end module constants_m","tags":"","loc":"sourcefile/constants_m.f90.html"},{"title":"strings_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~strings_m.f90~~EfferentGraph sourcefile~strings_m.f90 strings_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~strings_m.f90~~AfferentGraph sourcefile~strings_m.f90 strings_m.f90 sourcefile~config_io_m.f90 config_io_m.f90 sourcefile~config_io_m.f90->sourcefile~strings_m.f90 sourcefile~brown_m.f90 brown_m.f90 sourcefile~brown_m.f90->sourcefile~strings_m.f90 sourcefile~control_m.f90 control_m.f90 sourcefile~control_m.f90->sourcefile~strings_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~strings_m.f90 sourcefile~setup_m.f90->sourcefile~config_io_m.f90 sourcefile~setup_m.f90->sourcefile~control_m.f90 sourcefile~stats_m.f90 stats_m.f90 sourcefile~setup_m.f90->sourcefile~stats_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~stats_m.f90->sourcefile~strings_m.f90 sourcefile~stats_m.f90->sourcefile~control_m.f90 sourcefile~ia_bond_m.f90 ia_bond_m.f90 sourcefile~ia_bond_m.f90->sourcefile~strings_m.f90 sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~aabbtree_m.f90->sourcefile~strings_m.f90 sourcefile~aabb_m.fpp aabb_m.fpp sourcefile~aabbtree_m.f90->sourcefile~aabb_m.fpp sourcefile~aabb_m.fpp->sourcefile~strings_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~strings_m.f90 sourcefile~main.f90->sourcefile~control_m.f90 sourcefile~main.f90->sourcefile~setup_m.f90 sourcefile~aabbtree_sm.fpp aabbtree_sm.fpp sourcefile~aabbtree_sm.fpp->sourcefile~aabbtree_m.f90 sourcefile~interaction_m.f90->sourcefile~control_m.f90 sourcefile~interaction_m.f90->sourcefile~stats_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_bond_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~pairtab_m.fpp->sourcefile~aabbtree_m.f90 sourcefile~bd_solver_m.f90->sourcefile~config_io_m.f90 sourcefile~bd_solver_m.f90->sourcefile~brown_m.f90 sourcefile~bd_solver_m.f90->sourcefile~control_m.f90 sourcefile~bd_solver_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules strings_m Source Code strings_m.f90 Source Code module strings_m !! summary: Routines for string handling !! author:  George Benthien & others !! !! Many of these routines were originally written by !! [George Benthien](https://gbenthien.net/strings/str-index.html), some have !! been written by Sarit Dutta or gathered/modified from other authors (appropriately credited). !! !! These routines were developed primarily to aid in the reading and manipulation !! of input data from an ASCII text file. Accordingly, it is assumed that all !! characters to be processed are ASCII characters. use constants_m implicit none private :: str_from_inum , str_from_ilnum , str_from_dnum interface str_from_num !!  Generic  interface for writing a number to a string. The calling syntax is !!  `str_from_num(num, frmt)` where `number` is a real number or an integer, !!  `format` is the format desired, e.g., *e15.6*, *i5*, etc. module procedure str_from_inum module procedure str_from_ilnum module procedure str_from_dnum end interface str_from_num contains !****************************************************************************** pure function str_is_letter ( str ) result ( res ) !! Returns `.true.` if `str` contains only letters (*a--z* or *A--Z*) and !! `.false.` otherwise. character ( len =* ), intent ( in ) :: str logical :: res character ( len = 1 ) :: ch integer :: i res = . true . do i = 1 , len ( str ) ch = str ( i : i ) select case ( ch ) case ( 'A' : 'Z' ) cycle case ( 'a' : 'z' ) cycle case default res = . false . return end select end do end function !****************************************************************************** pure function str_is_digit ( str ) result ( res ) !! Returns `.true.` if `str` contains only digits (0,1,...,9) and !!`.false.` otherwise. character ( len =* ), intent ( in ) :: str logical :: res character ( len = 1 ) :: ch integer :: i res = . true . do i = 1 , len ( str ) ch = str ( i : i ) select case ( ch ) case ( '0' : '9' ) cycle case default res = . false . return end select end do end function !******************************************************************************* pure function str_is_space ( str ) result ( res ) !! Returns `.true.` if `str` is non-empty and contains only whitespace !! characters (tab or blankspace). Otherwise `.false.` is returned. !! !! *Note*: This function will return `.false.` for an empty string. character ( len =* ), intent ( in ) :: str logical :: res integer :: lenstr integer :: ich integer :: i lenstr = len ( str ) if ( lenstr == 0 ) then res = . false . return end if res = . true . do i = 1 , lenstr ich = iachar ( str ( i : i )) select case ( ich ) case ( 9 , 32 ) res = . true . case default res = . false . return end select end do end function !******************************************************************************* pure function str_is_comment ( line , comment_str ) result ( res ) !!  Returns `.true.` if `line` is a comment, `.false.` other wise. !! !!  `line` is a comment if `comment_str` is its first non-blank character !!  sequence. If `line` is an empty string or contains only blankspaces, the !!  return value is `.false.` If `comment_str` is empty, the return value is !!  `.true.`. character ( len =* ), intent ( in ) :: line !!  Input string character ( len =* ), intent ( in ) :: comment_str !!  String marking the beginning of a comment. logical :: res res = . false . if ( index ( adjustl ( line ), comment_str ) == 1 ) then res = . true . end if end function !******************************************************************************* pure function str_compact ( str ) result ( ostr ) !! Returns a copy of `str` with multiple spaces and tabs converted to !! single spaces, control characters deleted, and leading and trailing !! spaces removed. character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: ostr character ( len = len ( str )) :: buf character ( len = 1 ) :: ch integer :: lenstr integer :: isp , ich integer :: i , k lenstr = len ( str ) isp = 0 ; k = 0 buf = '' do i = 1 , lenstr ch = str ( i : i ) ich = iachar ( ch ) select case ( ich ) case ( 9 , 32 ) ! space or tab character if ( isp == 0 ) then k = k + 1 buf ( k : k ) = ' ' end if isp = 1 case ( 33 :) ! not a space, quote, or control character k = k + 1 buf ( k : k ) = ch isp = 0 end select end do ostr = trim ( adjustl ( buf )) end function !****************************************************************************** pure function str_remove_stcc ( str ) result ( ostr ) !! Returns a copy of the string `str` with spaces, tabs, and !! control characters removed. character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: ostr character ( len = len ( str )) :: buf character ( len = 1 ) :: ch integer :: lenstr integer :: ich integer :: k integer :: i lenstr = len ( str ) k = 0 do i = 1 , lenstr ch = str ( i : i ) ich = iachar ( ch ) select case ( ich ) case ( 0 : 32 ) ! space, tab, or control character cycle case ( 33 :) k = k + 1 buf ( k : k ) = ch end select end do ostr = trim ( adjustl ( buf )) end function !****************************************************************************** pure function str_to_upper ( str ) result ( ucstr ) !!  This function returns a string that is like the string `str` with all characters !!  that are not between a pair of quotes (\"...\" or '...') converted to uppercase. character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: ucstr integer :: ilen integer :: ioffset integer :: iquote integer :: iav integer :: iqc integer :: i ilen = len ( str ) ioffset = iachar ( 'A' ) - iachar ( 'a' ) iquote = 0 ucstr = str do i = 1 , ilen iav = iachar ( str ( i : i )) if ( ( iquote == 0 ) . and . (( iav == 34 ) . or . ( iav == 39 )) ) then iquote = 1 iqc = iav cycle end if if ( ( iquote == 1 ) . and . ( iav == iqc ) ) then iquote = 0 cycle end if if ( iquote == 1 ) cycle if ( ( iav >= iachar ( 'a' )) . and . ( iav <= iachar ( 'z' )) ) then ucstr ( i : i ) = achar ( iav + ioffset ) end if end do end function !********************************************************************** pure function str_to_lower ( str ) result ( lcstr ) !!  This function returns a string that is like the string `str` with all characters !!  that are not between a pair of quotes (\"...\" or '...') converted to lowercase. character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: lcstr integer :: ilen integer :: ioffset integer :: iquote integer :: iav integer :: iqc integer :: i ilen = len ( str ) ioffset = iachar ( 'A' ) - iachar ( 'a' ) iquote = 0 lcstr = str do i = 1 , ilen iav = iachar ( str ( i : i )) if ( ( iquote == 0 ) . and . (( iav == 34 ) . or . ( iav == 39 )) ) then iquote = 1 iqc = iav cycle end if if ( ( iquote == 1 ) . and . ( iav == iqc ) ) then iquote = 0 cycle end if if ( iquote == 1 ) cycle if ( ( iav >= iachar ( 'A' )) . and . ( iav <= iachar ( 'Z' )) ) then lcstr ( i : i ) = achar ( iav - ioffset ) end if end do end function !****************************************************************************** subroutine str_shift ( str , n ) !! Shifts characters in `str` by `n` positions (positive values !! denote a right shift and negative values denote a left shift). Characters !! that are shifted off the end are lost. Positions opened up by the shift !! are replaced by spaces. character ( len =* ), intent ( in out ) :: str integer , intent ( in ) :: n integer :: lenstr integer :: nabs lenstr = len ( str ) nabs = iabs ( n ) if ( nabs >= lenstr ) then str = repeat ( ' ' , lenstr ) return end if if ( n < 0 ) str = str ( nabs + 1 :) // repeat ( ' ' , nabs ) ! shift left if ( n > 0 ) str = repeat ( ' ' , nabs ) // str (: lenstr - nabs ) ! shift right end subroutine !****************************************************************************** subroutine str_insert ( str , substr , loc ) !! Inserts the string `substr` into the string `str` at position `loc`. !! Characters in `str` starting at position `loc` are shifted right to !! make room for the inserted string. Trailing spaces of `substr` are !! removed prior to insertion. character ( len =* ), intent ( in out ) :: str character ( len =* ), intent ( in ) :: substr integer , intent ( in ) :: loc character ( len = len ( str )) :: tempstr integer :: len_substr len_substr = len_trim ( substr ) tempstr = str ( loc :) call str_shift ( tempstr , len_substr ) tempstr ( 1 : len_substr ) = substr ( 1 : len_substr ) str ( loc :) = tempstr end subroutine !****************************************************************************** subroutine str_del ( str , substr , n ) !! Deletes first `n` occurrences of substring `substr` from string `str` and !! shifts characters left to fill hole. If `n < 0`, all occurances are !! deleted.  If `n` is not explicitly provided, it defaults to removing the !! first occurrence. Trailing spaces or blanks are not considered part of !! `substr`. character ( len =* ), intent ( in out ) :: str character ( len =* ), intent ( in ) :: substr integer , optional , intent ( in ) :: n integer :: n_ integer :: lensubstr integer :: ipos integer :: cntr n_ = 1 if ( present ( n )) n_ = n lensubstr = len_trim ( substr ) cntr = 0 do if (( n_ > 0 ) . and . ( cntr > n_ )) exit ipos = index ( str , substr ) if ( ipos == 0 ) exit str = str (: ipos - 1 ) // str ( ipos + lensubstr :) cntr = cntr + 1 end do end subroutine !********************************************************************** subroutine str_strip_comment ( str , comment_str ) !!  Strips trailing comment from a string. !! !!  The comment is assumed to begin with the sequence of characters in !!  `comment_str`. If the sequence `comment_str` is not found within `str`, !!  no changes are made. character ( len =* ), intent ( in out ) :: str !!  Input string character ( len =* ), intent ( in ) :: comment_str !!  String indicating beginning of a comment. integer :: ipos ipos = index ( adjustl ( str ), comment_str ) if ( ipos /= 0 ) then str = str ( 1 :( ipos - 1 )) end if end subroutine !********************************************************************** subroutine str_get_keyval ( str , key , val , delimiter ) !! Split a string `str` into two strings, `key` and `val` based on space !! delimiter. !! !! A non-empty non-comment string should be passed to this subroutine. !! Keys can have corresponding empty values, but keys must always be present character ( len =* ), intent ( in ) :: str character ( len = :), allocatable , intent ( out ) :: key character ( len = :), allocatable , intent ( out ) :: val character ( len =* ), intent ( in ), optional :: delimiter character ( len = :), allocatable :: delimiter_ character ( len = :), allocatable :: str_just integer :: m integer :: n !blankspace is represented as the integer 32 in ascii chart. delimiter_ = achar ( 32 ) if ( present ( delimiter )) delimiter_ = delimiter str_just = trim ( adjustl ( str )) n = len ( str_just ) m = index ( str_just , delimiter_ ) if ( m == 0 ) then key = str_just val = '' else key = trim ( str_just ( 1 : m - 1 )) val = str_just ( m + len_trim ( delimiter_ ): n ) end if val = trim ( adjustl ( val )) end subroutine !****************************************************************************** subroutine str_match ( str , ipos , imatch ) !! This routine finds the delimiter in string `str` that matches the delimiter !! in position `ipos` of `str`. The argument `imatch` contains the position of !! the matching delimiter. Allowable delimiters are (), [], {}, <>. character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: ipos integer , intent ( out ) :: imatch character ( len = 1 ) :: delim1 character ( len = 1 ) :: delim2 character ( len = 1 ) :: ch integer :: lenstr integer :: istart integer :: iend integer :: inc integer :: idelim2 integer :: isum integer :: i lenstr = len_trim ( str ) delim1 = str ( ipos : ipos ) select case ( delim1 ) case ( '(' ) idelim2 = iachar ( delim1 ) + 1 istart = ipos + 1 iend = lenstr inc = 1 case ( ')' ) idelim2 = iachar ( delim1 ) - 1 istart = ipos - 1 iend = 1 inc =- 1 case ( '[' , '{' , '<' ) idelim2 = iachar ( delim1 ) + 2 istart = ipos + 1 iend = lenstr inc = 1 case ( ']' , '}' , '>' ) idelim2 = iachar ( delim1 ) - 2 istart = ipos - 1 iend = 1 inc =- 1 case default write ( * , * ) delim1 , ' is not a valid delimiter' return end select if ( istart < 1 . or . istart > lenstr ) then write ( * , * ) delim1 , ' has no matching delimiter' return end if delim2 = achar ( idelim2 ) ! matching delimiter isum = 1 do i = istart , iend , inc ch = str ( i : i ) if ( ch /= delim1 . and . ch /= delim2 ) cycle if ( ch == delim1 ) isum = isum + 1 if ( ch == delim2 ) isum = isum - 1 if ( isum == 0 ) exit end do if ( isum /= 0 ) then write ( * , * ) delim1 , ' has no matching delimiter' return end if imatch = i end subroutine !********************************************************************** pure function str_from_inum ( num , frmt ) result ( str ) integer , intent ( in ) :: num character ( len = :), allocatable :: str character ( len =* ), optional , intent ( in ) :: frmt character ( len = :), allocatable :: frmt_ character ( len = 24 ) :: buf frmt_ = '(i0)' if ( present ( frmt )) frmt_ = frmt write ( buf , frmt_ ) num str = trim ( adjustl ( buf )) end function !********************************************************************** pure function str_from_ilnum ( num , frmt ) result ( str ) integer ( ip_long ), intent ( in ) :: num character ( len = :), allocatable :: str character ( len =* ), optional , intent ( in ) :: frmt character ( len = :), allocatable :: frmt_ character ( len = 24 ) :: buf frmt_ = '(i0)' if ( present ( frmt )) frmt_ = frmt write ( buf , frmt_ ) num str = trim ( adjustl ( buf )) end function !********************************************************************** pure function str_from_dnum ( num , frmt ) result ( str ) real ( rp ), intent ( in ) :: num character ( len = :), allocatable :: str character ( len =* ), optional , intent ( in ) :: frmt character ( len = :), allocatable :: frmt_ character ( len = 32 ) :: buf frmt_ = '(g0.15)' if ( present ( frmt )) frmt_ = frmt write ( buf , frmt_ ) num str = str_trimzero ( buf ) end function !****************************************************************************** subroutine str_compact_rlstr ( str ) !! author: Izaak Beekman !! date: 02/24/2015 !! !! Compact a string representing a real number, so that the same value is !! displayed with fewer characters. character ( len =* ), intent ( in out ) :: str !! string representation of a real number. character ( len = len ( str )) :: significand character ( len = len ( str )) :: expnt character ( len = 2 ) :: separator integer :: exp_start integer :: decimal_pos integer :: sig_trim integer :: exp_trim integer :: i !! counter str = adjustl ( str ) exp_start = scan ( str , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( str , '-+' , back = . true .) decimal_pos = scan ( str , '.' ) if ( exp_start /= 0 ) separator = str ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then !possibly signed, exponent-less float significand = str sig_trim = len_trim ( significand ) do i = len_trim ( significand ), decimal_pos + 2 , - 1 !look from right to left at 0s !but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do str = trim ( significand ( 1 : sig_trim )) else if ( exp_start > decimal_pos ) then !float has exponent significand = str ( 1 : exp_start - 1 ) sig_trim = len_trim ( significand ) do i = len_trim ( significand ), decimal_pos + 2 , - 1 !look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do expnt = adjustl ( str ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( str ( exp_start + 1 :)) end if exp_trim = 1 do i = 1 ,( len_trim ( expnt ) - 1 ) !look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit end if end do str = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable end if end subroutine !******************************************************************************* pure function str_trimzero ( str ) result ( res ) !! Deletes nonsignificant trailing zeroes from number string str. If number !! string ends in a decimal point, one trailing zero is added. character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: res character ( len = len ( str )) :: buf character ( len = 10 ) :: sexp character ( len = 1 ) :: ch integer :: ipos integer :: lbuf integer :: i buf = str ipos = scan ( str , 'eE' ) if ( ipos > 0 ) then sexp = buf ( ipos :) buf = buf ( 1 : ipos - 1 ) endif lbuf = len_trim ( buf ) do i = lbuf , 1 , - 1 ch = buf ( i : i ) if ( ch == '0' ) cycle if ( ch == '.' ) then buf = buf ( 1 : i ) // '0' if ( ipos > 0 ) buf = trim ( buf ) // trim ( sexp ) exit endif buf = buf ( 1 : i ) exit end do if ( ipos > 0 ) buf = trim ( buf ) // trim ( sexp ) res = trim ( adjustl ( buf )) end function !*********************************************************************** pure function str_to_d ( str ) result ( res ) character ( len =* ), intent ( in ) :: str real ( rp ) :: res read ( str , * ) res end function !*********************************************************************** pure function str_to_i ( str ) result ( res ) character ( len =* ), intent ( in ) :: str integer :: res read ( str , * ) res end function !*********************************************************************** pure function str_strip ( str , chars , ends ) result ( ostr ) !! Returns a copy of string `str` with the leading and trailing characters !! removed. The `chars` argument is a string specifying the set of characters to !! be removed.  The `chars` argument is not a prefix or suffix; rather, all !! combinations of its values are stripped. If `ends = 'l'`, only leading !! characters are removed, if `ends = 'r'`, only trailing characters are !! removed, and if `ends = 'b'` both leading and trailing characters are !! removed. character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: chars character ( len = 1 ), intent ( in ) :: ends !! {'l', 'r', 'b'} character ( len = :), allocatable :: ostr integer :: lenstr integer :: ibeg integer :: iend lenstr = len ( str ) select case ( ends ) case ( 'l' ) ibeg = verify ( str , chars ) iend = lenstr case ( 'r' ) ibeg = 1 iend = verify ( str , chars , . true .) case ( 'b' ) ibeg = verify ( str , chars ) iend = verify ( str , chars , . true .) case default ibeg = 1 iend = lenstr end select if (( ibeg == 0 ) . or . ( iend == 0 )) then ostr = '' else ostr = str ( ibeg : iend ) end if end function !********************************************************************** subroutine str_split ( str , delimiter , before ) !! Routine finds the first instance of a character from `delims` in the the !! string `str`. The characters before the found delimiter are output in !! `before`. The characters after the found delimiter are output in `str`. !! Repeated applications of this routine can be used to parse a string into its !! component parts. Multiple whitespaces of `str` are compacted into a single !! whitespace before splitting begins. If either `str` or `delimiter` is !! empty, an empty string is retured in `before` and `str` remains !! unchanged. character ( len =* ), intent ( in out ) :: str character ( len =* ), intent ( in ) :: delimiter character ( len = :), allocatable , intent ( out ) :: before integer :: lenstr integer :: lendelim integer :: ipos str = str_compact ( str ) lenstr = len ( str ) lendelim = len ( delimiter ) if ( ( lenstr == 0 ) . or . ( lendelim == 0 ) ) then ! `str` or `delimiter` is empty before = '' return end if ipos = index ( str , delimiter ) if ( ipos == 0 ) then ! string does not contain any delimiter before = '' return else before = str ( 1 :( ipos - 1 )) str = str (( ipos + lendelim - 1 ):) end if end subroutine !********************************************************************** subroutine str_append ( dest , source , sep ) !! Appends a copy of the `source` string to the `dest` string, with !! optional string `sep` in between. It is assumed that `dest` is long !! enough to hold the result, otherwise an error will be generated. character ( len =* ), intent ( in out ) :: dest character ( len =* ), intent ( in ) :: source character ( len =* ), optional , intent ( in ) :: sep character ( len = :), allocatable :: sep_ integer :: len_dest integer :: len_source integer :: len_sep_ integer :: ipos sep_ = '' if ( present ( sep )) sep_ = sep len_dest = len_trim ( dest ) len_source = len_trim ( adjustl ( source )) len_sep_ = len ( sep_ ) ipos = len_dest + 1 if ( len_sep_ > 0 ) then dest ( ipos :( ipos + len_sep_ ) ) = sep_ ipos = ipos + len_sep_ + 1 end if dest ( ipos :( ipos + len_source ) ) = trim ( adjustl ( source )) end subroutine !********************************************************************** pure function str_startswith ( str , prefix , start , finish ) result ( res ) !! Returns `.true.` if the string `str` starts with `prefix`, otherwise !! returns `.false.`. With optional `start`, test beginning at that position. !! With optional `finish`, stop comparing beyond that position. character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: prefix integer , optional , intent ( in ) :: start integer , optional , intent ( in ) :: finish logical :: res integer :: ibeg integer :: iend ibeg = 1 ; iend = len ( str ) if ( present ( start )) ibeg = start if ( present ( finish )) iend = finish !Return .false. if prefix is longer than str(ibeg:iend) if ( len ( prefix ) > ( iend - ibeg + 1 )) then res = . false . return end if if ( index ( str ( ibeg : iend ), prefix ) == 1 ) then res = . true . else res = . false . end if end function !********************************************************************** pure function str_endswith ( str , suffix , start , finish ) result ( res ) !! Returns `.true.` if the string `str` ends with `suffix`, otherwise !! return `.false.`. With optional `start`, test beginning at that position. !! With optional `finish`, stop comparing beyond that position. character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: suffix integer , optional , intent ( in ) :: start integer , optional , intent ( in ) :: finish logical :: res integer :: ibeg integer :: iend integer :: iloc ibeg = 1 ; iend = len ( str ) if ( present ( start )) ibeg = start if ( present ( finish )) iend = finish !Return .false. if suffix is longer than str(ibeg:iend) if ( len ( suffix ) > ( iend - ibeg + 1 )) then res = . false . return end if ! Getting last occurrance of suffix iloc = index ( str ( ibeg : iend ), suffix , back = . true .) if ( ( iloc + len ( suffix ) - 1 ) == iend ) then res = . true . else res = . false . end if end function !****************************************************************************** subroutine readline ( nunitr , line , comment_str , ios ) !!  Reads a line from unit=nunitr, ignoring blank lines !!  and deleting comments integer , intent ( in ) :: nunitr character ( len =* ), intent ( in out ) :: line character ( len =* ), intent ( in ) :: comment_str integer , intent ( out ) :: ios do read ( nunitr , '(a)' , iostat = ios ) line ! read input line if ( ios /= 0 ) return if (( len_trim ( line ) /= 0 ) . and . (. not . str_is_comment ( line , comment_str ))) then call str_strip_comment ( line , comment_str ) exit end if end do end subroutine !****************************************************************************** end module strings_m","tags":"","loc":"sourcefile/strings_m.f90.html"},{"title":"atmcfg_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~atmcfg_m.f90~~EfferentGraph sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~atmcfg_m.f90~~AfferentGraph sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~config_io_m.f90 config_io_m.f90 sourcefile~config_io_m.f90->sourcefile~atmcfg_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~pairtab_m.fpp->sourcefile~atmcfg_m.f90 sourcefile~ia_vdw_m.f90 ia_vdw_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~atmcfg_m.f90 sourcefile~stats_m.f90 stats_m.f90 sourcefile~stats_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_dihedral_m.f90 ia_dihedral_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~atmcfg_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~atmcfg_m.f90 sourcefile~setup_m.f90->sourcefile~config_io_m.f90 sourcefile~setup_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90->sourcefile~atmcfg_m.f90 sourcefile~bd_solver_m.f90->sourcefile~config_io_m.f90 sourcefile~bd_solver_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~ia_external_m.f90 ia_external_m.f90 sourcefile~ia_external_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_angle_m.f90 ia_angle_m.f90 sourcefile~ia_angle_m.f90->sourcefile~atmcfg_m.f90 sourcefile~interaction_m.f90->sourcefile~atmcfg_m.f90 sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~interaction_m.f90->sourcefile~ia_vdw_m.f90 sourcefile~interaction_m.f90->sourcefile~stats_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_dihedral_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_external_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_angle_m.f90 sourcefile~ia_tether_m.f90 ia_tether_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_tether_m.f90 sourcefile~ia_tether_m.f90->sourcefile~atmcfg_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules atmcfg_m Source Code atmcfg_m.f90 Source Code !********************************************************************************! !                                                                                ! ! The MIT License (MIT)                                                          ! !                                                                                ! ! Copyright (c) 2020 Sarit Dutta                                                 ! !                                                                                ! ! Permission is hereby granted, free of charge, to any person obtaining a copy   ! ! of this software and associated documentation files (the \"Software\"), to deal  ! ! in the Software without restriction, including without limitation the rights   ! ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      ! ! copies of the Software, and to permit persons to whom the Software is          ! ! furnished to do so, subject to the following conditions:                       ! !                                                                                ! ! The above copyright notice and this permission notice shall be included in all ! ! copies or substantial portions of the Software.                                ! !                                                                                ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     ! ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       ! ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    ! ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         ! ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  ! ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  ! ! SOFTWARE.                                                                      ! !                                                                                ! !********************************************************************************! module atmcfg_m use constants_m implicit none integer , parameter :: mxparam = 12 !! Maximum number of parameters for bonds, angles, etc. type atmcfg_t !Particle configuration: Atoms integer :: num_atom_types = 0 !! Number of *atom_type*s character ( len = 8 ), dimension (:), allocatable :: atom_names !! (*num_atom_types*,) array. Name of atoms of each type. integer , dimension (:), allocatable :: atom_styles !! (*num_atom_types*,) array. Style of atoms of each type. real ( rp ), dimension (:), allocatable :: atom_mass !! (*num_atom_types*,) array. Mass of atoms of each type. integer :: num_atoms = 0 !!  Number of atoms integer , dimension (:), allocatable :: atoms !! (*num_atoms*,) array. !! !! For atom *i*, its type *at = atoms(i)*, with style !! *atom_styles(at)*, name *atom_names(at)*, mass *atom_mass(at)*, charge !! *charge(i)*, position *coordinates(:,i)*, velocity *velocities(:,i)*, !! orientation (if the style requires) *orientations(:,i)*. The force !! acting on atom *i* is *forces(:,i)*. real ( rp ), dimension (:), allocatable :: charge !! (*num_atoms*,) array. real ( rp ), dimension (:,:), allocatable :: coordinates !!  (3, *num_atoms*) array real ( rp ), dimension (:,:), allocatable :: forces !!  (3, *num_atoms*) array !Particle configuration: Bonds integer :: num_bond_types = 0 !!  Number of *bond_type*s integer , dimension (:), allocatable :: bond_styles !!  (*num_bond_types*,) array. real ( rp ), dimension (:,:), allocatable :: bond_params !!  (*mxparam*,*num_bond_types*) array. integer :: num_bonds = 0 !!  Total number of bonds. integer , dimension (:,:), allocatable :: bonds !! (3, *num_bonds*) array. Bond *i* is of type *bt = bonds(1,i)*,  directed from !! atom *bonds(2,i)* to *bonds(3,i)*. Its style is *bond_styles(bt)* with !! parameters *bond_params(:,bt)*. !Particle configuration: Angles integer :: num_angle_types = 0 !!  Number of *angle_type*s integer , dimension (:), allocatable :: angle_styles !!  (*num_angle_types*,) array real ( rp ), dimension (:,:), allocatable :: angle_params !!  (*mxparam*, *num_angle_types*) array integer :: num_angles = 0 !!  Number of angles integer , dimension (:,:), allocatable :: angles !! (4, *num_angles*) array. Angle *i* is of type *ant = angles(1,i)*, incident !! to atoms *angles(2,i)*, *angles(3,i)*, and *angles(4,i)*. Its style is !! *angle_styles(ant)* with parameters *angle_params(:,ant)*. !Particle configuration: Dihedrals integer :: num_dihedral_types = 0 !!  Number of *dihedral_type*s integer , dimension (:), allocatable :: dihedral_styles !!  (*num_dihedral_types*,) array real ( rp ), dimension (:,:), allocatable :: dihedral_params !!  (*mxparam*, *num_dihedral_types*) array integer :: num_dihedrals = 0 !!  Number of dihedrals integer , dimension (:,:), allocatable :: dihedrals !! (5, *num_dihedrals*) array. Dihedral *i* is of type *dt = dihedrals(1,i)*, incident !! to atoms *dihedrals(2,i)*, *dihedrals(3,i)*, *dihedrals(4,i)*, and *dihedrals(5,i)*. !! Its style is *dihedral_styles(dt)* with parameters *dihedral_params(:,dt)*. !Particle configuration: Branches integer :: num_branches = 0 !! Total number of branches (including the backbone) integer , dimension (:,:), allocatable :: branches !! (3,*num_branches*) array. Branch *i* is tethered to atom *branches(1,i)*, !! contains *branches(2,i)* atoms, with the beginning atom index *branches(3,i)*. !Particle configuration: Molecules integer :: num_molecule_types = 0 !!  Number of *molecule_type*s character ( len = 8 ), dimension (:), allocatable :: molecule_names !! (*num_molecule_types*,) array integer , dimension (:), allocatable :: molecule_pop !! (*num_molecule_types*,) array integer :: num_molecules = 0 !!  Number of molecules integer , dimension (:,:), allocatable :: molecules !! (9,*num_molecules*) array. For molecule *i*, its type *mt = molecules(1,i)*, !! containing *molecules(2,i)* atoms with beginning index *molecules(3,i)*, !! *molecules(4,i)* bonds with beginning index *molecules(5,i)*, !! *molecules(6,i)* angles with beginning index *molecules(7,i)*, and !! *molecules(8,i)* dihedrals with beginning index *molecules(9,i)*. real ( rp ), dimension ( 3 ) :: molecule_com = 0.0_rp !! Center of mass of the molecule. This is used only when imcon == 0, i.e. !! for a single molecule without periodic boundaries. !Particle configuration: Tethers integer :: num_tether_types = 0 !!  Number of *tether_type*s integer , dimension (:), allocatable :: tether_styles !!  (*num_tether_types*,) array real ( rp ), dimension (:,:), allocatable :: tether_params !!  (*mxparam*, *num_tether_types*) array integer :: num_tethers = 0 !!  Number of tethers integer , dimension (:,:), allocatable :: tethers !! (2, *num_tethers*) array. Tether *i* is of type *tt = tethers(1,i)*, tethering !! atom *tethers(2,i)* to a point *tether_points(:,i)*. !! Its style is *tether_styles(tt)* with parameters *tether_params(:,tt)*. real ( rp ), dimension (:,:), allocatable :: tether_points !!  (3, *num_tethers*) array !Particle configuration: VDW (pair) interactions integer :: num_vdw_types = 0 !!  Number of *vdw_type*s integer , dimension (:), allocatable :: vdw_styles !!  (*num_vdw_types*,) array real ( rp ), dimension (:,:), allocatable :: vdw_params !!  (*mxparam*, *num_vdw_types*) array integer , dimension (:,:), allocatable :: vdw_pairs !!  (2, *num_vdw_types*) array. Stores atom type of interacting pairs, such !! that at_i >= at_j. !Particle configuration: External force field integer :: num_externals = 0 !!  Number of external fields integer , dimension (:), allocatable :: external_styles !!  (*num_external*,) array real ( rp ), dimension (:,:), allocatable :: external_params !!  (*mxparam*, *num_external*) array !Particle configuration: Flow field integer :: flow_style = 0 real ( rp ), dimension (:), allocatable :: flow_params !!  (*mxparam*,) array end type atmcfg_t contains !****************************************************************************** subroutine atmcfg_delete ( this ) !! Deallocates all memory acquired by a `configuration_t` object and resets !! all other components to zero. Exception: `num_coeffs` is not reset to !! zero. type ( atmcfg_t ), intent ( in out ) :: this this % num_atom_types = 0 ; this % num_atoms = 0 if ( allocated ( this % atom_names )) deallocate ( this % atom_names ) if ( allocated ( this % atom_styles )) deallocate ( this % atom_styles ) if ( allocated ( this % atom_mass )) deallocate ( this % atom_mass ) if ( allocated ( this % atoms )) deallocate ( this % atoms ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % forces )) deallocate ( this % forces ) if ( allocated ( this % charge )) deallocate ( this % charge ) this % num_bond_types = 0 ; this % num_bonds = 0 if ( allocated ( this % bond_styles )) deallocate ( this % bond_styles ) if ( allocated ( this % bond_params )) deallocate ( this % bond_params ) if ( allocated ( this % bonds )) deallocate ( this % bonds ) this % num_angle_types = 0 ; this % num_angles = 0 if ( allocated ( this % angle_styles )) deallocate ( this % angle_styles ) if ( allocated ( this % angle_params )) deallocate ( this % angle_params ) if ( allocated ( this % angles )) deallocate ( this % angles ) this % num_dihedral_types = 0 ; this % num_dihedrals = 0 if ( allocated ( this % dihedral_styles )) deallocate ( this % dihedral_styles ) if ( allocated ( this % dihedral_params )) deallocate ( this % dihedral_params ) if ( allocated ( this % dihedrals )) deallocate ( this % dihedrals ) this % num_branches = 0 if ( allocated ( this % branches )) deallocate ( this % branches ) this % num_molecule_types = 0 ; this % num_molecules = 0 if ( allocated ( this % molecule_names )) deallocate ( this % molecule_names ) if ( allocated ( this % molecule_pop )) deallocate ( this % molecule_pop ) if ( allocated ( this % molecules )) deallocate ( this % molecules ) this % num_tether_types = 0 ; this % num_tethers = 0 if ( allocated ( this % tether_styles )) deallocate ( this % tether_styles ) if ( allocated ( this % tether_params )) deallocate ( this % tether_params ) if ( allocated ( this % tethers )) deallocate ( this % tethers ) if ( allocated ( this % tether_points )) deallocate ( this % tether_points ) this % num_vdw_types = 0 if ( allocated ( this % vdw_styles )) deallocate ( this % vdw_styles ) if ( allocated ( this % vdw_params )) deallocate ( this % vdw_params ) if ( allocated ( this % vdw_pairs )) deallocate ( this % vdw_pairs ) this % num_externals = 0 if ( allocated ( this % external_styles )) deallocate ( this % external_styles ) if ( allocated ( this % external_params )) deallocate ( this % external_params ) if ( allocated ( this % flow_params )) deallocate ( this % flow_params ) end subroutine !****************************************************************************** end module atmcfg_m","tags":"","loc":"sourcefile/atmcfg_m.f90.html"},{"title":"ia_bond_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~ia_bond_m.f90~~EfferentGraph sourcefile~ia_bond_m.f90 ia_bond_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~ia_bond_m.f90->sourcefile~constants_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~ia_bond_m.f90->sourcefile~strings_m.f90 sourcefile~logger_m.f90 logger_m.f90 sourcefile~ia_bond_m.f90->sourcefile~logger_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 sourcefile~timestamp_m.f90 timestamp_m.f90 sourcefile~logger_m.f90->sourcefile~timestamp_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ia_bond_m.f90~~AfferentGraph sourcefile~ia_bond_m.f90 ia_bond_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_bond_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ia_bond_m Source Code ia_bond_m.f90 Source Code !********************************************************************************! !                                                                                ! ! The MIT License (MIT)                                                          ! !                                                                                ! ! Copyright (c) 2020 Sarit Dutta                                                 ! !                                                                                ! ! Permission is hereby granted, free of charge, to any person obtaining a copy   ! ! of this software and associated documentation files (the \"Software\"), to deal  ! ! in the Software without restriction, including without limitation the rights   ! ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      ! ! copies of the Software, and to permit persons to whom the Software is          ! ! furnished to do so, subject to the following conditions:                       ! !                                                                                ! ! The above copyright notice and this permission notice shall be included in all ! ! copies or substantial portions of the Software.                                ! !                                                                                ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     ! ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       ! ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    ! ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         ! ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  ! ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  ! ! SOFTWARE.                                                                      ! !                                                                                ! !********************************************************************************! module ia_bond_m !! This module contains routines to evaluate bond potentials and their !! derivative. !! !! The following styles are available: !! !! * Style 0. None (only topology) !! * Style 1. Harmonic. See [[bond_harm_set]]. !! * Style 2. FENE. See [[bond_fene_set]]. !! * Style 3. Kremer-Grest. See [[bond_kg_set]]. !! * Style 4. Marko-Siggia. See [[bond_ms_set]]. use constants_m use strings_m use logger_m implicit none private public :: ia_bond_setup , ia_get_bond_force contains !****************************************************************************** subroutine ia_bond_setup ( num_bond_types , bond_styles , bond_params ) !! Sets up parameters for bond potentials integer , intent ( in ) :: num_bond_types !! Number of bond types integer , dimension (:), intent ( in ) :: bond_styles !! Styles for each type real ( rp ), dimension (:,:), intent ( in out ) :: bond_params !! Parameters for each type, depending on style integer :: i , sty !Set bond interactions do i = 1 , num_bond_types sty = bond_styles ( i ) select case ( sty ) case ( 1 ) call bond_harm_set ( bond_params (:, i )) case ( 2 ) call bond_fene_set ( bond_params (:, i )) case ( 3 ) call bond_kg_set ( bond_params (:, i )) case ( 4 ) call bond_ms_set ( bond_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_bond_force ( rij_mag , sty , params , enrg , frc , ierr ) !! Calculates the energy & its derivative due to a bond. real ( rp ), intent ( in ) :: rij_mag !! Distance between bonded atoms integer , intent ( in ) :: sty !! Style of the bond real ( rp ), dimension (:), intent ( in ) :: params !! Parameters for bonded interaction real ( rp ), intent ( out ) :: enrg !! Bond energy real ( rp ), intent ( out ) :: frc !! Derivative of the potential. This is the magnitude of the force due !! to this potential. integer , intent ( out ) :: ierr !! Error flag ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp select case ( sty ) case ( 1 ) call bond_harm ( rij_mag , params , enrg , frc ) case ( 2 ) call bond_fene ( rij_mag , params , enrg , frc , ierr ) case ( 3 ) call bond_kg ( rij_mag , params , enrg , frc , ierr ) case ( 4 ) call bond_ms ( rij_mag , params , enrg , frc , ierr ) case default continue end select end subroutine !******************************************************************************** subroutine bond_harm_set ( params , k , r0 ) !! Setter for harmonic bond interaction. !! !!``` !!  U = (1/2)*k*(r - r0)&#94;2 !!``` !! User-set parameters: !! !! * params(1) = `k` (spring constant) !! * params(2) = `r0` (equilibrium distance) real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: r0 if ( present ( k )) params ( 1 ) = k if ( present ( r0 )) params ( 2 ) = r0 end subroutine !******************************************************************************** subroutine bond_harm ( r , params , enrg , frc ) !! Calculates energy & its derivative for harmonic bond. See [[bond_harm_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc enrg = 0.5_rp * params ( 1 ) * ( r - params ( 2 )) * ( r - params ( 2 )) frc = params ( 1 ) * ( r - params ( 2 )) end subroutine !******************************************************************************** subroutine bond_fene_set ( params , k , rmax , r0 ) !! Setter for FENE bond. !! !!``` !!  U = -0.5 k rmax&#94;2 log [1 - ((r - r0)/rmax)&#94;2] !!``` !! !! User-set parameters: !! !! * params(1) = `k` !! * params(2) = `rmax` !! * params(3) = `r0` !! !! @Note The bond cannot extend beyond (rmax+r0), where r0 is the !! equilibrium bond length. If r0 = 0, this reduces to the standard definition !! of FENE bonds. !! !! Internally stored parameters: !! !! * params(4) = `rmax&#94;2` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: rmax real ( rp ), intent ( in ), optional :: r0 if ( present ( k )) params ( 1 ) = k if ( present ( rmax )) params ( 2 ) = rmax if ( present ( r0 )) params ( 3 ) = r0 params ( 4 ) = params ( 2 ) * params ( 2 ) end subroutine !******************************************************************************** subroutine bond_fene ( r , params , enrg , frc , ierr ) !! Calculates energy & its derivative for FENE bond. See [[bond_fene_set]]. !! !! If bond length exceeds maximum extensible spring length, an error will be !! reported by `ierr = 1`. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr real ( rp ) :: k , rmax , r0 real ( rp ) :: extn , extnsq , rmaxsq ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp k = params ( 1 ); rmax = params ( 2 ); r0 = params ( 3 ); rmaxsq = params ( 4 ) extn = r - r0 ; extnsq = extn * extn if ( r >= ( rmax + r0 ) ) then ierr = 1 call logger % log_msg ( '<bond_fene> bondlength too large' ) call logger % log_msg ( '<bond_fene> r = ' // str_from_num ( r )) return else enrg = - 0.5_rp * k * rmaxsq * log ( 1.0_rp - extnsq / rmaxsq ) frc = k * extn / ( 1.0_rp - extnsq / rmaxsq ) end if end subroutine !****************************************************************************** subroutine bond_kg_set ( params , k , rmax , eps , sigma ) !! Setter for FENE bond interaction. !! !!``` !!   V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] + eps !!   W = -0.5 k rmax&#94;2 log [1 - (r/rmax)&#94;2] !!   U = W + V, r < 2&#94;(1/6)*sigma !!       W, r >= 2&#94;(1/6)*sigma !!``` !! User-set parameters: !! !! * params(1) = `k` !! * params(2) = `rmax` !! * params(3) = `eps` !! * params(4) = `sigma` !! !! Internally stored parameters: !! !! * params(5) = `rmax&#94;2` !! * params(6) = `2&#94;(1/6)*sigma` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: rmax real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ) :: k_ , rmax_ , eps_ , sigma_ if ( present ( k )) params ( 1 ) = k if ( present ( rmax )) params ( 2 ) = rmax if ( present ( eps )) params ( 3 ) = eps if ( present ( sigma )) params ( 4 ) = sigma k_ = params ( 1 ); rmax_ = params ( 2 ); eps_ = params ( 3 ); sigma_ = params ( 4 ) params ( 5 ) = rmax_ ** 2 params ( 6 ) = math_sxrt2 * sigma_ end subroutine !******************************************************************************** subroutine bond_kg ( r , params , enrg , frc , ierr ) !! Calculates energy & its derivative for Kremer-Grest bond. See [[bond_kg_set]]. !! !! If bond length exceeds maximum extensible spring length, an error will be !! reported as `ierr = 1`. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr real ( rp ) :: k , rmax , eps , sigma real ( rp ) :: rmaxsq , rcut real ( rp ) :: rsq , sir , sir2 , sir12 , sir6 ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp k = params ( 1 ); rmax = params ( 2 ); eps = params ( 3 ); sigma = params ( 4 ) rmaxsq = params ( 5 ); rcut = params ( 6 ) rsq = r * r if ( r >= rmax ) then ierr = 1 call logger % log_msg ( '<bond_kg> r > rmax' ) call logger % log_msg ( '<bond_kg> r = ' // str_from_num ( r )) return else if ( ( r >= rcut ) . and . ( r < rmax ) ) then enrg = - 0.5_rp * k * rmaxsq * log ( 1.0_rp - rsq / rmaxsq ) frc = k * r / ( 1.0_rp - rsq / rmaxsq ) else sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = - 0.5_rp * k * rmaxsq * log ( 1.0_rp - rsq / rmaxsq ) & + 4 * eps * ( sir12 - sir6 ) + eps frc = k * r / ( 1.0_rp - rsq / rmaxsq ) - 24 * eps * ( 2 * sir12 - sir6 ) / r end if end subroutine !****************************************************************************** subroutine bond_ms_set ( params , lp , rmax ) !! Setter for Marko-Siggia bond. !! !!``` !!   U = [-(1/2)*rtilde&#94;2 + 0.25/(1-rtilde)&#94;2 + 0.25*rtilde]*(rmax/lp), r < rmax !!   where rtilde = r/rmax. !!``` !! !! User-set parameters: !! !! * params(1) = `lp` (persistence length) !! * params(2) = `rmax` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: lp real ( rp ), intent ( in ), optional :: rmax if ( present ( lp )) params ( 1 ) = lp if ( present ( rmax )) params ( 2 ) = rmax end subroutine !******************************************************************************** subroutine bond_ms ( r , params , enrg , frc , ierr ) !! Evaluates the potential & its derivative for Marko-Siggia bond. !! See [[bond_ms_set]]. !! !! If bond length exceeds maximum extensible spring length, an error will be !! reported as `ierr = 1`. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr real ( rp ) :: lp , rmax , rtilde , rrtilde ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp lp = params ( 1 ); rmax = params ( 2 ) if ( r >= rmax ) then ierr = 1 call logger % log_msg ( '<bond_ms> r > rmax' ) call logger % log_msg ( '<bond_ms> r = ' // str_from_num ( r )) return else rtilde = r / rmax ; rrtilde = 1.0_rp / ( 1.0_rp - rtilde ) enrg = ( - 0.5 * rtilde * rtilde + 0.25_rp * rrtilde * rrtilde + 0.25 * rtilde ) * ( rmax / lp ) frc = ( - rtilde - 0.25_rp * rrtilde * rrtilde + 0.25_rp ) / lp end if end subroutine !****************************************************************************** end module ia_bond_m","tags":"","loc":"sourcefile/ia_bond_m.f90.html"},{"title":"control_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~control_m.f90~~EfferentGraph sourcefile~control_m.f90 control_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~control_m.f90->sourcefile~strings_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~control_m.f90->sourcefile~constants_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~control_m.f90~~AfferentGraph sourcefile~control_m.f90 control_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~control_m.f90 sourcefile~stats_m.f90 stats_m.f90 sourcefile~setup_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~stats_m.f90->sourcefile~control_m.f90 sourcefile~bd_solver_m.f90->sourcefile~control_m.f90 sourcefile~bd_solver_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~control_m.f90 sourcefile~interaction_m.f90->sourcefile~stats_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~control_m.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules control_m Source Code control_m.f90 Source Code !********************************************************************************! !                                                                                ! ! The MIT License (MIT)                                                          ! !                                                                                ! ! Copyright (c) 2020 Sarit Dutta                                                 ! !                                                                                ! ! Permission is hereby granted, free of charge, to any person obtaining a copy   ! ! of this software and associated documentation files (the \"Software\"), to deal  ! ! in the Software without restriction, including without limitation the rights   ! ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      ! ! copies of the Software, and to permit persons to whom the Software is          ! ! furnished to do so, subject to the following conditions:                       ! !                                                                                ! ! The above copyright notice and this permission notice shall be included in all ! ! copies or substantial portions of the Software.                                ! !                                                                                ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     ! ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       ! ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    ! ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         ! ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  ! ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  ! ! SOFTWARE.                                                                      ! !                                                                                ! !********************************************************************************! module control_m !! Routines for reading and witing control file. use constants_m use strings_m implicit none integer , parameter :: mxrdln = 1024 !! Maximum length of character string for input line buffer. type ctrlpar_t real ( rp ) :: rcutoff = 0.0_rp real ( rp ) :: tskin = 0.0_rp character ( len = 5 ) :: mth_ptgen = '' logical :: lelst = . false . logical :: lhdia = . false . logical :: lvdw = . false . integer :: excluded_atoms = 0 character ( len = 4 ) :: mob_fctr = '' integer :: lanc_mxitr = 0 real ( rp ) :: lanc_tol = 0.0_rp integer :: se_nlmxitr = 0 integer :: se_kdmax = 0 character ( len = 4 ) :: bdintg = '' real ( rp ), dimension ( 2 ) :: se_tol = 0.0_rp integer , dimension ( 2 ) :: stats_binsize = 0 real ( rp ) :: tim_stp = 0.0_rp integer ( ip_long ) :: nts_sim = 0 integer :: nts_mobsam = 0 integer ( ip_long ) :: nts_dump = 0 integer ( ip_long ) :: nts_samp = 0 integer ( ip_long ) :: nts_log = 0 logical :: lrevive = . false . !! {T, F}. Whether the simulation is restarted. logical :: read_seed = . false . !! {T, F}. Whether to initialize the random number generator by reading !! a seed from a file. If `read_seed` == T, the seed will be read from !! a file 'random_seed.txt' logical :: write_seed = . false . !! {T, F}. Whether to write the random number generator seed. If !!  `write_seed` == T the seed will be written to a file named !!  'random_seed.txt' logical :: write_traj = . false . !! Should the trajectory be written to file? {T, F} character ( len = :), allocatable :: fn_cfg !! Name of the file containing the initial configuration character ( len = :), allocatable :: fn_revive !! Name of the revive file character ( len = :), allocatable :: fn_stats !! Name of the statistics file character ( len = :), allocatable :: fn_traj !! Name of the trajectory file contains procedure :: read => control_read procedure :: write => control_write end type ctrlpar_t contains !****************************************************************************** subroutine control_read ( this , fn ) !! Reads simulation control parameters from file class ( ctrlpar_t ), intent ( out ) :: this !! A *ctrlpar_t* instance. character ( len =* ), intent ( in ) :: fn !! Name of parameters file. character ( len = :), allocatable :: key character ( len = :), allocatable :: val character ( len = mxrdln ) :: line character ( len = 1 ) :: cstr = '#' !Comment string integer :: fu integer :: ios open ( newunit = fu , file = fn , action = 'read' , status = 'old' ) do call readline ( fu , line , cstr , ios ) if ( ios /= 0 ) return call str_get_keyval ( line , key , val ) if ( key == 'rcutoff' ) read ( val , * ) this % rcutoff if ( key == 'tskin' ) read ( val , * ) this % tskin if ( key == 'mth_ptgen' ) read ( val , * ) this % mth_ptgen if ( key == 'lelst' ) read ( val , * ) this % lelst if ( key == 'lhdia' ) read ( val , * ) this % lhdia if ( key == 'lvdw' ) read ( val , * ) this % lvdw if ( key == 'excluded_atoms' ) read ( val , * ) this % excluded_atoms if ( key == 'mob_fctr' ) read ( val , * ) this % mob_fctr if ( key == 'lanc_mxitr' ) read ( val , * ) this % lanc_mxitr if ( key == 'lanc_tol' ) read ( val , * ) this % lanc_tol if ( key == 'bdintg' ) read ( val , * ) this % bdintg if ( key == 'se_nlmxitr' ) read ( val , * ) this % se_nlmxitr if ( key == 'se_kdmax' ) read ( val , * ) this % se_kdmax if ( key == 'se_tol' ) read ( val , * ) this % se_tol if ( key == 'stats_binsize' ) read ( val , * ) this % stats_binsize if ( key == 'tim_stp' ) read ( val , * ) this % tim_stp if ( key == 'nts_sim' ) this % nts_sim = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_mobsam' ) this % nts_mobsam = int ( str_to_d ( val )) if ( key == 'nts_dump' ) this % nts_dump = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_samp' ) this % nts_samp = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_log' ) this % nts_log = int ( str_to_d ( val ), ip_long ) if ( key == 'lrevive' ) read ( val , * ) this % lrevive if ( key == 'read_seed' ) read ( val , * ) this % read_seed if ( key == 'write_seed' ) read ( val , * ) this % write_seed if ( key == 'write_traj' ) read ( val , * ) this % write_traj if ( key == 'fn_cfg' ) this % fn_cfg = val if ( key == 'fn_revive' ) this % fn_revive = val if ( key == 'fn_stats' ) this % fn_stats = val if ( key == 'fn_traj' ) this % fn_traj = val end do close ( fu ) end subroutine !****************************************************************************** subroutine control_write ( this , fn ) !! Write simulation parameters to file class ( ctrlpar_t ), intent ( out ) :: this !! A *ctrlpar_t* instance. character ( len =* ), intent ( in ) :: fn !! Output file name integer :: fu open ( newunit = fu , file = fn , action = 'write' , status = 'replace' ) write ( fu , '(a,t20,g0.6)' ) 'rcutoff' , this % rcutoff write ( fu , '(a,t20,g0.6)' ) 'tskin' , this % tskin write ( fu , '(a,t20,a)' ) 'mth_ptgen' , trim ( adjustl ( this % mth_ptgen )) write ( fu , '(a,t20,l1)' ) 'lelst' , this % lelst write ( fu , '(a,t20,l1)' ) 'lhdia' , this % lhdia write ( fu , '(a,t20,l1)' ) 'lvdw' , this % lvdw write ( fu , '(a,t20,i0)' ) 'excluded_atoms' , this % excluded_atoms write ( fu , '(a,t20,a)' ) 'mob_fctr' , this % mob_fctr write ( fu , '(a,t20,i0)' ) 'lanc_mxitr' , this % lanc_mxitr write ( fu , '(a,t20,a)' ) 'lanc_tol' , str_from_num ( this % lanc_tol , '(es24.15)' ) write ( fu , '(a,t20,a)' ) 'bdintg' , this % bdintg write ( fu , '(a,t20,i0)' ) 'se_nlmxitr' , this % se_nlmxitr write ( fu , '(a,t20,i0)' ) 'se_kdmax' , this % se_kdmax write ( fu , '(a,t20,es12.5,1x,es12.5)' ) 'se_tol' , this % se_tol write ( fu , '(a,t20,i0,1x,i0)' ) 'stats_binsize' , this % stats_binsize write ( fu , * ) write ( fu , '(a,t20,a)' ) 'tim_stp' , str_from_num ( this % tim_stp , '(es24.15)' ) write ( fu , '(a,t20,i0)' ) 'nts_sim' , this % nts_sim write ( fu , '(a,t20,i0)' ) 'nts_mobsam' , this % nts_mobsam write ( fu , '(a,t20,i0)' ) 'nts_dump' , this % nts_dump write ( fu , '(a,t20,i0)' ) 'nts_samp' , this % nts_samp write ( fu , '(a,t20,i0)' ) 'nts_log' , this % nts_log write ( fu , * ) write ( fu , '(a,t20,l1)' ) 'lrevive' , this % lrevive write ( fu , '(a,t20,l1)' ) 'read_seed' , this % read_seed write ( fu , '(a,t20,l1)' ) 'write_seed' , this % write_seed write ( fu , '(a,t20,l1)' ) 'write_traj' , this % write_traj write ( fu , * ) if ( allocated ( this % fn_cfg )) then write ( fu , '(a,t20,a)' ) 'fn_cfg' , this % fn_cfg else write ( fu , '(a)' ) 'fn_cfg' end if if ( allocated ( this % fn_revive )) then write ( fu , '(a,t20,a)' ) 'fn_revive' , this % fn_revive else write ( fu , '(a)' ) 'fn_revive' end if if ( allocated ( this % fn_stats )) then write ( fu , '(a,t20,a)' ) 'fn_stats' , this % fn_stats else write ( fu , '(a)' ) 'fn_stats' end if if ( allocated ( this % fn_traj )) then write ( fu , '(a,t20,a)' ) 'fn_traj' , this % fn_traj else write ( fu , '(a)' ) 'fn_traj' end if close ( fu ) end subroutine !****************************************************************************** end module control_m","tags":"","loc":"sourcefile/control_m.f90.html"},{"title":"main.f90 – BROWNPAK","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~logger_m.f90 logger_m.f90 sourcefile~main.f90->sourcefile~logger_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~main.f90->sourcefile~setup_m.f90 sourcefile~control_m.f90 control_m.f90 sourcefile~main.f90->sourcefile~control_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~main.f90->sourcefile~constants_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~main.f90->sourcefile~strings_m.f90 sourcefile~timestamp_m.f90 timestamp_m.f90 sourcefile~logger_m.f90->sourcefile~timestamp_m.f90 sourcefile~setup_m.f90->sourcefile~logger_m.f90 sourcefile~setup_m.f90->sourcefile~control_m.f90 sourcefile~setup_m.f90->sourcefile~constants_m.f90 sourcefile~setup_m.f90->sourcefile~strings_m.f90 sourcefile~config_io_m.f90 config_io_m.f90 sourcefile~setup_m.f90->sourcefile~config_io_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~setup_m.f90->sourcefile~atmcfg_m.f90 sourcefile~stats_m.f90 stats_m.f90 sourcefile~setup_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~trajectory_m.f90 trajectory_m.f90 sourcefile~setup_m.f90->sourcefile~trajectory_m.f90 sourcefile~random_m.f90 random_m.f90 sourcefile~setup_m.f90->sourcefile~random_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~simbox_m.f90 simbox_m.f90 sourcefile~setup_m.f90->sourcefile~simbox_m.f90 sourcefile~control_m.f90->sourcefile~constants_m.f90 sourcefile~control_m.f90->sourcefile~strings_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 sourcefile~config_io_m.f90->sourcefile~constants_m.f90 sourcefile~config_io_m.f90->sourcefile~strings_m.f90 sourcefile~config_io_m.f90->sourcefile~atmcfg_m.f90 sourcefile~config_io_m.f90->sourcefile~simbox_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 sourcefile~stats_m.f90->sourcefile~control_m.f90 sourcefile~stats_m.f90->sourcefile~constants_m.f90 sourcefile~stats_m.f90->sourcefile~strings_m.f90 sourcefile~stats_m.f90->sourcefile~atmcfg_m.f90 sourcefile~stats_m.f90->sourcefile~simbox_m.f90 sourcefile~bd_solver_m.f90->sourcefile~logger_m.f90 sourcefile~bd_solver_m.f90->sourcefile~control_m.f90 sourcefile~bd_solver_m.f90->sourcefile~constants_m.f90 sourcefile~bd_solver_m.f90->sourcefile~config_io_m.f90 sourcefile~bd_solver_m.f90->sourcefile~atmcfg_m.f90 sourcefile~bd_solver_m.f90->sourcefile~stats_m.f90 sourcefile~bd_solver_m.f90->sourcefile~trajectory_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~brown_m.f90 brown_m.f90 sourcefile~bd_solver_m.f90->sourcefile~brown_m.f90 sourcefile~trajectory_m.f90->sourcefile~constants_m.f90 sourcefile~random_m.f90->sourcefile~constants_m.f90 sourcefile~interaction_m.f90->sourcefile~control_m.f90 sourcefile~interaction_m.f90->sourcefile~constants_m.f90 sourcefile~interaction_m.f90->sourcefile~atmcfg_m.f90 sourcefile~interaction_m.f90->sourcefile~stats_m.f90 sourcefile~interaction_m.f90->sourcefile~simbox_m.f90 sourcefile~table_m.f90 table_m.f90 sourcefile~interaction_m.f90->sourcefile~table_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~ia_vdw_m.f90 ia_vdw_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_vdw_m.f90 sourcefile~ia_dihedral_m.f90 ia_dihedral_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_dihedral_m.f90 sourcefile~ia_external_m.f90 ia_external_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_external_m.f90 sourcefile~ia_angle_m.f90 ia_angle_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_angle_m.f90 sourcefile~ia_tether_m.f90 ia_tether_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_tether_m.f90 sourcefile~ia_bond_m.f90 ia_bond_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_bond_m.f90 sourcefile~simbox_m.f90->sourcefile~constants_m.f90 sourcefile~simbox_m.f90->sourcefile~random_m.f90 sourcefile~table_m.f90->sourcefile~constants_m.f90 sourcefile~vector_m.f90 vector_m.f90 sourcefile~table_m.f90->sourcefile~vector_m.f90 sourcefile~pairtab_m.fpp->sourcefile~constants_m.f90 sourcefile~pairtab_m.fpp->sourcefile~atmcfg_m.f90 sourcefile~pairtab_m.fpp->sourcefile~simbox_m.f90 sourcefile~pairtab_m.fpp->sourcefile~table_m.f90 sourcefile~cell_list_m.f90 cell_list_m.f90 sourcefile~pairtab_m.fpp->sourcefile~cell_list_m.f90 sourcefile~connectivity_m.f90 connectivity_m.f90 sourcefile~pairtab_m.fpp->sourcefile~connectivity_m.f90 sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~aabbtree_m.f90 sourcefile~pairtab_m.fpp->sourcefile~vector_m.f90 sourcefile~brown_m.f90->sourcefile~logger_m.f90 sourcefile~brown_m.f90->sourcefile~constants_m.f90 sourcefile~brown_m.f90->sourcefile~strings_m.f90 sourcefile~brown_m.f90->sourcefile~random_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~constants_m.f90 sourcefile~ia_vdw_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~constants_m.f90 sourcefile~ia_dihedral_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_external_m.f90->sourcefile~constants_m.f90 sourcefile~ia_external_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_angle_m.f90->sourcefile~constants_m.f90 sourcefile~ia_angle_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_tether_m.f90->sourcefile~constants_m.f90 sourcefile~ia_tether_m.f90->sourcefile~atmcfg_m.f90 sourcefile~ia_bond_m.f90->sourcefile~logger_m.f90 sourcefile~ia_bond_m.f90->sourcefile~constants_m.f90 sourcefile~ia_bond_m.f90->sourcefile~strings_m.f90 sourcefile~cell_list_m.f90->sourcefile~constants_m.f90 sourcefile~cell_list_m.f90->sourcefile~simbox_m.f90 sourcefile~cell_list_m.f90->sourcefile~vector_m.f90 sourcefile~connectivity_m.f90->sourcefile~constants_m.f90 sourcefile~connectivity_m.f90->sourcefile~table_m.f90 sourcefile~connectivity_m.f90->sourcefile~vector_m.f90 sourcefile~aabbtree_m.f90->sourcefile~constants_m.f90 sourcefile~aabbtree_m.f90->sourcefile~strings_m.f90 sourcefile~aabbtree_m.f90->sourcefile~vector_m.f90 sourcefile~aabb_m.fpp aabb_m.fpp sourcefile~aabbtree_m.f90->sourcefile~aabb_m.fpp sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~aabb_m.fpp->sourcefile~constants_m.f90 sourcefile~aabb_m.fpp->sourcefile~strings_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs main Source Code main.f90 Source Code !********************************************************************************! ! The MIT License (MIT)                                                          ! !                                                                                ! ! Copyright (c) 2020 Sarit Dutta <saridut@gmail.com>                             ! !                                                                                ! ! Permission is hereby granted, free of charge, to any person obtaining a copy   ! ! of this software and associated documentation files (the \"Software\"), to deal  ! ! in the Software without restriction, including without limitation the rights   ! ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      ! ! copies of the Software, and to permit persons to whom the Software is          ! ! furnished to do so, subject to the following conditions:                       ! !                                                                                ! ! The above copyright notice and this permission notice shall be included in all ! ! copies or substantial portions of the Software.                                ! !                                                                                ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     ! ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       ! ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    ! ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         ! ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  ! ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  ! ! SOFTWARE.                                                                      ! !********************************************************************************! program main use constants_m use strings_m use logger_m use control_m use setup_m implicit none !******************************************************************************* character ( len = 64 ) :: cla character ( len = :), allocatable :: key character ( len = :), allocatable :: val character ( len = :), allocatable :: job_tag character ( len = :), allocatable :: fn_control type ( ctrlpar_t ) :: cpar integer :: ierr integer :: icla integer :: ncla ! number of command line arguments, without the command name !Two command line arguments may be provided -- (i) fn_control=val and !(ii) job_tag=val ! !Usage: ./brownpak fn_control=<str> job_tag=<int> fn_control = 'control.txt' ncla = command_argument_count () do icla = 1 , ncla call get_command_argument ( icla , value = cla , status = ierr ) if ( ierr > 0 ) then write ( * , '(a,1x,i0)' ) \"read failure for command argument\" , icla stop else if ( ierr == - 1 ) then write ( * , '(a,1x,i0)' ) \"command argument truncated\" , icla stop end if call str_get_keyval ( cla , key , val , '=' ) if ( key == 'fn_control' ) then fn_control = val else if ( key == 'job_tag' ) then job_tag = '.' // val end if end do call cpar % read ( fn_control ) call logger % init ( 'brownpak.log' // job_tag , . true .) call run ( cpar , job_tag ) call logger % finish () !******************************************************************************* end program","tags":"","loc":"sourcefile/main.f90.html"},{"title":"aabb_m.fpp – BROWNPAK","text":"This file depends on sourcefile~~aabb_m.fpp~~EfferentGraph sourcefile~aabb_m.fpp aabb_m.fpp sourcefile~strings_m.f90 strings_m.f90 sourcefile~aabb_m.fpp->sourcefile~strings_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~aabb_m.fpp->sourcefile~constants_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~aabb_m.fpp~~AfferentGraph sourcefile~aabb_m.fpp aabb_m.fpp sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~aabbtree_m.f90->sourcefile~aabb_m.fpp sourcefile~aabbtree_sm.fpp aabbtree_sm.fpp sourcefile~aabbtree_sm.fpp->sourcefile~aabbtree_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~pairtab_m.fpp->sourcefile~aabbtree_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules aabb_m Source Code aabb_m.fpp Source Code ! This code is adapted from the C++ implementation by ! [Lester Hedges](http://lesterhedges.net). The original ! C++ implementation can be found [here](https://github.com/lohedges/aabbcc#readme). ! ! The zlib/libpng License (Zlib) ! ! Copyright (c) 2009 Erin Catto http://www.box2d.org ! Copyright (c) 2016 Lester Hedges <lester.hedges+aabbcc@gmail.com> ! ! This software is provided 'as-is', without any express or implied ! warranty. In no event will the authors be held liable for any damages ! arising from the use of this software. ! ! Permission is granted to anyone to use this software for any purpose, ! including commercial applications, and to alter it and redistribute it ! freely, subject to the following restrictions: ! ! 1. The origin of this software must not be misrepresented; you must not !    claim that you wrote the original software. If you use this software !    in a product, an acknowledgment in the product documentation would be !    appreciated but is not required. ! ! 2. Altered source versions must be plainly marked as such, and must not be !    misrepresented as being the original software. ! ! 3. This notice may not be removed or altered from any source distribution. ! ! This code was adapted from parts of the Box2D Physics Engine, ! http://www.box2d.org #:include 'asserts.fypp' module aabb_m use constants_m use strings_m implicit none type aabb_t real ( rp ), dimension ( 3 ) :: lbnd real ( rp ), dimension ( 3 ) :: ubnd real ( rp ), dimension ( 3 ) :: center real ( rp ) :: srfarea contains procedure :: init => aabb_init procedure :: print => aabb_print procedure :: clear => aabb_clear procedure :: get_extent => aabb_get_extent procedure :: update => aabb_update procedure :: fatten => aabb_fatten procedure :: includes => aabb_includes procedure :: overlaps => aabb_overlaps procedure , private :: calc_center => aabb_calc_center procedure , private :: calc_srfarea => aabb_calc_srfarea end type aabb_t interface operator ( + ) module procedure :: aabb_union end interface contains !******************************************************************************* subroutine aabb_init ( this , lbnd , ubnd ) !! Initializes an *aabb_t* instance from lower and upper bounds. class ( aabb_t ), intent ( out ) :: this !! An *aabb_t* instance. real ( rp ), dimension ( 3 ), intent ( in ) :: lbnd !! Lower bound real ( rp ), dimension ( 3 ), intent ( in ) :: ubnd !! Upper bound @ : ASSERT ( all ( lbnd <= ubnd )) this % lbnd = lbnd ; this % ubnd = ubnd call this % calc_center () call this % calc_srfarea () end subroutine !******************************************************************************* subroutine aabb_print ( this , frmt , str ) !! Prints an AABB. class ( aabb_t ), intent ( in ) :: this !! An *aabb_t* instance. character ( len =* ), intent ( in ), optional :: frmt !! Fortran-style format string for a real number. Default: *(g0.6)*. character ( len = :), allocatable , intent ( out ), optional :: str !! If present, the output is printed to this string instead of STDOUT. character ( len = :), allocatable :: frmt_ , buf frmt_ = '(g0.6)' if ( present ( frmt )) frmt_ = trim ( adjustl ( frmt )) buf = 'lbnd: [' // str_from_num ( this % lbnd ( 1 ), frmt_ ) // ', ' & & // str_from_num ( this % lbnd ( 2 ), frmt_ ) // ', ' & & // str_from_num ( this % lbnd ( 3 ), frmt_ ) // ']' buf = buf // ', ubnd: [' // str_from_num ( this % ubnd ( 1 ), frmt_ ) // ', ' & & // str_from_num ( this % ubnd ( 2 ), frmt_ ) // ', ' & & // str_from_num ( this % ubnd ( 3 ), frmt_ ) // ']' buf = buf // ', center: [' // str_from_num ( this % center ( 1 ), frmt_ ) // ', ' & & // str_from_num ( this % center ( 2 ), frmt_ ) // ', ' & & // str_from_num ( this % center ( 3 ), frmt_ ) // ']' buf = buf // ', srfarea: ' // str_from_num ( this % srfarea , frmt_ ) if ( present ( str )) then str = buf else write ( * , * ) buf end if end subroutine !******************************************************************************* subroutine aabb_clear ( this ) !! Clears all attributes of an AABB and sets them to zero. class ( aabb_t ), intent ( in out ) :: this !! An *aabb_t* instance. this % lbnd = 0.0_rp ; this % ubnd = 0.0_rp this % center = 0.0_rp ; this % srfarea = 0.0_rp end subroutine !******************************************************************************* subroutine aabb_get_extent ( this , extent ) !! Calculates the extent of an *aabb*. The *extent* of an AABB is defined as !! the difference between its upper and lower bounds. class ( aabb_t ), intent ( in ) :: this !! An *aabb_t* instance. real ( rp ), dimension ( 3 ), intent ( out ) :: extent !! Extent of an AABB. extent = this % ubnd - this % lbnd end subroutine !******************************************************************************* subroutine aabb_update ( this , lbnd , ubnd ) !! Updates an AABB with new bounds. class ( aabb_t ), intent ( in out ) :: this !! An *aabb_t* instance. real ( rp ), dimension ( 3 ), intent ( in ), optional :: lbnd !! Lower bound real ( rp ), dimension ( 3 ), intent ( in ), optional :: ubnd !! Upper bound !Nothing to do if no bounds are present if ( (. not . present ( lbnd )) . and . (. not . present ( ubnd )) ) return !Update bounds based on input if ( present ( lbnd )) this % lbnd = lbnd if ( present ( ubnd )) this % ubnd = ubnd @ : ASSERT ( all ( this % lbnd <= this % ubnd ) ) call this % calc_center () call this % calc_srfarea () end subroutine !******************************************************************************* subroutine aabb_fatten ( this , frac ) !! Fattens an AABB by a fraction of its base extent. class ( aabb_t ), intent ( in out ) :: this !! An *aabb_t* instance. real ( rp ), intent ( in ) :: frac !! Fraction of AABB base extent. real ( rp ), dimension ( 3 ) :: extent extent = this % ubnd - this % lbnd !New bounds this % lbnd = this % lbnd - frac * extent ; this % ubnd = this % ubnd + frac * extent @ : ASSERT ( all ( this % lbnd <= this % ubnd ) ) call this % calc_center () call this % calc_srfarea () end subroutine !******************************************************************************* function aabb_includes ( this , other ) result ( res ) !! Returns *true* if *this* includes *other*, *false* otherwise. Inclusion !! is considered in a strict sense. class ( aabb_t ), intent ( in ) :: this !! An *aabb_t* instance. type ( aabb_t ), intent ( in ) :: other !! An *aabb_t* instance. logical :: res res = ( all ( this % lbnd < other % lbnd ) . and . all ( this % ubnd > other % ubnd ) ) end function !******************************************************************************* function aabb_overlaps ( this , other ) result ( res ) !! Returns *true* if *this* overlaps *other*, *false* otherwise. Touching !! does not count as an overlap. class ( aabb_t ), intent ( in ) :: this !! An *aabb_t* instance. type ( aabb_t ), intent ( in ) :: other !! An *aabb_t* instance. logical :: res res = ( all ( this % ubnd > other % lbnd ) . and . all ( other % ubnd > this % lbnd ) ) end function !******************************************************************************* function aabb_union ( x , y ) result ( z ) !! Combines AABBs *x* and *y* to return a new AABB *z*. type ( aabb_t ), intent ( in ) :: x !! An *aabb_t* instance. type ( aabb_t ), intent ( in ) :: y !! An *aabb_t* instance. type ( aabb_t ) :: z z % lbnd = merge ( x % lbnd , y % lbnd , ( x % lbnd < y % lbnd ) ) z % ubnd = merge ( x % ubnd , y % ubnd , ( x % ubnd > y % ubnd ) ) call z % calc_center () call z % calc_srfarea () end function !******************************************************************************* subroutine aabb_calc_center ( this ) !! Calculates the center of an *aabb*. class ( aabb_t ), intent ( in out ) :: this !! An *aabb_t* instance. this % center = 0.5_rp * ( this % ubnd + this % lbnd ) end subroutine !******************************************************************************* subroutine aabb_calc_srfarea ( this ) !! Calculates the surface area of an *aabb*. class ( aabb_t ), intent ( in out ) :: this !! An *aabb_t* instance. real ( rp ) :: dx , dy , dz dx = this % ubnd ( 1 ) - this % lbnd ( 1 ) dy = this % ubnd ( 2 ) - this % lbnd ( 2 ) dz = this % ubnd ( 3 ) - this % lbnd ( 3 ) this % srfarea = 2.0_rp * ( dx * dy + dx * dz + dy * dz ) end subroutine !******************************************************************************* end module aabb_m","tags":"","loc":"sourcefile/aabb_m.fpp.html"},{"title":"ia_tether_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~ia_tether_m.f90~~EfferentGraph sourcefile~ia_tether_m.f90 ia_tether_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~ia_tether_m.f90->sourcefile~constants_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~ia_tether_m.f90->sourcefile~atmcfg_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ia_tether_m.f90~~AfferentGraph sourcefile~ia_tether_m.f90 ia_tether_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_tether_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ia_tether_m Source Code ia_tether_m.f90 Source Code module ia_tether_m !! Tether potentials !! !! *Style 0: None !! *Style 1: Rigid connector (not implemented) !! *Style 2: Harmonic spring. See [[teth_harm_set]]. use constants_m use atmcfg_m implicit none private public :: ia_tether_setup , ia_get_tether_force contains !****************************************************************************** subroutine ia_tether_setup ( num_tether_types , tether_styles , tether_params ) !! Sets up parameters for tether potentials integer , intent ( in ) :: num_tether_types !! Number of tether types integer , dimension (:), intent ( in ) :: tether_styles !! Styles for each type real ( rp ), dimension (:,:), intent ( in out ) :: tether_params !! Parameters for each type, depending on style integer :: i , sty !Set tether interactions do i = 1 , num_tether_types sty = tether_styles ( i ) select case ( sty ) case ( 1 ) call teth_rigid_set ( tether_params (:, i )) case ( 2 ) call teth_harm_set ( tether_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_tether_force ( qmag , sty , params , enrg , frc , ierr ) !! Calculates the energy and its derivative due to a tether. real ( rp ), intent ( in ) :: qmag !! Distance between the tethered atom & the tether point integer , intent ( in ) :: sty !! Tether style real ( rp ), dimension (:), intent ( in ) :: params !! Parameters for tether interaction real ( rp ), intent ( out ) :: enrg !! Energy due to this tether real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr !! Error flag ierr = 0 enrg = 0.0_rp ; frc = 0.0_rp select case ( sty ) case ( 1 ) call teth_rigid ( qmag , params , enrg , frc , ierr ) case ( 2 ) call teth_harm ( qmag , params , enrg , frc ) case default continue end select end subroutine !******************************************************************************** subroutine teth_rigid_set ( params , r0 , eps ) !! Setter for rigid tether interaction. !! !! User-set parameters: !! !! * params(1) = `r0` (fixed separation distance) !! * params(2) = `eps` (allowed tolerance) real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: r0 real ( rp ), intent ( in ), optional :: eps if ( present ( r0 )) params ( 1 ) = r0 if ( present ( eps )) params ( 2 ) = eps end subroutine !******************************************************************************** subroutine teth_rigid ( r , params , enrg , frc , ierr ) !! Not implemented, needs constraint formalism. See [[teth_rigid_set]]. !! !! Calculates energy for rigid tether interaction. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp if ( abs ( r - params ( 1 )) < params ( 2 ) ) then enrg = 0.0_rp ; frc = 0.0_rp else ierr = 1 return end if end subroutine !******************************************************************************** !params(1) = k, params(2) = r0 (equilibrium distance) subroutine teth_harm_set ( params , k , r0 ) !! Setter for harmonic tether interaction. !! !!``` !!  U = (1/2)*k*(r - r0)&#94;2 !!``` !! User-set parameters: !! !! * params(1) = `k` (spring constant) !! * params(2) = `r0` (equilibrium distance) real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: r0 if ( present ( k )) params ( 1 ) = k if ( present ( r0 )) params ( 2 ) = r0 end subroutine !******************************************************************************** subroutine teth_harm ( r , params , enrg , frc ) !! Calculates energy and its derivative for harmonic tether interaction. See !! [[teth_harm_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc enrg = 0.5_rp * params ( 1 ) * ( r - params ( 2 )) * ( r - params ( 2 )) frc = params ( 1 ) * ( r - params ( 2 )) end subroutine !****************************************************************************** end module ia_tether_m","tags":"","loc":"sourcefile/ia_tether_m.f90.html"},{"title":"table_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~table_m.f90~~EfferentGraph sourcefile~table_m.f90 table_m.f90 sourcefile~vector_m.f90 vector_m.f90 sourcefile~table_m.f90->sourcefile~vector_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~table_m.f90->sourcefile~constants_m.f90 sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~table_m.f90~~AfferentGraph sourcefile~table_m.f90 table_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~table_m.f90 sourcefile~pairtab_m.fpp pairtab_m.fpp sourcefile~interaction_m.f90->sourcefile~pairtab_m.fpp sourcefile~pairtab_m.fpp->sourcefile~table_m.f90 sourcefile~connectivity_m.f90 connectivity_m.f90 sourcefile~pairtab_m.fpp->sourcefile~connectivity_m.f90 sourcefile~connectivity_m.f90->sourcefile~table_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules table_m Source Code table_m.f90 Source Code module table_m !! Implements a table with contiguously stored rows. use constants_m use vector_m implicit none private public :: itable_t public :: itbl_init type itable_t integer :: num_rows = 0 !Must be > 0 type ( ivector_t ) :: buffer integer , dimension (:), allocatable :: row_indx contains procedure :: delete => itbl_delete procedure :: clear => itbl_clear procedure :: append => itbl_append procedure :: set_val => itbl_set_val procedure :: is_in => itbl_is_in procedure :: get_val => itbl_get_val procedure :: get_row => itbl_get_row procedure :: shrink_to_fit => itbl_shrink_to_fit procedure :: print => itbl_print end type itable_t contains !****************************************************************************** subroutine itbl_init ( this , num_rows , ierr ) !! Creates an empty *itable_t* with *num_rows* rows and all rows having !! zero elements. type ( itable_t ), intent ( in out ) :: this integer , intent ( in ) :: num_rows !! Must be > 0 integer , intent ( out ), optional :: ierr integer :: istat if ( present ( ierr )) ierr = 0 !Set initial size guess to be num_rows call ivector_init ( this % buffer , num_rows ) allocate ( this % row_indx ( num_rows + 1 ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for this%row_indx of size' , num_rows if ( present ( ierr )) ierr = 1 return end if !Set the number of rows this % num_rows = num_rows !Empty table: All rows have zero elements this % row_indx = 1 end subroutine !****************************************************************************** subroutine itbl_delete ( this ) !! Deletes an *itable_t*. No access is allowed to this object after this call. class ( itable_t ), intent ( in out ) :: this call this % buffer % delete () if ( allocated ( this % row_indx )) deallocate ( this % row_indx ) this % num_rows = 0 end subroutine !****************************************************************************** subroutine itbl_clear ( this ) !! Clears all rows. Does not deallocate memory. class ( itable_t ), intent ( in out ) :: this call this % buffer % clear () this % row_indx = 1 end subroutine !****************************************************************************** subroutine itbl_append ( this , irow , val ) !! Appends an element `val` to row *irow*. class ( itable_t ), intent ( in out ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: val call this % buffer % append ( val ) this % row_indx ( irow + 1 :) = this % row_indx ( irow + 1 :) + 1 end subroutine !****************************************************************************** subroutine itbl_set_val ( this , irow , j , val ) !! Sets the value of the *j*th element of row *irow*. class ( itable_t ), intent ( in out ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: j integer , intent ( in ) :: val integer :: k , n n = this % row_indx ( irow + 1 ) - this % row_indx ( irow ) if ( j > n ) then write ( * , * ) 'error: out-of-bounds index ' , j write ( * , * ) 'for row length' , n stop else k = this % row_indx ( irow ) + j - 1 call this % buffer % set_val ( k , val ) end if end subroutine !****************************************************************************** function itbl_is_in ( this , irow , val ) result ( res ) !! Returns .true. if *val* is in row *irow*, .false. otherwise. class ( itable_t ), intent ( in ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: val logical :: res integer :: i res = . false . do i = this % row_indx ( irow ), this % row_indx ( irow + 1 ) - 1 if ( this % buffer % get_val ( i ) == val ) then res = . true . exit end if end do end function !****************************************************************************** function itbl_get_val ( this , irow , j ) result ( res ) !! Returns the *j*th element of row *irow* class ( itable_t ), intent ( in ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: j integer :: res integer :: k , n n = this % row_indx ( irow + 1 ) - this % row_indx ( irow ) if ( j > n ) then write ( * , * ) 'error: out-of-bounds index ' , j write ( * , * ) 'for row length' , n stop else k = this % row_indx ( irow ) + j - 1 res = this % buffer % get_val ( k ) end if end function !****************************************************************************** subroutine itbl_get_row ( this , irow , res ) !! Returns a pointer to the row data of *irow*. No bounds checking is performed. class ( itable_t ), target , intent ( in ) :: this integer , intent ( in ) :: irow integer , dimension (:), pointer , intent ( out ) :: res integer :: ibeg , iend res => null () ibeg = this % row_indx ( irow ) iend = this % row_indx ( irow + 1 ) - 1 call this % buffer % get_data ( res , ibeg , iend ) end subroutine !****************************************************************************** subroutine itbl_shrink_to_fit ( this , ierr ) !! Releases additional memory to fit underlying data. class ( itable_t ), intent ( in out ) :: this integer , intent ( out ), optional :: ierr if ( present ( ierr )) then call this % buffer % shrink_to_fit ( ierr ) else call this % buffer % shrink_to_fit () end if end subroutine !****************************************************************************** subroutine itbl_print ( this ) !! Prints an *itable_t*. class ( itable_t ), intent ( in ) :: this integer :: i , j do i = 1 , this % num_rows write ( * , '(i0,\": \",2x)' , advance = 'no' ) i do j = this % row_indx ( i ), this % row_indx ( i + 1 ) - 1 write ( * , '(i0,2x)' , advance = 'no' ) this % buffer % get_val ( j ) end do write ( * , * ) end do end subroutine !****************************************************************************** end module table_m","tags":"","loc":"sourcefile/table_m.f90.html"},{"title":"logger_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~logger_m.f90~~EfferentGraph sourcefile~logger_m.f90 logger_m.f90 sourcefile~timestamp_m.f90 timestamp_m.f90 sourcefile~logger_m.f90->sourcefile~timestamp_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~logger_m.f90~~AfferentGraph sourcefile~logger_m.f90 logger_m.f90 sourcefile~brown_m.f90 brown_m.f90 sourcefile~brown_m.f90->sourcefile~logger_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~logger_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90->sourcefile~logger_m.f90 sourcefile~bd_solver_m.f90->sourcefile~brown_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~ia_bond_m.f90 ia_bond_m.f90 sourcefile~ia_bond_m.f90->sourcefile~logger_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~logger_m.f90 sourcefile~main.f90->sourcefile~setup_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_bond_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules logger_m Source Code logger_m.f90 Source Code !********************************************************************************! ! The MIT License (MIT)                                                          ! !                                                                                ! ! Copyright (c) 2020 Sarit Dutta <saridut@gmail.com>                             ! !                                                                                ! ! Permission is hereby granted, free of charge, to any person obtaining a copy   ! ! of this software and associated documentation files (the \"Software\"), to deal  ! ! in the Software without restriction, including without limitation the rights   ! ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      ! ! copies of the Software, and to permit persons to whom the Software is          ! ! furnished to do so, subject to the following conditions:                       ! !                                                                                ! ! The above copyright notice and this permission notice shall be included in all ! ! copies or substantial portions of the Software.                                ! !                                                                                ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     ! ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       ! ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    ! ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         ! ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  ! ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  ! ! SOFTWARE.                                                                      ! !********************************************************************************! module logger_m !! Implements a basic logger. use iso_fortran_env , only : output_unit use timestamp_m , only : timestring implicit none private public :: logger type logger_t character ( len = :), allocatable :: fn !! Name of the log file integer :: fu = huge ( 0 ) !! Unit number of the log file logical :: is_open = . false . !! Is the log file open for writing? {T/F} contains procedure :: init => logger_init procedure :: finish => logger_finish procedure :: log_msg => logger_log_msg end type logger_t type ( logger_t ) :: logger contains !******************************************************************************** subroutine logger_init ( this , fn , use_stdout ) !! Initializes a logger. class ( logger_t ), intent ( out ) :: this !! A `logger_t` instance character ( len =* ), intent ( in ) :: fn !! Name of the log file. If `use_stdout` is true, `fn` is ignored. logical , intent ( in ) :: use_stdout !! Write all log messages to stdout rather than a file on disk? {T/F} integer :: ierr !Create a new log file and open it for writing. if ( use_stdout ) then this % fu = output_unit this % is_open = . true . else open ( newunit = this % fu , file = fn , action = 'write' , status = 'replace' , & iostat = ierr ) if ( ierr /= 0 ) then write ( * , '(a,i0)' ) 'error in opening log file; err code = ' , ierr else this % fn = fn this % is_open = . true . end if end if call this % log_msg ( 'start log' ) end subroutine !******************************************************************************** subroutine logger_finish ( this ) !! Cleanup routine for a `logger_t` instance. class ( logger_t ), intent ( in out ) :: this !! A `logger_t` instance call this % log_msg ( 'end log' ) if ( this % is_open . and . ( this % fu /= output_unit )) then close ( this % fu ) this % is_open = . false . this % fu = huge ( 0 ) end if end subroutine !******************************************************************************** subroutine logger_log_msg ( this , msg ) !! Write a message to the log file. class ( logger_t ), intent ( in ) :: this !! A `logger_t` instance character ( len =* ), intent ( in ) :: msg !! Message to write to the log file character ( len = 40 ) :: timstmp call timestring ( timstmp ) write ( this % fu , \"('[',a,']',1x,a)\" ) trim ( adjustl ( timstmp )), & trim ( adjustl ( msg )) flush ( this % fu ) end subroutine !******************************************************************************** end module logger_m","tags":"","loc":"sourcefile/logger_m.f90.html"},{"title":"aabbtree_sm.fpp – BROWNPAK","text":"This file depends on sourcefile~~aabbtree_sm.fpp~~EfferentGraph sourcefile~aabbtree_sm.fpp aabbtree_sm.fpp sourcefile~aabbtree_m.f90 aabbtree_m.f90 sourcefile~aabbtree_sm.fpp->sourcefile~aabbtree_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~aabbtree_m.f90->sourcefile~constants_m.f90 sourcefile~aabb_m.fpp aabb_m.fpp sourcefile~aabbtree_m.f90->sourcefile~aabb_m.fpp sourcefile~vector_m.f90 vector_m.f90 sourcefile~aabbtree_m.f90->sourcefile~vector_m.f90 sourcefile~strings_m.f90 strings_m.f90 sourcefile~aabbtree_m.f90->sourcefile~strings_m.f90 sourcefile~aabb_m.fpp->sourcefile~constants_m.f90 sourcefile~aabb_m.fpp->sourcefile~strings_m.f90 sourcefile~vector_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90 qsort_m.f90 sourcefile~vector_m.f90->sourcefile~qsort_m.f90 sourcefile~strings_m.f90->sourcefile~constants_m.f90 sourcefile~qsort_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules aabbtree_sm Source Code aabbtree_sm.fpp Source Code #: include 'asserts.fypp' submodule ( aabbtree_m ) aabbtree_sm implicit none contains !******************************************************************************* module subroutine node_init ( this ) class ( node_t ), intent ( out ) :: this real ( rp ), dimension ( 3 ) :: lbnd , ubnd this % next = NULL_NODE this % parent = NULL_NODE ; this % left = NULL_NODE ; this % right = NULL_NODE this % height = - 1 ; this % atom = 0 lbnd = 0.0_rp ; ubnd = 0.0_rp call this % aabb % init ( lbnd , ubnd ) end subroutine !******************************************************************************* module function node_isleaf ( this ) result ( res ) class ( node_t ), intent ( in ) :: this logical :: res res = ( this % left == null_node ) end function !******************************************************************************* module function node_asstr ( this , frmt ) result ( buf ) class ( node_t ), intent ( in ) :: this character ( len =* ), intent ( in ), optional :: frmt character ( len = :), allocatable :: buf character ( len = :), allocatable :: aabb_str buf = '{' buf = buf // 'next: ' // str_from_num ( this % next ) buf = buf // ', parent: ' // str_from_num ( this % parent ) buf = buf // ', left: ' // str_from_num ( this % left ) buf = buf // ', right: ' // str_from_num ( this % right ) buf = buf // ', height: ' // str_from_num ( this % height ) buf = buf // ', atom: ' // str_from_num ( this % atom ) if ( present ( frmt )) then call this % aabb % print ( frmt = frmt , str = aabb_str ) else call this % aabb % print ( str = aabb_str ) end if buf = buf // ', aabb: {' // aabb_str // '}' buf = buf // '}' end function !******************************************************************************* module subroutine init ( this , natoms , tskin ) class ( aabbtree_t ), intent ( out ) :: this integer , intent ( in ) :: natoms real ( rp ), intent ( in ) :: tskin integer :: i this % capacity = natoms ; this % tskin = tskin this % size = 0 allocate ( this % nodes ( this % capacity )) !Initially all nodes belong the free store. do i = 1 , this % capacity call this % nodes ( i )% init () this % nodes ( i )% next = i + 1 end do this % nodes ( this % capacity )% next = NULL_NODE this % freestore = 1 !Head of the free store points to the first node this % root = NULL_NODE allocate ( this % atnd_tab ( natoms )); this % atnd_tab = 0 !Initialize the stack call ivector_init ( stack ) end subroutine !******************************************************************************* module recursive subroutine print ( this , p ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ), optional :: p integer :: p_ p_ = this % root if ( present ( p )) p_ = p !Nothing to do for an empty tree if ( p_ == NULL_NODE ) return !If the tree is not empty call this % print ( this % nodes ( p_ )% left ) write ( * , '(i0,\": \",a)' ) p_ , this % nodes ( p_ )% asstr () call this % print ( this % nodes ( p_ )% right ) end subroutine !******************************************************************************* module subroutine clear ( this ) class ( aabbtree_t ), intent ( in out ) :: this integer :: i !Return all nodes in the tree to the free store do i = 1 , this % capacity if ( this % nodes ( i )% height < 0 ) cycle call this % fs_return ( i ) end do this % atnd_tab = 0 ; this % tskin = 0.0_rp this % root = NULL_NODE @ : ASSERT ( this % size == 0 ) call stack % clear () end subroutine !******************************************************************************* module subroutine delete ( this ) class ( aabbtree_t ), intent ( in out ) :: this if ( allocated ( this % nodes )) deallocate ( this % nodes ) if ( allocated ( this % atnd_tab )) deallocate ( this % atnd_tab ) this % capacity = 0 ; this % size = 0 ; this % tskin = 0.0_rp this % root = NULL_NODE ; this % freestore = NULL_NODE call stack % delete () end subroutine !******************************************************************************* module subroutine insert ( this , ia , pos , radius ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: ia real ( rp ), dimension ( 3 ), intent ( in ) :: pos real ( rp ), intent ( in ) :: radius real ( rp ), dimension ( 3 ) :: lbnd , ubnd , extent integer :: p !If atom already exists, nothing to do. if ( this % atnd_tab ( ia ) > 0 ) return !Get a new node from the free store p = this % fs_acquire () !Prepare the new node lbnd = pos - radius ; ubnd = pos + radius extent = ubnd - lbnd !Adjust bounds for a fattened AABB. lbnd = lbnd - this % tskin * extent ; ubnd = ubnd + this % tskin * extent !Initialize AABB with bounds call this % nodes ( p )% aabb % init ( lbnd , ubnd ) !Set atom this % nodes ( p )% atom = ia !Set node height to zero as this will be a leaf node this % nodes ( p )% height = 0 !Insert node as a leaf call this % insert_leaf ( p ) !Update atnd_tab this % atnd_tab ( ia ) = p end subroutine !******************************************************************************* module subroutine remove ( this , ia ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: ia integer :: p !Get the leaf containing atom ia. p = this % atnd_tab ( ia ) !Mark the slot in atnd_tab as vacant. this % atnd_tab ( ia ) = 0 @ : ASSERT ( p <= this % capacity ) @ : ASSERT ( this % nodes ( p )% isleaf () ) !Remove the leaf from the tree. call this % remove_leaf ( p ) !Return the removed node to the free store. call this % fs_return ( p ) end subroutine !******************************************************************************* module subroutine remove_all ( this ) class ( aabbtree_t ), intent ( in out ) :: this integer :: ia do ia = 1 , size ( this % atnd_tab ) if ( this % atnd_tab ( ia ) > 0 ) call this % remove ( ia ) end do end subroutine !******************************************************************************* module subroutine update_fatm ( this , ia , pos , radius , lstat ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: ia real ( rp ), dimension ( 3 ), intent ( in ) :: pos real ( rp ), intent ( in ) :: radius logical , intent ( out ) :: lstat real ( rp ), dimension ( 3 ) :: lbnd , ubnd lbnd = pos - radius ; ubnd = pos + radius call this % update ( ia , lbnd , ubnd , lstat ) end subroutine !******************************************************************************* module subroutine update_fatmaabb ( this , ia , lbnd , ubnd , lstat ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: ia real ( rp ), dimension ( 3 ), intent ( in ) :: lbnd real ( rp ), dimension ( 3 ), intent ( in ) :: ubnd logical , intent ( out ) :: lstat type ( aabb_t ) :: aabb integer :: p lstat = . false . !Get the leaf containing atom ia. p = this % atnd_tab ( ia ) !Initialize a new AABB call aabb % init ( lbnd , ubnd ) !No need to update if the atom is still within its fattened AABB if ( this % nodes ( p )% aabb % includes ( aabb ) ) then return else !Remove the current leaf call this % remove_leaf ( p ) !Fatten the new AABB call aabb % fatten ( this % tskin ) !Assign the new AABB this % nodes ( p )% aabb = aabb !Insert a new leaf node call this % insert_leaf ( p ) lstat = . true . end if end subroutine !******************************************************************************* module subroutine query_watm ( this , ia , nbrs ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ) :: ia type ( ivector_t ), intent ( in out ) :: nbrs integer :: p !Test overlap for atom ia against all other atoms p = this % atnd_tab ( ia ) call this % query ( ia , this % nodes ( p )% aabb , nbrs ) end subroutine !******************************************************************************* module subroutine query_watmaabb ( this , ia , aabb , nbrs ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ) :: ia type ( aabb_t ), intent ( in ) :: aabb type ( ivector_t ), intent ( in out ) :: nbrs integer :: p , ja call stack % clear () call nbrs % clear () !First push the root node onto a stack call stack % append ( this % root ) do if ( stack % len == 0 ) exit p = stack % pop () if ( p == NULL_NODE ) cycle !Test for overlap between AABBs if ( aabb % overlaps ( this % nodes ( p )% aabb ) ) then !Check if this is a leaf node if ( this % nodes ( p )% isleaf () ) then !Can't interact with itself ja = this % nodes ( p )% atom if ( ja /= ia ) call nbrs % append ( ja ) else call stack % append ( this % nodes ( p )% left ) call stack % append ( this % nodes ( p )% right ) end if end if end do end subroutine !******************************************************************************* module subroutine query_waabb ( this , aabb , atms ) class ( aabbtree_t ), intent ( in ) :: this type ( aabb_t ), intent ( in ) :: aabb type ( ivector_t ), intent ( in out ) :: atms !If tree is empty return an empty vector if ( this % size == 0 ) then call atms % clear (); return else !Test overlap of AABB against all leaf AABBs call this % query ( huge ( 0 ), aabb , atms ) end if end subroutine !******************************************************************************* module function get_num_atoms ( this ) result ( na ) class ( aabbtree_t ), intent ( in ) :: this integer :: na na = count ( this % atnd_tab > 0 ) end function !******************************************************************************* module function get_aabb ( this , ia ) result ( aabb ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ) :: ia type ( aabb_t ) :: aabb integer :: p p = this % atnd_tab ( ia ) aabb = this % nodes ( p )% aabb end function !******************************************************************************* module function get_height ( this ) result ( height ) class ( aabbtree_t ), intent ( in ) :: this integer :: height if ( this % root == NULL_NODE ) then height = 0 else height = this % nodes ( this % root )% height end if end function !******************************************************************************* module function get_max_balance ( this ) result ( max_balance ) class ( aabbtree_t ), intent ( in ) :: this integer :: max_balance integer :: i , balance , left , right max_balance = 0 !Loop over all nodes (including those in the free store) do i = 1 , this % capacity if ( this % nodes ( i )% height <= 1 ) cycle left = this % nodes ( i )% left ; right = this % nodes ( i )% right balance = abs ( this % nodes ( left )% height - this % nodes ( right )% height ) max_balance = max ( max_balance , balance ) end do end function !******************************************************************************* module function get_srfarea_ratio ( this ) result ( saratio ) class ( aabbtree_t ), intent ( in ) :: this real ( rp ) :: saratio real ( rp ) :: area_root , area_tot integer :: i if ( this % root == NULL_NODE ) then saratio = 0.0_rp ; return end if area_root = this % nodes ( this % root )% aabb % srfarea area_tot = 0.0_rp !Loop over all nodes do i = 1 , this % capacity !Ignore nodes in the free store if ( this % nodes ( i )% height < 0 ) cycle area_tot = area_tot + this % nodes ( i )% aabb % srfarea end do saratio = area_tot / area_root end function !******************************************************************************* module subroutine rebuild ( this ) class ( aabbtree_t ), intent ( in out ) :: this type ( ivector_t ) :: node_indices type ( aabb_t ) :: aabbi , aabbj , aabb real ( rp ) :: cost , cost_min integer :: counter , i , j , ind , jnd , imin , jmin integer :: indx_left , indx_right , p , hl , hr counter = 0 ; call ivector_init ( node_indices , this % size ) !Loop over all nodes and store the leaf node indices, return the rest to the !free store. do i = 1 , this % capacity !Ignore nodes in the free store if ( this % nodes ( i )% height < 0 ) cycle if ( this % nodes ( i )% isleaf () ) then this % nodes ( i )% parent = NULL_NODE call node_indices % append ( i ) counter = counter + 1 else call this % fs_return ( i ) end if end do !Rebuild tree from bottom up do if ( counter <= 1 ) exit cost_min = huge ( 0.0_rp ); imin = 0 ; jmin = 0 do i = 1 , counter ind = node_indices % get_val ( i ) aabbi = this % nodes ( ind )% aabb do j = ( i + 1 ), counter jnd = node_indices % get_val ( j ) aabbj = this % nodes ( jnd )% aabb aabb = aabbi + aabbj cost = aabb % srfarea if ( cost < cost_min ) then imin = i ; jmin = j ; cost_min = cost end if end do end do indx_left = node_indices % get_val ( imin ) indx_right = node_indices % get_val ( jmin ) hl = this % nodes ( indx_left )% height hr = this % nodes ( indx_right )% height p = this % fs_acquire () this % nodes ( p )% left = indx_left ; this % nodes ( p )% right = indx_right this % nodes ( p )% height = 1 + max ( hl , hr ) this % nodes ( p )% aabb = this % nodes ( indx_left )% aabb + this % nodes ( indx_right )% aabb this % nodes ( p )% parent = NULL_NODE this % nodes ( indx_left )% parent = p this % nodes ( indx_right )% parent = p call node_indices % set_val ( jmin , node_indices % get_val ( counter )) call node_indices % set_val ( imin , p ) counter = counter - 1 end do this % root = node_indices % get_val ( 1 ) call this % validate () end subroutine !******************************************************************************* module subroutine validate ( this ) class ( aabbtree_t ), intent ( in ) :: this integer :: num_free_nodes , p call this % validate_structure ( this % root ) call this % validate_metrics ( this % root ) num_free_nodes = 0 ; p = this % freestore do if ( p == NULL_NODE ) exit p = this % nodes ( p )% next num_free_nodes = num_free_nodes + 1 end do @ : ASSERT ( this % get_height () == this % calc_height () ) @ : ASSERT ( ( this % size + num_free_nodes ) == this % capacity ) end subroutine !******************************************************************************* module subroutine insert_leaf ( this , leaf ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: leaf type ( aabb_t ) :: aabb , leaf_aabb , combined_aabb real ( rp ) :: sa , combined_sa , old_area , new_area real ( rp ) :: cost , cost_inheritance , cost_left , cost_right integer :: p , sibling , old_parent , new_parent integer :: left , right !If the tree is empty, insert and make it root if ( this % root == NULL_NODE ) then this % root = leaf this % nodes ( this % root )% parent = NULL_NODE return end if !If the tree is not empty, find the best sibling for the node leaf_aabb = this % nodes ( leaf )% aabb p = this % root do if ( this % nodes ( p )% isleaf () ) exit left = this % nodes ( p )% left ; right = this % nodes ( p )% right sa = this % nodes ( p )% aabb % srfarea combined_aabb = this % nodes ( p )% aabb + leaf_aabb combined_sa = combined_aabb % srfarea !Cost of creating a new parent for this node & the new leaf cost = 2.0_rp * combined_sa !Minimum cost of pushing the leaf further down the tree cost_inheritance = 2.0_rp * ( combined_sa - sa ) !Cost of descending to the left if ( this % nodes ( left )% isleaf () ) then aabb = this % nodes ( left )% aabb + leaf_aabb cost_left = aabb % srfarea + cost_inheritance else aabb = this % nodes ( left )% aabb + leaf_aabb old_area = this % nodes ( left )% aabb % srfarea new_area = aabb % srfarea cost_left = ( new_area - old_area ) + cost_inheritance end if !Cost of descending to the right if ( this % nodes ( right )% isleaf () ) then aabb = this % nodes ( right )% aabb + leaf_aabb cost_right = aabb % srfarea + cost_inheritance else aabb = this % nodes ( right )% aabb + leaf_aabb old_area = this % nodes ( right )% aabb % srfarea new_area = aabb % srfarea cost_right = ( new_area - old_area ) + cost_inheritance end if !Descend according to the minimum cost if ( ( cost < cost_left ) . and . ( cost < cost_right ) ) exit !Descend if ( cost_left < cost_right ) then p = left else p = right end if end do sibling = p !Create a new parent old_parent = this % nodes ( sibling )% parent new_parent = this % fs_acquire () this % nodes ( new_parent )% parent = old_parent this % nodes ( new_parent )% aabb = this % nodes ( sibling )% aabb + leaf_aabb this % nodes ( new_parent )% height = this % nodes ( sibling )% height + 1 !Sibling was not root if ( old_parent /= NULL_NODE ) then if ( this % nodes ( old_parent )% left == sibling ) then this % nodes ( old_parent )% left = new_parent else this % nodes ( old_parent )% right = new_parent end if this % nodes ( new_parent )% left = sibling this % nodes ( new_parent )% right = leaf this % nodes ( sibling )% parent = new_parent this % nodes ( leaf )% parent = new_parent else !Sibling was the root this % nodes ( new_parent )% left = sibling this % nodes ( new_parent )% right = leaf this % nodes ( sibling )% parent = new_parent this % nodes ( leaf )% parent = new_parent this % root = new_parent end if !Walk back up the tree fixing heights and AABBs. p = this % nodes ( leaf )% parent do if ( p == NULL_NODE ) exit p = this % balance ( p ) left = this % nodes ( p )% left ; right = this % nodes ( p )% right this % nodes ( p )% height = 1 + & max ( this % nodes ( left )% height , this % nodes ( right )% height ) this % nodes ( p )% aabb = this % nodes ( left )% aabb + this % nodes ( right )% aabb p = this % nodes ( p )% parent end do end subroutine !******************************************************************************* module subroutine remove_leaf ( this , leaf ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: leaf integer :: parent , grandparent , sibling integer :: p , left , right if ( leaf == this % root ) then this % root = NULL_NODE return end if parent = this % nodes ( leaf )% parent grandparent = this % nodes ( parent )% parent if ( this % nodes ( parent )% left == leaf ) then sibling = this % nodes ( parent )% right else sibling = this % nodes ( parent )% left end if !Destroy the parent & connect the sibling to the grandparent if ( grandparent /= NULL_NODE ) then if ( this % nodes ( grandparent )% left == parent ) then this % nodes ( grandparent )% left = sibling else this % nodes ( grandparent )% right = sibling end if this % nodes ( sibling )% parent = grandparent call this % fs_return ( parent ) !Adjust ancestor bounds p = grandparent do if ( p == NULL_NODE ) exit p = this % balance ( p ) left = this % nodes ( p )% left ; right = this % nodes ( p )% right this % nodes ( p )% aabb = this % nodes ( left )% aabb + this % nodes ( right )% aabb this % nodes ( p )% height = 1 + & max ( this % nodes ( left )% height , this % nodes ( right )% height ) p = this % nodes ( p )% parent end do else this % root = sibling this % nodes ( sibling )% parent = NULL_NODE call this % fs_return ( parent ) end if end subroutine !******************************************************************************* module function balance ( this , p ) result ( q ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: p integer :: q integer :: left , right , right_left , right_right , left_right , left_left integer :: current_balance associate ( nodes => this % nodes ) @ : ASSERT ( p /= NULL_NODE ) if ( nodes ( p )% isleaf () . or . ( nodes ( p )% height < 2 ) ) then q = p return end if left = nodes ( p )% left right = nodes ( p )% right @ : ASSERT ( left <= this % capacity ) @ : ASSERT ( right <= this % capacity ) current_balance = nodes ( right )% height - nodes ( left )% height !Rotate right branch up if ( current_balance > 1 ) then right_left = nodes ( right )% left right_right = nodes ( right )% right @ : ASSERT ( right_left <= this % capacity ) @ : ASSERT ( right_right <= this % capacity ) !Swap node and its right-hand child nodes ( right )% left = p nodes ( right )% parent = nodes ( p )% parent nodes ( p )% parent = right !The node's old parent should now point to its right-hand child if ( nodes ( right )% parent /= NULL_NODE ) then if ( nodes ( nodes ( right )% parent )% left == p ) then nodes ( nodes ( right )% parent )% left = right else @ : ASSERT ( nodes ( nodes ( right )% parent )% right == p ) nodes ( nodes ( right )% parent )% right = right end if else this % root = right end if !Rotate if ( nodes ( right_left )% height > nodes ( right_right )% height ) then nodes ( right )% right = right_left nodes ( p )% right = right_right nodes ( right_right )% parent = p nodes ( p )% aabb = nodes ( left )% aabb + nodes ( right_right )% aabb nodes ( right )% aabb = nodes ( p )% aabb + nodes ( right_left )% aabb nodes ( p )% height = 1 + max ( nodes ( left )% height , nodes ( right_right )% height ) nodes ( right )% height = 1 + max ( nodes ( p )% height , nodes ( right_left )% height ) else nodes ( right )% right = right_right nodes ( p )% right = right_left nodes ( right_left )% parent = p nodes ( p )% aabb = nodes ( left )% aabb + nodes ( right_left )% aabb nodes ( right )% aabb = nodes ( p )% aabb + nodes ( right_right )% aabb nodes ( p )% height = 1 + max ( nodes ( left )% height , nodes ( right_left )% height ) nodes ( right )% height = 1 + max ( nodes ( p )% height , nodes ( right_right )% height ) end if q = right return end if !Rotate left branch up if ( current_balance < - 1 ) then left_left = nodes ( left )% left left_right = nodes ( left )% right @ : ASSERT ( left_left <= this % capacity ) @ : ASSERT ( left_right <= this % capacity ) !Swap node and its left-hand child nodes ( left )% left = p nodes ( left )% parent = nodes ( p )% parent nodes ( p )% parent = left !The node's old parent should now point to its left-hand child if ( nodes ( left )% parent /= NULL_NODE ) then if ( nodes ( nodes ( left )% parent )% left == p ) then nodes ( nodes ( left )% parent )% left = left else @ : ASSERT ( nodes ( nodes ( left )% parent )% right == p ) nodes ( nodes ( left )% parent )% right = left end if else this % root = left end if !Rotate if ( nodes ( left_left )% height > nodes ( left_right )% height ) then nodes ( left )% right = left_left nodes ( p )% left = left_right nodes ( left_right )% parent = p nodes ( p )% aabb = nodes ( right )% aabb + nodes ( left_right )% aabb nodes ( left )% aabb = nodes ( p )% aabb + nodes ( left_left )% aabb nodes ( p )% height = 1 + max ( nodes ( right )% height , nodes ( left_right )% height ) nodes ( left )% height = 1 + max ( nodes ( p )% height , nodes ( left_left )% height ) else nodes ( left )% right = left_right nodes ( p )% left = left_left nodes ( left_left )% parent = p nodes ( p )% aabb = nodes ( right )% aabb + nodes ( left_left )% aabb nodes ( left )% aabb = nodes ( p )% aabb + nodes ( left_right )% aabb nodes ( p )% height = 1 + max ( nodes ( right )% height , nodes ( left_left )% height ) nodes ( left )% height = 1 + max ( nodes ( p )% height , nodes ( left_right )% height ) end if q = left return end if q = p end associate end function !******************************************************************************* module recursive function calc_height ( this , p ) result ( height ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ), optional :: p integer :: height , p_ if ( present ( p )) then p_ = p else p_ = this % root end if if ( this % nodes ( p_ )% isleaf ()) then height = 0 else height = 1 + max ( this % calc_height ( this % nodes ( p_ )% left ), & this % calc_height ( this % nodes ( p_ )% right )) end if end function !******************************************************************************* module function fs_acquire ( this ) result ( p ) class ( aabbtree_t ), intent ( in out ) :: this integer :: p type ( node_t ), dimension (:), allocatable :: tmp integer :: n , i if ( this % freestore == NULL_NODE ) then @ : ASSERT ( this % size == this % capacity ) !Double the capacity n = this % capacity allocate ( tmp ( 2 * n ) ) tmp ( 1 : n ) = this % nodes do i = ( n + 1 ), 2 * n call tmp ( i )% init () tmp ( i )% next = i + 1 end do tmp ( n )% next = n + 1 tmp ( 2 * n )% next = NULL_NODE call move_alloc ( tmp , this % nodes ) this % capacity = 2 * n this % freestore = n + 1 end if !Acquire a new node p = this % freestore this % freestore = this % nodes ( p )% next !Increment the size of the tree this % size = this % size + 1 end function !******************************************************************************* module subroutine fs_return ( this , p ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: p @ : ASSERT ( p <= this % capacity ) @ : ASSERT ( 0 < this % size ) call this % nodes ( p )% init () this % nodes ( p )% next = this % freestore this % freestore = p !Decrement the size of the tree this % size = this % size - 1 end subroutine !******************************************************************************* module recursive subroutine validate_structure ( this , p ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ) :: p integer :: left , right if ( p == NULL_NODE ) return if ( p == this % root ) then @ : ASSERT ( this % nodes ( p )% parent == NULL_NODE ) end if left = this % nodes ( p )% left right = this % nodes ( p )% right if ( this % nodes ( p )% isleaf () ) then @ : ASSERT ( left == NULL_NODE ) @ : ASSERT ( right == NULL_NODE ) @ : ASSERT ( this % nodes ( p )% height == 0 ) return end if @ : ASSERT ( left <= this % capacity ) @ : ASSERT ( right <= this % capacity ) @ : ASSERT ( this % nodes ( left )% parent == p ) @ : ASSERT ( this % nodes ( right )% parent == p ) call this % validate_structure ( left ) call this % validate_structure ( right ) end subroutine !******************************************************************************* module recursive subroutine validate_metrics ( this , p ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ) :: p type ( aabb_t ) :: aabb integer :: left , right , height if ( p == NULL_NODE ) return left = this % nodes ( p )% left right = this % nodes ( p )% right if ( this % nodes ( p )% isleaf () ) then @ : ASSERT ( left == NULL_NODE ) @ : ASSERT ( right == NULL_NODE ) @ : ASSERT ( this % nodes ( p )% height == 0 ) return end if @ : ASSERT ( left <= this % capacity ) @ : ASSERT ( right <= this % capacity ) height = 1 + max ( this % nodes ( left )% height , this % nodes ( right )% height ) @ : ASSERT ( this % nodes ( p )% height == height ) aabb = this % nodes ( left )% aabb + this % nodes ( right )% aabb @ : ASSERT ( all ( aabb % lbnd == this % nodes ( p )% aabb % lbnd ) ) @ : ASSERT ( all ( aabb % ubnd == this % nodes ( p )% aabb % ubnd ) ) call this % validate_metrics ( left ) call this % validate_metrics ( right ) end subroutine !******************************************************************************* end submodule aabbtree_sm","tags":"","loc":"sourcefile/aabbtree_sm.fpp.html"},{"title":"ia_angle_m.f90 – BROWNPAK","text":"This file depends on sourcefile~~ia_angle_m.f90~~EfferentGraph sourcefile~ia_angle_m.f90 ia_angle_m.f90 sourcefile~constants_m.f90 constants_m.f90 sourcefile~ia_angle_m.f90->sourcefile~constants_m.f90 sourcefile~atmcfg_m.f90 atmcfg_m.f90 sourcefile~ia_angle_m.f90->sourcefile~atmcfg_m.f90 sourcefile~atmcfg_m.f90->sourcefile~constants_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ia_angle_m.f90~~AfferentGraph sourcefile~ia_angle_m.f90 ia_angle_m.f90 sourcefile~interaction_m.f90 interaction_m.f90 sourcefile~interaction_m.f90->sourcefile~ia_angle_m.f90 sourcefile~setup_m.f90 setup_m.f90 sourcefile~setup_m.f90->sourcefile~interaction_m.f90 sourcefile~bd_solver_m.f90 bd_solver_m.f90 sourcefile~setup_m.f90->sourcefile~bd_solver_m.f90 sourcefile~bd_solver_m.f90->sourcefile~interaction_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~setup_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ia_angle_m Source Code ia_angle_m.f90 Source Code module ia_angle_m !! Angle potentials !! !! * Style 0: None (Only topology) !! * Style 1: Cosine. See [[ang_cos_set]]. use constants_m use atmcfg_m implicit none private public :: ia_angle_setup , ia_get_angle_force contains !****************************************************************************** subroutine ia_angle_setup ( num_angle_types , angle_styles , angle_params ) !! Sets up parameters for angle potentials integer , intent ( in ) :: num_angle_types !! Number of angle types integer , dimension (:), intent ( in ) :: angle_styles !! Styles for each type real ( rp ), dimension (:,:), intent ( in out ) :: angle_params !! Parameters for each type, depending on style integer :: i , sty !Set angular interactions do i = 1 , num_angle_types sty = angle_styles ( i ) select case ( sty ) case ( 1 ) call ang_cos_set ( angle_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_angle_force ( q1 , q2 , sty , params , enrg , fim1 , fi , fip1 ) !! Calculates the energy & force due to an angle. real ( rp ), dimension ( 3 ), intent ( in ) :: q1 real ( rp ), dimension ( 3 ), intent ( in ) :: q2 integer , intent ( in ) :: sty real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), dimension ( 3 ), intent ( out ) :: fim1 real ( rp ), dimension ( 3 ), intent ( out ) :: fi real ( rp ), dimension ( 3 ), intent ( out ) :: fip1 real ( rp ), dimension ( 3 ) :: q1hat , q2hat real ( rp ) :: kang real ( rp ) :: q1mag , q2mag , ctheta q1mag = norm2 ( q1 ); q2mag = norm2 ( q2 ) q1hat = q1 / q1mag ; q2hat = q2 / q2mag ctheta = dot_product ( q1hat , q2hat ) !Floating point correction if ( ctheta > 1.0_rp ) ctheta = 1.0_rp if ( ctheta < - 1.0_rp ) ctheta = - 1.0_rp select case ( sty ) case ( 1 ) kang = params ( 1 ) enrg = kang * ( 1.0_rp - ctheta ) fim1 = kang * ( - q2hat + ctheta * q1hat ) / q1mag fip1 = kang * ( q1hat - ctheta * q2hat ) / q2mag fi = - ( fim1 + fip1 ) case default continue end select end subroutine !******************************************************************************** subroutine ang_cos_set ( params , k ) !! Setter for angular cosine interaction. !! !!``` !!   U(theta) = k*(1 - cos theta), !!   where theta is the complementary angle between bonds i & (i+1). !!``` !! User-set parameters: !! !! params(1) = `k` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k if ( present ( k )) params ( 1 ) = k end subroutine !****************************************************************************** end module ia_angle_m","tags":"","loc":"sourcefile/ia_angle_m.f90.html"},{"title":"nittfq.f – BROWNPAK","text":"Contents Subroutines nittfq Source Code nittfq.f Source Code subroutine nittfq ( n , xcur , fcur , fcnrm , step , eta , f , jacv , rpar , & ipar , ijacv , irpre , iksmax , ifdord , nfe , njve , nrpre , nli , r , & rcgs , rtil , d , p , q , u , v , y , rwork1 , rwork2 , rsnrm , dinpr , & dnorm , itrmks ) implicit none integer ifdord , ijacv , iksmax , irpre , itrmks , n , nfe , njve , & nrpre , nli integer ipar ( * ) double precision eta , fcnrm , rsnrm double precision d ( n ), fcur ( n ), p ( n ), q ( n ), rcgs ( n ), r ( n ), & rpar ( * ), rtil ( n ), rwork1 ( n ), rwork2 ( n ), step ( n ), & u ( n ), v ( n ), xcur ( n ), y ( n ) double precision dinpr , dnorm external f , jacv , dinpr , dnorm c ------------------------------------------------------------------------ c c This is nittfq v0.1, the TFQMR routine for determining (trial) inexact c Newton steps. The original reference is R. W. Freund, \"A Transpose-Free c Quasi-Minimal Residual Algorithm for Non-Hermitian Linear Systems\", c SIAM J. Sci. Comput., 14 (1993), pp. 470-482.  The implementation here c is based on the right preconditioned algorithm that appears in c J. N. Shadid and R. S. Tuminaro, \"A Comparison of Preconditioned c Nonsymmetric Krylov Methods on a Large-Scale MIMD Machine\", SIAM J. c Sci. Comput., 15 (1994), pp. 440-459. c c ------------------------------------------------------------------------ c c Explanation: c c  n       = dimension of the problem. c c  xcur    = vector of length n, current approximate solution. c c  fcur    = vector of length n, value of f at xcur. c c  fcnrm   = norm of fcur. c c  step    = vector of length n, (trial) step. c c  eta     = relative residual reduction factor. c c  f      = name of user-supplied subroutine for evaluating the function c           the zero of which is sought; this routine has the form c c                 subroutine f(n, xcur, fcur, rpar, ipar, itrmf) c c           where xcur is the array containing the current x value, fcur c           is f(xcur) on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmf is an integer termination flag.  The meaning of c           itrmf is as follows: c             0 => normal termination; desired function value calculated. c             1 => failure to produce f(xcur). c c  jacv   = name of user-supplied subroutine for evaluating J*v or c           P(inverse)*v, where J is the Jacobian of f and P is a c           right preconditioning operator. If neither analytic J*v c           evaluations nor right preconditioning is used, this can c           be a dummy subroutine; if right preconditioning is used but c           not analytic J*v evaluations, this need only evaluate c           P(inverse)*v. The form is c c           subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) c c           where xcur and fcur are vectors of length n containing the c           current x and f values, ijob is an integer flag indicating c           which product is desired, v is a vector of length n to be c           multiplied, z is a vector of length n containing the desired c           product on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmjv is an integer termination c           flag. The meaning of ijob is as follows: c             0 => z = J*v c             1 => z = P(inverse)*v c           The meaning of itrmjv is as follows: c             0 => normal termination; desired product evaluated. c             1 => failure to produce J*v. c             2 => failure to produce P(inverse)*v. c           This subroutine is called only from nitjv, and is always c           called with v .ne. z. c c  rpar    = real parameter/work array passed to the f and jacv routines. c c  ipar    = integer parameter/work array passed to the f and jacv routines. c c  ijacv   = flag for determining method of J*v evaluation. c              0 => finite-difference evaluation (default). c              1 => analytic evaluation. c c  irpre   = flag for right preconditioning. c              0 => no right preconditioning c              1 => right preconditioning c c  iksmax  = maximum allowable number of TFQMR iterations. c c  ifdord  = order of the finite-difference formula used in BiCGSTAB c            when J*v products are evaluated using finite-differences. c            When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or c            4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on c            input to this subroutine, ifdord determines the order of the c            finite-difference formula used at each BiCGSTAB iteration c            (default 1). In this case, ijacv is set to -1 below to c            signal to nitjv that the order of the finite-difference c            formula is to be determined by ifdord. The original value c            ijacv = 0 is restored on return. c c  nfe     = number of function evaluations. c c  njve    = number of J*v evaluations. c c  nrpre   = number of P(inverse)*v evaluations. c c  nli     = number of linear iterations. c c  r       = residual vector (for the QMR process) c c  rcgs    = residual vector (of the underlying CGS process) c c  rtil    = 'shadow' residual vector used in bi-orthogonalization c c  d       = vector used in TFQMR c c  p       = vector used in TFQMR c c  q       = vector used in TFQMR c c  u       = vector used in TFQMR c c  v       = vector used in TFQMR c c  y       = vector used in TFQMR c c  rwork1  = work vector, passed on to nitjv c c  rwork2  = work vector, passed on to nitjv c c  rsnrm   = TFQMR residual norm on return. c c  dinpr   = inner-product routine, either user-supplied or blas ddot. c c  dnorm   = norm routine, either user-supplied or blas dnrm2. c c  itrmks  = termination flag; values have the following meanings: c              0 => normal termination: acceptable step found. c              1 => J*v failure in nitjv. c              2 => P(inverse)*v failure in nitjv. c              3 => acceptable step not found in iksmax TFQMR iterations. c              4 => TFQMR breakdown. c              5 => floating point error (the underlying CGS iteration c                   has probably blown up) c c             Note: On return, nitsol terminates if itrmks is 1 or 2. c             If itrmks is 3 or 4, nitsol may terminate or continue. c             In this event, the step returned is a meaningful inexact c             Newton step only if the residual norm has been reduced. c             A decision on termination/continuation is made in nitdrv c             according to whether there is sufficient residual norm c             reduction, even though the desired inexact Newton condition c             may not hold. c c ------------------------------------------------------------------------- c  Subroutines required by this and all called routines: c    user supplied:  nitjv c    nitsol routines: none c    BLAS routines- dcopy, daxpy, dscal, dswap c    LAPACK routines - dlamch c    user supplied or BLAS:  dinpr, dnorm c    explanation: In nitsol, dinpr and dnorm are set to either the BLAS c    ddot and dnrm2 routines or the user-supplied routines. c This subroutine called by: nitdrv c Subroutines called by this subroutine: daxpy, dcopy, dscal, dswap, dinpr, c    dlamch, dnorm, nitjv, dlamch c Common block: include 'nitprint.h' c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number. c  Parameters- double precision zero , one parameter ( zero = 0.0d0 , one = 1.0d0 ) c  Local variables- integer i integer itask integer itrmjv integer itfq integer k double precision alpha double precision abstol double precision beta double precision c double precision cgsnorm double precision qmreta double precision omega double precision rho double precision rho_old double precision sigma double precision t double precision tau double precision theta character * 2 ab ( 0 : 1 ) data ab / '.a' , '.b' / double precision sfmin data sfmin / zero / c  External subroutines- double precision dlamch external daxpy external dcopy external dlamch external dscal external dswap external nitjv c  Intrinsics- intrinsic abs intrinsic dble intrinsic sqrt c  Start of executable code- c  Initialize sfmin only on first entry. if ( sfmin . eq . zero ) sfmin = dlamch ( 's' ) c If finite-differences are used to evaluate J*v products (ijacv= 0), then c ijacv is set to -1 within this subroutine to signal to nitjv that the c order of the finite-difference formula is to be determined by ifdord. c The original value ijacv= 0 is restored on return. if ( ijacv . eq . 0 ) ijacv = - 1 c Set the stopping tolerance, initialize the step, etc. rsnrm = fcnrm abstol = eta * rsnrm do 10 i = 1 , n step ( i ) = zero 10 continue itfq = 0 c For printing: if ( iplvl . ge . 3 ) then write ( ipunit , * ) write ( ipunit , 800 ) eta endif if ( iplvl . ge . 4 ) then write ( ipunit , 810 ) write ( ipunit , * ) write ( ipunit , 820 ) itfq , rsnrm endif c  Initialize residual and work vectors. call dcopy ( n , fcur , 1 , rcgs , 1 ) call dscal ( n , - one , rcgs , 1 ) c  Choice here is rtil = r. call dcopy ( n , rcgs , 1 , rtil , 1 ) if ( irpre . eq . 0 ) then call dcopy ( n , rcgs , 1 , p , 1 ) else itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , rcgs , p , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 2 goto 900 endif endif call dcopy ( n , p , 1 , u , 1 ) rho = dinpr ( n , rcgs , 1 , rtil , 1 ) do 20 i = 1 , n d ( i ) = zero 20 continue itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , p , v , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 1 goto 900 end if alpha = zero omega = fcnrm tau = omega theta = zero qmreta = zero c  Start iterations. 100 continue itfq = itfq + 1 nli = nli + 1 sigma = dinpr ( n , rtil , 1 , v , 1 ) c  If sigma = 0 we have a serious breakdown.  We check this condition c  by trying to detect whether division by sigma causes an overflow. if ( abs ( sigma ) . lt . sfmin * abs ( rho ) ) then itrmks = 4 goto 900 else alpha = rho / sigma endif c  Need Pv for calculation of q.  First store result in q, then c  swap some vectors to cast calculation of q as a SAXPY. if ( irpre . eq . 0 ) then call dcopy ( n , v , 1 , q , 1 ) else itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , v , q , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 2 goto 900 endif endif call dcopy ( n , u , 1 , y , 1 ) call dswap ( n , q , 1 , u , 1 ) call daxpy ( n , - alpha , u , 1 , q , 1 ) call dcopy ( n , y , 1 , u , 1 ) c  Update residual. do 30 i = 1 , n y ( i ) = u ( i ) + q ( i ) 30 continue itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , y , v , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 1 goto 900 end if call daxpy ( n , - alpha , v , 1 , rcgs , 1 ) cgsnorm = dnorm ( n , rcgs , 1 ) c  Check for cgsnorm = NaN. if ( cgsnorm . ne . cgsnorm ) then itrmks = 5 goto 900 endif c  QMR section. do 60 k = 0 , 1 c  Use weighting strategy from (5.11) of Freund reference. t = qmreta * theta ** 2 t = t / alpha if ( k . eq . 0 ) then do 40 i = 1 , n d ( i ) = u ( i ) + t * d ( i ) 40 continue omega = sqrt ( omega * cgsnorm ) else if ( k . eq . 1 ) then do 50 i = 1 , n d ( i ) = q ( i ) + t * d ( i ) 50 continue omega = cgsnorm endif theta = omega / tau c = one / sqrt ( one + theta ** 2 ) tau = tau * theta * c qmreta = alpha * c ** 2 c For printing: if ( iplvl . ge . 4 . and . tau . gt . abstol ) then write ( ipunit , 830 ) itfq , ab ( k ), tau , '     (estimated)' endif call daxpy ( n , qmreta , d , 1 , step , 1 ) c  Convergence check.  Do a cheap test to save on Jacobi-vector products. c  In case residual history is requested by iplvl, we must calculate c  the QMR residual from scratch.  Note termination is always determined c  by the smoothed residual, calculated from scratch. if ( tau . le . abstol ) then itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , & ifdord , itask , nfe , njve , nrpre , step , r , rwork1 , & rwork2 , dnorm , itrmjv ) c  This calculation of the QMR residual is off by a factor c  of -1, but we don't care until we return from this routine. call daxpy ( n , one , fcur , 1 , r , 1 ) rsnrm = dnorm ( n , r , 1 ) c For printing: if ( iplvl . ge . 4 ) then write ( ipunit , 830 ) itfq , ab ( k ), rsnrm , '  (from scratch)' endif c  Check for rsnrm = NaN. if ( rsnrm . ne . rsnrm ) then itrmks = 5 goto 900 endif c  If rsnrm is small enough, exit. if ( rsnrm . lt . abstol ) then itrmks = 0 goto 900 endif endif 60 continue rho_old = rho rho = dinpr ( n , rtil , 1 , rcgs , 1 ) c  If rho_old = 0 we have a serious breakdown.  We check this condition c  by trying to detect whether division by rho_old causes an overflow. if ( abs ( rho_old ) . lt . sfmin * abs ( rho ) ) then itrmks = 4 goto 900 else beta = rho / rho_old endif if ( irpre . eq . 0 ) then call dcopy ( n , rcgs , 1 , v , 1 ) else itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , rcgs , v , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 2 goto 900 endif endif call daxpy ( n , beta , q , 1 , v , 1 ) call dcopy ( n , v , 1 , u , 1 ) call daxpy ( n , beta , p , 1 , q , 1 ) call daxpy ( n , beta , q , 1 , v , 1 ) call dcopy ( n , v , 1 , p , 1 ) itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , p , v , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 1 goto 900 end if if ( itfq . ge . iksmax ) then itrmks = 3 goto 900 end if c  Do again goto 100 c  All returns made here. 900 continue c  If residual hasn't been updated, force c  computation of residual from scratch. if ( rsnrm . eq . fcnrm ) then itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , & ifdord , itask , nfe , njve , nrpre , step , r , rwork1 , & rwork2 , dnorm , itrmjv ) call daxpy ( n , one , fcur , 1 , r , 1 ) rsnrm = dnorm ( n , r , 1 ) if ( rsnrm . le . abstol ) itrmks = 0 end if c  Correct residual before returning. call dscal ( n , - one , r , 1 ) c If ijacv = -1, then restore it to the original value ijacv = 0. if ( ijacv . eq . - 1 ) ijacv = 0 c For printing: if ( iplvl . ge . 3 ) then write ( ipunit , * ) if ( itrmks . ne . 1 . and . itrmks . ne . 2 ) then write ( ipunit , 840 ) itrmks , rsnrm else write ( ipunit , 850 ) itrmks endif endif return 800 format ( 'nittfq:  eta =' , 1 pd10 . 3 ) 810 format ( 'nittfq:  TFQMR iteration no. (parts a and b),' , & ' linear residual norm' ) 820 format ( 5 x , i4 , 5 x , 1 pd10 . 3 ) 830 format ( 5 x , i4 , a2 , 3 x , 1 pd10 . 3 , a16 ) 840 format ( 'nittfq:  itrmks =' , i2 , '   final lin. res. norm =' , & 1 pd10 . 3 ) 850 format ( 'nittfq: itrmks:' , i4 ) c  End of nittfq. end","tags":"","loc":"sourcefile/nittfq.f.html"},{"title":"nitjv.f – BROWNPAK","text":"Contents Subroutines nitjv nitfd Source Code nitjv.f Source Code subroutine nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , v , z , $ rwork1 , rwork2 , dnorm , itrmjv ) implicit none integer n , ipar ( * ), ijacv , ifdord , itask , nfe , njve , nrpre , $ itrmjv double precision xcur ( n ), fcur ( n ), rpar ( * ), v ( n ), z ( n ), $ rwork1 ( n ), rwork2 ( n ), dnorm external f , jacv , dnorm c ------------------------------------------------------------------------ c c This is nitjv v0.3, the routine for controlling evaluation of products c J*v or J*P(inverse)*v or P(inverse)*v, where J is the Jacobian of f c and P is a right preconditioning operator. c c ------------------------------------------------------------------------ c c Explanation: c c  n       = dimension of the problem. c c  xcur    = vector of length n, initial guess on input and final c            approximate solution on output. c c  fcur    = vector of length n, value of f at xcur. c c  f       = name of user-supplied subroutine for evaluating the function c            the zero of which is sought; this routine has the form c c                 subroutine f(n, xcur, fcur, rpar, ipar, itrmf) c c            where xcur is the array containing the current x value, fcur c            is f(xcur) on output, rpar and ipar are, respectively, real c            and integer parameter/work arrays for use by the subroutine, c            and itrmf is an integer termination flag.  The meaning of c            itrmf is as follows: c              0 => normal termination; desired function value calculated. c              1 => failure to produce f(xcur). c c  jacv    = name of user-supplied subroutine for evaluating J*v or c            P(inverse)*v, where J is the Jacobian of f and P is a c            right preconditioning operator. If neither analytic J*v c            evaluations nor right preconditioning is used, this can c            be a dummy subroutine; if right preconditioning is used but c            not analytic J*v evaluations, this need only evaluate c            P(inverse)*v. The form is c c            subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) c c            where xcur and fcur are vectors of length n containing the c            current x and f values, ijob is an integer flag indicating c            which product is desired, v is a vector of length n to be c            multiplied, z is a vector of length n containing the desired c            product on output, rpar and ipar are, respectively, real c            and integer parameter/work arrays for use by the subroutine, c            and itrmjv is an integer termination c            flag. The meaning of ijob is as follows: c              0 => z = J*v c              1 => z = P(inverse)*v c            The meaning of itrmjv is as follows: c              0 => normal termination; desired product evaluated. c              1 => failure to produce J*v. c              2 => failure to produce P(inverse)*v. c            This subroutine is called only from nitjv, and is always c            called with v .ne. z. c c  rpar    = real parameter/work array passed to the f and jacv routines. c c  ipar    = integer parameter/work array passed to the f and jacv routines. c c  ijacv   = flag for determining method of J*v evaluation. c             -1 => finite-difference evaluation of order ifdord. c              0 => first-order finite-difference evaluation. c              1 => analytic evaluation. c c  ifdord  = order of the finite-difference formula (sometimes) used when c            J*v products are evaluated using finite-differences. When c            ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or 4 in c            nitsol; subsequently, ijacv may be temporarily reset to -1 in c            the Krylov solver to force a finite-difference evaluation of c            order ifdord. If ijacv = 1 on input to nitsol, then ifdord is c            irrelevant. When ijacv = 0 on input to nitsol, the precise c            meaning of ifdord is as follows: c c            If GMRES is used, then ifdord matters only if iresup = 1, in c            which case it determines the order of the finite-difference c            formula used in evaluating the initial residual at each GMRES c            restart (default 2). NOTE: This only affects initial residuals c            at restarts; first-order differences are always used within c            each GMRES cycle. Using higher-order differences at restarts c            only should give the same accuracy as if higher-order c            differences were used throughout; see K. Turner and H. F. c            Walker, \"Efficient high accuracy solutions with GMRES(m),\" c            SIAM J. Sci. Stat. Comput., 13 (1992), pp. 815--825. c c            If BiCGSTAB or TFQMR is used, then ifdord determines the c            order of the finite-difference formula used at each c            iteration (default 1). c c  itask   = flag for determining which product is produced. c              0 => z = J*v c              1 => z = J*P(inverse)*v c              2 => z = P(inverse)*v c c  nfe     = number of function evaluations. c c  njve    = number of J*v evaluations. c c  nrpre   = number of P(inverse)*v evaluations. c c  v       = vector to be multiplied. c c  z       = desired product. c c  rwork1  = vector of length n, work array. c c  rwork2  = vector of length n, work array. Note: rwork2 is only referenced c            when a J-product is evaluated with a finite-difference of c            order 2 or 4, i.e., when itask = 0 or 1, ijacv = 0, and c            ifdord = 2 or 4. c c  dnorm   = norm routine, either user-supplied or blas dnrm2. c c  itrmjv  = termination flag; values have the following meanings: c              0 => normal termination; desired product evaluated. c              1 => failure to produce J*v. c              2 => failure to produce P(inverse)*v. c c ------------------------------------------------------------------------ c c Subroutines required by this and all called routines: c c    user supplied: f, jacv c c    nitsol routines: nitfd c c    blas routine: daxpy, dcopy, dscal c c    user supplied or blas: dnorm c c    explanation: In nitsol, dnorm is set to either the blas c    dnrm2 routine or the user-supplied usrnrm routine. c c This subroutine called by: nitgm, nitstb, nittfq c c Subroutines called by this subroutine: dcopy, jacv, nitfd c c Common block: c include 'nitprint.h' c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number. c c ------------------------------------------------------------------------ c integer ijob c c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c If z = J*v is desired (itask = 0), then copy v into rwork1; if c z = J*P(inverse)*v or z = P(inverse)*v is desired (itask = 1,2), c then compute P(inverse)*v in rwork1. c ------------------------------------------------------------------------ if ( itask . eq . 0 ) then call dcopy ( n , v , 1 , rwork1 , 1 ) else ijob = 1 call jacv ( n , xcur , fcur , ijob , v , rwork1 , rpar , ipar , itrmjv ) nrpre = nrpre + 1 if ( itrmjv . ne . 0 ) go to 900 endif c ------------------------------------------------------------------------ c If only z = P(inverse)*v is desired (itask = 2), then copy rwork1 into c z and exit. c ------------------------------------------------------------------------ if ( itask . eq . 2 ) then call dcopy ( n , rwork1 , 1 , z , 1 ) go to 900 endif c ------------------------------------------------------------------------ c If z = J*v or z = J*P(inverse)*v is desired (itask = 0, 1), then c compute J*rwork1 in z by either analytic evaluation (ijacv = 1) or c finite-differences (ijacv = 0, -1). c ------------------------------------------------------------------------ if ( ijacv . eq . 1 ) then ijob = 0 call jacv ( n , xcur , fcur , ijob , rwork1 , z , rpar , ipar , itrmjv ) else call nitfd ( n , xcur , fcur , f , rpar , ipar , ijacv , ifdord , $ nfe , rwork1 , z , rwork2 , dnorm , itrmjv ) endif njve = njve + 1 c ------------------------------------------------------------------------ c All returns made here. c ------------------------------------------------------------------------ 900 continue return end subroutine nitfd ( n , xcur , fcur , f , rpar , ipar , ijacv , ifdord , $ nfe , v , z , rwork , dnorm , itrmjv ) implicit none integer n , ipar ( * ), ijacv , ifdord , nfe , itrmjv double precision xcur ( n ), fcur ( n ), rpar ( * ), v ( n ), z ( n ), $ rwork ( n ), dnorm external f , dnorm c ------------------------------------------------------------------------ c c This is nitfd v0.3, the routine for finite-difference evaluation of c products z = J*v, where J is the Jacobian of f. c c ------------------------------------------------------------------------ c c Explanation: c c  n       = dimension of the problem. c c  xcur    = vector of length n, initial guess on input and final c            approximate solution on output. c c  fcur    = vector of length n, value of f at xcur. c c  f       = name of user-supplied subroutine for evaluating the function c            the zero of which is sought; this routine has the form c c                  subroutine f(n, xcur, fcur, rpar, ipar, itrmf) c c           where xcur is the array containing the current x value, fcur c           is f(xcur) on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmf is an integer termination flag.  The meaning of c           itrmf is as follows: c             0 => normal termination; desired function value calculated. c             1 => failure to produce f(xcur). c c  rpar    = real parameter/work array passed to the f routine. c c  ipar    = integer parameter/work array passed to the f routine. c c  ijacv   = flag for determining method of J*v evaluation. In this c            subroutine, this should be 0 or -1 on input, as follows: c             -1 => finite-difference evaluation of order ifdord. c              0 => first-order finite-difference evaluation. c c  ifdord  = order of the finite-difference formula used when ijacv = -1. c            When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or c            4 in nitsol; subsequently, ijacv may be temporarily reset to c            -1 in the Krylov solver to force a finite-difference evaluation c            of order ifdord. If ijacv = 1 on input to nitsol, then ifdord c            is irrelevant. When ijacv = 0 on input to nitsol, the precise c            meaning of ifdord is as follows: c c            If GMRES is used, then ifdord matters only if iresup = 1, in c            which case it determines the order of the finite-difference c            formula used in evaluating the initial residual at each GMRES c            restart (default 2). NOTE: This only affects initial residuals c            at restarts; first-order differences are always used within c            each GMRES cycle. Using higher-order differences at restarts c            only should give the same accuracy as if higher-order c            differences were used throughout; see K. Turner and H. F. c            Walker, \"Efficient high accuracy solutions with GMRES(m),\" c            SIAM J. Sci. Stat. Comput., 13 (1992), pp. 815--825. c c            If BiCGSTAB or TFQMR is used, then ifdord determines the c            order of the finite-difference formula used at each c            iteration (default 1). c c  nfe     = number of function evaluations. c c  v       = vector to be multiplied in the product J*v. c c  z       = desired product J*v. c c  rwork   = vector of length n, work array. c c  dnorm   = norm routine, either user-supplied or blas dnrm2. c c  itrmjv  = termination flag; values have the following meanings: c              0 => normal termination; desired product evaluated. c              1 => failure to produce J*v. c c ------------------------------------------------------------------------ c c Remark: In the selection of the difference step eps in the perturbation c x + eps*v for approximating J*v by a finite difference, we assume the c following: c     1. f and a few derivatives (up to five when ifdord = 4) all c        have about the same scale. c     2. The relative error in f-evaluations is about epsmach (machine c        epsilon). c     3. The computed value of the sum of two vectors y and z has error c        bounded by epsmach*(||y|| + ||z||). c c The choice of eps is c c             eps = {[(1 + ||x||)*epsmach]**(1/(ifdord+1)} /||v||, c c which approximately minimizes a bound on the relative error in the c difference approximation. c c ------------------------------------------------------------------------ c c Subroutines required by this and all called routines: c c    user supplied: f c c    nitsol routines: none c c    blas routine: daxpy, dscal c c    lapack routine:  dlamch c    user supplied or blas: dnorm c c    explanation: In nitsol, dnorm is set to either the blas c    dnrm2 routine or the user-supplied usrnrm routine. c c This subroutine called by: nitjv c c Subroutines called by this subroutine: daxpy, dlamch, dscal, dnorm, f c c Common block: c include 'nitprint.h' c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number. c c ------------------------------------------------------------------------ c double precision eps , epsmach , temp integer i , itrmf , ncall c double precision dlamch external dlamch c c ------------------------------------------------------------------------ data ncall / 0 / save ncall , epsmach c ------------------------------------------------------------------------ c Set epsmach (machine epsilon) on first call. c ------------------------------------------------------------------------ if ( ncall . eq . 0 ) epsmach = 2.0d0 * dlamch ( 'e' ) ncall = 1 c ------------------------------------------------------------------------ c Compute z = J*v by finite-differences: First, set eps = ||v||for later c use in computing the difference step; then evaluate the difference c formula according to ijacv and ifdord. c ------------------------------------------------------------------------ eps = dnorm ( n , v , 1 ) if ( eps . eq . 0.d0 ) then itrmjv = 1 go to 900 endif c ------------------------------------------------------------------------ c Here ijacv = 0 or ifdord = 1 => first-order forward difference. c ------------------------------------------------------------------------ if ( ijacv . eq . 0 . or . ifdord . eq . 1 ) then eps = dsqrt (( 1.d0 + dnorm ( n , xcur , 1 )) * epsmach ) / eps do 100 i = 1 , n v ( i ) = xcur ( i ) + eps * v ( i ) 100 continue call f ( n , v , z , rpar , ipar , itrmf ) if ( itrmf . ne . 0 ) then itrmjv = 1 goto 900 endif nfe = nfe + 1 do 110 i = 1 , n z ( i ) = ( z ( i ) - fcur ( i )) / eps 110 continue itrmjv = 0 go to 900 endif c ------------------------------------------------------------------------ c Here ijacv = -1 and ifdord = 2 => second-order central difference. c ------------------------------------------------------------------------ if ( ifdord . eq . 2 ) then eps = ((( 1.d0 + dnorm ( n , xcur , 1 )) * epsmach ) ** ( 1.d0 / 3.d0 )) / eps do 200 i = 1 , n rwork ( i ) = xcur ( i ) + eps * v ( i ) 200 continue call f ( n , rwork , z , rpar , ipar , itrmf ) nfe = nfe + 1 if ( itrmf . ne . 0 ) then itrmjv = 1 goto 900 endif do 210 i = 1 , n rwork ( i ) = xcur ( i ) - eps * v ( i ) 210 continue call f ( n , rwork , v , rpar , ipar , itrmf ) nfe = nfe + 1 if ( itrmf . ne . 0 ) then itrmjv = 1 goto 900 endif temp = 2.d0 * eps do 220 i = 1 , n z ( i ) = ( z ( i ) - v ( i )) / temp 220 continue itrmjv = 0 go to 900 endif c ------------------------------------------------------------------------ c Here ijacv = -1 and ifdord = 4 => fourth-order difference. c ------------------------------------------------------------------------ if ( ifdord . eq . 4 ) then eps = ((( 1.d0 + dnorm ( n , xcur , 1 )) * epsmach ) ** ( 1.d0 / 5.d0 )) / eps do 300 i = 1 , n rwork ( i ) = xcur ( i ) + eps * v ( i ) 300 continue call f ( n , rwork , z , rpar , ipar , itrmf ) nfe = nfe + 1 if ( itrmf . ne . 0 ) then itrmjv = 1 goto 900 endif temp = - eps call daxpy ( n , temp , v , 1 , xcur , 1 ) call f ( n , xcur , rwork , rpar , ipar , itrmf ) nfe = nfe + 1 if ( itrmf . ne . 0 ) then itrmjv = 1 goto 900 endif do 310 i = 1 , n z ( i ) = rwork ( i ) - z ( i ) 310 continue temp = eps / 2.d0 call daxpy ( n , temp , v , 1 , xcur , 1 ) call f ( n , xcur , rwork , rpar , ipar , itrmf ) nfe = nfe + 1 if ( itrmf . ne . 0 ) then itrmjv = 1 goto 900 endif temp = - 8.d0 call daxpy ( n , temp , rwork , 1 , z , 1 ) call daxpy ( n , eps , v , 1 , xcur , 1 ) call f ( n , xcur , rwork , rpar , ipar , itrmf ) nfe = nfe + 1 if ( itrmf . ne . 0 ) then itrmjv = 1 goto 900 endif temp = 8.d0 call daxpy ( n , temp , rwork , 1 , z , 1 ) temp = 1.d0 / ( 6.d0 * eps ) call dscal ( n , temp , z , 1 ) temp = - eps / 2.d0 call daxpy ( n , temp , v , 1 , xcur , 1 ) itrmjv = 0 endif c ------------------------------------------------------------------------ c All returns made here. c ------------------------------------------------------------------------ 900 continue return end","tags":"","loc":"sourcefile/nitjv.f.html"},{"title":"nitbt.f – BROWNPAK","text":"Contents Subroutines nitbt Source Code nitbt.f Source Code subroutine nitbt ( n , xcur , fcnrm , step , eta , xpls , fpls , fpnrm , $ oftjs , redfac , nfe , ibt , ibtmax , f , rpar , ipar , dnorm , $ itrmbt ) implicit none integer n , nfe , ibt , ibtmax , ipar ( * ), itrmbt double precision xcur ( n ), fcnrm , step ( n ), eta , $ xpls ( n ), fpls ( n ), fpnrm , oftjs , redfac , rpar ( * ), dnorm external f , dnorm c ------------------------------------------------------------------------ c c This is nitbt v0.3, the backtracking routine for the (inexact) Newton c iterations. c c ------------------------------------------------------------------------ c c Explanation: c c  n       = dimension of the problem c c  xcur    = vector of length n, current approximate solution (input). c c  fcnrm   = norm of f(xcur) c c  step    = vector of length n, initial (trial) step on input, final c            acceptable step on output. c c  eta     = initial inexact Newton level on input, final inexact Newton c            level on output. c c  xpls    = vector of length n, next approximate solution on output. c c  fpls    = vector of length n, value of f at xpls. c c  fpnrm   = norm of f(xpls) c c  oftjs   = original value of f(transpose)*Js. c c  redfac   = scalar factor by which the original step is reduced on output. c c  nfe     = number of function evaluations. c c  ibt     = number of backtracks on this call. c c  ibtmax   = maximum allowable number of backtracks (step reductions) c             per call to nitbt (default 10). c c             USAGE NOTE: If ibtmax = -1, then backtracking is turned c             off. In this case, the only function of this subroutine c             is to update xpls, fpls, and fpnrm. c c  f       = name of user-supplied subroutine for evaluating the function c            the zero of which is sought; this routine has the form c c                  subroutine f(n, xcur, fcur, rpar, ipar, itrmf) c c           where xcur is the array containing the current x value, fcur c           is f(xcur) on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmf is an integer termination flag.  The meaning of c           itrmf is as follows: c             0 => normal termination; desired function value calculated. c             1 => failure to produce f(xcur). c c  rpar    = real parameter/work array passed to the f and jacv routines. c c  ipar    = integer parameter/work array passed to the f and jacv routines. c c  dnorm   = norm routine, either user-supplied or blas dnrm2. c c  itrmbt  = termination flag; values have the following meanings: c              0 => normal termination: acceptable step found. c              1 => acceptable step not found in ibtmax reductions. c              2 => error in evaluation of f. c c ------------------------------------------------------------------------ c c Subroutines required by this and all called routines: c c    user supplied: f c c    nitsol routines: none c c    blas routine: dscal c c    user supplied or blas: dnorm c c    explanation: In nitsol, dnorm is set to either the blas c    dnrm2 routine or the user-supplied usrnrm routine. c c This subroutine called by: nitdrv c c Subroutines called by this subroutine: dnorm, dscal, f c c Common block: c include 'nitprint.h' c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number. c c ------------------------------------------------------------------------ double precision t , theta integer i , itrmf include 'nitparam.h' external nitbd c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Initialize. c ------------------------------------------------------------------------ t = 1.d-4 ibt = 0 redfac = 1.d0 c ------------------------------------------------------------------------ c Backtracking loop. c ------------------------------------------------------------------------ 100 continue do 110 i = 1 , n xpls ( i ) = xcur ( i ) + step ( i ) 110 continue call f ( n , xpls , fpls , rpar , ipar , itrmf ) if ( itrmf . ne . 0 ) then itrmbt = 2 go to 900 endif nfe = nfe + 1 fpnrm = dnorm ( n , fpls , 1 ) c ------------------------------------------------------------------------ c If t-condition is met or backtracking is turned off, return. c ------------------------------------------------------------------------ if ( fpnrm . le . ( 1.d0 - t * ( 1.d0 - eta )) * fcnrm . or . ibtmax . eq . - 1 ) $ then itrmbt = 0 go to 900 endif c ------------------------------------------------------------------------ c Otherwise, ... c ------------------------------------------------------------------------ ibt = ibt + 1 if ( ibt . gt . ibtmax ) then itrmbt = 1 go to 900 endif c ------------------------------------------------------------------------ c ... choose theta ... c ------------------------------------------------------------------------ theta = - ( oftjs * redfac ) / ( fpnrm ** 2 - fcnrm ** 2 - 2.d0 * oftjs * redfac ) if ( theta . lt . thmin ) theta = thmin if ( theta . gt . thmax ) theta = thmax c ------------------------------------------------------------------------ c ... then reduce the step, increase eta, update redfac ... c ------------------------------------------------------------------------ call dscal ( n , theta , step , 1 ) eta = 1.d0 - theta * ( 1.d0 - eta ) redfac = theta * redfac c ------------------------------------------------------------------------ c ... and return to the top of the loop. c ------------------------------------------------------------------------ c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 4 ) then if ( ibt . eq . 1 ) then write ( ipunit , * ) write ( ipunit , 800 ) write ( ipunit , * ) endif write ( ipunit , 810 ) ibt , fpnrm , theta endif 800 format ( 'nitbt:  Step reduction no., trial F norm, current ' , $ 'reduction factor' ) 810 format ( 5 x , i4 , 2 ( 5 x , 1 pd10 . 3 )) c ------------------------------------------------------------------------ go to 100 c ------------------------------------------------------------------------ c All returns made here. c ------------------------------------------------------------------------ 900 continue c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 3 . and . ibtmax . ne . - 1 ) then write ( ipunit , * ) if ( ibt . eq . 0 ) then write ( ipunit , 820 ) else write ( ipunit , 830 ) ibt , redfac endif endif 820 format ( 'nitbt:  no. of step reductions. = 0' ) 830 format ( 'nitbt:  no. of step reductions. =' , i2 , $ '    total reduction factor =' , 1 pd10 . 3 ) c ------------------------------------------------------------------------ return end","tags":"","loc":"sourcefile/nitbt.f.html"},{"title":"nitsol.f – BROWNPAK","text":"Contents Subroutines nitsol Source Code nitsol.f Source Code subroutine nitsol ( n , x , f , jacv , ftol , stptol , $ input , info , rwork , rpar , ipar , iterm , dinpr , dnorm ) implicit none integer n , input ( 10 ), info ( 6 ), ipar ( * ), iterm double precision x ( n ), ftol , stptol , rwork ( * ), rpar ( * ) double precision dinpr , dnorm external f , jacv , dinpr , dnorm c c ------------------------------------------------------------------------ c c This is nitsol v0.3. The basic algorithm is an inexact Newton method with c a backtracking globalization; the model is Algorithm INB of S. C. Eisenstat c and H. F. Walker, \"Globally convergent inexact Newton methods\", SIAM J. c Optimization, 4 (1994), pp. 393--422. Initial inexact Newton steps are c obtained by approximately solving the Newton equation with a transpose-free c Krylov subspace method; the current choices are GMRES, BiCGSTAB, and c TFQMR. Jacobian-vector products are evaluated either by finite-difference c approximation or a user-supplied analytic-evaluation subroutine. An option c is provided for user-supplied right preconditioning. Left preconditioning c is not explicitly included as an option, but the user may provide this c in the subroutines for evaluating the function and Jacobian-vector c products. Various algorithmic options can be selected through the input c vector. Optional common blocks are also available for printing diagnostic c information, passing information about the nonlinear iterations to user c subroutines, and controlling the behavior of the nonlinear iterations. c Summary statistics are provided by the info vector on output. c c This is the interface subroutine, which calls the driver subroutine nitdrv. c c ------------------------------------------------------------------------ c c Explanation: c c  n      = dimension of the problem. c c  x      = vector of length n, initial guess on input and final approximate c           solution on output. c c  f      = name of user-supplied subroutine for evaluating the function c           the zero of which is sought; this routine has the form c c                 subroutine f(n, xcur, fcur, rpar, ipar, itrmf) c c           where xcur is the array containing the current x value, fcur c           is f(xcur) on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmf is an integer termination flag.  The meaning of c           itrmf is as follows: c             0 => normal termination; desired function value calculated. c             1 => failure to produce f(xcur). c c  jacv   = name of user-supplied subroutine for optionally evaluating J*v c           or P(inverse)*v, where J is the Jacobian of f and P is a c           right preconditioning operator. If neither analytic J*v c           evaluations nor right preconditioning is used, this can c           be a dummy subroutine; if right preconditioning is used but c           not analytic J*v evaluations, this need only evaluate c           P(inverse)*v. The form is c c           subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) c c           where xcur and fcur are vectors of length n containing the c           current x and f values, ijob is an integer flag indicating c           which product is desired, v is a vector of length n to be c           multiplied, z is a vector of length n containing the desired c           product on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmjv is an integer termination flag. The meaning of c           ijob is as follows: c             0 => z = J*v c             1 => z = P(inverse)*v c           The meaning of itrmjv is as follows: c             0 => normal termination; desired product evaluated. c             1 => failure to produce J*v. c             2 => failure to produce P(inverse)*v. c           This subroutine is called only from nitjv, and is always c           called with v .ne. z. c c  ftol   = stopping tolerance on the f-norm. c c  stptol = stopping tolerance on the steplength. c c  input  = integer vector of length 10 containing various user-specified c           inputs; see below. c c  info   = integer vector of length 6 containing various outputs; c           see below. c c  rwork  = real work vector with length as follows: c c             solver    rwork length c c             GMRES     n*(kdmax+5)+kdmax*(kdmax+3), where kdmax is the c                       maximum Krylov subspace dimension, either the c                       default value of 20 or another value specified c                       by the user (see input(4) below). c c             BiCGSTAB  11*n c c             TFQMR     14*n c c           The final f-value is contained in the first n components of c           rwork on return. c c  rpar   = real parameter/work array passed to the f and jacv routines. c c  ipar   = integer parameter/work array passed to the f and jacv routines. c c  iterm   = termination flag; values have the following meanings: c             -k => illegal value in input(k). c              0 => normal termination: ||F||.le.ftol or ||step||.le.stptol. c              1 => nnimax nonlinear iterations reached without success. c              2 => failure to evaluate F. c              3 => in nitjv, J*v failure. c              4 => in nitjv, P(inverse)*v failure. c              5 => in nitdrv, insufficient initial model norm reduction c                   for adequate progress. NOTE: This can occur for several c                   reasons; examine itrmks on return from the Krylov c                   solver for further information. (This will be printed out c                   if iplvl .ge. 3; see the discussion of optional c                   common blocks below). c              6 => in nitbt, failure to reach an acceptable step through c                   backtracking. c c  dinpr  = name of user-supplied function for calculating vector inner c           products.  This function must have the form c c              xdoty = dinpr( n, x, sx, y, sy ) c c           where n is the length of the vectors, x and y are the c           starting locations of the vectors, and sx (sy) is the stride c           in memory between consecutive elements of x (y).  This is the c           same signature as the BLAS routine ddot; if the Euclidean c           inner product is desired the user can link to a local BLAS c           library and provide the name ddot to nitsol.  dinpr must be c           declared as an external function that returns a double c           precision value in the calling program. c c  dnorm  = name of user-supplied function for calculating vector norms. c           This function must have the form c c              xnorm = dnorm( n, x, sx ) c c           where n is the length of the vector, x is the starting c           location of the vector, and sx is the stride in memory c           between consecutive elements of x.  This is the same c           signature as the BLAS routine dnrm2; if the Euclidean c           norm is desired the user can link to a local BLAS library c           and provide the name dnrm2 to nitsol.  dnorm must be c           declared as an external function that returns a double c           precision value in the calling program. c c ------------------------------------------------------------------------ c c Further explanation of input: c c This array allows the user to specify various options. It should be c declared an integer vector of length 11 in the calling program. To c specify an option, set the appropriate input component to the desired c value according to the specifications below. c c USAGE NOTE: Setting a particular input component to zero gives the c default option for that component in all cases. c c The first five input components are things that every user might wish c to modify; the remainder will usually be of interest only to more c experienced users. c c Optional every-user input: c c    input(1) = nnimax = maximum number of nonlinear iterations (default 200). c c    input(2) = ijacv = flag for determining the method of J*v evaluation: c                 0 => finite-difference evaluation (default) c                 1 => analytic evaluation c c    input(3) = ikrysl = flag for determining the Krylov solver: c                 0 => GMRES (default) c                 1 => BiCGSTAB c                 2 => TFQMR c c               For brief descriptions of the solvers plus references, c               see the subroutines nitgm, nitstb, and nittfq. c c    input(4) = kdmax = maximum Krylov subspace dimension when GMRES is used c               (default 20). c c    input(5) = irpre = flag for right preconditioning: c                 0 => no right preconditioning c                 1 => right preconditioning c c Optional experienced user input: c c    input(6) = iksmax = maximum allowable number of iterations per call c               to the Krylov solver routine (default 1000). c c    input(7) = iresup = residual update flag when GMRES is used; on c               restarts, the residual is updated as follows: c                 0 => linear combination (default) c                 1 => direct evaluation c               The first is cheap (one n-vector saxpy) but may lose c               accuracy with extreme residual reduction; the second c               retains accuracy better but costs one J*v product per c               restart. c c    input(8) = ifdord = order of the finite-difference formula (sometimes) c               used when input(2) = ijacv = 0. When input(2) = ijacv = 0, c               this must be 0, 1, 2, or 4 on input; otherwise, it is c               irrelevant. With input(2) = ijacv = 0, the precise c               meaning is as follows: c c               If GMRES is used, then ifdord matters only if input(7) = c               iresup = 1, in which case it determines the order of c               the finite-difference formula used in evaluating the c               initial residual at each GMRES restart (default 2); if c               ifdord = 0 on input, then it is set to 2 below. NOTE: This c               only affects initial residuals at restarts; first-order c               differences are always used within each GMRES cycle. Using c               higher-order differences at restarts only should give c               the same accuracy as if higher-order differences were c               used throughout; see K. Turner and H. F. Walker, \"Efficient c               high accuracy solutions with GMRES(m),\" SIAM J. Sci. c               Stat. Comput., 13 (1992), pp. 815--825. c c               If BiCGSTAB or TFQMR is used, then ifdord determines the c               order of the finite-difference formula used at each c               iteration (default 1); if ifdord = 0 on input, then it c               is set to 1 below. c c    input(9) = ibtmax = maximum allowable number of backtracks (step c               reductions) per call to nitbt (default 10). c c               USAGE NOTE: Backtracking can be turned off by setting c\t\tibtmax = -1. Other negative values of ibtmax are not c               valid. c c    input(10) = ieta = flag determining the forcing term eta as follows: c                 0 => abs( ||fcur|| - ||fprev+Jprev*sprev|| )/||fprev|| c                      (default) c                 1 => (||fcur||/||fprev||)**2 c                 2 => gamma*(||fcur||/||fprev||)**alpha c                      for user-supplied gamma in (0,1] and alpha in (1,2] c                 3 => fixed (constant) eta in (0,1), either 0.1 (default) c\t\t       or specified by the user (see USAGE NOTE below) c               Here, fcur = current f, fprev = previous f, etc. The Krylov c               iterations are terminated when an iterate s satisfies c               an inexact Newton condition ||F + J*s|| .le. eta*||F||. c c               USAGE NOTE: If input(10) = ieta = 2, then alpha and gamma c               must be set in common block nitparam.h as described below. c\t\tIf input(10) = ieta = 3, then the desired constant eta may c\t\tbe similarly set in nitparam.h if a value other than the c\t\tdefault of 0.1 is desired. c c               The first three expressions above are from S. C. Eisenstat c               and H. F. Walker, \"Choosing the forcing terms in an inexact c               Newton method\", SIAM J. Scientific Computing, 17 (1996), c               pp. 16--32. (They may be modified according to certain c               safeguards in subroutine nitdrv.) The first gives convergence c               that is q-superlinear and of r-order (1+sqrt(5))/2. The c               second gives convergence that is r-quadratic and of q-order c               p for every p in [1,2). The third gives convergence that is c               of q-order alpha when gamma < 1 and, when gamma = 1, of c               r-order alpha and q-order p for every p in [1,alpha). The c               fourth gives q-linear convergence with asymptotic rate c               constant eta in a certain norm; see R. S. Dembo, S. C. c\t\tEisenstat, and T. Steihaug, \"Inexact Newton methods\", c               SIAM J. Numer. Anal., 18 (1982), pp. 400-408. c c               Of these four choices, the 1st is usually satisfactory, c               the 2nd or 3rd is sometimes preferred, and the 4th may be c               useful in some situations, e.g., it may be desirable to c               choose a fairly large fixed eta in (0,1), such as eta = .1, c               when numerical inaccuracy prevents the Krylov solver c               from obtaining much residual reduction. c c ------------------------------------------------------------------------ c c Further explanation of info: On output, the components of info are c as follows: c c     info(1)   = nfe (number of function evaluations) c     info(2)   = njve (number of J*v evaluations) c     info(3)   = nrpre (number of P(inverse)*v evaluations) c     info(4)   = nli (number of linear iterations) c     info(5)   = nni (number of nonlinear iterations) c     info(6)   = nbt (number of backtracks) c c ------------------------------------------------------------------------ c c Optional common blocks: c c These can be used to control printing of diagnostic information by nitsol, c to pass information about the nonlinear iterations to jacv or other user c subroutines, or to control the default behavior of the nonlinear iterations. c c For controlling printing of diagnostic information: c include 'nitprint.h' c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number, e.g., ipunit = 6 => standard output. c              NOTE: If ipunit = 0 on input, then it is set to 6 below. c c For passing information about the nonlinear iterations to user-supplied c subroutines: c include 'nitinfo.h' c c If information on the current state of the nonlinear iteration is c desired in a user-supplied subroutine (for example, deciding c whether to update a preconditioner), include this common block c in the subroutine. The variables are as follows: c c     instep - inexact Newton step number. c c    newstep - set to 0 at the beginning of an inexact Newton step. c              This may be checked in a user-supplied jacv to decide c              whether to update the preconditioner.  If you test on c              newstep .eq. 0 to determine whether to take some c              special action at the beginning of a nonlinear iteration, c              you must also set newstep to some nonzero value to c              subsequently avoid taking that action unnecessarily. c c    krystat - status of the Krylov iteration; same as itrmks (see c              the nitsol documentation). c c    avrate  - average rate of convergence of the Krylov solver during c              the previous inexact Newton step.  This may be checked c              in a user-supplied jacv to decide when to update the c              preconditioner. c c    fcurnrm - ||f(xcur)||. c c        eta - forcing term. c c c  For controlling the default behavior of the nonlinear iterations: c include 'nitparam.h' c nitparam contains some parameters that control the nonlinear c iterations.  In some cases, the default values reflect prevailing c practice; in other cases, they are chosen to produce good c average-case behavior.  To change the default values, include this c common block in the main program and set the desired variables c according to the following: c c    choice1_exp -  parameter used in the update of the forcing term c                   eta when ieta = 0 (default).  This is the exponent c                   for determining the etamin safeguard.  The default c                   value is choice1_exp = (1+sqrt(5))/2.  A larger c                   value will allow eta to decrease more rapidly, c                   while a smaller value will result in a larger c                   value for the safeguard. c c    choice2_exp  - parameter used in the update of the forcing term c                   eta when ieta = 2.  This is the exponent alpha c\t\t    in the expression gamma*(||fcur||/||fprev||)**alpha; c\t\t    it is also used to determine the etamin safeguard. c\t\t    The default value is 2.0. Valid values are in the c\t\t    range (1.0, 2.0]. c c    choice2_coef - parameter used in the update of the forcing term eta c                   when ieta = 2.  This is the coefficient gamma used c\t\t    in the expression gamma*(||fcur||/||fprev||)**alpha; c                   it is also used to determine the etamin safeguard. c                   The default value is 1.0. Valid values are in the c\t\t    range (0.0, 1.0]. c c    eta_cutoff   - parameter used to determine when to disable c                   safeguarding the update of the forcing term.  It c                   only has meaning when ieta .ne. 3.  The default c                   value is 0.1.  A value of 0.0 will enable c\t\t    safeguarding always; a value of 1.0 will disable c\t\t    safeguarding always. c c    etamax       - parameter used to provide an upper bound on the c\t\t    forcing terms when input(10) .ne. 3. This is c\t\t    necessary to ensure convergence of the inexact Newton c\t\t    iterates and is imposed whenever eta would otherwise c\t\t    be too large. (An overly large eta can result from c\t\t    the updating formulas when input(10) .ne. 3 or from c                   safeguarding when the previous forcing term has been c\t\t    excessively increased during backtracking.) The c\t\t    default value of etamax is 1.0 - 1.e-4.  When c\t\t    backtracking occurs several times during a nonlinear c\t\t    solve the forcing term can remain near etamax for several c                   nonlinear steps and cause the nonlinear iterations c                   to nearly stagnate.  In such cases a smaller value of c                   etamax may prevent this.  Valid values are in the c                   range (0.0, 1.0). c c    etafixed     - this is the user-supplied fixed eta when ieta = 3. c                   The  default value is etafixed = 0.1.  Valid values c                   are in the range (0.0,1.0). c c    thmin        - when backtracking occurs, this is the smallest c                   reduction factor that will be applied to the current c                   step in a single backtracking reduction.  The default c                   value is 0.1.  Valid  values are in the range c                   [0.0, thmax]. c c    thmax        - when backtracking occurs, this is the largest c                   reduction factor that will be applied to the current c                   step in a single backtracking reduction.  The default c                   value is 0.5.  Valid values are in the range c                   [thmin, 1.0). c c  The values in this common block are checked once here in nitsol c  before the main solution driver is called.  If any parameter has c  an invalid value, it is silently reset to the default value. c c ------------------------------------------------------------------------ c c Subroutines required by this and all called routines: c c     user supplied: f, jacv, dinpr, dnorm c c     nitsol routines: nitbd.f, nitbt, nitdrv, nitgm, nitjv, nitstb, nittfq c c     lapack routines: dlaic1, dlamch.f c c     blas routines: daxpy, dcopy, dscal, dswap c c This subroutine called by: calling program c c Subroutines called by this subroutine: nitdrv c c ------------------------------------------------------------------------ c c Remaining declarations: c integer ibtmax , ieta , ifdord , ijacv , ikrysl , iksmax , iresup , $ irpre , kdmax , lfcur , lfpls , lrwork , lstep , lxpls , $ nbt , nfe , njve , nli , nni , nnimax , nrpre include 'nitdflts.h' external nitbd c ------------------------------------------------------------------------ c c Begin executable code. c c ------------------------------------------------------------------------ c Check inputs and initialize parameters. c ------------------------------------------------------------------------ if ( ipunit . gt . 6 ) open ( unit = ipunit , status = 'unknown' ) if ( ipunit . eq . 0 ) ipunit = 6 if ( input ( 1 ) . eq . 0 ) then nnimax = 200 else if ( input ( 1 ) . gt . 0 ) then nnimax = input ( 1 ) else iterm = - 1 go to 900 endif endif if ( input ( 2 ) . eq . 0 . or . input ( 2 ) . eq . 1 ) then ijacv = input ( 2 ) else iterm = - 2 go to 900 endif if ( input ( 3 ) . ge . 0 . and . input ( 3 ) . le . 2 ) then ikrysl = input ( 3 ) else iterm = - 3 go to 900 endif if ( ikrysl . eq . 0 ) then if ( input ( 4 ) . eq . 0 ) then kdmax = 20 else if ( input ( 4 ) . gt . 0 ) then kdmax = input ( 4 ) else iterm = - 4 go to 900 endif endif endif if ( input ( 5 ) . eq . 0 . or . input ( 5 ) . eq . 1 ) then irpre = input ( 5 ) else iterm = - 5 go to 900 endif if ( input ( 6 ) . eq . 0 ) then iksmax = 1000 else if ( input ( 6 ) . gt . 0 ) then iksmax = input ( 6 ) else iterm = - 6 go to 900 endif endif if ( ikrysl . eq . 0 ) then if ( input ( 7 ) . eq . 0 . or . input ( 7 ) . eq . 1 ) then iresup = input ( 7 ) else iterm = - 7 go to 900 endif endif if ( ijacv . eq . 0 ) then if ( input ( 8 ) . eq . 0 ) then if ( ikrysl . eq . 0 ) then ifdord = 2 else ifdord = 1 endif else if ( input ( 8 ) . eq . 1 . or . input ( 8 ) . eq . 2 . or . $ input ( 8 ) . eq . 4 ) then ifdord = input ( 8 ) else iterm = - 8 go to 900 endif endif endif if ( input ( 9 ) . eq . 0 ) then ibtmax = 10 else if ( input ( 9 ) . gt . 0 . or . input ( 9 ) . eq . - 1 ) then ibtmax = input ( 9 ) else iterm = - 9 go to 900 endif endif if ( input ( 10 ) . ge . 0 . and . input ( 10 ) . le . 3 ) then ieta = input ( 10 ) else iterm = - 10 go to 900 endif c ------------------------------------------------------------------------ c  Check possible invalid value for printout level.  In c  case the value is invalid the default is restored. c ------------------------------------------------------------------------ if ( iplvl . lt . 0 . or . iplvl . gt . 4 ) iplvl = DFLT_PRLVL c ------------------------------------------------------------------------ c  Check possible invalid values for various parameters.  In c  case the values are invalid the defaults are restored. c ------------------------------------------------------------------------ if ( choice1_exp . le . 1.0d0 . or . choice1_exp . gt . 2.0d0 ) & choice1_exp = DFLT_CHOICE1_EXP if ( choice2_exp . le . 1.0d0 . or . choice2_exp . gt . 2.0d0 ) & choice2_exp = DFLT_CHOICE2_EXP if ( choice2_coef . lt . 0.0d0 . or . choice2_coef . gt . 1.0d0 ) & choice2_coef = DFLT_CHOICE2_COEF if ( etamax . le . 0.0d0 ) etamax = DFLT_ETA_MAX if ( thmin . lt . 0.0d0 . or . thmin . gt . thmax ) & thmin = DFLT_THMIN if ( thmax . gt . 1.0d0 . or . thmax . lt . thmin ) & thmax = DFLT_THMAX c ------------------------------------------------------------------------ c  Initialize some pointers into the rwork array. c ------------------------------------------------------------------------ lfcur = 1 lxpls = lfcur + n lfpls = lxpls + n lstep = lfpls + n lrwork = lstep + n c ------------------------------------------------------------------------ c Call nitdrv. c ------------------------------------------------------------------------ call nitdrv ( n , x , rwork ( lfcur ), rwork ( lxpls ), rwork ( lfpls ), $ rwork ( lstep ), f , jacv , rpar , ipar , ftol , stptol , nnimax , $ ijacv , ikrysl , kdmax , irpre , iksmax , iresup , ifdord , $ ibtmax , ieta , iterm , nfe , njve , nrpre , nli , nni , nbt , $ rwork ( lrwork ), dinpr , dnorm ) c ------------------------------------------------------------------------ c Set output for return. c ------------------------------------------------------------------------ info ( 1 ) = nfe info ( 2 ) = njve info ( 3 ) = nrpre info ( 4 ) = nli info ( 5 ) = nni info ( 6 ) = nbt c ------------------------------------------------------------------------ c All returns made here. c ------------------------------------------------------------------------ 900 continue if ( ipunit . gt . 6 ) close ( unit = ipunit ) return end c -------------------- end of subroutine nitsol  --------------------------","tags":"","loc":"sourcefile/nitsol.f.html"},{"title":"nitstb.f – BROWNPAK","text":"Contents Subroutines nitstb Source Code nitstb.f Source Code subroutine nitstb ( n , xcur , fcur , fcnrm , step , eta , f , jacv , rpar , $ ipar , ijacv , irpre , iksmax , ifdord , nfe , njve , $ nrpre , nli , r , rtil , p , phat , v , t , rwork1 , rwork2 , $ rsnrm , dinpr , dnorm , itrmks ) implicit none integer n , ipar ( * ), ijacv , irpre , iksmax , ifdord , nfe , njve , $ nrpre , nli , itrmks double precision xcur ( n ), fcur ( n ), fcnrm , step ( n ), eta , rpar ( * ), $ r ( n ), rtil ( n ), p ( n ), phat ( n ), v ( n ), t ( n ), rwork1 ( n ), $ rwork2 ( n ), rsnrm , dinpr , dnorm external f , jacv , dinpr , dnorm c ------------------------------------------------------------------------ c c This is nitstb v0.3, the BiCGSTAB routine for determining (trial) inexact c Newton steps. The original reference is H. van der Vorst, \"Bi-CGSTAB: c A fast and smoothly converging variant of Bi-CG for the soluton of c nonsymmetric linear systems,\" SIAM J. Sci. Statist. Comput., 13 (1992), c pp. 631--644. c c ------------------------------------------------------------------------ c c Explanation: c c  n       = dimension of the problem. c c  xcur    = vector of length n, current approximate solution. c c  fcur    = vector of length n, value of f at xcur. c c  fcnrm   = norm of fcur. c c  step    = vector of length n, (trial) step. c c  eta     = relative residual reduction factor. c c  f      = name of user-supplied subroutine for evaluating the function c           the zero of which is sought; this routine has the form c c                 subroutine f(n, xcur, fcur, rpar, ipar, itrmf) c c           where xcur is the array containing the current x value, fcur c           is f(xcur) on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmf is an integer termination flag.  The meaning of c           itrmf is as follows: c             0 => normal termination; desired function value calculated. c             1 => failure to produce f(xcur). c c  jacv   = name of user-supplied subroutine for evaluating J*v or c           P(inverse)*v, where J is the Jacobian of f and P is a c           right preconditioning operator. If neither analytic J*v c           evaluations nor right preconditioning is used, this can c           be a dummy subroutine; if right preconditioning is used but c           not analytic J*v evaluations, this need only evaluate c           P(inverse)*v. The form is c c           subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) c c           where xcur and fcur are vectors of length n containing the c           current x and f values, ijob is an integer flag indicating c           which product is desired, v is a vector of length n to be c           multiplied, z is a vector of length n containing the desired c           product on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmjv is an integer termination c           flag. The meaning of ijob is as follows: c             0 => z = J*v c             1 => z = P(inverse)*v c           The meaning of itrmjv is as follows: c             0 => normal termination; desired product evaluated. c             1 => failure to produce J*v. c             2 => failure to produce P(inverse)*v. c           This subroutine is called only from nitjv, and is always c           called with v .ne. z. c c  rpar    = real parameter/work array passed to the f and jacv routines. c c  ipar    = integer parameter/work array passed to the f and jacv routines. c c  ijacv   = flag for determining method of J*v evaluation. c              0 => finite-difference evaluation (default). c              1 => analytic evaluation. c c  irpre   = flag for right preconditioning. c              0 => no right preconditioning c              1 => right preconditioning c c  iksmax  = maximum allowable number of BiCGSTAB iterations. c c  ifdord  = order of the finite-difference formula used in BiCGSTAB c            when J*v products are evaluated using finite-differences. c            When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or c            4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on c            input to this subroutine, ifdord determines the order of the c            finite-difference formula used at each BiCGSTAB iteration c            (default 1). In this case, ijacv is set to -1 below to c            signal to nitjv that the order of the finite-difference c            formula is to be determined by ifdord. The original value c            ijacv = 0 is restored on return. c c  nfe     = number of function evaluations. c c  njve    = number of J*v evaluations. c c  nrpre   = number of P(inverse)*v evaluations. c c  nli     = number of linear iterations. c c  r       = residual vector c c  rtil    = \"r-tilde\" vector used in BiCGSTAB c c  p       = vector used in BiCGSTAB c c  phat    = vector used in BiCGSTAB c c  v       = vector used in BiCGSTAB c c  t       = vector used in BiCGSTAB c c  rwork1  = work vector, passed on to nitjv c c  rwork2  = work vector, passed on to nitjv c c  rsnrm   = BiCGSTAB residual norm on return. c c  dinpr   = inner-product routine, either user-supplied or blas ddot. c c  dnorm   = norm routine, either user-supplied or blas dnrm2. c c  itrmks  = termination flag; values have the following meanings: c              0 => normal termination: acceptable step found. c              1 => J*v failure in nitjv. c              2 => P(inverse)*v failure in nitjv. c              3 => acceptable step not found in iksmax BiCGSTAB iterations. c              4 => BiCGSTAB breakdown. c c             Note: On return, nitsol terminates if itrmks is 1 or 2. c             If itrmks is 3 or 4, nitsol may terminate or continue. c             In this event, the step returned is a meaningful inexact c             Newton step only if the residual norm has been reduced. c             A decision on termination/continuation is made in nitdrv c             according to whether there is sufficient residual norm c             reduction, even though the desired inexact Newton condition c             may not hold. c c ------------------------------------------------------------------------- c c Subroutines required by this and all called routines: c c    user supplied: f, jacv c c    nitsol routines: nitjv, nitfd c c    blas routines: daxpy, dcopy, dscal c c    lapack routine:  dlamch c c    user supplied or blas: dinpr, dnorm c c    explanation: In nitsol, dinpr and dnorm are set to either the blas c    ddot and dnrm2 routines or the user-supplied usrnpr and usrnrm c    routines. c c This subroutine called by: nitdrv c c Subroutines called by this subroutine: daxpy, dcopy, dscal, dinpr, dlamch, c    dnorm, nitjv c c Common block: c include 'nitprint.h' c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number. c c ------------------------------------------------------------------------ c double precision abstol , alpha , beta , omega , $ rho , rhomns , tau , temp integer i , istb , itask , itrmjv double precision dlamch external dlamch c double precision sfmin data sfmin / 0.0d0 / c ------------------------------------------------------------------------ c c  Initialize sfmin only on first entry. c if ( sfmin . eq . 0.0d0 ) sfmin = dlamch ( 's' ) c ------------------------------------------------------------------------ c If finite-differences are used to evaluate J*v products (ijacv= 0), then c ijacv is set to -1 within this subroutine to signal to nitjv that the c order of the finite-difference formula is to be determined by ifdord. c The original value ijacv= 0 is restored on return. c ------------------------------------------------------------------------ if ( ijacv . eq . 0 ) ijacv = - 1 c ------------------------------------------------------------------------ c Set the stopping tolerance, initialize the step, etc. c ------------------------------------------------------------------------ rsnrm = fcnrm abstol = eta * rsnrm do 10 i = 1 , n step ( i ) = 0.d0 10 continue istb = 0 c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 3 ) then write ( ipunit , * ) write ( ipunit , 800 ) eta endif 800 format ( 'nitstb:  eta =' , 1 pd10 . 3 ) if ( iplvl . ge . 4 ) then write ( ipunit , 810 ) write ( ipunit , * ) write ( ipunit , 820 ) istb , rsnrm endif 810 format ( 'nitstb:  BiCGSTAB iteration no. (parts a and b)' , $ ' linear residual norm, ' ) 820 format ( 5 x , i4 , 5 x , 1 pd10 . 3 ) c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Set up r and rtil. c ------------------------------------------------------------------------ call dcopy ( n , fcur , 1 , r , 1 ) temp = - 1.d0 call dscal ( n , temp , r , 1 ) call dcopy ( n , r , 1 , rtil , 1 ) c ------------------------------------------------------------------------ c Top of the iteration loop. c ------------------------------------------------------------------------ 100 continue istb = istb + 1 nli = nli + 1 c ------------------------------------------------------------------------ c Perform the first \"half-iteration\". c ------------------------------------------------------------------------ rho = dinpr ( n , rtil , 1 , r , 1 ) if ( istb . eq . 1 ) then call dcopy ( n , r , 1 , p , 1 ) else if ( abs ( rhomns ) . lt . sfmin * abs ( rho ) ) then itrmks = 4 goto 900 else beta = ( rho / rhomns ) * ( alpha / omega ) call daxpy ( n , - omega , v , 1 , p , 1 ) call dscal ( n , beta , p , 1 ) call daxpy ( n , 1.d0 , r , 1 , p , 1 ) endif endif if ( irpre . eq . 0 ) then call dcopy ( n , p , 1 , phat , 1 ) else itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , p , phat , $ rwork1 , rwork2 , dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then itrmks = 2 go to 900 endif endif itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , phat , v , $ rwork1 , rwork2 , dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then itrmks = 1 go to 900 endif tau = dinpr ( n , rtil , 1 , v , 1 ) if ( abs ( tau ) . lt . sfmin * abs ( rho ) ) then itrmks = 4 goto 900 else alpha = rho / tau endif call daxpy ( n , - alpha , v , 1 , r , 1 ) call daxpy ( n , alpha , phat , 1 , step , 1 ) rsnrm = dnorm ( n , r , 1 ) c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 4 ) then write ( ipunit , 830 ) istb , rsnrm 830 format ( 5 x , i4 , '.a' , 3 x , 1 pd10 . 3 ) endif c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Test for termination. c ------------------------------------------------------------------------ if ( rsnrm . le . abstol ) then itrmks = 0 go to 900 endif c ------------------------------------------------------------------------ c Perform the second \"half-iteration\". c ------------------------------------------------------------------------ if ( irpre . eq . 0 ) then call dcopy ( n , r , 1 , phat , 1 ) else itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , r , phat , $ rwork1 , rwork2 , dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then itrmks = 2 go to 900 endif endif itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , phat , t , $ rwork1 , rwork2 , dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then itrmks = 1 go to 900 endif tau = dnorm ( n , t , 1 ) tau = tau * tau temp = dinpr ( n , t , 1 , r , 1 ) if ( tau . le . sfmin * abs ( temp ) ) then itrmks = 4 goto 900 else omega = temp / tau endif if ( abs ( omega ) . lt . sfmin * abs ( alpha ) ) then itrmks = 4 go to 900 endif call daxpy ( n , - omega , t , 1 , r , 1 ) call daxpy ( n , omega , phat , 1 , step , 1 ) rsnrm = dnorm ( n , r , 1 ) c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 4 ) then write ( ipunit , 840 ) istb , rsnrm 840 format ( 5 x , i4 , '.b' , 3 x , 1 pd10 . 3 ) endif c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Test for termination. c ------------------------------------------------------------------------ if ( rsnrm . le . abstol ) then itrmks = 0 go to 900 endif if ( istb . ge . iksmax ) then itrmks = 3 go to 900 endif c ------------------------------------------------------------------------ c If continuing, update and return to the top of the iteration loop. c ------------------------------------------------------------------------ rhomns = rho go to 100 c ------------------------------------------------------------------------ c Bottom of the iteration loop. c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c All returns made here. c ------------------------------------------------------------------------ 900 continue c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 3 ) then write ( ipunit , * ) if ( itrmks . ne . 1 . and . itrmks . ne . 2 ) then write ( ipunit , 850 ) itrmks , rsnrm 850 format ( 'nitstb:  itrmks =' , i2 , '   final lin. res. norm =' , $ 1 pd10 . 3 ) else write ( ipunit , 860 ) itrmks 860 format ( 'nitstb: itrmks:' , i4 ) endif endif c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c If ijacv = -1, then restore it to the original value ijacv = 0. c ------------------------------------------------------------------------ if ( ijacv . eq . - 1 ) ijacv = 0 return end","tags":"","loc":"sourcefile/nitstb.f.html"},{"title":"nitgm.f – BROWNPAK","text":"Contents Subroutines nitgm Source Code nitgm.f Source Code subroutine nitgm ( n , xcur , fcur , fcnrm , step , eta , f , jacv , rpar , $ ipar , ijacv , irpre , iksmax , iresup , ifdord , nfe , njve , $ nrpre , nli , kdmax , kdmaxp1 , vv , rr , svbig , svsml , w , rwork , $ rsnrm , dinpr , dnorm , itrmks ) implicit none integer n , ipar ( * ), ijacv , irpre , iksmax , iresup , ifdord , nfe , $ njve , nrpre , nli , kdmax , kdmaxp1 , itrmks double precision xcur ( n ), fcur ( n ), fcnrm , step ( n ), eta , rpar ( * ), $ vv ( n , kdmaxp1 ), rr ( kdmax , kdmax ), svbig ( kdmax ), svsml ( kdmax ), $ w ( kdmax ), rwork ( n ), rsnrm , dinpr , dnorm external f , jacv , dinpr , dnorm c ------------------------------------------------------------------------ c c This is nitgm v0.3, the GMRES routine for determining (trial) inexact c Newton steps. This implementation is the \"simpler\" Gram-Schmidt GMRES c implementation from L. Zhou and H. F. Walker, \"A simpler GMRES,\" c J. Numerical Lin. Alg. Appl., 1 (1994), pp. 571-581. c c ------------------------------------------------------------------------ c c Explanation: c c  n       = dimension of the problem. c c  xcur    = vector of length n, current approximate solution. c c  fcur    = vector of length n, value of f at xcur. c c  fcnrm   = norm of fcur. c c  step    = vector of length n, (trial) step. c c  eta     = relative residual reduction factor. c c  f       = name of user-supplied subroutine for evaluating the function c            the zero of which is sought; this routine has the form c c                  subroutine f(n, xcur, fcur, rpar, ipar, itrmf) c c           where xcur is the array containing the current x value, fcur c           is f(xcur) on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmf is an integer termination flag.  The meaning of c           itrmf is as follows: c             0 => normal termination; desired function value calculated. c             1 => failure to produce f(xcur). c c  jacv    = name of user-supplied subroutine for evaluating J*v or c            P(inverse)*v, where J is the Jacobian of f and P is a c            right preconditioning operator. If neither analytic J*v c            evaluations nor right preconditioning is used, this can c            be a dummy subroutine; if right preconditioning is used but c            not analytic J*v evaluations, this need only evaluate c            P(inverse)*v. The form is c c            subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) c c            where xcur and fcur are vectors of length n containing the c            current x and f values, ijob is an integer flag indicating c            which product is desired, v is a vector of length n to be c            multiplied, z is a vector of length n containing the desired c            product on output, rpar and ipar are, respectively, real c            and integer parameter/work arrays for use by the subroutine, c            and itrmjv is an integer termination c            flag. The meaning of ijob is as follows: c              0 => z = J*v c              1 => z = P(inverse)*v c            The meaning of itrmjv is as follows: c              0 => normal termination; desired product evaluated. c              1 => failure to produce J*v. c              2 => failure to produce P(inverse)*v. c            This subroutine is called only from nitjv, and is always c            called with v .ne. z. c c  rpar    = real parameter/work array passed to the f and jacv routines. c c  ipar    = integer parameter/work array passed to the f and jacv routines. c c  ijacv   = flag for determining method of J*v evaluation. c              0 => finite-difference evaluation (default). c              1 => analytic evaluation. c c  irpre   = flag for right preconditioning. c              0 => no right preconditioning c              1 => right preconditioning c c  iksmax  = maximum allowable number of GMRES iterations. c c  iresup  = residual update flag; on GMRES restarts, the residual is c            updated as follows: c               0 => linear combination (default) c               1 => direct evaluation c            The first is cheap (one n-vector saxpy) but may lose c            accuracy with extreme residual reduction; the second c            retains accuracy better but costs one J*v product c c  ifdord  = order of the finite-difference formula (sometimes) used on c            GMRES restarts when J*v products are evaluated using finite- c            differences. When ijacv = 0 on input to nitsol, ifdord is set c            to 1, 2, or 4 in nitsol; otherwise, it is irrelevant. When c            ijacv = 0 on input to this subroutine, the precise meaning is c            as follows: c c            With GMRES, ifdord matters only if iresup = 1, in which case c            it determines the order of the finite-difference formula used c            in evaluating the initial residual at each GMRES restart c            (default 2). If iresup = 1 and ijacv = 0 on input to this c            subroutine, then ijacv is temporarily reset to -1 at each c            restart below to force a finite-difference evaluation of order c            ifdord. NOTE: This only affects initial residuals at restarts; c            first-order differences are always used within each GMRES c            cycle. Using higher-order differences at restarts only should c            give the same accuracy as if higher-order differences were c            used throughout; see K. Turner and H. F. Walker, \"Efficient c            high accuracy solutions with GMRES(m),\" SIAM J. Sci. Stat. c            Comput., 13 (1992), pp. 815--825. c c  nfe     = number of function evaluations. c c  njve    = number of J*v evaluations. c c  nrpre   = number of P(inverse)*v evaluations. c c  nli     = number of linear iterations. c c  kdmax   = maximum Krylov subspace dimension; default 10. c c  kdmaxp1 = kdmax + 1. c c  vv      = n x (kdmax+1) matrix for storage of Krylov basis in GMRES; c            on return, the residual vector is contained in the first c            column. c c  rr      = kdmax x kdmax matrix for storage of triangular matrix in GMRES. c c  svbig   = vector of length kdmax for storage of estimate of singular c            vector of rr with largest singular value. c c  svsml   = vector of length kdmax for storage of estimate of singular c            vector of rr with smallest singular value. c c  w       = vector of length kdmax, contains right-hand side of c            triangular system and least-squares residual norm in GMRES. c c  rwork   = vector of length n, work array. c c  rsnrm   = GMRES residual norm on return. c c  dinpr   = inner-product routine, either user-supplied or blas ddot. c c  dnorm   = norm routine, either user-supplied or blas dnrm2. c c  itrmks  = termination flag; values have the following meanings: c              0 => normal termination: acceptable step found. c              1 => J*v failure in nitjv. c              2 => P(inverse)*v failure in nitjv. c              3 => acceptable step not found in iksmax GMRES iterations. c              4 => insufficient residual norm reduction over a cycle c                   of kdmax steps (stagnation) before an acceptable step c                   has been found. c              5 => dangerous ill-conditioning detected before an acceptable c                   step has been found. c c             Note: On return, nitsol terminates if itrmks is 1 or 2. If c             itrmks is 3, 4, or 5, nitsol may terminate or continue. In c             this event, a meaningful inexact Newton step is returned, c             even though the desired inexact Newton condition may not c             hold, and a decision on termination/continuation is made c             in nitdrv according to whether there is sufficient residual c             norm reduction. c c ------------------------------------------------------------------------- c c Subroutines required by this and all called routines: c c    user supplied: f, jacv c c    nitsol routines: nitjv, nitfd c c    lapack routine: dlaic1, dlamch c c    blas routines: daxpy, dcopy, dscal c c    user supplied or blas: dinpr, dnorm c c    explanation: In nitsol, dinpr and dnorm are set to either the blas c    ddot and dnrm2 routines or the user-supplied usrnpr and usrnrm c    routines. c c This subroutine called by: nitdrv c c Subroutines called by this subroutine: daxpy, dcopy, dscal, dlaic1, c    dlamch, dinpr, dnorm, nitjv c c Common block: c include 'nitprint.h' c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number. c c ------------------------------------------------------------------------ c double precision abstol , big , cs , cndmax , epsmach , rsnrm0 , $ sestpr , small , sn , temp integer i , igm , ijob , itask , itrmjv , kd , kdp1 , ncall double precision dlamch external dlamch c ------------------------------------------------------------------------ c ------------------------------------------------------------------------ data ncall / 0 / save ncall , cndmax , epsmach c ------------------------------------------------------------------------ c Initialize. c ------------------------------------------------------------------------ if ( ncall . eq . 0 ) then epsmach = 2.0d0 * dlamch ( 'e' ) ncall = 1 cndmax = 1.d0 / ( 10 0.d0 * epsmach ) endif do 20 i = 1 , n step ( i ) = 0.d0 20 continue igm = 0 c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 3 ) then write ( ipunit , * ) write ( ipunit , 800 ) eta endif 800 format ( 'nitgm:  eta =' , 1 pd10 . 3 ) if ( iplvl . ge . 4 ) then write ( ipunit , 810 ) write ( ipunit , * ) write ( ipunit , 820 ) igm , fcnrm endif 810 format ( 'nitgm:  GMRES iteration no., linear residual norm, ' , $ 'condition no. estimate' ) 820 format ( 5 x , i4 , 2 ( 5 x , 1 pd10 . 3 )) c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Set the stopping tolerance, etc. c ------------------------------------------------------------------------ rsnrm0 = fcnrm abstol = eta * rsnrm0 c ------------------------------------------------------------------------ c Place the normalized initial residual in the first column of the vv array. c ------------------------------------------------------------------------ call dcopy ( n , fcur , 1 , vv ( 1 , 1 ), 1 ) temp = - 1.d0 / fcnrm call dscal ( n , temp , vv ( 1 , 1 ), 1 ) c ------------------------------------------------------------------------ c Top of the outer GMRES loop. c ------------------------------------------------------------------------ 100 continue kd = 0 rsnrm = 1.d0 c ------------------------------------------------------------------------ c Top of the inner GMRES loop. c ------------------------------------------------------------------------ 200 continue kd = kd + 1 kdp1 = kd + 1 nli = nli + 1 igm = igm + 1 c ------------------------------------------------------------------------ c Evaluate J*(kd-th Krylov subspace basis vector) in vv(.,kdp1). c Note: rwork can be used for both work arrays in this call because c the second is not referenced within nitjv. c ------------------------------------------------------------------------ if ( irpre . eq . 0 ) then itask = 0 else itask = 1 endif call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , vv ( 1 , kd ), vv ( 1 , kdp1 ), $ rwork , rwork , dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then if ( itrmjv . eq . 1 ) itrmks = 1 if ( itrmjv . eq . 2 ) itrmks = 2 go to 900 endif c ------------------------------------------------------------------------ c Do modified Gram-Schmidt. c ------------------------------------------------------------------------ do 210 i = 2 , kd rr ( i - 1 , kd ) = dinpr ( n , vv ( 1 , i ), 1 , vv ( 1 , kdp1 ), 1 ) call daxpy ( n , - rr ( i - 1 , kd ), vv ( 1 , i ), 1 , vv ( 1 , kdp1 ), 1 ) 210 continue rr ( kd , kd ) = dnorm ( n , vv ( 1 , kdp1 ), 1 ) c ------------------------------------------------------------------------ c Update the estimates of the largest and smallest singular values. c ------------------------------------------------------------------------ if ( kd . eq . 1 ) then big = rr ( 1 , 1 ) small = big svbig ( 1 ) = 1.d0 svsml ( 1 ) = 1.d0 else ijob = 1 call dlaic1 ( ijob , kd - 1 , svbig , big , rr ( 1 , kd ), rr ( kd , kd ), $ sestpr , sn , cs ) big = sestpr call dscal ( kd - 1 , sn , svbig , 1 ) svbig ( kd ) = cs ijob = 2 call dlaic1 ( ijob , kd - 1 , svsml , small , rr ( 1 , kd ), rr ( kd , kd ), $ sestpr , sn , cs ) small = sestpr call dscal ( kd - 1 , sn , svsml , 1 ) svsml ( kd ) = cs endif c ------------------------------------------------------------------------ c Terminate if the estimated condition number is too great. c ------------------------------------------------------------------------ if ( big . ge . small * cndmax ) then if ( kd . eq . 1 ) then itrmks = 5 go to 900 else kdp1 = kd kd = kd - 1 call daxpy ( n , w ( kd ), vv ( 1 , kdp1 ), 1 , vv ( 1 , 1 ), 1 ) go to 300 endif endif c ------------------------------------------------------------------------ c Normalize vv(.,kdp1). c ------------------------------------------------------------------------ temp = 1.d0 / rr ( kd , kd ) call dscal ( n , temp , vv ( 1 , kdp1 ), 1 ) c ------------------------------------------------------------------------ c Update w and the residual norm by rsnrm <- rsnrm*dsin(dacos(w(kd)/rsnrm). c ------------------------------------------------------------------------ w ( kd ) = dinpr ( n , vv ( 1 , 1 ), 1 , vv ( 1 , kdp1 ), 1 ) temp = max ( min ( w ( kd ) / rsnrm , 1.0D0 ), - 1.0d0 ) rsnrm = rsnrm * dsin ( dacos ( temp )) c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 4 ) then write ( ipunit , 820 ) igm , rsnrm * rsnrm0 , big / small c         if (kd .eq. kdmax) write(ipunit,*) endif c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Test for termination of the inner loop. c ------------------------------------------------------------------------ if ( ( rsnrm0 * rsnrm . le . abstol ) . or . ( kd . eq . kdmax ) . or . $ ( igm . ge . iksmax ) ) go to 300 c ------------------------------------------------------------------------ c If not terminating the inner loop, update the residual vector c and go to the top of the inner loop. c ------------------------------------------------------------------------ call daxpy ( n , - w ( kd ), vv ( 1 , kdp1 ), 1 , vv ( 1 , 1 ), 1 ) go to 200 c ------------------------------------------------------------------------ c Bottom of inner loop. c ------------------------------------------------------------------------ 300 continue c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 4 ) then write ( ipunit , * ) endif c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Compute the solution: c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Use svbig for storage of the original components of w. c ------------------------------------------------------------------------ call dcopy ( kd , w , 1 , svbig , 1 ) c ------------------------------------------------------------------------ c Overwrite w with the solution of the upper triangular system. c ------------------------------------------------------------------------ do 310 i = kd , 1 , - 1 w ( i ) = w ( i ) / rr ( i , i ) if ( i . gt . 1 ) call daxpy ( i - 1 , - w ( i ), rr ( 1 , i ), 1 , w , 1 ) 310 continue c ------------------------------------------------------------------------ c Now form the linear combination to accumulate the correction in c the work vector. c ------------------------------------------------------------------------ call dcopy ( n , vv ( 1 , 1 ), 1 , rwork , 1 ) call dscal ( n , w ( 1 ), rwork , 1 ) if ( kd . gt . 1 ) then call daxpy ( kd - 1 , w ( 1 ), svbig , 1 , w ( 2 ), 1 ) do 320 i = 2 , kd call daxpy ( n , w ( i ), vv ( 1 , i ), 1 , rwork , 1 ) 320 continue endif c ------------------------------------------------------------------------ c If iresup .eq. 0, then update the residual vector by linear c combination. This frees vv(.,kdp1) for use as a work array. c ------------------------------------------------------------------------ if ( iresup . eq . 0 ) then call daxpy ( n , - svbig ( kd ), vv ( 1 , kdp1 ), 1 , vv ( 1 , 1 ), 1 ) endif c ------------------------------------------------------------------------ c If right preconditioning is used, overwrite c correction <-- P(inverse)*correction, using vv(.,kdp1) as a work array. c Note: vv(.,kdp1) can be used for both work arrays in this call because c the second is not referenced within nitjv. c ------------------------------------------------------------------------ if ( irpre . gt . 0 ) then itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , rwork , rwork , $ vv ( 1 , kdp1 ), vv ( 1 , kdp1 ), dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then itrmks = 2 go to 900 endif endif c ------------------------------------------------------------------------ c Update the step. This frees rwork for use as a work array. c ------------------------------------------------------------------------ call daxpy ( n , rsnrm0 , rwork , 1 , step , 1 ) c ------------------------------------------------------------------------ c If iresup .eq. 1, then update the residual vector by direct evaluation, c using rwork and vv(.,kdp1) as work arrays. Note: Two distinct work c arrays are needed in this call because both are referenced within nitjv c if the J*step product is evaluated with a finite-difference of order c two or higher. If finite-differences are used (ijacv= 0), then ijacv c is temporarily set to -1 to signal to nitjv that the order of the c finite-difference formula is to be determined by ifdord. c ------------------------------------------------------------------------ if ( iresup . eq . 1 ) then itask = 0 if ( ijacv . eq . 0 ) ijacv = - 1 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , step , vv ( 1 , 1 ), $ rwork , vv ( 1 , kdp1 ), dnorm , itrmjv ) if ( ijacv . eq . - 1 ) ijacv = 0 if ( itrmjv . gt . 0 ) then itrmks = 1 go to 900 endif do 330 i = 1 , n vv ( i , 1 ) = - fcur ( i ) - vv ( i , 1 ) 330 continue endif c ------------------------------------------------------------------------ c Test for termination. c ------------------------------------------------------------------------ if ( rsnrm0 * rsnrm . le . abstol ) then itrmks = 0 go to 900 endif if ( igm . ge . iksmax ) then itrmks = 3 go to 900 endif if ( big . ge . small * cndmax ) then itrmks = 5 go to 900 endif temp = dfloat ( kd ) * dlog ( abstol / ( rsnrm0 * rsnrm )) / $ dlog ( rsnrm / ( 1.d0 + 1 0.d0 * epsmach )) if ( temp . ge . 100 0.d0 * dfloat ( iksmax - igm )) then itrmks = 4 go to 900 endif c ------------------------------------------------------------------------ c If not terminating, then normalize the initial residual, etc., and c return to the top of the outer loop. c ------------------------------------------------------------------------ if ( iresup . eq . 0 ) then rsnrm0 = rsnrm0 * rsnrm temp = 1.d0 / rsnrm else rsnrm0 = dnorm ( n , vv ( 1 , 1 ), 1 ) temp = 1.d0 / rsnrm0 endif call dscal ( n , temp , vv ( 1 , 1 ), 1 ) go to 100 c ------------------------------------------------------------------------ c All returns made here. c ------------------------------------------------------------------------ 900 continue if ( itrmks . ne . 1 . and . itrmks . ne . 2 ) then if ( iresup . eq . 0 ) then call dscal ( n , rsnrm0 , vv ( 1 , 1 ), 1 ) rsnrm = rsnrm0 * rsnrm else rsnrm = dnorm ( n , vv ( 1 , 1 ), 1 ) endif endif c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 3 ) then if ( itrmks . ne . 1 . and . itrmks . ne . 2 ) then write ( ipunit , 830 ) itrmks , rsnrm 830 format ( 'nitgm:  itrmks =' , i2 , '    final lin. res. norm =' , $ 1 pd10 . 3 ) else write ( ipunit , 840 ) itrmks 840 format ( 'nitgm: itrmks:' , i4 ) endif endif c ------------------------------------------------------------------------ return end","tags":"","loc":"sourcefile/nitgm.f.html"},{"title":"nitdrv.f – BROWNPAK","text":"Contents Subroutines nitdrv Source Code nitdrv.f Source Code subroutine nitdrv ( n , xcur , fcur , xpls , fpls , $ step , f , jacv , rpar , ipar , ftol , stptol , nnimax , $ ijacv , ikrysl , kdmax , irpre , iksmax , iresup , ifdord , $ ibtmax , ieta , iterm , nfe , njve , nrpre , nli , nni , nbt , $ rwork , dinpr , dnorm ) implicit none integer n , ipar ( * ), nnimax , ijacv , ikrysl , kdmax , irpre , $ iksmax , iresup , ifdord , ibtmax , ieta , iterm , nfe , njve , $ nrpre , nli , nni , nbt double precision xcur ( n ), fcur ( n ), xpls ( n ), fpls ( n ), $ step ( n ), rpar ( * ), ftol , stptol , rwork ( * ), dinpr , dnorm external f , jacv , dinpr , dnorm c ------------------------------------------------------------------------ c c This is nitdrv v0.3, the driver routine for the Newton iterative c method. c c ------------------------------------------------------------------------ c c Explanation: c c  n       = dimension of the problem. c c  xcur    = vector of length n, initial guess on input and final c            approximate solution on output. c c  fcur    = vector of length n, value of f at xcur. c c  xpls    = vector of length n, next (trial) approximate solution. c            Also used as a work array where indicated. c c  fpls    = vector of length n, value of f at xpls. Also used as a c            work array where indicated. c c  step    = vector of length n, (trial) step. c c  f       = name of user-supplied subroutine for evaluating the function c            the zero of which is sought; this routine has the form c c                 subroutine f(n, xcur, fcur, rpar, ipar, itrmf) c c           where xcur is the array containing the current x value, fcur c           is f(xcur) on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmf is an integer termination flag.  The meaning of c           itrmf is as follows: c             0 => normal termination; desired function value calculated. c             1 => failure to produce f(xcur). c c  jacv    = name of user-supplied subroutine for evaluating J*v or c            P(inverse)*v, where J is the Jacobian of f and P is a c            right preconditioning operator. If neither analytic J*v c            evaluations nor right preconditioning is used, this can c            be a dummy subroutine; if right preconditioning is used but c            not analytic J*v evaluations, this need only evaluate c            P(inverse)*v. The form is c c            subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) c c            where xcur and fcur are vectors of length n containing the c            current x and f values, ijob is an integer flag indicating c            which product is desired, v is a vector of length n to be c            multiplied, z is a vector of length n containing the desired c            product on output, rpar and ipar are, respectively, real c            and integer parameter/work arrays for use by the subroutine, c            and itrmjv is an integer termination flag. The meaning of c            ijob is as follows: c              0 => z = J*v c              1 => z = P(inverse)*v c            The meaning of itrmjv is as follows: c              0 => normal termination; desired product evaluated. c              1 => failure to produce J*v. c              2 => failure to produce P(inverse)*v. c            This subroutine is called only from nitjv, and is always c            called with v .ne. z. c c  rpar    = real parameter/work array passed to the f and jacv routines. c c  ipar    = integer parameter/work array passed to the f and jacv routines. c c  ftol    = stopping tolerance on the f-norm. c c  stptol  = stopping tolerance on the steplength. c c  nnimax  = maximum allowable number of nonlinear iterations (default 200). c c  ijacv   = flag for determining the method of J*v evaluation: c              0 => finite-difference evaluation (default) c              1 => analytic evaluation c c  ikrysl  = flag for determining the Krylov solver: c              0 => GMRES (default) c              1 => BiCGSTAB c              2 => TFQMR c c            For brief descriptions of the solvers plus references, c            see the subroutines nitgm, nitstb, and nittfq. c c  kdmax   = maximum Krylov subspace dimension when GMRES is used c            (default 20). c c  irpre   = flag for right preconditioning: c              0 => no right preconditioning c              1 => right preconditioning c c  iksmax  = maximum allowable number of iterations per call to the Krylov c            solver (default 1000). c c  iresup  = residual update flag when GMRES is used; on GMRES restarts, c            the residual is updated as follows: c              0 => linear combination (default) c              1 => direct evaluation c            The first is cheap (one n-vector saxpy) but may lose c            accuracy with extreme residual reduction; the second c            retains accuracy better but costs one J*v product per c            restart. c c  ifdord  = order of the finite-difference formula (sometimes) used when c            ijacv = 0. When ijacv = 0, this is set to 1, 2, or 4 in nitsol; c            otherwise it is irrelevant. With ijacv = 0, the precise meaning c            is as follows: c c            If GMRES is used, then ifdord matters only if iresup = 1, in c            which case it determines the order of the finite-difference c            formula used in evaluating the initial residual at each GMRES c            restart (default 2). NOTE: This only affects initial residuals c            at restarts; first-order differences are always used within c            each GMRES cycle. Using higher-order differences at restarts c            only should give the same accuracy as if higher-order c            differences were used throughout; see K. Turner and H. F. c            Walker, \"Efficient high accuracy solutions with GMRES(m),\" c            SIAM J. Sci. Stat. Comput., 13 (1992), pp. 815--825. c c            If BiCGSTAB or TFQMR is used, then ifdord determines the c            order of the finite-difference formula used at each c            iteration (default 1). c c  ibtmax  = maximum allowable number of backtracks (step c            reductions) per call to nitbt (default 10). c c            USAGE NOTE: Backtracking can be turned off by setting c            ibtmax = -1. Other negative values of ibtmax are not c            valid. c c c  ieta    = flag determining the forcing term eta as follows: c               0 => (||fcur|| - ||fprev+Jprev*sprev||)/||fprev|| c                    (default) c               1 => (||fcur||/||fprev||)**2 c               2 => gamma*(||fcur||/||fprev||)**alpha c                    for user-supplied gamma in (0,1] and alpha in (1,2] c               3 => user-supplied eta in [0,1). c                 3 => fixed (constant) eta in (0,1), either 0.1 (default) c\t\t       or specified by the user (see USAGE NOTE below) c            Here, fcur = current f, fprev = previous f, etc. The Krylov c            iterations are terminated when an iterate s satisfies c            an inexact Newton condition ||F + J*s|| .le. eta*||F||. c c            USAGE NOTE: If ieta = 2, then alpha and gamma must be set c            in common block nitparam.h as described below. If c\t     ieta = 3, then the desired constant eta may be similarly c\t     set in nitparam.h if a value other than the default of c\t     0.1 is desired. c c            The first three expressions above are from S. C. Eisenstat c            and H. F. Walker, \"Choosing the forcing terms in an inexact c            Newton method\", SIAM J. Scientific Computing, 17 (1996), c            pp. 16--32. (They may be modified according to certain c            safeguards below.) The first gives convergence that is c            q-superlinear and of r-order (1+sqrt(5))/2. The second gives c            convergence that is r-quadratic and of q-order p for every p c            in [1,2). The third gives convergence that is of q-order alpha c            when gamma < 1 and, when gamma = 1, of r-order alpha and c            q-order p for every p in [1,alpha). The fourth gives q-linear c            convergence with asymptotic rate constant alpha in a certain c            norm; see R. S. Dembo, S. C. Eisenstat, and T. Steihaug, c            \"Inexact Newton methods\", SIAM J. Numer. Anal., 18 (1982), c            pp. 400-408. c c            Of these four choices, the 1st is usually satisfactory, c            the 2nd or 3rd is sometimes preferred, and the 4th may be c            useful in some situations, e.g., it may be desirable to c            choose a fairly large fixed eta in (0,1), such as eta = .1, c            when numerical inaccuracy prevents the Krylov solver c            from obtaining much residual reduction. c c  iterm   = termination flag; values have the following meanings: c              0 => normal termination: ||F||.le.ftol or ||step||.le.stptol. c              1 => nnimax nonlinear iterations reached without success. c              2 => failure to evaluate F. c              3 => in nitjv, J*v failure. c              4 => in nitjv, P(inverse)*v failure. c              5 => in nitdrv, insufficient initial model norm reduction c                   for adequate progress. NOTE: This can occur for several c                   reasons; examine itrmks on return from the Krylov c                   solver for further information. (This will be printed out c                   if iplvl .ge. 3, see the discussion of optional c                   common blocks below). c              6 => in nitbt, failure to reach an acceptable step through c                   backtracking. c c  nfe     = number of function evaluations. c c  njve    = number of J*v evaluations. c c  nrpre   = number of P(inverse)*v evaluations. c c  nli     = number of linear iterations. c c  nni     = number of nonlinear iterations. c c  nbt     = number of backtracks. c c  rwork   = real work vector for use by the Krylov solver. It is passed c            in as the tail of the rwork vector in nitsol. On input to c            nitsol, it should have length as follows: c c             solver    rwork length c             GMRES     n*(kdmax+5)+kdmax*(kdmax+3), where kdmax is the c                       maximum Krylov subspace dimension, either the c                       default value of 20 or another value specified c                       by the user. c             BiCGSTAB  11*n c             TFQMR     14*n c c  dinpr   = inner-product routine, either user-supplied or BLAS ddot. c c  dnorm   = norm routine, either user-supplied or BLAS dnrm2. c c ------------------------------------------------------------------------ c c Optional common blocks: c c These can be used to control printing of diagnostic information by nitsol, c to pass information about the nonlinear iterations to jacv or other user c subroutines, or to control the default behavior of the nonlinear iterations. c c For controlling printing of diagnostic information: c include 'nitprint.h' c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number, e.g., ipunit = 6 => standard output. c c For passing information about the nonlinear iterations to user-supplied c subroutines: c include 'nitinfo.h' c c If information on the current state of the nonlinear iteration is c desired in a user-supplied subroutine (for example, deciding c whether to update a preconditioner), include this common block c in the subroutine. The variables are as follows: c c     instep - inexact Newton step number. c c    newstep - set to 0 at the beginning of an inexact Newton step. c              This may be checked in a user-supplied jacv to decide c              whether to update the preconditioner.  If you test on c              newstep .eq. 0 to determine whether to take some c              special action at the beginning of a nonlinear iteration, c              you must also set newstep to some nonzero value to c              subsequently avoid taking that action unnecessarily. c c    krystat - status of the Krylov iteration; same as itrmks (see c              the nitsol documentation). c c    avrate  - average rate of convergence of the Krylov solver during c              the previous inexact Newton step.  This may be checked c              in a user-supplied jacv to decide when to update the c              preconditioner. c c    fcurnrm - ||f(xcur)||. c c c  For controlling the default behavior of the nonlinear iterations: c include 'nitparam.h' c nitparam contains some parameters that control the nonlinear c iterations.  In some cases, the default values reflect prevailing c practice; in other cases, they are chosen to produce good c average-case behavior.  To change the default values, include this c common block in the main program and set the desired variables c according to the following: c c    choice1_exp -  parameter used in the update of the forcing term c                   eta when ieta = 0 (default).  This is the exponent c                   for determining the etamin safeguard.  The default c                   value is choice1_exp = (1+sqrt(5))/2.  A larger c                   value will allow eta to decrease more rapidly, c                   while a smaller value will result in a larger c                   value for the safeguard. c c    choice2_exp  - parameter used in the update of the forcing term c                   eta when ieta = 2.  This is the exponent alpha c\t\t    in the expression gamma*(||fcur||/||fprev||)**alpha; c\t\t    it is also used to determine the etamin safeguard. c\t\t    The default value is 2.0. Valid values are in the c\t\t    range (1.0, 2.0]. c c    choice2_coef - parameter used in the update of the forcing term eta c                   when ieta = 2.  This is the coefficient gamma used c\t\t    in the expression gamma*(||fcur||/||fprev||)**alpha; c                   it is also used to determine the etamin safeguard. c                   The default value is 1.0. Valid values are in the c\t\t    range (0.0, 1.0]. c c    eta_cutoff   - parameter used to determine when to disable c                   safeguarding the update of the forcing term.  It c                   only has meaning when ieta .ne. 3.  The default c                   value is 0.1.  A value of 0.0 will enable c\t\t    safeguarding always; a value of 1.0 will disable c\t\t    safeguarding always. c c    etamax       - parameter used to provide an upper bound on the c\t\t    forcing terms when input(10) .ne. 3. This is c\t\t    necessary to ensure convergence of the inexact Newton c\t\t    iterates and is imposed whenever eta would otherwise c\t\t    be too large. (An overly large eta can result from c\t\t    the updating formulas when input(10) .ne. 3 or from c                   safeguarding when the previous forcing term has been c\t\t    excessively increased during backtracking.) The c\t\t    default value of etamax is 1.0 - 1.e-4.  When c\t\t    backtracking occurs several times during a nonlinear c\t\t    solve the forcing term can remain near etamax for several c                   nonlinear steps and cause the nonlinear iterations c                   to nearly stagnate.  In such cases a smaller value of c                   etamax may prevent this.  Valid values are in the c                   range (0.0, 1.0). c c    etafixed     - this is the user-supplied fixed eta when ieta = 3. c                   The  default value is etafixed = 0.1.  Valid values c                   are in the range (0.0,1.0). c c    thmin        - when backtracking occurs, this is the smallest c                   reduction factor that will be applied to the current c                   step in a single backtracking reduction.  The default c                   value is 0.1.  Valid  values are in the range c                   [0.0, thmax]. c c    thmax        - when backtracking occurs, this is the largest c                   reduction factor that will be applied to the current c                   step in a single backtracking reduction.  The default c                   value is 0.5.  Valid values are in the range c                   [thmin, 1.0). c c  The values in this common block are not checked here.  We assume c  that if you call nitdrv directly you know what you are doing. c c ------------------------------------------------------------------------ c c Subroutines required by this and all called routines: c c    user supplied: f, jacv c c    nitsol routines: nitbd.f, nitbt, nitgm, nitjv, nitstb, nittfq, c c    lapack routines: dlaic1, dlamch c c    blas routines: daxpy, dcopy, dscal, dswap c c    user supplied or BLAS (see below): dinpr, dnorm c c    Explanation: The call to nitsol specifies dinpr and dnorm as c    either user-supplied inner-product and norm routines or the c    BLAS ddot and dnrm2 routines. c c This subroutine called by: nitsol c c Subroutines called by this subroutine: dcopy, dinpr, dlamch, dnorm, f, c    nitbt, nitgm, nitstb, nittfq c c ------------------------------------------------------------------------ c c Remaining declarations: c c NOTE: In nitinfo.h, instep, newstep, krystat are declared integer, c and avrate and fcurnrm are declared double precision. c double precision alpha , epsmach , eta , etamin , fcnrm , $ flmnrm , fpnrm , gamma , oftjs , oftlm , redfac , rsnrm , $ stpnrm , temp integer ibt , itrmbt , itrmf , itrmks , lrr , lsvbig , lsvsml , lvv , lw , $ lr , ld , lrcgs , lrtil , lp , lphat , lq , lu , lv , lt , lrwork , ly , $ kdmaxp1 , ncall double precision dlamch external dlamch external nitbd c ------------------------------------------------------------------------ c For printing: integer infe , injve , inrpre , inli c ------------------------------------------------------------------------ data ncall / 0 / save ncall , alpha , gamma , epsmach c ------------------------------------------------------------------------ c Initialize. c ------------------------------------------------------------------------ if ( ncall . eq . 0 ) epsmach = 2.0d0 * dlamch ( 'e' ) ncall = 1 if ( ieta . eq . 0 ) alpha = choice1_exp if ( ieta . eq . 2 ) alpha = choice2_exp if ( ieta . eq . 2 ) gamma = choice2_coef if ( ieta . eq . 3 ) then eta = etafixed else eta = . 5 d0 endif nfe = 0 njve = 0 nrpre = 0 nli = 0 nni = 0 nbt = 0 avrate = 1.0d0 c ------------------------------------------------------------------------ c Evaluate f at initial x and initialize eta. c ------------------------------------------------------------------------ call f ( n , xcur , fcur , rpar , ipar , itrmf ) if ( itrmf . ne . 0 ) then iterm = 2 go to 900 endif nfe = nfe + 1 fcnrm = dnorm ( n , fcur , 1 ) c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 1 ) then write ( ipunit , * ) write ( ipunit , * ) write ( ipunit , * ) 'nitdrv:  Beginning nonlinear iterations.' endif c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Nonlinear iteration loop. c      tstrt = etime(dummy) c ------------------------------------------------------------------------ 100 continue c ------------------------------------------------------------------------ c For printing: c      if (iplvl .eq. 0) then c         if ( nni .eq. 0 ) then c            write(ipunit,799) nni, njve, 0.0d0, fcnrm c         else c            write(ipunit,799) nni, njve, etime(dummy)-tstrt, fcnrm c         endif c      endif c 799  format( 2(2x,i4),2(2x,1pe12.3) ) if ( iplvl . ge . 1 ) then write ( ipunit , * ) if ( iplvl . eq . 1 ) write ( ipunit , 800 ) nni , fcnrm if ( iplvl . ge . 2 ) write ( ipunit , 810 ) nni , fcnrm endif 800 format ( '    It. no.' , i4 , '      F norm =' , 1 pd12 . 3 ) 810 format ( '--- It. no.' , i4 , '      F norm =' , 1 pd12 . 3 , $ ' ---------------------------' ) if ( iplvl . ge . 2 ) then write ( ipunit , * ) write ( ipunit , 820 ) nfe , njve , nrpre , nli infe = nfe injve = njve inrpre = nrpre inli = nli endif 820 format ( '  Initial totals:  nfe =' , i4 , '    njve =' , i4 , $ '    nrpre =' , i4 , '    nli =' , i4 ) c ------------------------------------------------------------------------ c c------------------------------------------------------------------------ c Test for stopping. c------------------------------------------------------------------------ if ( fcnrm . le . ftol ) then iterm = 0 go to 900 endif if ( nni . gt . 0 . and . stpnrm . le . stptol . and . itrmks . eq . 0 ) then iterm = 0 go to 900 endif if ( nni . ge . nnimax ) then iterm = 1 go to 900 endif c ------------------------------------------------------------------------ c Compute the (trial) inexact Newton step with the Krylov solver. c ------------------------------------------------------------------------ c Update data in nitinfo to mark the start of a new inexact Newton step. c ------------------------------------------------------------------------ newstep = 0 instep = nni fcurnrm = fcnrm c ------------------------------------------------------------------------ c If ikrysl = 0, apply GMRES, using fpls as a work array. c ------------------------------------------------------------------------ if ( ikrysl . eq . 0 ) then kdmaxp1 = kdmax + 1 lvv = 1 lrr = lvv + n * kdmaxp1 lsvbig = lrr + kdmax * kdmax lsvsml = lsvbig + kdmax lw = lsvsml + kdmax call nitgm ( n , xcur , fcur , fcnrm , step , eta , f , jacv , rpar , $ ipar , ijacv , irpre , iksmax , iresup , ifdord , nfe , njve , $ nrpre , nli , kdmax , kdmaxp1 , rwork ( lvv ), rwork ( lrr ), $ rwork ( lsvbig ), rwork ( lsvsml ), rwork ( lw ), fpls , $ rsnrm , dinpr , dnorm , itrmks ) endif c ------------------------------------------------------------------------ c If ikrysl = 1, apply BiCGSTAB, using fpls as a work array. c ------------------------------------------------------------------------ if ( ikrysl . eq . 1 ) then lr = 1 lrtil = lr + n lp = lrtil + n lphat = lp + n lv = lphat + n lt = lv + n lrwork = lt + n call nitstb ( n , xcur , fcur , fcnrm , step , eta , f , jacv , rpar , $ ipar , ijacv , irpre , iksmax , ifdord , nfe , njve , $ nrpre , nli , rwork ( lr ), rwork ( lrtil ), rwork ( lp ), $ rwork ( lphat ), rwork ( lv ), rwork ( lt ), rwork ( lrwork ), fpls , $ rsnrm , dinpr , dnorm , itrmks ) endif c ------------------------------------------------------------------------ c If ikrysl = 2, apply TFQMR c ------------------------------------------------------------------------ if ( ikrysl . eq . 2 ) then lr = 1 lrcgs = lr + n lrtil = lrcgs + n ld = lrtil + n lp = ld + n lq = lp + n lu = lq + n lv = lu + n ly = lv + n lrwork = ly + n call nittfq ( n , xcur , fcur , fcnrm , step , eta , f , jacv , rpar , $ ipar , ijacv , irpre , iksmax , ifdord , nfe , njve , nrpre , nli , $ rwork ( lr ), rwork ( lrcgs ), rwork ( lrtil ), rwork ( ld ), $ rwork ( lp ), rwork ( lq ), rwork ( lu ), rwork ( lv ), rwork ( ly ), $ rwork ( lrwork ), fpls , rsnrm , dinpr , dnorm , itrmks ) endif c ------------------------------------------------------------------------ c  Set values in nitinfo that reflect state of iterative solver. c ------------------------------------------------------------------------ krystat = itrmks avrate = ( rsnrm / fcnrm ) ** ( 1.0d0 / dble ( nli )) c ------------------------------------------------------------------------ c Check itrmks and decide whether to terminate or continue: c        0 => continue, inexact Newton condition successfully met c   1 or 2 => terminate unconditionally, J*v or P(inverse)*v failure) c   .ge. 3 => terminate if the model norm has increased or if reduction at c             the current rate would at best require more than 1000 time c             the maximum remaining number of nonlinear iterations. c ------------------------------------------------------------------------ if ( itrmks . eq . 1 . or . itrmks . eq . 2 ) then iterm = itrmks + 2 go to 900 endif if ( itrmks . ge . 3 ) then if ( rsnrm / fcnrm . ge . 1.d0 ) then iterm = 5 go to 900 else temp = dlog ( ftol / fcnrm ) / $ dlog ( rsnrm / (( 1.d0 + 1 0.d0 * epsmach ) * fcnrm )) if ( temp . gt . 100 0.d0 * dfloat ( nnimax - nni )) then iterm = 5 go to 900 endif endif endif c ------------------------------------------------------------------------ c Compute the original value of f(transpose)*Js for backtracking; the c original value of f(transpose)*(linear model) is also computed for c later use. NOTE: The first n components of rwork contain the residual c vector for the Newton equation, which is -(linear model). c ------------------------------------------------------------------------ oftlm = - dinpr ( n , fcur , 1 , rwork , 1 ) oftjs = oftlm - fcnrm ** 2 c ------------------------------------------------------------------------ c Determine an acceptable step via backtracking. c ------------------------------------------------------------------------ call nitbt ( n , xcur , fcnrm , step , eta , xpls , fpls , fpnrm , oftjs , $ redfac , nfe , ibt , ibtmax , f , rpar , ipar , dnorm , itrmbt ) if ( itrmbt . eq . 1 ) then iterm = 6 go to 900 else if ( itrmbt . eq . 2 ) then iterm = 2 go to 900 endif nbt = nbt + ibt c ------------------------------------------------------------------------ c Set eta for next iteration. c ------------------------------------------------------------------------ if ( ieta . eq . 0 ) then etamin = eta ** alpha temp = 1.d0 - redfac flmnrm = dsqrt (( temp * fcnrm ) ** 2 + 2.d0 * redfac * temp * oftlm + $ ( redfac * rsnrm ) ** 2 ) eta = dabs ( fpnrm - flmnrm ) / fcnrm endif if ( ieta . eq . 1 ) then etamin = eta ** 2 eta = ( fpnrm / fcnrm ) ** 2 endif if ( ieta . eq . 2 ) then etamin = gamma * eta ** alpha eta = gamma * ( fpnrm / fcnrm ) ** alpha endif if ( ieta . ne . 3 ) then if ( etamin . le . eta_cutoff ) etamin = 0.d0 chfw         if (etamin .le. 1.d-1) etamin = 1.d-1 if ( eta . lt . etamin ) eta = etamin if ( eta . gt . etamax ) eta = etamax if ( eta * fpnrm . le . 2.d0 * ftol ) eta = (. 8 d0 * ftol ) / fpnrm endif if ( ieta . eq . 3 ) eta = etafixed c ------------------------------------------------------------------------ c Update xcur, fcur, fcnrm, stpnrm, nni for next iteration. c ------------------------------------------------------------------------ call dcopy ( n , xpls , 1 , xcur , 1 ) call dcopy ( n , fpls , 1 , fcur , 1 ) fcnrm = fpnrm stpnrm = dnorm ( n , step , 1 ) nni = nni + 1 c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 2 ) then infe = nfe - infe injve = njve - injve inrpre = nrpre - inrpre inli = nli - inli if ( ieta . gt . 0 ) then temp = 1.d0 - redfac flmnrm = dsqrt (( temp * fcnrm ) ** 2 + 2.d0 * redfac * temp * oftlm + $ ( redfac * rsnrm ) ** 2 ) endif write ( ipunit , * ) write ( ipunit , 830 ) infe , injve , inrpre , inli , stpnrm , flmnrm endif 830 format ( '  At this step:   nfe =' , i4 , '    njve =' , i4 , $ '    nrpre =' , i4 , '    nli =' , i4 , / , 17 x , $ ' step norm =' , 1 pd10 . 3 , 5 x , $ 'final lin. model norm =' , 1 pd10 . 3 ) c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Return to top of loop for next iteration. c ------------------------------------------------------------------------ go to 100 c ------------------------------------------------------------------------ c All returns made here. c ------------------------------------------------------------------------ 900 continue c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 1 ) then write ( ipunit , * ) write ( ipunit , * ) write ( ipunit , * ) 'nitdrv:  Terminating nonlinear iterations.' endif c ------------------------------------------------------------------------ return end","tags":"","loc":"sourcefile/nitdrv.f.html"},{"title":"nitbd.f – BROWNPAK","text":"Contents Block Data Units nitbd Source Code nitbd.f Source Code block data nitbd c  Purpose- Initialize nitparam common block with default values. include 'nitdflts.h' include 'nitparam.h' include 'nitprint.h' data choice1_exp / DFLT_CHOICE1_EXP / data choice2_exp / DFLT_CHOICE2_EXP / data choice2_coef / DFLT_CHOICE2_COEF / data eta_cutoff / DFLT_ETA_CUTOFF / data etamax / DFLT_ETA_MAX / data thmin / DFLT_THMIN / data thmax / DFLT_THMAX / data etafixed / DFLT_ETA_FIXED / data iplvl / DFLT_PRLVL / data ipunit / STDOUT / end","tags":"","loc":"sourcefile/nitbd.f.html"},{"title":"node_t – BROWNPAK ","text":"type, private :: node_t Inherits type~~node_t~~InheritsGraph type~node_t node_t type~aabb_t aabb_t type~node_t->type~aabb_t aabb Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~node_t~~InheritedByGraph type~node_t node_t type~aabbtree_t aabbtree_t type~aabbtree_t->type~node_t nodes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables next parent left right height atom aabb Type-Bound Procedures init isleaf asstr Source Code node_t Components Type Visibility Attributes Name Initial integer, public :: next = NULL_NODE integer, public :: parent = NULL_NODE integer, public :: left = NULL_NODE integer, public :: right = NULL_NODE integer, public :: height = -1 integer, public :: atom = 0 type( aabb_t ), public :: aabb Type-Bound Procedures procedure, public :: init => node_init interface private module subroutine node_init(this) Implementation → Initializes a node. Arguments Type Intent Optional Attributes Name class( node_t ), intent(out) :: this A node_t instance. procedure, public :: isleaf => node_isleaf interface private module function node_isleaf(this) result(res) Implementation → Is this a leaf node? Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. Return Value logical true if this is a leaf node, false otherwise. procedure, public :: asstr => node_asstr interface private module function node_asstr(this, frmt) result(buf) Implementation → Returns a string representation of a node. Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. character(len=*), intent(in), optional :: frmt Format string for real numbers, e.g. '(f15.6)'. Default: (g0.6) . Return Value character(len=:),\n  allocatable Return value Source Code type node_t integer :: next = NULL_NODE integer :: parent = NULL_NODE integer :: left = NULL_NODE integer :: right = NULL_NODE integer :: height = - 1 integer :: atom = 0 type ( aabb_t ) :: aabb contains procedure :: init => node_init procedure :: isleaf => node_isleaf procedure :: asstr => node_asstr end type node_t","tags":"","loc":"type/node_t.html"},{"title":"aabbtree_t – BROWNPAK ","text":"type, public :: aabbtree_t Inherits type~~aabbtree_t~~InheritsGraph type~aabbtree_t aabbtree_t type~node_t node_t type~aabbtree_t->type~node_t nodes type~aabb_t aabb_t type~node_t->type~aabb_t aabb Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables nodes atnd_tab capacity freestore size root tskin Type-Bound Procedures init print clear delete insert remove remove_all update_fatm update_fatmaabb update query_watm query_waabb query_watmaabb query get_num_atoms get_aabb get_height get_max_balance get_srfarea_ratio rebuild validate insert_leaf remove_leaf balance calc_height fs_acquire fs_return validate_structure validate_metrics Source Code aabbtree_t Components Type Visibility Attributes Name Initial type( node_t ), public, dimension(:), allocatable :: nodes integer, public, dimension(:), allocatable :: atnd_tab Atom -> node map. integer, public :: capacity Maximum number of nodes that the tree can currently handle. This may\n increase as more atoms are inserted. integer, public :: freestore Pointer to head to the free store. integer, public :: size Number of nodes in the tree. integer, public :: root Pointer to the tree root. real(kind=rp), public :: tskin Thickness of the skin for fattened AABBs, as a fraction of the AABB\n base length. Type-Bound Procedures procedure, public :: init interface private module subroutine init(this, natoms, tskin) Implementation → Initializes an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(out) :: this An aabbtree_t instance. integer, intent(in) :: natoms Estimated number of atoms to be handled by this tree. real(kind=rp), intent(in) :: tskin Thickness of the skin for fattened AABBs, as a fraction of the\n AABB base length. procedure, public :: print interface private recursive module subroutine print(this, p) Implementation → Prints a subtree of an AABB tree rooted at p in order. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default is the root of the\n whole tree. procedure, public :: clear interface private module subroutine clear(this) Implementation → Clears an AABB tree. Associated memory is not deallocated. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. procedure, public :: delete interface private module subroutine delete(this) Implementation → Deletes an AABB tree. All associated memory is deallocated. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. procedure, public :: insert interface private module subroutine insert(this, ia, pos, radius) Implementation → Inserts an atom into an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) procedure, public :: remove interface private module subroutine remove(this, ia) Implementation → Removes an atom from an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index procedure, public :: remove_all interface private module subroutine remove_all(this) Implementation → Removes all atoms from an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. procedure, public :: update_fatm interface private module subroutine update_fatm(this, ia, pos, radius, lstat) Implementation → Updates an AABB tree for the case when an atom leaves its fattened\n AABB. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. procedure, public :: update_fatmaabb interface private module subroutine update_fatmaabb(this, ia, lbnd, ubnd, lstat) Implementation → Updates an AABB tree for the case when an atom leaves its fattened\n AABB, with the bounds of the new AABB for the atom as input. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound of atom AABB real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound of atom AABB logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. generic, public :: update => update_fatm , update_fatmaabb private interface update_fatm () Arguments None private interface update_fatmaabb () Arguments None procedure, public :: query_watm interface private module subroutine query_watm(this, ia, nbrs) Implementation → Query an AABB tree for a set of potential neighbors of an atom. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. procedure, public :: query_waabb interface private module subroutine query_waabb(this, aabb, atms) Implementation → Query an AABB tree for the set of atoms whose AABBS overlap with aabb . Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. type( aabb_t ), intent(in) :: aabb An aabb_t instance. type( ivector_t ), intent(inout) :: atms List of potential neighbors. procedure, public :: query_watmaabb interface private module subroutine query_watmaabb(this, ia, aabb, nbrs) Implementation → Query an AABB tree for a set of potential neighbors of an atom & its\n bounding AABB. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. type( aabb_t ), intent(in) :: aabb Bounding AABB for atom with index ia . type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. generic, public :: query => query_watm , query_waabb , query_watmaabb private interface query_watm () Arguments None private interface query_waabb () Arguments None private interface query_watmaabb () Arguments None procedure, public :: get_num_atoms interface private module function get_num_atoms(this) result(na) Implementation → Returns the number of atoms in an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value procedure, public :: get_aabb interface private module function get_aabb(this, ia) result(aabb) Implementation → Returns a copy of the AABB associated with atom with index ia . Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. Return Value type( aabb_t ) AABB of atom ia . procedure, public :: get_height interface private module function get_height(this) result(height) Implementation → Returns the height of an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. procedure, public :: get_max_balance interface private module function get_max_balance(this) result(max_balance) Implementation → Returns the maximum difference between the height of two children\n of a node. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. procedure, public :: get_srfarea_ratio interface private module function get_srfarea_ratio(this) result(saratio) Implementation → Returns the ratio of the sum of the node surface area to the surface\n area of the root node. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value real(kind=rp) Return value. procedure, public :: rebuild interface private module subroutine rebuild(this) Implementation → Rebuilds an optimal AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. procedure, public :: validate interface private module subroutine validate(this) Implementation → Validates an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. procedure, private :: insert_leaf interface private module subroutine insert_leaf(this, leaf) Implementation → Inserts a leaf node into a tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node procedure, private :: remove_leaf interface private module subroutine remove_leaf(this, leaf) Implementation → Removes a leaf node from a tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node procedure, private :: balance interface private module function balance(this, p) result(q) Implementation → Balances an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node index Return Value integer procedure, private :: calc_height interface private recursive module function calc_height(this, p) result(height) Implementation → Calculates the height of a subtree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default: Root of the whole\n tree. Return Value integer Return value procedure, private :: fs_acquire interface private module function fs_acquire(this) result(p) Implementation → Acquires a new node from the free store and returns a pointer to it. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Return Value integer Return value procedure, private :: fs_return interface private module subroutine fs_return(this, p) Implementation → Returns a node to the free store. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node pointer. procedure, private :: validate_structure interface private recursive module subroutine validate_structure(this, p) Implementation → Asserts that an AABB subtree has a valid structure. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. procedure, private :: validate_metrics interface private recursive module subroutine validate_metrics(this, p) Implementation → Asserts that an AABB subtree has a valid metric. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. Source Code type aabbtree_t type ( node_t ), dimension (:), allocatable :: nodes integer , dimension (:), allocatable :: atnd_tab !! Atom -> node map. integer :: capacity !! Maximum number of nodes that the tree can currently handle. This may !! increase as more atoms are inserted. integer :: freestore !! Pointer to head to the free store. integer :: size !! Number of nodes in the tree. integer :: root !! Pointer to the tree root. real ( rp ) :: tskin !! Thickness of the skin for fattened AABBs, as a fraction of the AABB !! base length. contains procedure :: init procedure :: print procedure :: clear procedure :: delete procedure :: insert procedure :: remove procedure :: remove_all procedure :: update_fatm procedure :: update_fatmaabb generic :: update => update_fatm , update_fatmaabb procedure :: query_watm procedure :: query_waabb procedure :: query_watmaabb generic :: query => query_watm , query_waabb , query_watmaabb procedure :: get_num_atoms procedure :: get_aabb procedure :: get_height procedure :: get_max_balance procedure :: get_srfarea_ratio procedure :: rebuild procedure :: validate procedure , private :: insert_leaf procedure , private :: remove_leaf procedure , private :: balance procedure , private :: calc_height procedure , private :: fs_acquire procedure , private :: fs_return procedure , private :: validate_structure procedure , private :: validate_metrics end type aabbtree_t","tags":"","loc":"type/aabbtree_t.html"},{"title":"smbx_t – BROWNPAK ","text":"type, public :: smbx_t Contents Variables imcon basis dl_basis volume is_deforming is_aligned Type-Bound Procedures init set_basis freeze unfreeze get_image wrap_all to_center to_origin get_rnd_points Source Code smbx_t Components Type Visibility Attributes Name Initial integer, public :: imcon real(kind=rp), public, dimension(3,3) :: basis real(kind=rp), public, dimension(3,3) :: dl_basis real(kind=rp), public :: volume logical, public :: is_deforming logical, public :: is_aligned Whether the basis vectors are aligned with the laboratory frame Type-Bound Procedures procedure, public :: init => smbx_init public subroutine smbx_init (this, imcon) Initializes an instance of smbx_t . Can also be called to reset. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(out) :: this An instance of smbx_t . integer, intent(in) :: imcon Flag specifying boundary conditions on the simulation box. Read more… procedure, public :: set_basis => smbx_set_basis public subroutine smbx_set_basis (this, bv) Sets all three basis vectors. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(3,3) :: bv procedure, public :: freeze => smbx_freeze public subroutine smbx_freeze (this) Specifies this as non-deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this procedure, public :: unfreeze => smbx_unfreeze public subroutine smbx_unfreeze (this) Specifies this as deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this procedure, public :: get_image => smbx_get_image public subroutine smbx_get_image (this, r) Returns the image of r under PBC. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(3) :: r procedure, public :: wrap_all => smbx_wrap_all public subroutine smbx_wrap_all (this, coords) Wraps atom positions w.r.t. periodic boundary conditions. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords procedure, public :: to_center => smbx_to_center public subroutine smbx_to_center (this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the center \n of the box. Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com procedure, public :: to_origin => smbx_to_origin public subroutine smbx_to_origin (this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the origin.\n Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com procedure, public :: get_rnd_points => smbx_get_rnd_points public subroutine smbx_get_rnd_points (this, coords) Returns uniformly distributed points within the box. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(out), dimension(:,:) :: coords Source Code type smbx_t integer :: imcon real ( rp ), dimension ( 3 , 3 ) :: basis real ( rp ), dimension ( 3 , 3 ) :: dl_basis real ( rp ) :: volume logical :: is_deforming logical :: is_aligned !! Whether the basis vectors are aligned with the laboratory frame contains procedure :: init => smbx_init procedure :: set_basis => smbx_set_basis procedure :: freeze => smbx_freeze procedure :: unfreeze => smbx_unfreeze procedure :: get_image => smbx_get_image procedure :: wrap_all => smbx_wrap_all procedure :: to_center => smbx_to_center procedure :: to_origin => smbx_to_origin procedure :: get_rnd_points => smbx_get_rnd_points end type smbx_t","tags":"","loc":"type/smbx_t.html"},{"title":"trajectory_t – BROWNPAK ","text":"type, private :: trajectory_t Contents Variables header_size frame_size num_atoms frmcmp fn file_id num_frames isopen Type-Bound Procedures create open delete close read append_frame write_frame init Source Code trajectory_t Components Type Visibility Attributes Name Initial integer, public :: header_size = 0 integer, public :: frame_size = 0 integer, public :: num_atoms = 0 integer, public, dimension(4) :: frmcmp = 0 character(len=:), public, allocatable :: fn integer, public :: file_id = 0 integer, public :: num_frames = 0 logical, public :: isopen = .false. Type-Bound Procedures procedure, public :: create => traj_create private subroutine traj_create (this, fn, na, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of atoms integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges procedure, public :: open => traj_open private subroutine traj_open (this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr procedure, public :: delete => traj_delete private subroutine traj_delete (this) After a call to this subroutine, all memory within this is deallocated,\n all components of this are reset to zero, and the underlying file is\n closed (if open). Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this procedure, public :: close => traj_close private subroutine traj_close (this) Closes the underlying file of a trajectory_t . Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this procedure, public :: read => traj_read private subroutine traj_read (this, iframe, nts, ierr, coordinates, velocities, forces, charge) Read from an open trajectory. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(in) :: this integer, intent(in) :: iframe Frame number integer(kind=ip_long), intent(out) :: nts Time step counter integer, intent(out) :: ierr Error flag real(kind=rp), intent(out), optional dimension(:,:) :: coordinates real(kind=rp), intent(out), optional dimension(:,:) :: velocities real(kind=rp), intent(out), optional dimension(:,:) :: forces real(kind=rp), intent(out), optional dimension(:) :: charge procedure, public :: append_frame => traj_append_frame private subroutine traj_append_frame (this, nts, coordinates) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates procedure, public :: write_frame => traj_write_frame private subroutine traj_write_frame (this, iframe, nts, coordinates) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer, intent(in) :: iframe integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates generic, public :: init => create , open private subroutine traj_create (this, fn, na, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of atoms integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges private subroutine traj_open (this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr Source Code type trajectory_t integer :: header_size = 0 integer :: frame_size = 0 integer :: num_atoms = 0 integer , dimension ( 4 ) :: frmcmp = 0 character ( len = :), allocatable :: fn integer :: file_id = 0 integer :: num_frames = 0 logical :: isopen = . false . contains procedure :: create => traj_create procedure :: open => traj_open procedure :: delete => traj_delete procedure :: close => traj_close procedure :: read => traj_read procedure :: append_frame => traj_append_frame procedure :: write_frame => traj_write_frame generic :: init => create , open end type trajectory_t","tags":"","loc":"type/trajectory_t.html"},{"title":"ivector_t – BROWNPAK ","text":"type, public :: ivector_t Inherited by type~~ivector_t~~InheritedByGraph type~ivector_t ivector_t type~itable_t itable_t type~itable_t->type~ivector_t buffer Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables len_init len len_max buffer Type-Bound Procedures delete clear get_val set_val get_data append pop resize shrink_to_fit sort unique print Source Code ivector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 integer, public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => ivector_delete public subroutine ivector_delete (this) Deletes an ivector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this procedure, public :: clear => ivector_clear public subroutine ivector_clear (this) Clears an ivector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this procedure, public :: get_val => ivector_get_val public function ivector_get_val (this, i) result(res) Returns the ith element of an ivector . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this integer, intent(in) :: i Return Value integer procedure, public :: set_val => ivector_set_val public subroutine ivector_set_val (this, i, val) Sets the value of the ith element of an ivector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: val procedure, public :: get_data => ivector_get_data public subroutine ivector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in), target :: this integer, intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend procedure, public :: append => ivector_append public subroutine ivector_append (this, val) Adds an element to the end of an ivector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: val procedure, public :: pop => ivector_pop public function ivector_pop (this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Return Value integer procedure, public :: resize => ivector_resize public subroutine ivector_resize (this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr procedure, public :: shrink_to_fit => ivector_shrink_to_fit public subroutine ivector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of an ivector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional :: ierr procedure, public :: sort => ivector_sort public subroutine ivector_sort (this, order) Sorts an ivector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order procedure, public :: unique => ivector_unique public subroutine ivector_unique (this) Sorts and removes all duplicate entries of an ivector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call ivector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this procedure, public :: print => ivector_print public subroutine ivector_print (this) Prints an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Source Code type ivector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init integer , dimension (:), allocatable :: buffer contains procedure :: delete => ivector_delete procedure :: clear => ivector_clear procedure :: get_val => ivector_get_val procedure :: set_val => ivector_set_val procedure :: get_data => ivector_get_data procedure :: append => ivector_append procedure :: pop => ivector_pop procedure :: resize => ivector_resize procedure :: shrink_to_fit => ivector_shrink_to_fit procedure :: sort => ivector_sort procedure :: unique => ivector_unique procedure :: print => ivector_print end type ivector_t","tags":"","loc":"type/ivector_t.html"},{"title":"dvector_t – BROWNPAK ","text":"type, public :: dvector_t Contents Variables len_init len len_max buffer Type-Bound Procedures delete clear get_val set_val get_data append pop resize shrink_to_fit sort unique print Source Code dvector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 real(kind=rp), public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => dvector_delete public subroutine dvector_delete (this) Deletes a dvector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this procedure, public :: clear => dvector_clear public subroutine dvector_clear (this) Clears a dvector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this procedure, public :: get_val => dvector_get_val public function dvector_get_val (this, i) result(res) Returns the ith element of a dvector . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rp) procedure, public :: set_val => dvector_set_val public subroutine dvector_set_val (this, i, val) Sets the value of the ith element of a dvector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: i real(kind=rp), intent(in) :: val procedure, public :: get_data => dvector_get_data public subroutine dvector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in), target :: this real(kind=rp), intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend procedure, public :: append => dvector_append public subroutine dvector_append (this, val) Adds an element to the end of a dvector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this real(kind=rp), intent(in) :: val procedure, public :: pop => dvector_pop public function dvector_pop (this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Return Value real(kind=rp) procedure, public :: resize => dvector_resize public subroutine dvector_resize (this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr procedure, public :: shrink_to_fit => dvector_shrink_to_fit public subroutine dvector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of a dvector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional :: ierr procedure, public :: sort => dvector_sort public subroutine dvector_sort (this, order) Sorts a dvector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order procedure, public :: unique => dvector_unique public subroutine dvector_unique (this) Sorts and removes all duplicate entries of a dvector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call dvector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this procedure, public :: print => dvector_print public subroutine dvector_print (this) Prints a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Source Code type dvector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init real ( rp ), dimension (:), allocatable :: buffer contains procedure :: delete => dvector_delete procedure :: clear => dvector_clear procedure :: get_val => dvector_get_val procedure :: set_val => dvector_set_val procedure :: get_data => dvector_get_data procedure :: append => dvector_append procedure :: pop => dvector_pop procedure :: resize => dvector_resize procedure :: shrink_to_fit => dvector_shrink_to_fit procedure :: sort => dvector_sort procedure :: unique => dvector_unique procedure :: print => dvector_print end type dvector_t","tags":"","loc":"type/dvector_t.html"},{"title":"atmcfg_t – BROWNPAK ","text":"type, public :: atmcfg_t Contents Variables num_atom_types atom_names atom_styles atom_mass num_atoms atoms charge coordinates forces num_bond_types bond_styles bond_params num_bonds bonds num_angle_types angle_styles angle_params num_angles angles num_dihedral_types dihedral_styles dihedral_params num_dihedrals dihedrals num_branches branches num_molecule_types molecule_names molecule_pop num_molecules molecules molecule_com num_tether_types tether_styles tether_params num_tethers tethers tether_points num_vdw_types vdw_styles vdw_params vdw_pairs num_externals external_styles external_params flow_style flow_params Source Code atmcfg_t Components Type Visibility Attributes Name Initial integer, public :: num_atom_types = 0 Number of atom_type s character(len=8), public, dimension(:), allocatable :: atom_names ( num_atom_types ,) array. Name of atoms of each type. integer, public, dimension(:), allocatable :: atom_styles ( num_atom_types ,) array. Style of atoms of each type. real(kind=rp), public, dimension(:), allocatable :: atom_mass ( num_atom_types ,) array. Mass of atoms of each type. integer, public :: num_atoms = 0 Number of atoms integer, public, dimension(:), allocatable :: atoms ( num_atoms ,) array. For atom i , its type at = atoms(i) , with style atom_styles(at) , name atom_names(at) , mass atom_mass(at) , charge charge(i) , position coordinates(:,i) , velocity velocities(:,i) ,\n orientation (if the style requires) orientations(:,i) . The force \n acting on atom i is forces(:,i) . real(kind=rp), public, dimension(:), allocatable :: charge ( num_atoms ,) array. real(kind=rp), public, dimension(:,:), allocatable :: coordinates (3, num_atoms ) array real(kind=rp), public, dimension(:,:), allocatable :: forces (3, num_atoms ) array integer, public :: num_bond_types = 0 Number of bond_type s integer, public, dimension(:), allocatable :: bond_styles ( num_bond_types ,) array. real(kind=rp), public, dimension(:,:), allocatable :: bond_params ( mxparam , num_bond_types ) array. integer, public :: num_bonds = 0 Total number of bonds. integer, public, dimension(:,:), allocatable :: bonds (3, num_bonds ) array. Bond i is of type bt = bonds(1,i) ,  directed from\n atom bonds(2,i) to bonds(3,i) . Its style is bond_styles(bt) with\n parameters bond_params(:,bt) . integer, public :: num_angle_types = 0 Number of angle_type s integer, public, dimension(:), allocatable :: angle_styles ( num_angle_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: angle_params ( mxparam , num_angle_types ) array integer, public :: num_angles = 0 Number of angles integer, public, dimension(:,:), allocatable :: angles (4, num_angles ) array. Angle i is of type ant = angles(1,i) , incident\n to atoms angles(2,i) , angles(3,i) , and angles(4,i) . Its style is angle_styles(ant) with parameters angle_params(:,ant) . integer, public :: num_dihedral_types = 0 Number of dihedral_type s integer, public, dimension(:), allocatable :: dihedral_styles ( num_dihedral_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: dihedral_params ( mxparam , num_dihedral_types ) array integer, public :: num_dihedrals = 0 Number of dihedrals integer, public, dimension(:,:), allocatable :: dihedrals (5, num_dihedrals ) array. Dihedral i is of type dt = dihedrals(1,i) , incident\n to atoms dihedrals(2,i) , dihedrals(3,i) , dihedrals(4,i) , and dihedrals(5,i) .\n Its style is dihedral_styles(dt) with parameters dihedral_params(:,dt) . integer, public :: num_branches = 0 Total number of branches (including the backbone) integer, public, dimension(:,:), allocatable :: branches (3, num_branches ) array. Branch i is tethered to atom branches(1,i) ,\n contains branches(2,i) atoms, with the beginning atom index branches(3,i) . integer, public :: num_molecule_types = 0 Number of molecule_type s character(len=8), public, dimension(:), allocatable :: molecule_names ( num_molecule_types ,) array integer, public, dimension(:), allocatable :: molecule_pop ( num_molecule_types ,) array integer, public :: num_molecules = 0 Number of molecules integer, public, dimension(:,:), allocatable :: molecules (9, num_molecules ) array. For molecule i , its type mt = molecules(1,i) , \n containing molecules(2,i) atoms with beginning index molecules(3,i) , molecules(4,i) bonds with beginning index molecules(5,i) , molecules(6,i) angles with beginning index molecules(7,i) , and molecules(8,i) dihedrals with beginning index molecules(9,i) . real(kind=rp), public, dimension(3) :: molecule_com = 0.0_rp Center of mass of the molecule. This is used only when imcon == 0, i.e.\n for a single molecule without periodic boundaries. integer, public :: num_tether_types = 0 Number of tether_type s integer, public, dimension(:), allocatable :: tether_styles ( num_tether_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: tether_params ( mxparam , num_tether_types ) array integer, public :: num_tethers = 0 Number of tethers integer, public, dimension(:,:), allocatable :: tethers (2, num_tethers ) array. Tether i is of type tt = tethers(1,i) , tethering\n atom tethers(2,i) to a point tether_points(:,i) .\n Its style is tether_styles(tt) with parameters tether_params(:,tt) . real(kind=rp), public, dimension(:,:), allocatable :: tether_points (3, num_tethers ) array integer, public :: num_vdw_types = 0 Number of vdw_type s integer, public, dimension(:), allocatable :: vdw_styles ( num_vdw_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: vdw_params ( mxparam , num_vdw_types ) array integer, public, dimension(:,:), allocatable :: vdw_pairs (2, num_vdw_types ) array. Stores atom type of interacting pairs, such\n that at_i >= at_j. integer, public :: num_externals = 0 Number of external fields integer, public, dimension(:), allocatable :: external_styles ( num_external ,) array real(kind=rp), public, dimension(:,:), allocatable :: external_params ( mxparam , num_external ) array integer, public :: flow_style = 0 real(kind=rp), public, dimension(:), allocatable :: flow_params ( mxparam ,) array Source Code type atmcfg_t !Particle configuration: Atoms integer :: num_atom_types = 0 !! Number of *atom_type*s character ( len = 8 ), dimension (:), allocatable :: atom_names !! (*num_atom_types*,) array. Name of atoms of each type. integer , dimension (:), allocatable :: atom_styles !! (*num_atom_types*,) array. Style of atoms of each type. real ( rp ), dimension (:), allocatable :: atom_mass !! (*num_atom_types*,) array. Mass of atoms of each type. integer :: num_atoms = 0 !!  Number of atoms integer , dimension (:), allocatable :: atoms !! (*num_atoms*,) array. !! !! For atom *i*, its type *at = atoms(i)*, with style !! *atom_styles(at)*, name *atom_names(at)*, mass *atom_mass(at)*, charge !! *charge(i)*, position *coordinates(:,i)*, velocity *velocities(:,i)*, !! orientation (if the style requires) *orientations(:,i)*. The force !! acting on atom *i* is *forces(:,i)*. real ( rp ), dimension (:), allocatable :: charge !! (*num_atoms*,) array. real ( rp ), dimension (:,:), allocatable :: coordinates !!  (3, *num_atoms*) array real ( rp ), dimension (:,:), allocatable :: forces !!  (3, *num_atoms*) array !Particle configuration: Bonds integer :: num_bond_types = 0 !!  Number of *bond_type*s integer , dimension (:), allocatable :: bond_styles !!  (*num_bond_types*,) array. real ( rp ), dimension (:,:), allocatable :: bond_params !!  (*mxparam*,*num_bond_types*) array. integer :: num_bonds = 0 !!  Total number of bonds. integer , dimension (:,:), allocatable :: bonds !! (3, *num_bonds*) array. Bond *i* is of type *bt = bonds(1,i)*,  directed from !! atom *bonds(2,i)* to *bonds(3,i)*. Its style is *bond_styles(bt)* with !! parameters *bond_params(:,bt)*. !Particle configuration: Angles integer :: num_angle_types = 0 !!  Number of *angle_type*s integer , dimension (:), allocatable :: angle_styles !!  (*num_angle_types*,) array real ( rp ), dimension (:,:), allocatable :: angle_params !!  (*mxparam*, *num_angle_types*) array integer :: num_angles = 0 !!  Number of angles integer , dimension (:,:), allocatable :: angles !! (4, *num_angles*) array. Angle *i* is of type *ant = angles(1,i)*, incident !! to atoms *angles(2,i)*, *angles(3,i)*, and *angles(4,i)*. Its style is !! *angle_styles(ant)* with parameters *angle_params(:,ant)*. !Particle configuration: Dihedrals integer :: num_dihedral_types = 0 !!  Number of *dihedral_type*s integer , dimension (:), allocatable :: dihedral_styles !!  (*num_dihedral_types*,) array real ( rp ), dimension (:,:), allocatable :: dihedral_params !!  (*mxparam*, *num_dihedral_types*) array integer :: num_dihedrals = 0 !!  Number of dihedrals integer , dimension (:,:), allocatable :: dihedrals !! (5, *num_dihedrals*) array. Dihedral *i* is of type *dt = dihedrals(1,i)*, incident !! to atoms *dihedrals(2,i)*, *dihedrals(3,i)*, *dihedrals(4,i)*, and *dihedrals(5,i)*. !! Its style is *dihedral_styles(dt)* with parameters *dihedral_params(:,dt)*. !Particle configuration: Branches integer :: num_branches = 0 !! Total number of branches (including the backbone) integer , dimension (:,:), allocatable :: branches !! (3,*num_branches*) array. Branch *i* is tethered to atom *branches(1,i)*, !! contains *branches(2,i)* atoms, with the beginning atom index *branches(3,i)*. !Particle configuration: Molecules integer :: num_molecule_types = 0 !!  Number of *molecule_type*s character ( len = 8 ), dimension (:), allocatable :: molecule_names !! (*num_molecule_types*,) array integer , dimension (:), allocatable :: molecule_pop !! (*num_molecule_types*,) array integer :: num_molecules = 0 !!  Number of molecules integer , dimension (:,:), allocatable :: molecules !! (9,*num_molecules*) array. For molecule *i*, its type *mt = molecules(1,i)*, !! containing *molecules(2,i)* atoms with beginning index *molecules(3,i)*, !! *molecules(4,i)* bonds with beginning index *molecules(5,i)*, !! *molecules(6,i)* angles with beginning index *molecules(7,i)*, and !! *molecules(8,i)* dihedrals with beginning index *molecules(9,i)*. real ( rp ), dimension ( 3 ) :: molecule_com = 0.0_rp !! Center of mass of the molecule. This is used only when imcon == 0, i.e. !! for a single molecule without periodic boundaries. !Particle configuration: Tethers integer :: num_tether_types = 0 !!  Number of *tether_type*s integer , dimension (:), allocatable :: tether_styles !!  (*num_tether_types*,) array real ( rp ), dimension (:,:), allocatable :: tether_params !!  (*mxparam*, *num_tether_types*) array integer :: num_tethers = 0 !!  Number of tethers integer , dimension (:,:), allocatable :: tethers !! (2, *num_tethers*) array. Tether *i* is of type *tt = tethers(1,i)*, tethering !! atom *tethers(2,i)* to a point *tether_points(:,i)*. !! Its style is *tether_styles(tt)* with parameters *tether_params(:,tt)*. real ( rp ), dimension (:,:), allocatable :: tether_points !!  (3, *num_tethers*) array !Particle configuration: VDW (pair) interactions integer :: num_vdw_types = 0 !!  Number of *vdw_type*s integer , dimension (:), allocatable :: vdw_styles !!  (*num_vdw_types*,) array real ( rp ), dimension (:,:), allocatable :: vdw_params !!  (*mxparam*, *num_vdw_types*) array integer , dimension (:,:), allocatable :: vdw_pairs !!  (2, *num_vdw_types*) array. Stores atom type of interacting pairs, such !! that at_i >= at_j. !Particle configuration: External force field integer :: num_externals = 0 !!  Number of external fields integer , dimension (:), allocatable :: external_styles !!  (*num_external*,) array real ( rp ), dimension (:,:), allocatable :: external_params !!  (*mxparam*, *num_external*) array !Particle configuration: Flow field integer :: flow_style = 0 real ( rp ), dimension (:), allocatable :: flow_params !!  (*mxparam*,) array end type atmcfg_t","tags":"","loc":"type/atmcfg_t.html"},{"title":"ctrlpar_t – BROWNPAK ","text":"type, public :: ctrlpar_t Contents Variables rcutoff tskin mth_ptgen lelst lhdia lvdw excluded_atoms mob_fctr lanc_mxitr lanc_tol se_nlmxitr se_kdmax bdintg se_tol stats_binsize tim_stp nts_sim nts_mobsam nts_dump nts_samp nts_log lrevive read_seed write_seed write_traj fn_cfg fn_revive fn_stats fn_traj Type-Bound Procedures read write Source Code ctrlpar_t Components Type Visibility Attributes Name Initial real(kind=rp), public :: rcutoff = 0.0_rp real(kind=rp), public :: tskin = 0.0_rp character(len=5), public :: mth_ptgen = '' logical, public :: lelst = .false. logical, public :: lhdia = .false. logical, public :: lvdw = .false. integer, public :: excluded_atoms = 0 character(len=4), public :: mob_fctr = '' integer, public :: lanc_mxitr = 0 real(kind=rp), public :: lanc_tol = 0.0_rp integer, public :: se_nlmxitr = 0 integer, public :: se_kdmax = 0 character(len=4), public :: bdintg = '' real(kind=rp), public, dimension(2) :: se_tol = 0.0_rp integer, public, dimension(2) :: stats_binsize = 0 real(kind=rp), public :: tim_stp = 0.0_rp integer(kind=ip_long), public :: nts_sim = 0 integer, public :: nts_mobsam = 0 integer(kind=ip_long), public :: nts_dump = 0 integer(kind=ip_long), public :: nts_samp = 0 integer(kind=ip_long), public :: nts_log = 0 logical, public :: lrevive = .false. {T, F}. Whether the simulation is restarted. logical, public :: read_seed = .false. {T, F}. Whether to initialize the random number generator by reading\n a seed from a file. If read_seed == T, the seed will be read from\n a file 'random_seed.txt' logical, public :: write_seed = .false. {T, F}. Whether to write the random number generator seed. If write_seed == T the seed will be written to a file named\n  'random_seed.txt' logical, public :: write_traj = .false. Should the trajectory be written to file? {T, F} character(len=:), public, allocatable :: fn_cfg Name of the file containing the initial configuration character(len=:), public, allocatable :: fn_revive Name of the revive file character(len=:), public, allocatable :: fn_stats Name of the statistics file character(len=:), public, allocatable :: fn_traj Name of the trajectory file Type-Bound Procedures procedure, public :: read => control_read public subroutine control_read (this, fn) Reads simulation control parameters from file Arguments Type Intent Optional Attributes Name class( ctrlpar_t ), intent(out) :: this A ctrlpar_t instance. character(len=*), intent(in) :: fn Name of parameters file. procedure, public :: write => control_write public subroutine control_write (this, fn) Write simulation parameters to file Arguments Type Intent Optional Attributes Name class( ctrlpar_t ), intent(out) :: this A ctrlpar_t instance. character(len=*), intent(in) :: fn Output file name Source Code type ctrlpar_t real ( rp ) :: rcutoff = 0.0_rp real ( rp ) :: tskin = 0.0_rp character ( len = 5 ) :: mth_ptgen = '' logical :: lelst = . false . logical :: lhdia = . false . logical :: lvdw = . false . integer :: excluded_atoms = 0 character ( len = 4 ) :: mob_fctr = '' integer :: lanc_mxitr = 0 real ( rp ) :: lanc_tol = 0.0_rp integer :: se_nlmxitr = 0 integer :: se_kdmax = 0 character ( len = 4 ) :: bdintg = '' real ( rp ), dimension ( 2 ) :: se_tol = 0.0_rp integer , dimension ( 2 ) :: stats_binsize = 0 real ( rp ) :: tim_stp = 0.0_rp integer ( ip_long ) :: nts_sim = 0 integer :: nts_mobsam = 0 integer ( ip_long ) :: nts_dump = 0 integer ( ip_long ) :: nts_samp = 0 integer ( ip_long ) :: nts_log = 0 logical :: lrevive = . false . !! {T, F}. Whether the simulation is restarted. logical :: read_seed = . false . !! {T, F}. Whether to initialize the random number generator by reading !! a seed from a file. If `read_seed` == T, the seed will be read from !! a file 'random_seed.txt' logical :: write_seed = . false . !! {T, F}. Whether to write the random number generator seed. If !!  `write_seed` == T the seed will be written to a file named !!  'random_seed.txt' logical :: write_traj = . false . !! Should the trajectory be written to file? {T, F} character ( len = :), allocatable :: fn_cfg !! Name of the file containing the initial configuration character ( len = :), allocatable :: fn_revive !! Name of the revive file character ( len = :), allocatable :: fn_stats !! Name of the statistics file character ( len = :), allocatable :: fn_traj !! Name of the trajectory file contains procedure :: read => control_read procedure :: write => control_write end type ctrlpar_t","tags":"","loc":"type/ctrlpar_t.html"},{"title":"aabb_t – BROWNPAK ","text":"type, public :: aabb_t Inherited by type~~aabb_t~~InheritedByGraph type~aabb_t aabb_t type~node_t node_t type~node_t->type~aabb_t aabb type~aabbtree_t aabbtree_t type~aabbtree_t->type~node_t nodes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables lbnd ubnd center srfarea Type-Bound Procedures init print clear get_extent update fatten includes overlaps calc_center calc_srfarea Source Code aabb_t Components Type Visibility Attributes Name Initial real(kind=rp), public, dimension(3) :: lbnd real(kind=rp), public, dimension(3) :: ubnd real(kind=rp), public, dimension(3) :: center real(kind=rp), public :: srfarea Type-Bound Procedures procedure, public :: init => aabb_init public subroutine aabb_init (this, lbnd, ubnd) Initializes an aabb_t instance from lower and upper bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(out) :: this An aabb_t instance. real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound procedure, public :: print => aabb_print public subroutine aabb_print (this, frmt, str) Prints an AABB. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. character(len=*), intent(in), optional :: frmt Fortran-style format string for a real number. Default: (g0.6) . character(len=:), intent(out), optional allocatable :: str If present, the output is printed to this string instead of STDOUT. procedure, public :: clear => aabb_clear public subroutine aabb_clear (this) Clears all attributes of an AABB and sets them to zero. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. procedure, public :: get_extent => aabb_get_extent public subroutine aabb_get_extent (this, extent) Calculates the extent of an aabb . The extent of an AABB is defined as\n the difference between its upper and lower bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. real(kind=rp), intent(out), dimension(3) :: extent Extent of an AABB. procedure, public :: update => aabb_update public subroutine aabb_update (this, lbnd, ubnd) Updates an AABB with new bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in), optional dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), optional dimension(3) :: ubnd Upper bound procedure, public :: fatten => aabb_fatten public subroutine aabb_fatten (this, frac) Fattens an AABB by a fraction of its base extent. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in) :: frac Fraction of AABB base extent. procedure, public :: includes => aabb_includes public function aabb_includes (this, other) result(res) Returns true if this includes other , false otherwise. Inclusion\n is considered in a strict sense. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical procedure, public :: overlaps => aabb_overlaps public function aabb_overlaps (this, other) result(res) Returns true if this overlaps other , false otherwise. Touching\n does not count as an overlap. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical procedure, private :: calc_center => aabb_calc_center public subroutine aabb_calc_center (this) Calculates the center of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. procedure, private :: calc_srfarea => aabb_calc_srfarea public subroutine aabb_calc_srfarea (this) Calculates the surface area of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. Source Code type aabb_t real ( rp ), dimension ( 3 ) :: lbnd real ( rp ), dimension ( 3 ) :: ubnd real ( rp ), dimension ( 3 ) :: center real ( rp ) :: srfarea contains procedure :: init => aabb_init procedure :: print => aabb_print procedure :: clear => aabb_clear procedure :: get_extent => aabb_get_extent procedure :: update => aabb_update procedure :: fatten => aabb_fatten procedure :: includes => aabb_includes procedure :: overlaps => aabb_overlaps procedure , private :: calc_center => aabb_calc_center procedure , private :: calc_srfarea => aabb_calc_srfarea end type aabb_t","tags":"","loc":"type/aabb_t.html"},{"title":"itable_t – BROWNPAK ","text":"type, public :: itable_t Inherits type~~itable_t~~InheritsGraph type~itable_t itable_t type~ivector_t ivector_t type~itable_t->type~ivector_t buffer Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables num_rows buffer row_indx Type-Bound Procedures delete clear append set_val is_in get_val get_row shrink_to_fit print Source Code itable_t Components Type Visibility Attributes Name Initial integer, public :: num_rows = 0 type( ivector_t ), public :: buffer integer, public, dimension(:), allocatable :: row_indx Type-Bound Procedures procedure, public :: delete => itbl_delete private subroutine itbl_delete (this) Deletes an itable_t . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this procedure, public :: clear => itbl_clear private subroutine itbl_clear (this) Clears all rows. Does not deallocate memory. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this procedure, public :: append => itbl_append private subroutine itbl_append (this, irow, val) Appends an element val to row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: val procedure, public :: set_val => itbl_set_val private subroutine itbl_set_val (this, irow, j, val) Sets the value of the j th element of row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: j integer, intent(in) :: val procedure, public :: is_in => itbl_is_in private function itbl_is_in (this, irow, val) result(res) Returns .true. if val is in row irow , .false. otherwise. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: val Return Value logical procedure, public :: get_val => itbl_get_val private function itbl_get_val (this, irow, j) result(res) Returns the j th element of row irow Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: j Return Value integer procedure, public :: get_row => itbl_get_row private subroutine itbl_get_row (this, irow, res) Returns a pointer to the row data of irow . No bounds checking is performed. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in), target :: this integer, intent(in) :: irow integer, intent(out), dimension(:), pointer :: res procedure, public :: shrink_to_fit => itbl_shrink_to_fit private subroutine itbl_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(out), optional :: ierr procedure, public :: print => itbl_print private subroutine itbl_print (this) Prints an itable_t . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this Source Code type itable_t integer :: num_rows = 0 !Must be > 0 type ( ivector_t ) :: buffer integer , dimension (:), allocatable :: row_indx contains procedure :: delete => itbl_delete procedure :: clear => itbl_clear procedure :: append => itbl_append procedure :: set_val => itbl_set_val procedure :: is_in => itbl_is_in procedure :: get_val => itbl_get_val procedure :: get_row => itbl_get_row procedure :: shrink_to_fit => itbl_shrink_to_fit procedure :: print => itbl_print end type itable_t","tags":"","loc":"type/itable_t.html"},{"title":"logger_t – BROWNPAK ","text":"type, private :: logger_t Contents Variables fn fu is_open Type-Bound Procedures init finish log_msg Source Code logger_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: fn Name of the log file integer, public :: fu = huge(0) Unit number of the log file logical, public :: is_open = .false. Is the log file open for writing? {T/F} Type-Bound Procedures procedure, public :: init => logger_init private subroutine logger_init (this, fn, use_stdout) Initializes a logger. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(out) :: this A logger_t instance character(len=*), intent(in) :: fn Name of the log file. If use_stdout is true, fn is ignored. logical, intent(in) :: use_stdout Write all log messages to stdout rather than a file on disk? {T/F} procedure, public :: finish => logger_finish private subroutine logger_finish (this) Cleanup routine for a logger_t instance. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(inout) :: this A logger_t instance procedure, public :: log_msg => logger_log_msg private subroutine logger_log_msg (this, msg) Write a message to the log file. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(in) :: this A logger_t instance character(len=*), intent(in) :: msg Message to write to the log file Source Code type logger_t character ( len = :), allocatable :: fn !! Name of the log file integer :: fu = huge ( 0 ) !! Unit number of the log file logical :: is_open = . false . !! Is the log file open for writing? {T/F} contains procedure :: init => logger_init procedure :: finish => logger_finish procedure :: log_msg => logger_log_msg end type logger_t","tags":"","loc":"type/logger_t.html"},{"title":"nittfq – BROWNPAK","text":"subroutine nittfq(n, xcur, fcur, fcnrm, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, ifdord, nfe, njve, nrpre, nli, r, rcgs, rtil, d, p, q, u, v, y, rwork1, rwork2, rsnrm, dinpr, dnorm, itrmks) Arguments Type Intent Optional Attributes Name integer :: n double precision :: xcur (n) double precision :: fcur (n) double precision :: fcnrm double precision :: step (n) double precision :: eta real :: f integer :: jacv double precision :: rpar (*) integer :: ipar (*) integer :: ijacv integer :: irpre integer :: iksmax integer :: ifdord integer :: nfe integer :: njve integer :: nrpre integer :: nli double precision :: r (n) double precision :: rcgs (n) double precision :: rtil (n) double precision :: d (n) double precision :: p (n) double precision :: q (n) double precision :: u (n) double precision :: v (n) double precision :: y (n) double precision :: rwork1 (n) double precision :: rwork2 (n) double precision :: rsnrm double precision :: dinpr double precision :: dnorm integer :: itrmks Calls proc~~nittfq~~CallsGraph proc~nittfq nittfq proc~nitjv nitjv proc~nittfq->proc~nitjv daxpy daxpy proc~nittfq->daxpy dlamch dlamch proc~nittfq->dlamch dscal dscal proc~nittfq->dscal dswap dswap proc~nittfq->dswap dcopy dcopy proc~nittfq->dcopy proc~nitjv->dcopy proc~nitfd nitfd proc~nitjv->proc~nitfd proc~nitfd->daxpy proc~nitfd->dlamch proc~nitfd->dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Common Blocks nitprint Common Blocks common /nitprint/ Type Attributes Name Initial integer :: iplvl integer :: ipunit","tags":"","loc":"proc/nittfq.html"},{"title":"nitjv – BROWNPAK","text":"subroutine nitjv(n, xcur, fcur, f, jacv, rpar, ipar, ijacv, ifdord, itask, nfe, njve, nrpre, v, z, rwork1, rwork2, dnorm, itrmjv) Arguments Type Intent Optional Attributes Name integer :: n double precision :: xcur (n) double precision :: fcur (n) real :: f integer :: jacv double precision :: rpar (*) integer :: ipar (*) integer :: ijacv integer :: ifdord integer :: itask integer :: nfe integer :: njve integer :: nrpre double precision :: v (n) double precision :: z (n) double precision :: rwork1 (n) double precision :: rwork2 (n) double precision :: dnorm integer :: itrmjv Calls proc~~nitjv~~CallsGraph proc~nitjv nitjv dcopy dcopy proc~nitjv->dcopy proc~nitfd nitfd proc~nitjv->proc~nitfd dlamch dlamch proc~nitfd->dlamch daxpy daxpy proc~nitfd->daxpy dscal dscal proc~nitfd->dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~nitjv~~CalledByGraph proc~nitjv nitjv proc~nitstb nitstb proc~nitstb->proc~nitjv proc~nittfq nittfq proc~nittfq->proc~nitjv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Common Blocks nitprint Common Blocks common /nitprint/ Type Attributes Name Initial integer :: iplvl integer :: ipunit","tags":"","loc":"proc/nitjv.html"},{"title":"nitfd – BROWNPAK","text":"subroutine nitfd(n, xcur, fcur, f, rpar, ipar, ijacv, ifdord, nfe, v, z, rwork, dnorm, itrmjv) Arguments Type Intent Optional Attributes Name integer :: n double precision :: xcur (n) double precision :: fcur (n) real :: f double precision :: rpar (*) integer :: ipar (*) integer :: ijacv integer :: ifdord integer :: nfe double precision :: v (n) double precision :: z (n) double precision :: rwork (n) double precision :: dnorm integer :: itrmjv Calls proc~~nitfd~~CallsGraph proc~nitfd nitfd dlamch dlamch proc~nitfd->dlamch daxpy daxpy proc~nitfd->daxpy dscal dscal proc~nitfd->dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~nitfd~~CalledByGraph proc~nitfd nitfd proc~nitjv nitjv proc~nitjv->proc~nitfd proc~nitstb nitstb proc~nitstb->proc~nitjv proc~nittfq nittfq proc~nittfq->proc~nitjv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Common Blocks nitprint Common Blocks common /nitprint/ Type Attributes Name Initial integer :: iplvl integer :: ipunit","tags":"","loc":"proc/nitfd.html"},{"title":"nitbt – BROWNPAK","text":"subroutine nitbt(n, xcur, fcnrm, step, eta, xpls, fpls, fpnrm, oftjs, redfac, nfe, ibt, ibtmax, f, rpar, ipar, dnorm, itrmbt) Arguments Type Intent Optional Attributes Name integer :: n double precision :: xcur (n) double precision :: fcnrm double precision :: step (n) double precision :: eta double precision :: xpls (n) double precision :: fpls (n) double precision :: fpnrm double precision :: oftjs double precision :: redfac integer :: nfe integer :: ibt integer :: ibtmax real :: f double precision :: rpar (*) integer :: ipar (*) double precision :: dnorm integer :: itrmbt Calls proc~~nitbt~~CallsGraph proc~nitbt nitbt dscal dscal proc~nitbt->dscal 2 2 proc~nitbt->2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~nitbt~~CalledByGraph proc~nitbt nitbt proc~nitdrv nitdrv proc~nitdrv->proc~nitbt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Common Blocks nitprint nitparam Common Blocks common /nitprint/ Type Attributes Name Initial integer :: iplvl integer :: ipunit common /nitparam/ Type Attributes Name Initial double precision :: choice1_exp double precision :: choice2_exp double precision :: choice2_coef double precision :: eta_cutoff double precision :: etamax double precision :: thmin double precision :: thmax double precision :: etafixed","tags":"","loc":"proc/nitbt.html"},{"title":"nitsol – BROWNPAK","text":"subroutine nitsol(n, x, f, jacv, ftol, stptol, input, info, rwork, rpar, ipar, iterm, dinpr, dnorm) Arguments Type Intent Optional Attributes Name integer :: n double precision :: x (n) real :: f integer :: jacv double precision :: ftol double precision :: stptol integer :: input (10) integer :: info (6) double precision :: rwork (*) double precision :: rpar (*) integer :: ipar (*) integer :: iterm double precision :: dinpr double precision :: dnorm Called by proc~~nitsol~~CalledByGraph proc~nitsol nitsol proc~integrate_se integrate_se proc~integrate_se->proc~nitsol proc~bds_run bds_run proc~bds_run->proc~integrate_se proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Common Blocks nitprint nitinfo nitparam Common Blocks common /nitprint/ Type Attributes Name Initial integer :: iplvl integer :: ipunit common /nitinfo/ Type Attributes Name Initial double precision :: avrate double precision :: fcurnrm integer :: instep integer :: newstep integer :: krystat common /nitparam/ Type Attributes Name Initial double precision :: choice1_exp double precision :: choice2_exp double precision :: choice2_coef double precision :: eta_cutoff double precision :: etamax double precision :: thmin double precision :: thmax double precision :: etafixed","tags":"","loc":"proc/nitsol.html"},{"title":"nitstb – BROWNPAK","text":"subroutine nitstb(n, xcur, fcur, fcnrm, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, ifdord, nfe, njve, nrpre, nli, r, rtil, p, phat, v, t, rwork1, rwork2, rsnrm, dinpr, dnorm, itrmks) Arguments Type Intent Optional Attributes Name integer :: n double precision :: xcur (n) double precision :: fcur (n) double precision :: fcnrm double precision :: step (n) double precision :: eta real :: f integer :: jacv double precision :: rpar (*) integer :: ipar (*) integer :: ijacv integer :: irpre integer :: iksmax integer :: ifdord integer :: nfe integer :: njve integer :: nrpre integer :: nli double precision :: r (n) double precision :: rtil (n) double precision :: p (n) double precision :: phat (n) double precision :: v (n) double precision :: t (n) double precision :: rwork1 (n) double precision :: rwork2 (n) double precision :: rsnrm double precision :: dinpr double precision :: dnorm integer :: itrmks Calls proc~~nitstb~~CallsGraph proc~nitstb nitstb proc~nitjv nitjv proc~nitstb->proc~nitjv dlamch dlamch proc~nitstb->dlamch daxpy daxpy proc~nitstb->daxpy dscal dscal proc~nitstb->dscal dcopy dcopy proc~nitstb->dcopy proc~nitjv->dcopy proc~nitfd nitfd proc~nitjv->proc~nitfd proc~nitfd->dlamch proc~nitfd->daxpy proc~nitfd->dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Common Blocks nitprint Common Blocks common /nitprint/ Type Attributes Name Initial integer :: iplvl integer :: ipunit","tags":"","loc":"proc/nitstb.html"},{"title":"nitgm – BROWNPAK","text":"subroutine nitgm(n, xcur, fcur, fcnrm, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, iresup, ifdord, nfe, njve, nrpre, nli, kdmax, kdmaxp1, vv, rr, svbig, svsml, w, rwork, rsnrm, dinpr, dnorm, itrmks) Arguments Type Intent Optional Attributes Name integer :: n double precision :: xcur (n) double precision :: fcur (n) double precision :: fcnrm double precision :: step (n) double precision :: eta real :: f integer :: jacv double precision :: rpar (*) integer :: ipar (*) integer :: ijacv integer :: irpre integer :: iksmax integer :: iresup integer :: ifdord integer :: nfe integer :: njve integer :: nrpre integer :: nli integer :: kdmax integer :: kdmaxp1 double precision :: vv (n,kdmaxp1) double precision :: rr (kdmax,kdmax) double precision :: svbig (kdmax) double precision :: svsml (kdmax) double precision :: w (kdmax) double precision :: rwork (n) double precision :: rsnrm double precision :: dinpr double precision :: dnorm integer :: itrmks Calls proc~~nitgm~~CallsGraph proc~nitgm nitgm dfloat dfloat proc~nitgm->dfloat dacos dacos proc~nitgm->dacos daxpy daxpy proc~nitgm->daxpy dlamch dlamch proc~nitgm->dlamch dscal dscal proc~nitgm->dscal dsin dsin proc~nitgm->dsin dcopy dcopy proc~nitgm->dcopy 2 2 proc~nitgm->2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Common Blocks nitprint Common Blocks common /nitprint/ Type Attributes Name Initial integer :: iplvl integer :: ipunit","tags":"","loc":"proc/nitgm.html"},{"title":"nitdrv – BROWNPAK","text":"subroutine nitdrv(n, xcur, fcur, xpls, fpls, step, f, jacv, rpar, ipar, ftol, stptol, nnimax, ijacv, ikrysl, kdmax, irpre, iksmax, iresup, ifdord, ibtmax, ieta, iterm, nfe, njve, nrpre, nli, nni, nbt, rwork, dinpr, dnorm) Arguments Type Intent Optional Attributes Name integer :: n double precision :: xcur (n) double precision :: fcur (n) double precision :: xpls (n) double precision :: fpls (n) double precision :: step (n) real :: f integer :: jacv double precision :: rpar (*) integer :: ipar (*) double precision :: ftol double precision :: stptol integer :: nnimax integer :: ijacv integer :: ikrysl integer :: kdmax integer :: irpre integer :: iksmax integer :: iresup integer :: ifdord integer :: ibtmax integer :: ieta integer :: iterm integer :: nfe integer :: njve integer :: nrpre integer :: nli integer :: nni integer :: nbt double precision :: rwork (*) double precision :: dinpr double precision :: dnorm Calls proc~~nitdrv~~CallsGraph proc~nitdrv nitdrv dfloat dfloat proc~nitdrv->dfloat dlamch dlamch proc~nitdrv->dlamch dcopy dcopy proc~nitdrv->dcopy proc~nitbt nitbt proc~nitdrv->proc~nitbt dscal dscal proc~nitbt->dscal 2 2 proc~nitbt->2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Common Blocks nitprint nitinfo nitparam Common Blocks common /nitprint/ Type Attributes Name Initial integer :: iplvl integer :: ipunit common /nitinfo/ Type Attributes Name Initial double precision :: avrate double precision :: fcurnrm integer :: instep integer :: newstep integer :: krystat common /nitparam/ Type Attributes Name Initial double precision :: choice1_exp double precision :: choice2_exp double precision :: choice2_coef double precision :: eta_cutoff double precision :: etamax double precision :: thmin double precision :: thmax double precision :: etafixed","tags":"","loc":"proc/nitdrv.html"},{"title":"node_isleaf – BROWNPAK","text":"interface Calls interface~~node_isleaf~~CallsGraph interface~node_isleaf node_isleaf proc~node_isleaf node_isleaf interface~node_isleaf->proc~node_isleaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module function node_isleaf(this) result(res) Implementation → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. Return Value logical true if this is a leaf node, false otherwise. Description Is this a leaf node?","tags":"","loc":"interface/node_isleaf.html"},{"title":"node_asstr – BROWNPAK","text":"interface Calls interface~~node_asstr~~CallsGraph interface~node_asstr node_asstr proc~node_asstr node_asstr interface~node_asstr->proc~node_asstr interface~str_from_num str_from_num proc~node_asstr->interface~str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module function node_asstr(this, frmt) result(buf) Implementation → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. character(len=*), intent(in), optional :: frmt Format string for real numbers, e.g. '(f15.6)'. Default: (g0.6) . Return Value character(len=:),\n  allocatable Return value Description Returns a string representation of a node.","tags":"","loc":"interface/node_asstr.html"},{"title":"get_num_atoms – BROWNPAK","text":"interface Calls interface~~get_num_atoms~~CallsGraph interface~get_num_atoms get_num_atoms proc~get_num_atoms get_num_atoms interface~get_num_atoms->proc~get_num_atoms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module function get_num_atoms(this) result(na) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value Description Returns the number of atoms in an AABB tree.","tags":"","loc":"interface/get_num_atoms.html"},{"title":"get_aabb – BROWNPAK","text":"interface Calls interface~~get_aabb~~CallsGraph interface~get_aabb get_aabb proc~get_aabb get_aabb interface~get_aabb->proc~get_aabb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module function get_aabb(this, ia) result(aabb) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. Return Value type( aabb_t ) AABB of atom ia . Description Returns a copy of the AABB associated with atom with index ia .","tags":"","loc":"interface/get_aabb.html"},{"title":"get_height – BROWNPAK","text":"interface Calls interface~~get_height~~CallsGraph interface~get_height get_height proc~get_height get_height interface~get_height->proc~get_height Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module function get_height(this) result(height) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. Description Returns the height of an AABB tree.","tags":"","loc":"interface/get_height.html"},{"title":"get_max_balance – BROWNPAK","text":"interface Calls interface~~get_max_balance~~CallsGraph interface~get_max_balance get_max_balance proc~get_max_balance get_max_balance interface~get_max_balance->proc~get_max_balance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module function get_max_balance(this) result(max_balance) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. Description Returns the maximum difference between the height of two children\n of a node.","tags":"","loc":"interface/get_max_balance.html"},{"title":"get_srfarea_ratio – BROWNPAK","text":"interface Calls interface~~get_srfarea_ratio~~CallsGraph interface~get_srfarea_ratio get_srfarea_ratio proc~get_srfarea_ratio get_srfarea_ratio interface~get_srfarea_ratio->proc~get_srfarea_ratio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module function get_srfarea_ratio(this) result(saratio) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value real(kind=rp) Return value. Description Returns the ratio of the sum of the node surface area to the surface\n area of the root node.","tags":"","loc":"interface/get_srfarea_ratio.html"},{"title":"balance – BROWNPAK","text":"interface Calls interface~~balance~~CallsGraph interface~balance balance proc~balance balance interface~balance->proc~balance nodes nodes proc~balance->nodes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module function balance(this, p) result(q) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node index Return Value integer Description Balances an AABB tree.","tags":"","loc":"interface/balance.html"},{"title":"calc_height – BROWNPAK","text":"interface Calls interface~~calc_height~~CallsGraph interface~calc_height calc_height proc~calc_height calc_height interface~calc_height->proc~calc_height Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private recursive module function calc_height(this, p) result(height) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default: Root of the whole\n tree. Return Value integer Return value Description Calculates the height of a subtree.","tags":"","loc":"interface/calc_height.html"},{"title":"fs_acquire – BROWNPAK","text":"interface Calls interface~~fs_acquire~~CallsGraph interface~fs_acquire fs_acquire proc~fs_acquire fs_acquire interface~fs_acquire->proc~fs_acquire Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module function fs_acquire(this) result(p) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Return Value integer Return value Description Acquires a new node from the free store and returns a pointer to it.","tags":"","loc":"interface/fs_acquire.html"},{"title":"node_init – BROWNPAK","text":"interface Calls interface~~node_init~~CallsGraph interface~node_init node_init proc~node_init node_init interface~node_init->proc~node_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine node_init(this) Implementation → Arguments Type Intent Optional Attributes Name class( node_t ), intent(out) :: this A node_t instance. Description Initializes a node.","tags":"","loc":"interface/node_init.html"},{"title":"init – BROWNPAK","text":"interface Calls interface~~init~~CallsGraph interface~init init proc~init init interface~init->proc~init interface~ivector_init ivector_init proc~init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine init(this, natoms, tskin) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(out) :: this An aabbtree_t instance. integer, intent(in) :: natoms Estimated number of atoms to be handled by this tree. real(kind=rp), intent(in) :: tskin Thickness of the skin for fattened AABBs, as a fraction of the\n AABB base length. Description Initializes an AABB tree.","tags":"","loc":"interface/init.html"},{"title":"print – BROWNPAK","text":"interface Calls interface~~print~~CallsGraph interface~print print proc~print print interface~print->proc~print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private recursive module subroutine print(this, p) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default is the root of the\n whole tree. Description Prints a subtree of an AABB tree rooted at p in order.","tags":"","loc":"interface/print.html"},{"title":"clear – BROWNPAK","text":"interface Calls interface~~clear~~CallsGraph interface~clear clear proc~clear clear interface~clear->proc~clear Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine clear(this) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Description Clears an AABB tree. Associated memory is not deallocated.","tags":"","loc":"interface/clear.html"},{"title":"delete – BROWNPAK","text":"interface Calls interface~~delete~~CallsGraph interface~delete delete proc~delete delete interface~delete->proc~delete Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine delete(this) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Description Deletes an AABB tree. All associated memory is deallocated.","tags":"","loc":"interface/delete.html"},{"title":"insert – BROWNPAK","text":"interface Calls interface~~insert~~CallsGraph interface~insert insert proc~insert insert interface~insert->proc~insert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine insert(this, ia, pos, radius) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) Description Inserts an atom into an AABB tree.","tags":"","loc":"interface/insert.html"},{"title":"remove – BROWNPAK","text":"interface Calls interface~~remove~~CallsGraph interface~remove remove proc~remove remove interface~remove->proc~remove Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine remove(this, ia) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index Description Removes an atom from an AABB tree.","tags":"","loc":"interface/remove.html"},{"title":"remove_all – BROWNPAK","text":"interface Calls interface~~remove_all~~CallsGraph interface~remove_all remove_all proc~remove_all remove_all interface~remove_all->proc~remove_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine remove_all(this) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Description Removes all atoms from an AABB tree.","tags":"","loc":"interface/remove_all.html"},{"title":"update_fatm – BROWNPAK","text":"interface Calls interface~~update_fatm~~CallsGraph interface~update_fatm update_fatm proc~update_fatm update_fatm interface~update_fatm->proc~update_fatm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine update_fatm(this, ia, pos, radius, lstat) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. Description Updates an AABB tree for the case when an atom leaves its fattened\n AABB.","tags":"","loc":"interface/update_fatm.html"},{"title":"update_fatmaabb – BROWNPAK","text":"interface Calls interface~~update_fatmaabb~~CallsGraph interface~update_fatmaabb update_fatmaabb proc~update_fatmaabb update_fatmaabb interface~update_fatmaabb->proc~update_fatmaabb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine update_fatmaabb(this, ia, lbnd, ubnd, lstat) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound of atom AABB real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound of atom AABB logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. Description Updates an AABB tree for the case when an atom leaves its fattened\n AABB, with the bounds of the new AABB for the atom as input.","tags":"","loc":"interface/update_fatmaabb.html"},{"title":"query_watm – BROWNPAK","text":"interface Calls interface~~query_watm~~CallsGraph interface~query_watm query_watm proc~query_watm query_watm interface~query_watm->proc~query_watm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine query_watm(this, ia, nbrs) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. Description Query an AABB tree for a set of potential neighbors of an atom.","tags":"","loc":"interface/query_watm.html"},{"title":"query_watmaabb – BROWNPAK","text":"interface Calls interface~~query_watmaabb~~CallsGraph interface~query_watmaabb query_watmaabb proc~query_watmaabb query_watmaabb interface~query_watmaabb->proc~query_watmaabb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine query_watmaabb(this, ia, aabb, nbrs) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. type( aabb_t ), intent(in) :: aabb Bounding AABB for atom with index ia . type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. Description Query an AABB tree for a set of potential neighbors of an atom & its\n bounding AABB.","tags":"","loc":"interface/query_watmaabb.html"},{"title":"query_waabb – BROWNPAK","text":"interface Calls interface~~query_waabb~~CallsGraph interface~query_waabb query_waabb proc~query_waabb query_waabb interface~query_waabb->proc~query_waabb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine query_waabb(this, aabb, atms) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. type( aabb_t ), intent(in) :: aabb An aabb_t instance. type( ivector_t ), intent(inout) :: atms List of potential neighbors. Description Query an AABB tree for the set of atoms whose AABBS overlap with aabb .","tags":"","loc":"interface/query_waabb.html"},{"title":"rebuild – BROWNPAK","text":"interface Calls interface~~rebuild~~CallsGraph interface~rebuild rebuild proc~rebuild rebuild interface~rebuild->proc~rebuild interface~ivector_init ivector_init proc~rebuild->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine rebuild(this) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Description Rebuilds an optimal AABB tree.","tags":"","loc":"interface/rebuild.html"},{"title":"validate – BROWNPAK","text":"interface Calls interface~~validate~~CallsGraph interface~validate validate proc~validate validate interface~validate->proc~validate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine validate(this) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Description Validates an AABB tree.","tags":"","loc":"interface/validate.html"},{"title":"insert_leaf – BROWNPAK","text":"interface Calls interface~~insert_leaf~~CallsGraph interface~insert_leaf insert_leaf proc~insert_leaf insert_leaf interface~insert_leaf->proc~insert_leaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine insert_leaf(this, leaf) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node Description Inserts a leaf node into a tree.","tags":"","loc":"interface/insert_leaf.html"},{"title":"remove_leaf – BROWNPAK","text":"interface Calls interface~~remove_leaf~~CallsGraph interface~remove_leaf remove_leaf proc~remove_leaf remove_leaf interface~remove_leaf->proc~remove_leaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine remove_leaf(this, leaf) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node Description Removes a leaf node from a tree.","tags":"","loc":"interface/remove_leaf.html"},{"title":"fs_return – BROWNPAK","text":"interface Calls interface~~fs_return~~CallsGraph interface~fs_return fs_return proc~fs_return fs_return interface~fs_return->proc~fs_return Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module subroutine fs_return(this, p) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node pointer. Description Returns a node to the free store.","tags":"","loc":"interface/fs_return.html"},{"title":"validate_structure – BROWNPAK","text":"interface Calls interface~~validate_structure~~CallsGraph interface~validate_structure validate_structure proc~validate_structure validate_structure interface~validate_structure->proc~validate_structure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private recursive module subroutine validate_structure(this, p) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. Description Asserts that an AABB subtree has a valid structure.","tags":"","loc":"interface/validate_structure.html"},{"title":"validate_metrics – BROWNPAK","text":"interface Calls interface~~validate_metrics~~CallsGraph interface~validate_metrics validate_metrics proc~validate_metrics validate_metrics interface~validate_metrics->proc~validate_metrics Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private recursive module subroutine validate_metrics(this, p) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. Description Asserts that an AABB subtree has a valid metric.","tags":"","loc":"interface/validate_metrics.html"},{"title":"cl_get_num_cells – BROWNPAK","text":"public function cl_get_num_cells() result(res) Returns the total number of cells Arguments None Return Value integer Called by proc~~cl_get_num_cells~~CalledByGraph proc~cl_get_num_cells cl_get_num_cells proc~build_pt_cell_list build_pt_cell_list proc~build_pt_cell_list->proc~cl_get_num_cells proc~pt_build pt_build proc~pt_build->proc~build_pt_cell_list proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~pt_build proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_get_num_cells.html"},{"title":"cl_init – BROWNPAK","text":"public subroutine cl_init(na_max, cs_min, simbox) Initializes a cell list. Arguments Type Intent Optional Attributes Name integer, intent(in) :: na_max Maximum number of atoms to be handled. real(kind=rp), intent(in) :: cs_min Minimum size (i.e. length) of a cell. type( smbx_t ), intent(in) :: simbox Simulation box Calls proc~~cl_init~~CallsGraph proc~cl_init cl_init interface~ivector_init ivector_init proc~cl_init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cl_init~~CalledByGraph proc~cl_init cl_init proc~pt_init pt_init proc~pt_init->proc~cl_init proc~ia_setup ia_setup proc~ia_setup->proc~pt_init proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_init.html"},{"title":"cl_set_cell_size – BROWNPAK","text":"public subroutine cl_set_cell_size(cs, simbox) Sets the cell size. The actual cell size may be slightly larger. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: cs type( smbx_t ), intent(in) :: simbox Called by proc~~cl_set_cell_size~~CalledByGraph proc~cl_set_cell_size cl_set_cell_size proc~pt_init pt_init proc~pt_init->proc~cl_set_cell_size proc~ia_setup ia_setup proc~ia_setup->proc~pt_init proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_set_cell_size.html"},{"title":"cl_build_cell_nbrs – BROWNPAK","text":"public subroutine cl_build_cell_nbrs() Makes a table of neighboring cells. Arguments None Called by proc~~cl_build_cell_nbrs~~CalledByGraph proc~cl_build_cell_nbrs cl_build_cell_nbrs proc~pt_init pt_init proc~pt_init->proc~cl_build_cell_nbrs proc~ia_setup ia_setup proc~ia_setup->proc~pt_init proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_build_cell_nbrs.html"},{"title":"cl_delete – BROWNPAK","text":"public subroutine cl_delete() Deallocates memory allocated in cl_init . Arguments None Called by proc~~cl_delete~~CalledByGraph proc~cl_delete cl_delete proc~pt_delete pt_delete proc~pt_delete->proc~cl_delete proc~ia_finish ia_finish proc~ia_finish->proc~pt_delete proc~finish finish proc~finish->proc~ia_finish proc~run run proc~run->proc~finish program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_delete.html"},{"title":"cl_build – BROWNPAK","text":"public subroutine cl_build(coords) Sorts atoms into cells for calculating short-range interations Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: coords Called by proc~~cl_build~~CalledByGraph proc~cl_build cl_build proc~build_pt_cell_list build_pt_cell_list proc~build_pt_cell_list->proc~cl_build proc~pt_build pt_build proc~pt_build->proc~build_pt_cell_list proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~pt_build proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_build.html"},{"title":"cl_get_contents – BROWNPAK","text":"public subroutine cl_get_contents(ic, res) Returns a pointer to the entries of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res Called by proc~~cl_get_contents~~CalledByGraph proc~cl_get_contents cl_get_contents proc~build_pt_cell_list build_pt_cell_list proc~build_pt_cell_list->proc~cl_get_contents proc~cl_print cl_print proc~cl_print->proc~cl_get_contents proc~pt_build pt_build proc~pt_build->proc~build_pt_cell_list proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~pt_build proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_get_contents.html"},{"title":"cl_get_nbr_cells – BROWNPAK","text":"public subroutine cl_get_nbr_cells(ic, res) Returns a pointer to the neighbor cells of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res Called by proc~~cl_get_nbr_cells~~CalledByGraph proc~cl_get_nbr_cells cl_get_nbr_cells proc~build_pt_cell_list build_pt_cell_list proc~build_pt_cell_list->proc~cl_get_nbr_cells proc~cl_print cl_print proc~cl_print->proc~cl_get_nbr_cells proc~pt_build pt_build proc~pt_build->proc~build_pt_cell_list proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~pt_build proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_get_nbr_cells.html"},{"title":"cl_print – BROWNPAK","text":"public subroutine cl_print() Prints a cell list Arguments None Calls proc~~cl_print~~CallsGraph proc~cl_print cl_print proc~cl_get_contents cl_get_contents proc~cl_print->proc~cl_get_contents proc~cl_get_nbr_cells cl_get_nbr_cells proc~cl_print->proc~cl_get_nbr_cells Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_print.html"},{"title":"smbx_init – BROWNPAK","text":"public subroutine smbx_init(this, imcon) Initializes an instance of smbx_t . Can also be called to reset. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(out) :: this An instance of smbx_t . integer, intent(in) :: imcon Flag specifying boundary conditions on the simulation box. imcon = 0 : Unbounded domain. While not explicitly enforced this \n    is useful only for a single molecule. The dynamics is performed in the\n    c.o.m. frame of reference. imcon = 1 : PBC along x , y , & z . There are no restrictions on\n    the number of molecules. Contents None","tags":"","loc":"proc/smbx_init.html"},{"title":"smbx_set_basis – BROWNPAK","text":"public subroutine smbx_set_basis(this, bv) Sets all three basis vectors. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(3,3) :: bv Contents None","tags":"","loc":"proc/smbx_set_basis.html"},{"title":"smbx_freeze – BROWNPAK","text":"public subroutine smbx_freeze(this) Specifies this as non-deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/smbx_freeze.html"},{"title":"smbx_unfreeze – BROWNPAK","text":"public subroutine smbx_unfreeze(this) Specifies this as deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/smbx_unfreeze.html"},{"title":"smbx_get_image – BROWNPAK","text":"public subroutine smbx_get_image(this, r) Returns the image of r under PBC. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(3) :: r Contents None","tags":"","loc":"proc/smbx_get_image.html"},{"title":"smbx_wrap_all – BROWNPAK","text":"public subroutine smbx_wrap_all(this, coords) Wraps atom positions w.r.t. periodic boundary conditions. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords Contents None","tags":"","loc":"proc/smbx_wrap_all.html"},{"title":"smbx_to_center – BROWNPAK","text":"public subroutine smbx_to_center(this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the center \n of the box. Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com Contents None","tags":"","loc":"proc/smbx_to_center.html"},{"title":"smbx_to_origin – BROWNPAK","text":"public subroutine smbx_to_origin(this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the origin.\n Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com Contents None","tags":"","loc":"proc/smbx_to_origin.html"},{"title":"smbx_get_rnd_points – BROWNPAK","text":"public subroutine smbx_get_rnd_points(this, coords) Returns uniformly distributed points within the box. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(out), dimension(:,:) :: coords Calls proc~~smbx_get_rnd_points~~CallsGraph proc~smbx_get_rnd_points smbx_get_rnd_points proc~get_rv_uniform get_rv_uniform proc~smbx_get_rnd_points->proc~get_rv_uniform vdrnguniform vdrnguniform proc~get_rv_uniform->vdrnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/smbx_get_rnd_points.html"},{"title":"ia_external_setup – BROWNPAK","text":"public subroutine ia_external_setup(num_externals, external_styles, external_params) Sets up parameters for external potentials. Usually there is nothing to\n set for externals, but this acts as a placeholder for special cases. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_externals Number of external fields integer, intent(in), dimension(:) :: external_styles Styles for each field real(kind=rp), intent(inout), dimension(:,:) :: external_params Parameters for each field, depending on style Called by proc~~ia_external_setup~~CalledByGraph proc~ia_external_setup ia_external_setup proc~ia_setup ia_setup proc~ia_setup->proc~ia_external_setup proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_external_setup.html"},{"title":"ia_add_external_forces – BROWNPAK","text":"public subroutine ia_add_external_forces(num_externals, external_styles, external_params, coordinates, energy_external, forces, stress, ierr) Calculates the force and energy due to an external field and adds to energy_external , 'forces , & stress`. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_externals Number of external fields integer, intent(in), dimension(:) :: external_styles Styles for each field real(kind=rp), intent(inout), dimension(:,:) :: external_params Parameters for each field, depending on style real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(out) :: energy_external real(kind=rp), intent(inout), dimension(:,:) :: forces real(kind=rp), intent(inout), dimension(3,3) :: stress integer, intent(out) :: ierr Called by proc~~ia_add_external_forces~~CalledByGraph proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_external_forces.html"},{"title":"traj_create – BROWNPAK","text":"private subroutine traj_create(this, fn, na, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of atoms integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges Contents None","tags":"","loc":"proc/traj_create.html"},{"title":"traj_open – BROWNPAK","text":"private subroutine traj_open(this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/traj_open.html"},{"title":"traj_delete – BROWNPAK","text":"private subroutine traj_delete(this) After a call to this subroutine, all memory within this is deallocated,\n all components of this are reset to zero, and the underlying file is\n closed (if open). Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/traj_delete.html"},{"title":"traj_close – BROWNPAK","text":"private subroutine traj_close(this) Closes the underlying file of a trajectory_t . Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/traj_close.html"},{"title":"traj_read – BROWNPAK","text":"private subroutine traj_read(this, iframe, nts, ierr, coordinates, velocities, forces, charge) Read from an open trajectory. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(in) :: this integer, intent(in) :: iframe Frame number integer(kind=ip_long), intent(out) :: nts Time step counter integer, intent(out) :: ierr Error flag real(kind=rp), intent(out), optional dimension(:,:) :: coordinates real(kind=rp), intent(out), optional dimension(:,:) :: velocities real(kind=rp), intent(out), optional dimension(:,:) :: forces real(kind=rp), intent(out), optional dimension(:) :: charge Contents None","tags":"","loc":"proc/traj_read.html"},{"title":"traj_append_frame – BROWNPAK","text":"private subroutine traj_append_frame(this, nts, coordinates) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates Contents None","tags":"","loc":"proc/traj_append_frame.html"},{"title":"traj_write_frame – BROWNPAK","text":"private subroutine traj_write_frame(this, iframe, nts, coordinates) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer, intent(in) :: iframe integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates Contents None","tags":"","loc":"proc/traj_write_frame.html"},{"title":"ia_dihedral_setup – BROWNPAK","text":"public subroutine ia_dihedral_setup(num_dihedral_types, dihedral_styles, dihedral_params) Sets up parameters for dihedral potentials Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_dihedral_types Number of dihedral types integer, intent(in), dimension(:) :: dihedral_styles Styles for each type real(kind=rp), intent(inout), dimension(:,:) :: dihedral_params Parameters for each type, depending on style Called by proc~~ia_dihedral_setup~~CalledByGraph proc~ia_dihedral_setup ia_dihedral_setup proc~ia_setup ia_setup proc~ia_setup->proc~ia_dihedral_setup proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_dihedral_setup.html"},{"title":"ia_get_dihedral_force – BROWNPAK","text":"public subroutine ia_get_dihedral_force(q1, q2, q3, sty, params, enrg, fi, fj, fk, fl) Calculates the force & energy due to a dihedral. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 real(kind=rp), intent(in), dimension(3) :: q3 integer, intent(in) :: sty real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fj real(kind=rp), intent(out), dimension(3) :: fk real(kind=rp), intent(out), dimension(3) :: fl Called by proc~~ia_get_dihedral_force~~CalledByGraph proc~ia_get_dihedral_force ia_get_dihedral_force proc~ia_add_dihedral_forces ia_add_dihedral_forces proc~ia_add_dihedral_forces->proc~ia_get_dihedral_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_get_dihedral_force.html"},{"title":"iqsort – BROWNPAK","text":"public subroutine iqsort(list, order) Sorts a sequence of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), DIMENSION (:) :: list Sequence of integers to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence Called by proc~~iqsort~~CalledByGraph proc~iqsort iqsort proc~ivector_sort ivector_sort proc~ivector_sort->proc~iqsort proc~ivector_unique ivector_unique proc~ivector_unique->proc~iqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code iqsort Source Code RECURSIVE SUBROUTINE iqsort ( list , order ) !!  Sorts a sequence of integers IMPLICIT NONE INTEGER , DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of integers to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE iqsort","tags":"","loc":"proc/iqsort.html"},{"title":"dqsort – BROWNPAK","text":"public subroutine dqsort(list, order) Sorts a sequence of reals Arguments Type Intent Optional Attributes Name real(kind=RP), intent(inout), DIMENSION (:) :: list Sequence of reals to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence Called by proc~~dqsort~~CalledByGraph proc~dqsort dqsort proc~dvector_unique dvector_unique proc~dvector_unique->proc~dqsort proc~dvector_sort dvector_sort proc~dvector_sort->proc~dqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dqsort Source Code RECURSIVE SUBROUTINE dqsort ( list , order ) !!  Sorts a sequence of reals !\"\" IMPLICIT NONE REAL ( RP ), DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of reals to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE dqsort","tags":"","loc":"proc/dqsort.html"},{"title":"ia_vdw_setup – BROWNPAK","text":"public subroutine ia_vdw_setup(num_vdw_types, vdw_styles, vdw_params) Sets up parameters for vdw potentials Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_vdw_types Number of types of vdw interactions integer, intent(in), dimension(:) :: vdw_styles Styles for each type real(kind=rp), intent(inout), dimension(:,:) :: vdw_params Parameters for each type, depending on style Called by proc~~ia_vdw_setup~~CalledByGraph proc~ia_vdw_setup ia_vdw_setup proc~ia_setup ia_setup proc~ia_setup->proc~ia_vdw_setup proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_vdw_setup.html"},{"title":"ia_get_vdw_force – BROWNPAK","text":"public subroutine ia_get_vdw_force(rij_mag, qi, qj, sty, params, enrg, frc, ierr) Calculates the energy & its derivative due to a single interacting pair of atoms. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between two atoms real(kind=rp), intent(in) :: qi Charge on atom i real(kind=rp), intent(in) :: qj Charge on atom j integer, intent(in) :: sty Style of vdw interaction real(kind=rp), intent(in), dimension(:) :: params Parameters for vdw interaction real(kind=rp), intent(out) :: enrg Energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of force due to\n this potential. integer, intent(out) :: ierr Error flag Calls proc~~ia_get_vdw_force~~CallsGraph proc~ia_get_vdw_force ia_get_vdw_force proc~vdw_lj_coul_debye vdw_lj_coul_debye proc~ia_get_vdw_force->proc~vdw_lj_coul_debye proc~vdw_cosine vdw_cosine proc~ia_get_vdw_force->proc~vdw_cosine proc~vdw_gaussian vdw_gaussian proc~ia_get_vdw_force->proc~vdw_gaussian proc~vdw_lj vdw_lj proc~ia_get_vdw_force->proc~vdw_lj proc~vdw_dpd vdw_dpd proc~ia_get_vdw_force->proc~vdw_dpd proc~vdw_lj_coul vdw_lj_coul proc~ia_get_vdw_force->proc~vdw_lj_coul Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_get_vdw_force~~CalledByGraph proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_get_vdw_force.html"},{"title":"vdw_lj_set – BROWNPAK","text":"private subroutine vdw_lj_set(params, eps, sigma, rcut) Setter for 12-6 LJ (truncated & force-shifted) interaction. The potential U is given by: V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] U = V - V(rcut) - (r - rcut)*dV/dr, r < rcut, 0, r >= rcut where dV/dr is evaluated at r = rcut . User-set parameters: params(1) = eps params(2) = sigma params(3) = rcut Internally stored parameters: params(4) = V(rcut) params(5) = dV/dr(rcut) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut Contents None","tags":"","loc":"proc/vdw_lj_set.html"},{"title":"vdw_lj – BROWNPAK","text":"private pure subroutine vdw_lj(r, params, enrg, frc) Evaluates the potential and its derivative for LJ interaction. See vdw_lj_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Called by proc~~vdw_lj~~CalledByGraph proc~vdw_lj vdw_lj proc~ia_get_vdw_force ia_get_vdw_force proc~ia_get_vdw_force->proc~vdw_lj proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/vdw_lj.html"},{"title":"vdw_gaussian_set – BROWNPAK","text":"private subroutine vdw_gaussian_set(params, A, B, rcut) Setter for gaussian interaction. The potential is truncated and\n force-shifted. The potential U is given by: V = A*exp(-B*r&#94;2) U = V - V(rcut) - (r - rcut)*dV/dr, r < rcut 0, r >= rcut, where dV/dr is evaluated at r = rcut . User-set parameters: params(1) = A params(2) = B params(3) = rcut Internally stored parameters: params(4) = V(rcut) params(5) = dV/dr(rcut) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: B real(kind=rp), intent(in), optional :: rcut Contents None","tags":"","loc":"proc/vdw_gaussian_set.html"},{"title":"vdw_gaussian – BROWNPAK","text":"private pure subroutine vdw_gaussian(r, params, enrg, frc) Calculates energy & its derivative for gaussian interaction. See vdw_gaussian_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Called by proc~~vdw_gaussian~~CalledByGraph proc~vdw_gaussian vdw_gaussian proc~ia_get_vdw_force ia_get_vdw_force proc~ia_get_vdw_force->proc~vdw_gaussian proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/vdw_gaussian.html"},{"title":"vdw_cosine_set – BROWNPAK","text":"private subroutine vdw_cosine_set(params, A, rcut) Setter for cosine interaction. The potential U is given by: U = A*[1 + cos(pi*r/rcut)], r < rcut 0, r >= rcut The potential as well as its derivative is zero at r = rcut . User-set parameters: params(1) = A params(2) = rcut Internally stored parameters: None Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: rcut Contents None","tags":"","loc":"proc/vdw_cosine_set.html"},{"title":"vdw_cosine – BROWNPAK","text":"private pure subroutine vdw_cosine(r, params, enrg, frc) Evaluates the potential and its derivative for  cosine interaction.\n See vdw_cosine_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Called by proc~~vdw_cosine~~CalledByGraph proc~vdw_cosine vdw_cosine proc~ia_get_vdw_force ia_get_vdw_force proc~ia_get_vdw_force->proc~vdw_cosine proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/vdw_cosine.html"},{"title":"vdw_lj_coul_debye_set – BROWNPAK","text":"private subroutine vdw_lj_coul_debye_set(params, eps, sigma, rcut, rcut_coul, C, kappa) Setter for 12-6 LJ with screened Coulombic interaction. The potential U is given by: V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] W = C*qi*qj*exp(-kappa*r)/r if rcut_coul > 0: U = V - V(rcut) + W - W(rcut_coul), r < rcut W - W(rcut_coul), rcut <= r < rcut_coul 0, r >= rcut_coul if rcut_coul <= 0: U = V - V(rcut) + W, r < rcut W, r >= rcut The LJ potential V is cut & shifted at r = rcut . If rcut_coul > 0 , the screened Coulombic potential W is cut & shifted\n at r = rcut_coul . If rcut_coul <= 0 , no cutoff is applied on W . rcut_coul must be >= rcut . User-set parameters: params(1) = eps params(2) = sigma params(3) = rcut params(4) = rcut_coul params(5) = C params(6) = kappa Internally stored parameters: params(7) = V(rcut) params(8) = C*exp(-kappa*rcut_coul)/rcut_coul Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C real(kind=rp), intent(in), optional :: kappa Contents None","tags":"","loc":"proc/vdw_lj_coul_debye_set.html"},{"title":"vdw_lj_coul_debye – BROWNPAK","text":"private pure subroutine vdw_lj_coul_debye(r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for screened Coulombic interaction\ncombined with 12-6 LJ (cut & shifted). See vdw_lj_coul_debye_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Called by proc~~vdw_lj_coul_debye~~CalledByGraph proc~vdw_lj_coul_debye vdw_lj_coul_debye proc~ia_get_vdw_force ia_get_vdw_force proc~ia_get_vdw_force->proc~vdw_lj_coul_debye proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/vdw_lj_coul_debye.html"},{"title":"vdw_lj_coul_set – BROWNPAK","text":"private subroutine vdw_lj_coul_set(params, eps, sigma, rcut, rcut_coul, C) Setter for 12-6 LJ with Coulombic interaction. The potential U is given by: V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] W = C*qi*qj/r if rcut_coul > 0: U = V - V(rcut) + W - W(rcut_coul), r < rcut W - W(rcut_coul), rcut <= r < rcut_coul 0, r >= rcut_coul if rcut_coul <= 0: U = V - V(rcut) + W, r < rcut W, r >= rcut The LJ potential V is cut & shifted at r = rcut . If rcut_coul > 0 , the Coulombic potential W is cut & shifted at r = rcut_coul . If rcut_coul <= 0 , no cutoff is applied on W . rcut_coul must be >= rcut . User-set parameters: params(1) = eps params(2) = sigma params(3) = rcut params(4) = rcut_coul params(5) = C Internally stored parameters: params(6) = V(rcut) params(7) = C/rcut_coul Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C Contents None","tags":"","loc":"proc/vdw_lj_coul_set.html"},{"title":"vdw_lj_coul – BROWNPAK","text":"private pure subroutine vdw_lj_coul(r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for Coulombic interaction\n combined with 12-6 LJ (cut & shifted). See vdw_lj_coul_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Called by proc~~vdw_lj_coul~~CalledByGraph proc~vdw_lj_coul vdw_lj_coul proc~ia_get_vdw_force ia_get_vdw_force proc~ia_get_vdw_force->proc~vdw_lj_coul proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/vdw_lj_coul.html"},{"title":"vdw_dpd_set – BROWNPAK","text":"private subroutine vdw_dpd_set(params, A, rcut) Setter for standard DPD interaction. The potential U is given by: U = (A/2)*rcut*(1 - (r/rcut))&#94;2, r < rcut User-set parameters: params(1) = A params(2) = rcut Internally stored parameters: None Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: rcut Contents None","tags":"","loc":"proc/vdw_dpd_set.html"},{"title":"vdw_dpd – BROWNPAK","text":"private pure subroutine vdw_dpd(r, params, enrg, frc) Evaluates the potential and its derivative for standard DPD interaction.\n See vdw_dpd_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Called by proc~~vdw_dpd~~CalledByGraph proc~vdw_dpd vdw_dpd proc~ia_get_vdw_force ia_get_vdw_force proc~ia_get_vdw_force->proc~vdw_dpd proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/vdw_dpd.html"},{"title":"ivector_get_len – BROWNPAK","text":"public function ivector_get_len(this) result(res) Returns the length of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/ivector_get_len.html"},{"title":"dvector_get_len – BROWNPAK","text":"public function dvector_get_len(this) result(res) Returns the length of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/dvector_get_len.html"},{"title":"ivector_get_val – BROWNPAK","text":"public function ivector_get_val(this, i) result(res) Returns the ith element of an ivector . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/ivector_get_val.html"},{"title":"dvector_get_val – BROWNPAK","text":"public function dvector_get_val(this, i) result(res) Returns the ith element of a dvector . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rp) Contents None","tags":"","loc":"proc/dvector_get_val.html"},{"title":"ivector_pop – BROWNPAK","text":"public function ivector_pop(this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Return Value integer Contents None","tags":"","loc":"proc/ivector_pop.html"},{"title":"dvector_pop – BROWNPAK","text":"public function dvector_pop(this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Return Value real(kind=rp) Contents None","tags":"","loc":"proc/dvector_pop.html"},{"title":"ivector_init – BROWNPAK","text":"public subroutine ivector_init(this, len_init, ierr) Creates an empty ivector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/ivector_init.html"},{"title":"dvector_init – BROWNPAK","text":"public subroutine dvector_init(this, len_init, ierr) Creates an empty dvector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/dvector_init.html"},{"title":"ivector_from_array – BROWNPAK","text":"public subroutine ivector_from_array(this, x) Creates an ivector with all elements from an array Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), dimension(:) :: x Calls proc~~ivector_from_array~~CallsGraph proc~ivector_from_array ivector_from_array interface~ivector_init ivector_init proc~ivector_from_array->interface~ivector_init interface~ivector_init->proc~ivector_from_array interface~ivector_init->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ivector_from_array~~CalledByGraph proc~ivector_from_array ivector_from_array interface~ivector_init ivector_init proc~ivector_from_array->interface~ivector_init interface~ivector_init->proc~ivector_from_array interface~ivector_init->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ivector_from_array.html"},{"title":"dvector_from_array – BROWNPAK","text":"public subroutine dvector_from_array(this, x) Creates a dvector with all elements from an array Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(:) :: x Calls proc~~dvector_from_array~~CallsGraph proc~dvector_from_array dvector_from_array interface~dvector_init dvector_init proc~dvector_from_array->interface~dvector_init interface~dvector_init->proc~dvector_from_array interface~dvector_init->interface~dvector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dvector_from_array~~CalledByGraph proc~dvector_from_array dvector_from_array interface~dvector_init dvector_init interface~dvector_init->proc~dvector_from_array interface~dvector_init->interface~dvector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dvector_from_array.html"},{"title":"ivector_delete – BROWNPAK","text":"public subroutine ivector_delete(this) Deletes an ivector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/ivector_delete.html"},{"title":"dvector_delete – BROWNPAK","text":"public subroutine dvector_delete(this) Deletes a dvector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/dvector_delete.html"},{"title":"ivector_clear – BROWNPAK","text":"public subroutine ivector_clear(this) Clears an ivector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/ivector_clear.html"},{"title":"dvector_clear – BROWNPAK","text":"public subroutine dvector_clear(this) Clears a dvector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/dvector_clear.html"},{"title":"ivector_assign – BROWNPAK","text":"public subroutine ivector_assign(this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other Called by proc~~ivector_assign~~CalledByGraph proc~ivector_assign ivector_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~ivector_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ivector_assign.html"},{"title":"dvector_assign – BROWNPAK","text":"public subroutine dvector_assign(this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other Called by proc~~dvector_assign~~CalledByGraph proc~dvector_assign dvector_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~dvector_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dvector_assign.html"},{"title":"i_dvector_assign – BROWNPAK","text":"public subroutine i_dvector_assign(this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other Called by proc~~i_dvector_assign~~CalledByGraph proc~i_dvector_assign i_dvector_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~i_dvector_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/i_dvector_assign.html"},{"title":"ivector_set_val – BROWNPAK","text":"public subroutine ivector_set_val(this, i, val) Sets the value of the ith element of an ivector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: val Contents None","tags":"","loc":"proc/ivector_set_val.html"},{"title":"dvector_set_val – BROWNPAK","text":"public subroutine dvector_set_val(this, i, val) Sets the value of the ith element of a dvector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: i real(kind=rp), intent(in) :: val Contents None","tags":"","loc":"proc/dvector_set_val.html"},{"title":"ivector_append – BROWNPAK","text":"public subroutine ivector_append(this, val) Adds an element to the end of an ivector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: val Contents None","tags":"","loc":"proc/ivector_append.html"},{"title":"dvector_append – BROWNPAK","text":"public subroutine dvector_append(this, val) Adds an element to the end of a dvector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this real(kind=rp), intent(in) :: val Contents None","tags":"","loc":"proc/dvector_append.html"},{"title":"ivector_get_data – BROWNPAK","text":"public subroutine ivector_get_data(this, res, ibeg, iend) Returns a pointer to the underlying data of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in), target :: this integer, intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend Contents None","tags":"","loc":"proc/ivector_get_data.html"},{"title":"dvector_get_data – BROWNPAK","text":"public subroutine dvector_get_data(this, res, ibeg, iend) Returns a pointer to the underlying data of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in), target :: this real(kind=rp), intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend Contents None","tags":"","loc":"proc/dvector_get_data.html"},{"title":"ivector_resize – BROWNPAK","text":"public subroutine ivector_resize(this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/ivector_resize.html"},{"title":"dvector_resize – BROWNPAK","text":"public subroutine dvector_resize(this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/dvector_resize.html"},{"title":"ivector_shrink_to_fit – BROWNPAK","text":"public subroutine ivector_shrink_to_fit(this, ierr) Releases additional memory to fit underlying data of an ivector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/ivector_shrink_to_fit.html"},{"title":"dvector_shrink_to_fit – BROWNPAK","text":"public subroutine dvector_shrink_to_fit(this, ierr) Releases additional memory to fit underlying data of a dvector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/dvector_shrink_to_fit.html"},{"title":"ivector_sort – BROWNPAK","text":"public subroutine ivector_sort(this, order) Sorts an ivector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order Calls proc~~ivector_sort~~CallsGraph proc~ivector_sort ivector_sort proc~iqsort iqsort proc~ivector_sort->proc~iqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ivector_sort.html"},{"title":"dvector_sort – BROWNPAK","text":"public subroutine dvector_sort(this, order) Sorts a dvector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order Calls proc~~dvector_sort~~CallsGraph proc~dvector_sort dvector_sort proc~dqsort dqsort proc~dvector_sort->proc~dqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dvector_sort.html"},{"title":"ivector_unique – BROWNPAK","text":"public subroutine ivector_unique(this) Sorts and removes all duplicate entries of an ivector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call ivector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Calls proc~~ivector_unique~~CallsGraph proc~ivector_unique ivector_unique proc~iqsort iqsort proc~ivector_unique->proc~iqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ivector_unique.html"},{"title":"dvector_unique – BROWNPAK","text":"public subroutine dvector_unique(this) Sorts and removes all duplicate entries of a dvector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call dvector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Calls proc~~dvector_unique~~CallsGraph proc~dvector_unique dvector_unique proc~dqsort dqsort proc~dvector_unique->proc~dqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dvector_unique.html"},{"title":"ivector_print – BROWNPAK","text":"public subroutine ivector_print(this) Prints an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Contents None","tags":"","loc":"proc/ivector_print.html"},{"title":"dvector_print – BROWNPAK","text":"public subroutine dvector_print(this) Prints a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Contents None","tags":"","loc":"proc/dvector_print.html"},{"title":"ivector_init – BROWNPAK","text":"public interface ivector_init Calls interface~~ivector_init~~CallsGraph interface~ivector_init ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~ivector_init~~CalledByGraph interface~ivector_init ivector_init interface~ivector_init->interface~ivector_init proc~cl_init cl_init proc~cl_init->interface~ivector_init proc~atat_build atat_build proc~atat_build->interface~ivector_init proc~itbl_init itbl_init proc~atat_build->proc~itbl_init proc~exat_build exat_build proc~exat_build->interface~ivector_init proc~exat_build->proc~itbl_init proc~rebuild rebuild proc~rebuild->interface~ivector_init proc~itbl_init->interface~ivector_init proc~init init proc~init->interface~ivector_init proc~build_pt_aabbtree build_pt_aabbtree proc~build_pt_aabbtree->interface~ivector_init interface~rebuild rebuild interface~rebuild->proc~rebuild interface~init init interface~init->proc~init proc~pt_build pt_build proc~pt_build->proc~build_pt_aabbtree proc~atan_build atan_build proc~atan_build->proc~itbl_init proc~atbo_build atbo_build proc~atbo_build->proc~itbl_init proc~pt_init pt_init proc~pt_init->proc~cl_init proc~pt_init->proc~atat_build proc~pt_init->proc~exat_build proc~pt_init->proc~itbl_init proc~atdh_build atdh_build proc~atdh_build->proc~itbl_init proc~ia_setup ia_setup proc~ia_setup->proc~pt_init proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~pt_build proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~run run proc~run->proc~ia_setup proc~bds_run bds_run proc~run->proc~bds_run program~main main program~main->proc~run proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run->proc~integrate_em Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures ivector_init ivector_from_array Module Procedures public interface ivector_init () Arguments None public subroutine ivector_from_array (this, x) Creates an ivector with all elements from an array Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), dimension(:) :: x","tags":"","loc":"interface/ivector_init.html"},{"title":"dvector_init – BROWNPAK","text":"public interface dvector_init Calls interface~~dvector_init~~CallsGraph interface~dvector_init dvector_init interface~dvector_init->interface~dvector_init proc~dvector_from_array dvector_from_array interface~dvector_init->proc~dvector_from_array proc~dvector_from_array->interface~dvector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~dvector_init~~CalledByGraph interface~dvector_init dvector_init interface~dvector_init->interface~dvector_init proc~dvector_from_array dvector_from_array interface~dvector_init->proc~dvector_from_array proc~dvector_from_array->interface~dvector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures dvector_init dvector_from_array Module Procedures public interface dvector_init () Arguments None public subroutine dvector_from_array (this, x) Creates a dvector with all elements from an array Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(:) :: x","tags":"","loc":"interface/dvector_init.html"},{"title":"assignment(=) – BROWNPAK","text":"public interface assignment(=) Calls interface~~assignment(=)~~CallsGraph interface~assignment(=) assignment(=) proc~i_dvector_assign i_dvector_assign interface~assignment(=)->proc~i_dvector_assign proc~ivector_assign ivector_assign interface~assignment(=)->proc~ivector_assign proc~dvector_assign dvector_assign interface~assignment(=)->proc~dvector_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures ivector_assign dvector_assign i_dvector_assign Module Procedures public subroutine ivector_assign (this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine dvector_assign (this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other public subroutine i_dvector_assign (this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other","tags":"","loc":"interface/assignment(=).html"},{"title":"hms_current_hms – BROWNPAK","text":"public subroutine hms_current_hms(h, m, s, mm) HMS_CURRENT_HMS returns the current HMS time as integers. Example: If the current time is 9:45:54.872 AM, then H = 9 \n   M = 45\n   S = 54\n   MM = 872 Licensing: This code is distributed under the GNU LGPL license. Modified: 26 February 2005 Author: John Burkardt Parameters: Output, integer ( kind = 4 ) H, M, S, MM, the current hour, minute, \n   second, and thousandths of a second. Arguments Type Intent Optional Attributes Name integer(kind=4) :: h integer(kind=4) :: m integer(kind=4) :: s integer(kind=4) :: mm Called by proc~~hms_current_hms~~CalledByGraph proc~hms_current_hms hms_current_hms proc~hms_delta_print hms_delta_print proc~hms_delta_print->proc~hms_current_hms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/hms_current_hms.html"},{"title":"hms_current_print – BROWNPAK","text":"public subroutine hms_current_print(string) HMS_CURRENT_PRINT prints the current HMS time, and a user specified string. Example: Wallclock : 9 : 45 : 54.872 AM Started determinant calculation . Wallclock : 9 : 47 : 32.738 AM Finished determinant calculation . Licensing: This code is distributed under the GNU LGPL license. Modified: 05 May 2003 Author: John Burkardt Parameters: Input, character ( len = * ) STRING, the string to be printed. Arguments Type Intent Optional Attributes Name character(len=*) :: string Calls proc~~hms_current_print~~CallsGraph proc~hms_current_print hms_current_print proc~hms_current_string hms_current_string proc~hms_current_print->proc~hms_current_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/hms_current_print.html"},{"title":"hms_current_string – BROWNPAK","text":"public subroutine hms_current_string(string) HMS_CURRENT_STRING writes the current HMS data into a string. Example: STRING = ' 9:45:54.872 AM' Licensing: This code is distributed under the GNU LGPL license. Modified: 26 February 2005 Author: John Burkardt Parameters: Output, character ( len = * ) STRING, contains the HMS information. A character length of 15 should always be sufficient. Arguments Type Intent Optional Attributes Name character(len=*) :: string Called by proc~~hms_current_string~~CalledByGraph proc~hms_current_string hms_current_string proc~hms_current_print hms_current_print proc~hms_current_print->proc~hms_current_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/hms_current_string.html"},{"title":"hms_delta_print – BROWNPAK","text":"public subroutine hms_delta_print(string) HMS_DELTA_PRINT prints the change in HMS time, and a user specified string. Example: Delta Wallclock:  0:01:37.966 AM  Determinant calculation. Licensing: This code is distributed under the GNU LGPL license. Modified: 06 May 2003 Author: John Burkardt Parameters: Input, character ( len = * ) STRING, the string to be printed. Arguments Type Intent Optional Attributes Name character(len=*) :: string Calls proc~~hms_delta_print~~CallsGraph proc~hms_delta_print hms_delta_print proc~hms_current_hms hms_current_hms proc~hms_delta_print->proc~hms_current_hms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/hms_delta_print.html"},{"title":"timestamp – BROWNPAK","text":"public subroutine timestamp() TIMESTAMP prints the current YMDHMS date as a time stamp. Example: 31 May 2001   9:45:54.872 AM Licensing: This code is distributed under the GNU LGPL license. Modified: 18 May 2013 Author: John Burkardt Parameters: None Arguments None Contents None","tags":"","loc":"proc/timestamp.html"},{"title":"timestring – BROWNPAK","text":"public subroutine timestring(string) TIMESTRING writes the current YMDHMS date into a string. Example: STRING = '31 May 2001   9:45:54.872 AM' Licensing: This code is distributed under the GNU LGPL license. Modified: 06 August 2005 Author: John Burkardt Parameters: Output, character ( len = * ) STRING, contains the date information. A character length of 40 should always be sufficient. Arguments Type Intent Optional Attributes Name character(len=*) :: string Called by proc~~timestring~~CalledByGraph proc~timestring timestring proc~logger_log_msg logger_log_msg proc~logger_log_msg->proc~timestring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/timestring.html"},{"title":"ia_setup – BROWNPAK","text":"public subroutine ia_setup(cpar, simbox, atc) Builds necessary neighbor tables and sets up parameters for potentials. Arguments Type Intent Optional Attributes Name type( ctrlpar_t ), intent(in) :: cpar type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc Calls proc~~ia_setup~~CallsGraph proc~ia_setup ia_setup proc~ia_vdw_setup ia_vdw_setup proc~ia_setup->proc~ia_vdw_setup proc~ia_external_setup ia_external_setup proc~ia_setup->proc~ia_external_setup proc~ia_tether_setup ia_tether_setup proc~ia_setup->proc~ia_tether_setup proc~ia_angle_setup ia_angle_setup proc~ia_setup->proc~ia_angle_setup proc~ia_dihedral_setup ia_dihedral_setup proc~ia_setup->proc~ia_dihedral_setup proc~pt_init pt_init proc~ia_setup->proc~pt_init proc~ia_bond_setup ia_bond_setup proc~ia_setup->proc~ia_bond_setup proc~cl_init cl_init proc~pt_init->proc~cl_init proc~atat_build atat_build proc~pt_init->proc~atat_build proc~exat_build exat_build proc~pt_init->proc~exat_build proc~cl_set_cell_size cl_set_cell_size proc~pt_init->proc~cl_set_cell_size proc~itbl_init itbl_init proc~pt_init->proc~itbl_init proc~cl_build_cell_nbrs cl_build_cell_nbrs proc~pt_init->proc~cl_build_cell_nbrs interface~ivector_init ivector_init proc~cl_init->interface~ivector_init proc~atat_build->proc~itbl_init proc~atat_build->interface~ivector_init proc~exat_build->proc~itbl_init proc~exat_build->interface~ivector_init proc~itbl_init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_setup~~CalledByGraph proc~ia_setup ia_setup proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_setup.html"},{"title":"ia_finish – BROWNPAK","text":"public subroutine ia_finish() Cleanup routine for interaction calculation. Arguments None Calls proc~~ia_finish~~CallsGraph proc~ia_finish ia_finish proc~pt_delete pt_delete proc~ia_finish->proc~pt_delete proc~cl_delete cl_delete proc~pt_delete->proc~cl_delete Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_finish~~CalledByGraph proc~ia_finish ia_finish proc~finish finish proc~finish->proc~ia_finish proc~run run proc~run->proc~finish program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_finish.html"},{"title":"ia_calc_forces – BROWNPAK","text":"public subroutine ia_calc_forces(simbox, atc, ierr) Calculates total forces and energies Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc integer, intent(out) :: ierr Calls proc~~ia_calc_forces~~CallsGraph proc~ia_calc_forces ia_calc_forces proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~pt_build pt_build proc~ia_add_vdw_forces->proc~pt_build proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force proc~vdw_lj_coul_debye vdw_lj_coul_debye proc~ia_get_vdw_force->proc~vdw_lj_coul_debye proc~vdw_cosine vdw_cosine proc~ia_get_vdw_force->proc~vdw_cosine proc~vdw_gaussian vdw_gaussian proc~ia_get_vdw_force->proc~vdw_gaussian proc~vdw_lj vdw_lj proc~ia_get_vdw_force->proc~vdw_lj proc~vdw_dpd vdw_dpd proc~ia_get_vdw_force->proc~vdw_dpd proc~vdw_lj_coul vdw_lj_coul proc~ia_get_vdw_force->proc~vdw_lj_coul proc~bond_fene bond_fene proc~ia_get_bond_force->proc~bond_fene proc~bond_harm bond_harm proc~ia_get_bond_force->proc~bond_harm proc~bond_kg bond_kg proc~ia_get_bond_force->proc~bond_kg proc~bond_ms bond_ms proc~ia_get_bond_force->proc~bond_ms proc~build_pt_cell_list build_pt_cell_list proc~pt_build->proc~build_pt_cell_list proc~build_pt_n2 build_pt_n2 proc~pt_build->proc~build_pt_n2 proc~build_pt_aabbtree build_pt_aabbtree proc~pt_build->proc~build_pt_aabbtree proc~build_pt_verlet build_pt_verlet proc~pt_build->proc~build_pt_verlet proc~teth_rigid teth_rigid proc~ia_get_tether_force->proc~teth_rigid proc~teth_harm teth_harm proc~ia_get_tether_force->proc~teth_harm proc~cl_build cl_build proc~build_pt_cell_list->proc~cl_build proc~cl_get_num_cells cl_get_num_cells proc~build_pt_cell_list->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~build_pt_cell_list->proc~cl_get_nbr_cells proc~cl_get_contents cl_get_contents proc~build_pt_cell_list->proc~cl_get_contents interface~str_from_num str_from_num proc~bond_fene->interface~str_from_num proc~bond_kg->interface~str_from_num interface~ivector_init ivector_init proc~build_pt_aabbtree->interface~ivector_init proc~bond_ms->interface~str_from_num interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~ivector_from_array->interface~ivector_init proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_calc_forces~~CalledByGraph proc~ia_calc_forces ia_calc_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_calc_forces.html"},{"title":"ia_add_vdw_forces – BROWNPAK","text":"private subroutine ia_add_vdw_forces(simbox, atc, ierr) Calculates force and energy due to all short-ranged non-bonded pairwise\n interactions based on pair_tab . Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc integer, intent(out) :: ierr Calls proc~~ia_add_vdw_forces~~CallsGraph proc~ia_add_vdw_forces ia_add_vdw_forces proc~pt_build pt_build proc~ia_add_vdw_forces->proc~pt_build proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~build_pt_cell_list build_pt_cell_list proc~pt_build->proc~build_pt_cell_list proc~build_pt_n2 build_pt_n2 proc~pt_build->proc~build_pt_n2 proc~build_pt_aabbtree build_pt_aabbtree proc~pt_build->proc~build_pt_aabbtree proc~build_pt_verlet build_pt_verlet proc~pt_build->proc~build_pt_verlet proc~vdw_lj_coul_debye vdw_lj_coul_debye proc~ia_get_vdw_force->proc~vdw_lj_coul_debye proc~vdw_cosine vdw_cosine proc~ia_get_vdw_force->proc~vdw_cosine proc~vdw_gaussian vdw_gaussian proc~ia_get_vdw_force->proc~vdw_gaussian proc~vdw_lj_coul vdw_lj_coul proc~ia_get_vdw_force->proc~vdw_lj_coul proc~vdw_lj vdw_lj proc~ia_get_vdw_force->proc~vdw_lj proc~vdw_dpd vdw_dpd proc~ia_get_vdw_force->proc~vdw_dpd proc~cl_build cl_build proc~build_pt_cell_list->proc~cl_build proc~cl_get_num_cells cl_get_num_cells proc~build_pt_cell_list->proc~cl_get_num_cells proc~cl_get_contents cl_get_contents proc~build_pt_cell_list->proc~cl_get_contents proc~cl_get_nbr_cells cl_get_nbr_cells proc~build_pt_cell_list->proc~cl_get_nbr_cells interface~ivector_init ivector_init proc~build_pt_aabbtree->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_add_vdw_forces~~CalledByGraph proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_vdw_forces.html"},{"title":"ia_add_bond_forces – BROWNPAK","text":"private subroutine ia_add_bond_forces(simbox, atc, ierr) Calculates forces & energy due to all bonds. Will add to energy_bond & and 'forces in module m_globals`. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc integer, intent(out) :: ierr Calls proc~~ia_add_bond_forces~~CallsGraph proc~ia_add_bond_forces ia_add_bond_forces proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~bond_harm bond_harm proc~ia_get_bond_force->proc~bond_harm proc~bond_fene bond_fene proc~ia_get_bond_force->proc~bond_fene proc~bond_kg bond_kg proc~ia_get_bond_force->proc~bond_kg proc~bond_ms bond_ms proc~ia_get_bond_force->proc~bond_ms interface~str_from_num str_from_num proc~bond_fene->interface~str_from_num proc~bond_kg->interface~str_from_num proc~bond_ms->interface~str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_add_bond_forces~~CalledByGraph proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_bond_forces.html"},{"title":"ia_add_angle_forces – BROWNPAK","text":"private subroutine ia_add_angle_forces(simbox, atc) Calculates forces & energy due to all angles. Will add to energy_angle & 'forces`. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc Calls proc~~ia_add_angle_forces~~CallsGraph proc~ia_add_angle_forces ia_add_angle_forces proc~ia_get_angle_force ia_get_angle_force proc~ia_add_angle_forces->proc~ia_get_angle_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_angle_forces.html"},{"title":"ia_add_dihedral_forces – BROWNPAK","text":"private subroutine ia_add_dihedral_forces(simbox, atc) Calculates forces & energy due to all dihedrals. Will add to energy_dihedral & 'forces`. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc Calls proc~~ia_add_dihedral_forces~~CallsGraph proc~ia_add_dihedral_forces ia_add_dihedral_forces proc~ia_get_dihedral_force ia_get_dihedral_force proc~ia_add_dihedral_forces->proc~ia_get_dihedral_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_dihedral_forces.html"},{"title":"ia_add_tether_forces – BROWNPAK","text":"private subroutine ia_add_tether_forces(atc, ierr) Calculates forces & energy due to all tethers. Will add to energy_tether &\n 'forces`. Tether forces are not subject to periodic boundary conditions. Arguments Type Intent Optional Attributes Name type( atmcfg_t ), intent(inout) :: atc integer, intent(out) :: ierr Calls proc~~ia_add_tether_forces~~CallsGraph proc~ia_add_tether_forces ia_add_tether_forces proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force proc~teth_rigid teth_rigid proc~ia_get_tether_force->proc~teth_rigid proc~teth_harm teth_harm proc~ia_get_tether_force->proc~teth_harm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_add_tether_forces~~CalledByGraph proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_tether_forces.html"},{"title":"scalar_triple_product – BROWNPAK","text":"public function scalar_triple_product(a, b, c) result(res) Returns the scalar triple product a .( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c Return Value real(kind=rp) Contents None","tags":"","loc":"proc/scalar_triple_product.html"},{"title":"det – BROWNPAK","text":"public function det(A) result(res) Returns the determinant of an (N x N) matrix, where N = 2, 3, or 4. Original routine by David Simpson Note For a general NxN matrix do an LU decomp Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (N,N) array, where N = 2, 3, or 4. Return Value real(kind=rp) Called by proc~~det~~CalledByGraph proc~det det proc~eigval_33rsym eigval_33rsym proc~eigval_33rsym->proc~det Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/det.html"},{"title":"trace – BROWNPAK","text":"public function trace(mat) result(res) Returns the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mat (:,:) (N,N) array Return Value real(kind=rp) Contents None","tags":"","loc":"proc/trace.html"},{"title":"isclose – BROWNPAK","text":"public elemental function isclose(a, b, rel_tol, abs_tol) Checks if two floating point numbers of type double are close within\n  tolerance. Based on python implementation at https://github.com/PythonCHB/close_pep/blob/master/is_close.py .\n  The method='weak' option is used here. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b real(kind=rp), intent(in), optional :: rel_tol Relative tolerance, rel_tol >= 0, default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance, abs_tol >= 0, default 0.0 Return Value logical Called by proc~~isclose~~CalledByGraph proc~isclose isclose proc~allclose_rank1 allclose_rank1 proc~allclose_rank1->proc~isclose proc~unitize unitize proc~unitize->proc~isclose proc~allclose_rank3 allclose_rank3 proc~allclose_rank3->proc~isclose proc~allclose_rank2 allclose_rank2 proc~allclose_rank2->proc~isclose proc~eigval_33rsym eigval_33rsym proc~eigval_33rsym->proc~isclose interface~allclose allclose interface~allclose->proc~allclose_rank1 interface~allclose->proc~allclose_rank3 interface~allclose->proc~allclose_rank2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/isclose.html"},{"title":"allclose_rank1 – BROWNPAK","text":"public function allclose_rank1(a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical Calls proc~~allclose_rank1~~CallsGraph proc~allclose_rank1 allclose_rank1 proc~isclose isclose proc~allclose_rank1->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allclose_rank1~~CalledByGraph proc~allclose_rank1 allclose_rank1 interface~allclose allclose interface~allclose->proc~allclose_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/allclose_rank1.html"},{"title":"allclose_rank2 – BROWNPAK","text":"public function allclose_rank2(a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical Calls proc~~allclose_rank2~~CallsGraph proc~allclose_rank2 allclose_rank2 proc~isclose isclose proc~allclose_rank2->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allclose_rank2~~CalledByGraph proc~allclose_rank2 allclose_rank2 interface~allclose allclose interface~allclose->proc~allclose_rank2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/allclose_rank2.html"},{"title":"allclose_rank3 – BROWNPAK","text":"public function allclose_rank3(a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical Calls proc~~allclose_rank3~~CallsGraph proc~allclose_rank3 allclose_rank3 proc~isclose isclose proc~allclose_rank3->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allclose_rank3~~CalledByGraph proc~allclose_rank3 allclose_rank3 interface~allclose allclose interface~allclose->proc~allclose_rank3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/allclose_rank3.html"},{"title":"get_quad_form – BROWNPAK","text":"public function get_quad_form(A, x) result(res) Calculates the quadratic form x&#94;T A x , where A is an n x n matrix and x is a\n  vector of length n Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (n,n) array real(kind=rp), intent(in), dimension(:) :: x (n,) array Return Value real(kind=rp) Contents None","tags":"","loc":"proc/get_quad_form.html"},{"title":"rad2deg – BROWNPAK","text":"public elemental subroutine rad2deg(rad, deg) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rad real(kind=rp), intent(out) :: deg Contents None","tags":"","loc":"proc/rad2deg.html"},{"title":"deg2rad – BROWNPAK","text":"public elemental subroutine deg2rad(deg, rad) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: deg real(kind=rp), intent(out) :: rad Contents None","tags":"","loc":"proc/deg2rad.html"},{"title":"cross – BROWNPAK","text":"public subroutine cross(a, b, c) Calculates the cross product between two 3-element vectors Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(out), dimension(3) :: c Cross product of a and b ; c = a x b Contents None","tags":"","loc":"proc/cross.html"},{"title":"cross_mat – BROWNPAK","text":"public subroutine cross_mat(a, mat) Calculates the cross product matrix of a 3-element vector. The cross\n product matrix A of a is defined as a x b = A . b ,\n where b is another 3-element vector. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(out), dimension(3,3) :: mat Cross product matrix of a Contents None","tags":"","loc":"proc/cross_mat.html"},{"title":"outer – BROWNPAK","text":"public subroutine outer(a, b, c) Calculates the outer product of two vectors, . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (n,) array real(kind=rp), intent(out), dimension(:,:) :: c (m,n) array; Outer product Contents None","tags":"","loc":"proc/outer.html"},{"title":"vector_triple_product – BROWNPAK","text":"public subroutine vector_triple_product(a, b, c, d) Returns the vector triple product d = a x ( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c real(kind=rp), intent(out), dimension(3) :: d Vector triple product Contents None","tags":"","loc":"proc/vector_triple_product.html"},{"title":"swap_integer – BROWNPAK","text":"public elemental subroutine swap_integer(a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b Called by proc~~swap_integer~~CalledByGraph proc~swap_integer swap_integer interface~swap swap interface~swap->proc~swap_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_integer.html"},{"title":"swap_real – BROWNPAK","text":"public elemental subroutine swap_real(a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b Called by proc~~swap_real~~CalledByGraph proc~swap_real swap_real interface~swap swap interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_real.html"},{"title":"swap_complex – BROWNPAK","text":"public elemental subroutine swap_complex(a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b Called by proc~~swap_complex~~CalledByGraph proc~swap_complex swap_complex interface~swap swap interface~swap->proc~swap_complex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_complex.html"},{"title":"unitize – BROWNPAK","text":"public subroutine unitize(a) Normalizes a vector in-place. If the magnitude of the vector is nearly\n zero, no normalization takes place and the vector is returned as is with\n a warning message. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: a (m,) array Calls proc~~unitize~~CallsGraph proc~unitize unitize proc~isclose isclose proc~unitize->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/unitize.html"},{"title":"linspace – BROWNPAK","text":"public subroutine linspace(start, finish, num, val, step) Generates evenly spaced numbers over a specified interval. Both end\n points are included. If start < finish , the returned step size (if step is present) will be negative. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point real(kind=rp), intent(in) :: finish Ending point, finish /= start integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(out), optional :: step Step size Called by proc~~linspace~~CalledByGraph proc~linspace linspace proc~logspace logspace proc~logspace->proc~linspace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/linspace.html"},{"title":"logspace – BROWNPAK","text":"public subroutine logspace(start, finish, num, val, base) Generates numbers spaced evenly on a log scale.\n  In linear space, the sequence starts at base ** start ( base to the power of start ) and ends with base ** stop Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point, base ** start is the starting value real(kind=rp), intent(in) :: finish Ending point, finish /= start , base ** start is the ending value integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(in), optional :: base Base of the logspace, default 10 Calls proc~~logspace~~CallsGraph proc~logspace logspace proc~linspace linspace proc~logspace->proc~linspace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/logspace.html"},{"title":"identity – BROWNPAK","text":"public subroutine identity(mat_eye) Creates an identity matrix of size n x n. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:) :: mat_eye (n,n) array Called by proc~~identity~~CalledByGraph proc~identity identity proc~eigval_33rsym eigval_33rsym proc~eigval_33rsym->proc~identity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/identity.html"},{"title":"get_diagonal – BROWNPAK","text":"public subroutine get_diagonal(mat, d) Returns the diagonal elements of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mat (n,n) array real(kind=rp), intent(out), dimension(:) :: d (n,) array; contains the entries of the main diagonal Contents None","tags":"","loc":"proc/get_diagonal.html"},{"title":"add_transpose – BROWNPAK","text":"public subroutine add_transpose(mat) Adds a square matrix and its transpose in place: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat (n,n) array Contents None","tags":"","loc":"proc/add_transpose.html"},{"title":"subtract_transpose – BROWNPAK","text":"public subroutine subtract_transpose(mat) Calculates the difference of a square matrix and its transpose in place: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat Contents None","tags":"","loc":"proc/subtract_transpose.html"},{"title":"multiply_transpose – BROWNPAK","text":"public subroutine multiply_transpose(A, B) Multiplies a matrix with its transpose: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (m,n) array real(kind=rp), intent(out), dimension(:,:) :: B (m,m) array Contents None","tags":"","loc":"proc/multiply_transpose.html"},{"title":"orth – BROWNPAK","text":"public subroutine orth(a) Orthogonalizes a set of vectors in-place using Gram-Schmidt orthonormalization Reference: Golub and Van Loan, Matrix Computations, 3rd edition, Section 5.2.8,\n Algorithm 5.2.5, p. 231. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: a (m,n) array, where m <= n. The first m columns of the matrix are\n  overwritten with the orthogonal basis vectors. Contents None","tags":"","loc":"proc/orth.html"},{"title":"invert_mat33 – BROWNPAK","text":"public subroutine invert_mat33(a, inv_a) Inverts a 3x3 matrix. Reference: https://www.geometrictools.com/Documentation/LaplaceExpansionTheorem.pdf Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3,3) :: inv_a Contents None","tags":"","loc":"proc/invert_mat33.html"},{"title":"eigval_33rsym – BROWNPAK","text":"public subroutine eigval_33rsym(a, ev) Calculates the eigenvalues of a 3 x 3 real symmetric matrix. The\n eigenvalues calculated are in decreasing order. Only the diagonal and\n lower triangular part of the matrix is accessed. Reference: https://en.wikipedia.org/wiki/Eigenvalue_algorithm#cite_note-Smith-12 See also David Eberly's notes and implementation at \n https://www.geometrictools.com/Documentation/RobustEigenSymmetric3x3.pdf Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3) :: ev Calls proc~~eigval_33rsym~~CallsGraph proc~eigval_33rsym eigval_33rsym proc~isclose isclose proc~eigval_33rsym->proc~isclose proc~det det proc~eigval_33rsym->proc~det proc~identity identity proc~eigval_33rsym->proc~identity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/eigval_33rsym.html"},{"title":"dsyevc3 – BROWNPAK","text":"public subroutine dsyevc3(A, W) Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's\n analytical algorithm.\n Only the diagonal and upper triangular parts of A are accessed. The access\n is read-only. Copyright (C) 2006  Joachim Kopp Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), DIMENSION(3,3) :: A real(kind=RP), intent(out), DIMENSION(3) :: W (3) Contents None","tags":"","loc":"proc/dsyevc3.html"},{"title":"allclose – BROWNPAK","text":"public interface allclose Checks if two arrays are elementwise close within tolerance Calls interface~~allclose~~CallsGraph interface~allclose allclose proc~allclose_rank1 allclose_rank1 interface~allclose->proc~allclose_rank1 proc~allclose_rank3 allclose_rank3 interface~allclose->proc~allclose_rank3 proc~allclose_rank2 allclose_rank2 interface~allclose->proc~allclose_rank2 proc~isclose isclose proc~allclose_rank1->proc~isclose proc~allclose_rank3->proc~isclose proc~allclose_rank2->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures allclose_rank1 allclose_rank2 allclose_rank3 Module Procedures public function allclose_rank1 (a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank2 (a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank3 (a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical","tags":"","loc":"interface/allclose.html"},{"title":"swap – BROWNPAK","text":"public interface swap Swaps two arrays Calls interface~~swap~~CallsGraph interface~swap swap proc~swap_integer swap_integer interface~swap->proc~swap_integer proc~swap_complex swap_complex interface~swap->proc~swap_complex proc~swap_real swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures swap_integer swap_real swap_complex Module Procedures public elemental subroutine swap_integer (a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b public elemental subroutine swap_real (a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b public elemental subroutine swap_complex (a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b","tags":"","loc":"interface/swap.html"},{"title":"run – BROWNPAK","text":"public subroutine run(cpar, job_tag) Arguments Type Intent Optional Attributes Name type( ctrlpar_t ), intent(in) :: cpar character(len=*), intent(in) :: job_tag This string will be used as is, i.e. if there are leading or trailing\n white spaces, they will appear in any I/O file names. Calls proc~~run~~CallsGraph proc~run run proc~finish finish proc~run->proc~finish proc~read_config read_config proc~run->proc~read_config proc~bds_init bds_init proc~run->proc~bds_init proc~stats_init stats_init proc~run->proc~stats_init proc~init_stream init_stream proc~run->proc~init_stream proc~bds_run bds_run proc~run->proc~bds_run proc~read_dump read_dump proc~run->proc~read_dump proc~ia_setup ia_setup proc~run->proc~ia_setup proc~ia_finish ia_finish proc~finish->proc~ia_finish proc~atmcfg_delete atmcfg_delete proc~finish->proc~atmcfg_delete proc~bds_finish bds_finish proc~finish->proc~bds_finish proc~stats_finish stats_finish proc~finish->proc~stats_finish proc~str_to_i str_to_i proc~read_config->proc~str_to_i proc~readline readline proc~read_config->proc~readline proc~str_startswith str_startswith proc~read_config->proc~str_startswith proc~str_split str_split proc~read_config->proc~str_split proc~brn_init brn_init proc~bds_init->proc~brn_init proc~write_hdr write_hdr proc~stats_init->proc~write_hdr proc~zero_out zero_out proc~stats_init->proc~zero_out vslnewstream vslnewstream proc~init_stream->vslnewstream str_from_num str_from_num proc~bds_run->str_from_num proc~integrate_em integrate_em proc~bds_run->proc~integrate_em proc~integrate_se integrate_se proc~bds_run->proc~integrate_se proc~write_dump write_dump proc~bds_run->proc~write_dump proc~stats_accumulate stats_accumulate proc~bds_run->proc~stats_accumulate proc~stats_write stats_write proc~bds_run->proc~stats_write proc~ia_vdw_setup ia_vdw_setup proc~ia_setup->proc~ia_vdw_setup proc~ia_dihedral_setup ia_dihedral_setup proc~ia_setup->proc~ia_dihedral_setup proc~pt_init pt_init proc~ia_setup->proc~pt_init proc~ia_tether_setup ia_tether_setup proc~ia_setup->proc~ia_tether_setup proc~ia_external_setup ia_external_setup proc~ia_setup->proc~ia_external_setup proc~ia_angle_setup ia_angle_setup proc~ia_setup->proc~ia_angle_setup proc~ia_bond_setup ia_bond_setup proc~ia_setup->proc~ia_bond_setup proc~pt_delete pt_delete proc~ia_finish->proc~pt_delete proc~str_is_comment str_is_comment proc~readline->proc~str_is_comment proc~str_strip_comment str_strip_comment proc~readline->proc~str_strip_comment proc~cl_init cl_init proc~pt_init->proc~cl_init proc~atat_build atat_build proc~pt_init->proc~atat_build proc~exat_build exat_build proc~pt_init->proc~exat_build proc~cl_set_cell_size cl_set_cell_size proc~pt_init->proc~cl_set_cell_size proc~itbl_init itbl_init proc~pt_init->proc~itbl_init proc~cl_build_cell_nbrs cl_build_cell_nbrs proc~pt_init->proc~cl_build_cell_nbrs proc~calc_drift calc_drift proc~integrate_em->proc~calc_drift proc~calc_diffusion calc_diffusion proc~integrate_em->proc~calc_diffusion proc~integrate_se->proc~calc_diffusion proc~nitsol nitsol proc~integrate_se->proc~nitsol proc~compute_ic0 compute_ic0 proc~stats_accumulate->proc~compute_ic0 proc~compute_ic1 compute_ic1 proc~stats_accumulate->proc~compute_ic1 proc~str_compact str_compact proc~str_split->proc~str_compact proc~brn_finish brn_finish proc~bds_finish->proc~brn_finish proc~stats_finish->proc~zero_out proc~cl_delete cl_delete proc~pt_delete->proc~cl_delete dsymv dsymv proc~calc_drift->dsymv proc~ia_calc_forces ia_calc_forces proc~calc_drift->proc~ia_calc_forces interface~ivector_init ivector_init proc~cl_init->interface~ivector_init proc~atat_build->proc~itbl_init proc~atat_build->interface~ivector_init proc~calc_rpy_tensor calc_rpy_tensor proc~calc_diffusion->proc~calc_rpy_tensor proc~brn_calc_dw brn_calc_dw proc~calc_diffusion->proc~brn_calc_dw proc~brn_calc_bdw brn_calc_bdw proc~calc_diffusion->proc~brn_calc_bdw proc~exat_build->proc~itbl_init proc~exat_build->interface~ivector_init proc~itbl_init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~get_rv_gaussian get_rv_gaussian proc~brn_calc_dw->proc~get_rv_gaussian proc~calc_bdw_blanc calc_bdw_blanc proc~brn_calc_bdw->proc~calc_bdw_blanc proc~calc_bdw_cholesky calc_bdw_cholesky proc~brn_calc_bdw->proc~calc_bdw_cholesky proc~calc_bdw_lanc calc_bdw_lanc proc~brn_calc_bdw->proc~calc_bdw_lanc proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force dsbevd dsbevd proc~calc_bdw_blanc->dsbevd dorgqr dorgqr proc~calc_bdw_blanc->dorgqr dgeqp3 dgeqp3 proc~calc_bdw_blanc->dgeqp3 dtrmm dtrmm proc~calc_bdw_cholesky->dtrmm dpotrf dpotrf proc~calc_bdw_cholesky->dpotrf proc~pt_build pt_build proc~ia_add_vdw_forces->proc~pt_build proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force proc~ivector_from_array->interface~ivector_init proc~bond_harm bond_harm proc~ia_get_bond_force->proc~bond_harm proc~bond_fene bond_fene proc~ia_get_bond_force->proc~bond_fene proc~bond_kg bond_kg proc~ia_get_bond_force->proc~bond_kg proc~bond_ms bond_ms proc~ia_get_bond_force->proc~bond_ms proc~build_pt_cell_list build_pt_cell_list proc~pt_build->proc~build_pt_cell_list proc~build_pt_n2 build_pt_n2 proc~pt_build->proc~build_pt_n2 proc~build_pt_aabbtree build_pt_aabbtree proc~pt_build->proc~build_pt_aabbtree proc~build_pt_verlet build_pt_verlet proc~pt_build->proc~build_pt_verlet proc~teth_rigid teth_rigid proc~ia_get_tether_force->proc~teth_rigid proc~teth_harm teth_harm proc~ia_get_tether_force->proc~teth_harm proc~vdw_lj_coul_debye vdw_lj_coul_debye proc~ia_get_vdw_force->proc~vdw_lj_coul_debye proc~vdw_cosine vdw_cosine proc~ia_get_vdw_force->proc~vdw_cosine proc~vdw_gaussian vdw_gaussian proc~ia_get_vdw_force->proc~vdw_gaussian proc~vdw_lj_coul vdw_lj_coul proc~ia_get_vdw_force->proc~vdw_lj_coul proc~vdw_lj vdw_lj proc~ia_get_vdw_force->proc~vdw_lj proc~vdw_dpd vdw_dpd proc~ia_get_vdw_force->proc~vdw_dpd proc~cl_build cl_build proc~build_pt_cell_list->proc~cl_build proc~cl_get_num_cells cl_get_num_cells proc~build_pt_cell_list->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~build_pt_cell_list->proc~cl_get_nbr_cells proc~cl_get_contents cl_get_contents proc~build_pt_cell_list->proc~cl_get_contents interface~str_from_num str_from_num proc~bond_fene->interface~str_from_num proc~build_pt_aabbtree->interface~ivector_init proc~bond_kg->interface~str_from_num proc~bond_ms->interface~str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~run~~CalledByGraph proc~run run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/run.html"},{"title":"finish – BROWNPAK","text":"public subroutine finish(atc) Arguments Type Intent Optional Attributes Name type( atmcfg_t ), intent(inout) :: atc Calls proc~~finish~~CallsGraph proc~finish finish proc~ia_finish ia_finish proc~finish->proc~ia_finish proc~stats_finish stats_finish proc~finish->proc~stats_finish proc~bds_finish bds_finish proc~finish->proc~bds_finish proc~atmcfg_delete atmcfg_delete proc~finish->proc~atmcfg_delete proc~pt_delete pt_delete proc~ia_finish->proc~pt_delete proc~zero_out zero_out proc~stats_finish->proc~zero_out proc~brn_finish brn_finish proc~bds_finish->proc~brn_finish proc~cl_delete cl_delete proc~pt_delete->proc~cl_delete Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~finish~~CalledByGraph proc~finish finish proc~run run proc~run->proc~finish program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/finish.html"},{"title":"read_dump – BROWNPAK","text":"public subroutine read_dump(nts, simbox, atc, fn) Reads from DUMP file Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(out) :: nts type( smbx_t ), intent(out) :: simbox type( atmcfg_t ), intent(out) :: atc character(len=*), intent(in) :: fn Called by proc~~read_dump~~CalledByGraph proc~read_dump read_dump proc~run run proc~run->proc~read_dump program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/read_dump.html"},{"title":"write_dump – BROWNPAK","text":"public subroutine write_dump(nts, simbox, atc, fn) Writes to DUMP file. Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: nts type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc character(len=*), intent(in) :: fn Called by proc~~write_dump~~CalledByGraph proc~write_dump write_dump proc~bds_run bds_run proc~bds_run->proc~write_dump proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/write_dump.html"},{"title":"read_config – BROWNPAK","text":"public subroutine read_config(simbox, atc, fn) Read from CONFIG file Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(out) :: simbox type( atmcfg_t ), intent(out) :: atc character(len=*), intent(in) :: fn Calls proc~~read_config~~CallsGraph proc~read_config read_config proc~str_startswith str_startswith proc~read_config->proc~str_startswith proc~readline readline proc~read_config->proc~readline proc~str_to_i str_to_i proc~read_config->proc~str_to_i proc~str_split str_split proc~read_config->proc~str_split proc~str_strip_comment str_strip_comment proc~readline->proc~str_strip_comment proc~str_is_comment str_is_comment proc~readline->proc~str_is_comment proc~str_compact str_compact proc~str_split->proc~str_compact Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_config~~CalledByGraph proc~read_config read_config proc~run run proc~run->proc~read_config program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/read_config.html"},{"title":"write_config – BROWNPAK","text":"public subroutine write_config(simbox, atc, fn, title) Write to cfg file Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc character(len=*), intent(in) :: fn character(len=*), intent(in) :: title Contents None","tags":"","loc":"proc/write_config.html"},{"title":"write_ldf – BROWNPAK","text":"public subroutine write_ldf(simbox, atc, fn_ld, title) Write to a LAMMPS data file. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc character(len=*), intent(in) :: fn_ld Name of the file character(len=*), intent(in) :: title Title of the configuation Contents None","tags":"","loc":"proc/write_ldf.html"},{"title":"write_xyz – BROWNPAK","text":"public subroutine write_xyz(atc, fn_xyz, title) Write to an XYZ file. Arguments Type Intent Optional Attributes Name type( atmcfg_t ), intent(in) :: atc character(len=*), intent(in) :: fn_xyz Name of the XYZ file character(len=*), intent(in) :: title Title (for the configuration) Contents None","tags":"","loc":"proc/write_xyz.html"},{"title":"stats_init – BROWNPAK","text":"public subroutine stats_init(cpar, simbox, atc, job_tag) Set up for stats collection Arguments Type Intent Optional Attributes Name type( ctrlpar_t ), intent(in) :: cpar type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc character(len=*), intent(in) :: job_tag Calls proc~~stats_init~~CallsGraph proc~stats_init stats_init proc~zero_out zero_out proc~stats_init->proc~zero_out proc~write_hdr write_hdr proc~stats_init->proc~write_hdr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~stats_init~~CalledByGraph proc~stats_init stats_init proc~run run proc~run->proc~stats_init program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/stats_init.html"},{"title":"stats_finish – BROWNPAK","text":"public subroutine stats_finish() Clean up for stats collection. Arguments None Calls proc~~stats_finish~~CallsGraph proc~stats_finish stats_finish proc~zero_out zero_out proc~stats_finish->proc~zero_out Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~stats_finish~~CalledByGraph proc~stats_finish stats_finish proc~finish finish proc~finish->proc~stats_finish proc~run run proc~run->proc~finish program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/stats_finish.html"},{"title":"zero_out – BROWNPAK","text":"private subroutine zero_out() Arguments None Called by proc~~zero_out~~CalledByGraph proc~zero_out zero_out proc~stats_finish stats_finish proc~stats_finish->proc~zero_out proc~stats_init stats_init proc~stats_init->proc~zero_out proc~run run proc~run->proc~stats_init proc~finish finish proc~run->proc~finish proc~finish->proc~stats_finish program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/zero_out.html"},{"title":"write_hdr – BROWNPAK","text":"private subroutine write_hdr(simbox, atc) Writes header of the file fn_stats . Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc Called by proc~~write_hdr~~CalledByGraph proc~write_hdr write_hdr proc~stats_init stats_init proc~stats_init->proc~write_hdr proc~run run proc~run->proc~stats_init program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/write_hdr.html"},{"title":"stats_write – BROWNPAK","text":"public subroutine stats_write(nts, simbox, atc) Writes statistics to fn_stats . Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: nts type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc Called by proc~~stats_write~~CalledByGraph proc~stats_write stats_write proc~bds_run bds_run proc~bds_run->proc~stats_write proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/stats_write.html"},{"title":"stats_accumulate – BROWNPAK","text":"public subroutine stats_accumulate(simbox, atc) Accumulates statistics. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc Calls proc~~stats_accumulate~~CallsGraph proc~stats_accumulate stats_accumulate proc~compute_ic0 compute_ic0 proc~stats_accumulate->proc~compute_ic0 proc~compute_ic1 compute_ic1 proc~stats_accumulate->proc~compute_ic1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~stats_accumulate~~CalledByGraph proc~stats_accumulate stats_accumulate proc~bds_run bds_run proc~bds_run->proc~stats_accumulate proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/stats_accumulate.html"},{"title":"compute_ic1 – BROWNPAK","text":"private subroutine compute_ic1(simbox, atc) Computes statistics for possibly multiple chains in a periodic domain. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc Called by proc~~compute_ic1~~CalledByGraph proc~compute_ic1 compute_ic1 proc~stats_accumulate stats_accumulate proc~stats_accumulate->proc~compute_ic1 proc~bds_run bds_run proc~bds_run->proc~stats_accumulate proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/compute_ic1.html"},{"title":"compute_ic0 – BROWNPAK","text":"private subroutine compute_ic0(atc) Computes statistics for a single chain in unbounded domain. Arguments Type Intent Optional Attributes Name type( atmcfg_t ), intent(in) :: atc Called by proc~~compute_ic0~~CalledByGraph proc~compute_ic0 compute_ic0 proc~stats_accumulate stats_accumulate proc~stats_accumulate->proc~compute_ic0 proc~bds_run bds_run proc~bds_run->proc~stats_accumulate proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/compute_ic0.html"},{"title":"atbo_build – BROWNPAK","text":"public subroutine atbo_build(num_atoms, num_bonds, bonds, atbo_tab) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_atoms integer, intent(in) :: num_bonds integer, intent(in), dimension(:,:) :: bonds type( itable_t ), intent(out) :: atbo_tab Atoms -> bonds table Calls proc~~atbo_build~~CallsGraph proc~atbo_build atbo_build proc~itbl_init itbl_init proc~atbo_build->proc~itbl_init interface~ivector_init ivector_init proc~itbl_init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/atbo_build.html"},{"title":"atan_build – BROWNPAK","text":"public subroutine atan_build(num_atoms, num_angles, angles, atan_tab) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_atoms integer, intent(in) :: num_angles integer, intent(in), dimension(:,:) :: angles type( itable_t ), intent(out) :: atan_tab Atoms -> angles table Calls proc~~atan_build~~CallsGraph proc~atan_build atan_build proc~itbl_init itbl_init proc~atan_build->proc~itbl_init interface~ivector_init ivector_init proc~itbl_init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/atan_build.html"},{"title":"atdh_build – BROWNPAK","text":"public subroutine atdh_build(num_atoms, num_dihedrals, dihedrals, atdh_tab) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_atoms integer, intent(in) :: num_dihedrals integer, intent(in), dimension(:,:) :: dihedrals type( itable_t ), intent(out) :: atdh_tab Atoms -> dihedrals table Calls proc~~atdh_build~~CallsGraph proc~atdh_build atdh_build proc~itbl_init itbl_init proc~atdh_build->proc~itbl_init interface~ivector_init ivector_init proc~itbl_init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/atdh_build.html"},{"title":"atat_build – BROWNPAK","text":"public subroutine atat_build(num_atoms, bonds, atbo_tab, atat_tab) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_atoms integer, intent(in), dimension(:,:) :: bonds type( itable_t ), intent(in) :: atbo_tab Atoms -> bonds table type( itable_t ), intent(out) :: atat_tab Atoms -> bonded atoms table (1-ring) Calls proc~~atat_build~~CallsGraph proc~atat_build atat_build proc~itbl_init itbl_init proc~atat_build->proc~itbl_init interface~ivector_init ivector_init proc~atat_build->interface~ivector_init proc~itbl_init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~atat_build~~CalledByGraph proc~atat_build atat_build proc~pt_init pt_init proc~pt_init->proc~atat_build proc~ia_setup ia_setup proc~ia_setup->proc~pt_init proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/atat_build.html"},{"title":"exat_build – BROWNPAK","text":"public subroutine exat_build(num_atoms, excluded_atoms, atat_tab, exat_tab) Before a call to this first build atbo_tab. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_atoms integer, intent(in) :: excluded_atoms type( itable_t ), intent(in) :: atat_tab Atoms -> bonded atoms table type( itable_t ), intent(out) :: exat_tab Atoms -> excluded (from vdw calculation) atoms table Calls proc~~exat_build~~CallsGraph proc~exat_build exat_build proc~itbl_init itbl_init proc~exat_build->proc~itbl_init interface~ivector_init ivector_init proc~exat_build->interface~ivector_init proc~itbl_init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~exat_build~~CalledByGraph proc~exat_build exat_build proc~pt_init pt_init proc~pt_init->proc~exat_build proc~ia_setup ia_setup proc~ia_setup->proc~pt_init proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/exat_build.html"},{"title":"bds_init – BROWNPAK","text":"public subroutine bds_init(cpar, num_atoms, job_tag, ierr) Initializes the BD solver. Arguments Type Intent Optional Attributes Name type( ctrlpar_t ), intent(in) :: cpar integer, intent(in) :: num_atoms character(len=*), intent(in) :: job_tag integer, intent(out) :: ierr Calls proc~~bds_init~~CallsGraph proc~bds_init bds_init proc~brn_init brn_init proc~bds_init->proc~brn_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bds_init~~CalledByGraph proc~bds_init bds_init proc~run run proc~run->proc~bds_init program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bds_init.html"},{"title":"bds_finish – BROWNPAK","text":"public subroutine bds_finish() Clears up memory allocated in bds_init . Arguments None Calls proc~~bds_finish~~CallsGraph proc~bds_finish bds_finish proc~brn_finish brn_finish proc~bds_finish->proc~brn_finish Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bds_finish~~CalledByGraph proc~bds_finish bds_finish proc~finish finish proc~finish->proc~bds_finish proc~run run proc~run->proc~finish program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bds_finish.html"},{"title":"bds_run – BROWNPAK","text":"public subroutine bds_run(nts_beg, simbox, atc, ierr) Driver for BD integrator. Repeatedly calls integrate_em or integrate_se to update atom\n positions. Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: nts_beg type(smbx_t), intent(in), target :: simbox type( atmcfg_t ), intent(inout), target :: atc integer, intent(out) :: ierr Error flag Calls proc~~bds_run~~CallsGraph proc~bds_run bds_run str_from_num str_from_num proc~bds_run->str_from_num proc~integrate_em integrate_em proc~bds_run->proc~integrate_em proc~integrate_se integrate_se proc~bds_run->proc~integrate_se proc~stats_write stats_write proc~bds_run->proc~stats_write proc~write_dump write_dump proc~bds_run->proc~write_dump proc~stats_accumulate stats_accumulate proc~bds_run->proc~stats_accumulate proc~calc_drift calc_drift proc~integrate_em->proc~calc_drift proc~calc_diffusion calc_diffusion proc~integrate_em->proc~calc_diffusion proc~integrate_se->proc~calc_diffusion proc~nitsol nitsol proc~integrate_se->proc~nitsol proc~compute_ic0 compute_ic0 proc~stats_accumulate->proc~compute_ic0 proc~compute_ic1 compute_ic1 proc~stats_accumulate->proc~compute_ic1 dsymv dsymv proc~calc_drift->dsymv proc~ia_calc_forces ia_calc_forces proc~calc_drift->proc~ia_calc_forces proc~calc_rpy_tensor calc_rpy_tensor proc~calc_diffusion->proc~calc_rpy_tensor proc~brn_calc_dw brn_calc_dw proc~calc_diffusion->proc~brn_calc_dw proc~brn_calc_bdw brn_calc_bdw proc~calc_diffusion->proc~brn_calc_bdw proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~get_rv_gaussian get_rv_gaussian proc~brn_calc_dw->proc~get_rv_gaussian proc~calc_bdw_blanc calc_bdw_blanc proc~brn_calc_bdw->proc~calc_bdw_blanc proc~calc_bdw_cholesky calc_bdw_cholesky proc~brn_calc_bdw->proc~calc_bdw_cholesky proc~calc_bdw_lanc calc_bdw_lanc proc~brn_calc_bdw->proc~calc_bdw_lanc proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force dsbevd dsbevd proc~calc_bdw_blanc->dsbevd dorgqr dorgqr proc~calc_bdw_blanc->dorgqr dgeqp3 dgeqp3 proc~calc_bdw_blanc->dgeqp3 dtrmm dtrmm proc~calc_bdw_cholesky->dtrmm dpotrf dpotrf proc~calc_bdw_cholesky->dpotrf vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian proc~pt_build pt_build proc~ia_add_vdw_forces->proc~pt_build proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force proc~bond_harm bond_harm proc~ia_get_bond_force->proc~bond_harm proc~bond_fene bond_fene proc~ia_get_bond_force->proc~bond_fene proc~bond_kg bond_kg proc~ia_get_bond_force->proc~bond_kg proc~bond_ms bond_ms proc~ia_get_bond_force->proc~bond_ms proc~build_pt_cell_list build_pt_cell_list proc~pt_build->proc~build_pt_cell_list proc~build_pt_n2 build_pt_n2 proc~pt_build->proc~build_pt_n2 proc~build_pt_aabbtree build_pt_aabbtree proc~pt_build->proc~build_pt_aabbtree proc~build_pt_verlet build_pt_verlet proc~pt_build->proc~build_pt_verlet proc~teth_rigid teth_rigid proc~ia_get_tether_force->proc~teth_rigid proc~teth_harm teth_harm proc~ia_get_tether_force->proc~teth_harm proc~vdw_lj_coul_debye vdw_lj_coul_debye proc~ia_get_vdw_force->proc~vdw_lj_coul_debye proc~vdw_cosine vdw_cosine proc~ia_get_vdw_force->proc~vdw_cosine proc~vdw_gaussian vdw_gaussian proc~ia_get_vdw_force->proc~vdw_gaussian proc~vdw_lj_coul vdw_lj_coul proc~ia_get_vdw_force->proc~vdw_lj_coul proc~vdw_lj vdw_lj proc~ia_get_vdw_force->proc~vdw_lj proc~vdw_dpd vdw_dpd proc~ia_get_vdw_force->proc~vdw_dpd proc~cl_build cl_build proc~build_pt_cell_list->proc~cl_build proc~cl_get_num_cells cl_get_num_cells proc~build_pt_cell_list->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~build_pt_cell_list->proc~cl_get_nbr_cells proc~cl_get_contents cl_get_contents proc~build_pt_cell_list->proc~cl_get_contents interface~str_from_num str_from_num proc~bond_fene->interface~str_from_num interface~ivector_init ivector_init proc~build_pt_aabbtree->interface~ivector_init proc~bond_kg->interface~str_from_num proc~bond_ms->interface~str_from_num interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~ivector_from_array->interface~ivector_init proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bds_run~~CalledByGraph proc~bds_run bds_run proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bds_run.html"},{"title":"integrate_em – BROWNPAK","text":"private subroutine integrate_em(ierr) Performs one step of BD integration using explicit Euler-Maruyama scheme. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~integrate_em~~CallsGraph proc~integrate_em integrate_em proc~calc_diffusion calc_diffusion proc~integrate_em->proc~calc_diffusion proc~calc_drift calc_drift proc~integrate_em->proc~calc_drift proc~calc_rpy_tensor calc_rpy_tensor proc~calc_diffusion->proc~calc_rpy_tensor proc~brn_calc_dw brn_calc_dw proc~calc_diffusion->proc~brn_calc_dw proc~brn_calc_bdw brn_calc_bdw proc~calc_diffusion->proc~brn_calc_bdw dsymv dsymv proc~calc_drift->dsymv proc~ia_calc_forces ia_calc_forces proc~calc_drift->proc~ia_calc_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~get_rv_gaussian get_rv_gaussian proc~brn_calc_dw->proc~get_rv_gaussian proc~calc_bdw_blanc calc_bdw_blanc proc~brn_calc_bdw->proc~calc_bdw_blanc proc~calc_bdw_cholesky calc_bdw_cholesky proc~brn_calc_bdw->proc~calc_bdw_cholesky proc~calc_bdw_lanc calc_bdw_lanc proc~brn_calc_bdw->proc~calc_bdw_lanc proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force dsbevd dsbevd proc~calc_bdw_blanc->dsbevd dorgqr dorgqr proc~calc_bdw_blanc->dorgqr dgeqp3 dgeqp3 proc~calc_bdw_blanc->dgeqp3 dtrmm dtrmm proc~calc_bdw_cholesky->dtrmm dpotrf dpotrf proc~calc_bdw_cholesky->dpotrf vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian proc~pt_build pt_build proc~ia_add_vdw_forces->proc~pt_build proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force proc~bond_harm bond_harm proc~ia_get_bond_force->proc~bond_harm proc~bond_fene bond_fene proc~ia_get_bond_force->proc~bond_fene proc~bond_kg bond_kg proc~ia_get_bond_force->proc~bond_kg proc~bond_ms bond_ms proc~ia_get_bond_force->proc~bond_ms proc~build_pt_cell_list build_pt_cell_list proc~pt_build->proc~build_pt_cell_list proc~build_pt_n2 build_pt_n2 proc~pt_build->proc~build_pt_n2 proc~build_pt_aabbtree build_pt_aabbtree proc~pt_build->proc~build_pt_aabbtree proc~build_pt_verlet build_pt_verlet proc~pt_build->proc~build_pt_verlet proc~teth_rigid teth_rigid proc~ia_get_tether_force->proc~teth_rigid proc~teth_harm teth_harm proc~ia_get_tether_force->proc~teth_harm proc~vdw_lj_coul_debye vdw_lj_coul_debye proc~ia_get_vdw_force->proc~vdw_lj_coul_debye proc~vdw_cosine vdw_cosine proc~ia_get_vdw_force->proc~vdw_cosine proc~vdw_gaussian vdw_gaussian proc~ia_get_vdw_force->proc~vdw_gaussian proc~vdw_lj_coul vdw_lj_coul proc~ia_get_vdw_force->proc~vdw_lj_coul proc~vdw_lj vdw_lj proc~ia_get_vdw_force->proc~vdw_lj proc~vdw_dpd vdw_dpd proc~ia_get_vdw_force->proc~vdw_dpd proc~cl_build cl_build proc~build_pt_cell_list->proc~cl_build proc~cl_get_num_cells cl_get_num_cells proc~build_pt_cell_list->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~build_pt_cell_list->proc~cl_get_nbr_cells proc~cl_get_contents cl_get_contents proc~build_pt_cell_list->proc~cl_get_contents interface~str_from_num str_from_num proc~bond_fene->interface~str_from_num interface~ivector_init ivector_init proc~build_pt_aabbtree->interface~ivector_init proc~bond_kg->interface~str_from_num proc~bond_ms->interface~str_from_num interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~ivector_from_array->interface~ivector_init proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~integrate_em~~CalledByGraph proc~integrate_em integrate_em proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/integrate_em.html"},{"title":"integrate_se – BROWNPAK","text":"private subroutine integrate_se(ierr) Performs one step of BD integration using semi-implicit Euler scheme. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~integrate_se~~CallsGraph proc~integrate_se integrate_se proc~calc_diffusion calc_diffusion proc~integrate_se->proc~calc_diffusion proc~nitsol nitsol proc~integrate_se->proc~nitsol proc~brn_calc_dw brn_calc_dw proc~calc_diffusion->proc~brn_calc_dw proc~brn_calc_bdw brn_calc_bdw proc~calc_diffusion->proc~brn_calc_bdw proc~calc_rpy_tensor calc_rpy_tensor proc~calc_diffusion->proc~calc_rpy_tensor proc~get_rv_gaussian get_rv_gaussian proc~brn_calc_dw->proc~get_rv_gaussian proc~calc_bdw_lanc calc_bdw_lanc proc~brn_calc_bdw->proc~calc_bdw_lanc proc~calc_bdw_cholesky calc_bdw_cholesky proc~brn_calc_bdw->proc~calc_bdw_cholesky proc~calc_bdw_blanc calc_bdw_blanc proc~brn_calc_bdw->proc~calc_bdw_blanc dtrmm dtrmm proc~calc_bdw_cholesky->dtrmm dpotrf dpotrf proc~calc_bdw_cholesky->dpotrf vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian dsbevd dsbevd proc~calc_bdw_blanc->dsbevd dorgqr dorgqr proc~calc_bdw_blanc->dorgqr dgeqp3 dgeqp3 proc~calc_bdw_blanc->dgeqp3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~integrate_se~~CalledByGraph proc~integrate_se integrate_se proc~bds_run bds_run proc~bds_run->proc~integrate_se proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/integrate_se.html"},{"title":"se_fval – BROWNPAK","text":"public subroutine se_fval(n, xcur, fcur, rpar, ipar, ierr) Calculates the nonlinear function. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rp), intent(in), dimension(*) :: xcur real(kind=rp), intent(out), dimension(*) :: fcur real(kind=rp), intent(in), dimension(*) :: rpar integer, intent(in), dimension(*) :: ipar integer, intent(out) :: ierr Calls proc~~se_fval~~CallsGraph proc~se_fval se_fval proc~calc_drift calc_drift proc~se_fval->proc~calc_drift proc~ia_calc_forces ia_calc_forces proc~calc_drift->proc~ia_calc_forces dsymv dsymv proc~calc_drift->dsymv proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~pt_build pt_build proc~ia_add_vdw_forces->proc~pt_build proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force proc~vdw_lj_coul_debye vdw_lj_coul_debye proc~ia_get_vdw_force->proc~vdw_lj_coul_debye proc~vdw_cosine vdw_cosine proc~ia_get_vdw_force->proc~vdw_cosine proc~vdw_gaussian vdw_gaussian proc~ia_get_vdw_force->proc~vdw_gaussian proc~vdw_lj vdw_lj proc~ia_get_vdw_force->proc~vdw_lj proc~vdw_dpd vdw_dpd proc~ia_get_vdw_force->proc~vdw_dpd proc~vdw_lj_coul vdw_lj_coul proc~ia_get_vdw_force->proc~vdw_lj_coul proc~bond_fene bond_fene proc~ia_get_bond_force->proc~bond_fene proc~bond_harm bond_harm proc~ia_get_bond_force->proc~bond_harm proc~bond_kg bond_kg proc~ia_get_bond_force->proc~bond_kg proc~bond_ms bond_ms proc~ia_get_bond_force->proc~bond_ms proc~build_pt_cell_list build_pt_cell_list proc~pt_build->proc~build_pt_cell_list proc~build_pt_n2 build_pt_n2 proc~pt_build->proc~build_pt_n2 proc~build_pt_aabbtree build_pt_aabbtree proc~pt_build->proc~build_pt_aabbtree proc~build_pt_verlet build_pt_verlet proc~pt_build->proc~build_pt_verlet proc~teth_rigid teth_rigid proc~ia_get_tether_force->proc~teth_rigid proc~teth_harm teth_harm proc~ia_get_tether_force->proc~teth_harm proc~cl_build cl_build proc~build_pt_cell_list->proc~cl_build proc~cl_get_num_cells cl_get_num_cells proc~build_pt_cell_list->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~build_pt_cell_list->proc~cl_get_nbr_cells proc~cl_get_contents cl_get_contents proc~build_pt_cell_list->proc~cl_get_contents interface~str_from_num str_from_num proc~bond_fene->interface~str_from_num proc~bond_kg->interface~str_from_num interface~ivector_init ivector_init proc~build_pt_aabbtree->interface~ivector_init proc~bond_ms->interface~str_from_num interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~ivector_from_array->interface~ivector_init proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/se_fval.html"},{"title":"se_jacv – BROWNPAK","text":"public subroutine se_jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, ierr) Calculates jacobian times vector product. This is a dummy subroutine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rp), intent(in), dimension(:) :: xcur real(kind=rp), intent(in), dimension(:) :: fcur integer, intent(in) :: ijob real(kind=rp), intent(in), dimension(:) :: v real(kind=rp), intent(out), dimension(:) :: z real(kind=rp), intent(in), dimension(:) :: rpar integer, intent(in), dimension(:) :: ipar integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/se_jacv.html"},{"title":"calc_diffusion – BROWNPAK","text":"private subroutine calc_diffusion(ierr) Calculates the diffusion term of the SDE. Updates module variables diffusion and cntr_mobsam . Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~calc_diffusion~~CallsGraph proc~calc_diffusion calc_diffusion proc~brn_calc_dw brn_calc_dw proc~calc_diffusion->proc~brn_calc_dw proc~brn_calc_bdw brn_calc_bdw proc~calc_diffusion->proc~brn_calc_bdw proc~calc_rpy_tensor calc_rpy_tensor proc~calc_diffusion->proc~calc_rpy_tensor proc~get_rv_gaussian get_rv_gaussian proc~brn_calc_dw->proc~get_rv_gaussian proc~calc_bdw_lanc calc_bdw_lanc proc~brn_calc_bdw->proc~calc_bdw_lanc proc~calc_bdw_cholesky calc_bdw_cholesky proc~brn_calc_bdw->proc~calc_bdw_cholesky proc~calc_bdw_blanc calc_bdw_blanc proc~brn_calc_bdw->proc~calc_bdw_blanc dtrmm dtrmm proc~calc_bdw_cholesky->dtrmm dpotrf dpotrf proc~calc_bdw_cholesky->dpotrf vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian dsbevd dsbevd proc~calc_bdw_blanc->dsbevd dorgqr dorgqr proc~calc_bdw_blanc->dorgqr dgeqp3 dgeqp3 proc~calc_bdw_blanc->dgeqp3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_diffusion~~CalledByGraph proc~calc_diffusion calc_diffusion proc~integrate_em integrate_em proc~integrate_em->proc~calc_diffusion proc~integrate_se integrate_se proc~integrate_se->proc~calc_diffusion proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~bds_run->proc~integrate_se proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/calc_diffusion.html"},{"title":"calc_drift – BROWNPAK","text":"private subroutine calc_drift(ierr) Calculates the drift term of the SDE. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~calc_drift~~CallsGraph proc~calc_drift calc_drift proc~ia_calc_forces ia_calc_forces proc~calc_drift->proc~ia_calc_forces dsymv dsymv proc~calc_drift->dsymv proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~pt_build pt_build proc~ia_add_vdw_forces->proc~pt_build proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force proc~vdw_lj_coul_debye vdw_lj_coul_debye proc~ia_get_vdw_force->proc~vdw_lj_coul_debye proc~vdw_cosine vdw_cosine proc~ia_get_vdw_force->proc~vdw_cosine proc~vdw_gaussian vdw_gaussian proc~ia_get_vdw_force->proc~vdw_gaussian proc~vdw_lj vdw_lj proc~ia_get_vdw_force->proc~vdw_lj proc~vdw_dpd vdw_dpd proc~ia_get_vdw_force->proc~vdw_dpd proc~vdw_lj_coul vdw_lj_coul proc~ia_get_vdw_force->proc~vdw_lj_coul proc~bond_fene bond_fene proc~ia_get_bond_force->proc~bond_fene proc~bond_harm bond_harm proc~ia_get_bond_force->proc~bond_harm proc~bond_kg bond_kg proc~ia_get_bond_force->proc~bond_kg proc~bond_ms bond_ms proc~ia_get_bond_force->proc~bond_ms proc~build_pt_cell_list build_pt_cell_list proc~pt_build->proc~build_pt_cell_list proc~build_pt_n2 build_pt_n2 proc~pt_build->proc~build_pt_n2 proc~build_pt_aabbtree build_pt_aabbtree proc~pt_build->proc~build_pt_aabbtree proc~build_pt_verlet build_pt_verlet proc~pt_build->proc~build_pt_verlet proc~teth_rigid teth_rigid proc~ia_get_tether_force->proc~teth_rigid proc~teth_harm teth_harm proc~ia_get_tether_force->proc~teth_harm proc~cl_build cl_build proc~build_pt_cell_list->proc~cl_build proc~cl_get_num_cells cl_get_num_cells proc~build_pt_cell_list->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~build_pt_cell_list->proc~cl_get_nbr_cells proc~cl_get_contents cl_get_contents proc~build_pt_cell_list->proc~cl_get_contents interface~str_from_num str_from_num proc~bond_fene->interface~str_from_num proc~bond_kg->interface~str_from_num interface~ivector_init ivector_init proc~build_pt_aabbtree->interface~ivector_init proc~bond_ms->interface~str_from_num interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~ivector_from_array->interface~ivector_init proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_drift~~CalledByGraph proc~calc_drift calc_drift proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/calc_drift.html"},{"title":"calc_rpy_tensor – BROWNPAK","text":"private subroutine calc_rpy_tensor(coordinates, mob) Calculates the RPY approximation to the mobility tensor. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: coordinates (3, num_atoms*) matrix; stores the atom positions. real(kind=rp), intent(out), dimension(:,:) :: mob (3 num_atoms , 3 num_atoms ) matrix; stores the mobility tensor. Called by proc~~calc_rpy_tensor~~CalledByGraph proc~calc_rpy_tensor calc_rpy_tensor proc~calc_diffusion calc_diffusion proc~calc_diffusion->proc~calc_rpy_tensor proc~integrate_em integrate_em proc~integrate_em->proc~calc_diffusion proc~integrate_se integrate_se proc~integrate_se->proc~calc_diffusion proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~bds_run->proc~integrate_se proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/calc_rpy_tensor.html"},{"title":"pt_init – BROWNPAK","text":"public subroutine pt_init(mth, num_atoms, excl_atoms, rcut, tskn, bonds, simbox, pair_tab) Performs initial setup for building a pair list. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mth integer, intent(in) :: num_atoms integer, intent(in) :: excl_atoms real(kind=rp), intent(in) :: rcut real(kind=rp), intent(in) :: tskn integer, intent(in), dimension(:,:) :: bonds type( smbx_t ), intent(in) :: simbox type( itable_t ), intent(inout) :: pair_tab Calls proc~~pt_init~~CallsGraph proc~pt_init pt_init proc~cl_init cl_init proc~pt_init->proc~cl_init proc~atat_build atat_build proc~pt_init->proc~atat_build proc~exat_build exat_build proc~pt_init->proc~exat_build proc~cl_set_cell_size cl_set_cell_size proc~pt_init->proc~cl_set_cell_size proc~itbl_init itbl_init proc~pt_init->proc~itbl_init proc~cl_build_cell_nbrs cl_build_cell_nbrs proc~pt_init->proc~cl_build_cell_nbrs interface~ivector_init ivector_init proc~cl_init->interface~ivector_init proc~atat_build->proc~itbl_init proc~atat_build->interface~ivector_init proc~exat_build->proc~itbl_init proc~exat_build->interface~ivector_init proc~itbl_init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pt_init~~CalledByGraph proc~pt_init pt_init proc~ia_setup ia_setup proc~ia_setup->proc~pt_init proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pt_init.html"},{"title":"pt_delete – BROWNPAK","text":"public subroutine pt_delete(pair_tab) Cleanup for pair list calculation. Arguments Type Intent Optional Attributes Name type( itable_t ), intent(inout) :: pair_tab Calls proc~~pt_delete~~CallsGraph proc~pt_delete pt_delete proc~cl_delete cl_delete proc~pt_delete->proc~cl_delete Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pt_delete~~CalledByGraph proc~pt_delete pt_delete proc~ia_finish ia_finish proc~ia_finish->proc~pt_delete proc~finish finish proc~finish->proc~ia_finish proc~run run proc~run->proc~finish program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pt_delete.html"},{"title":"pt_build – BROWNPAK","text":"public subroutine pt_build(simbox, coordinates, pair_tab) Builds a pair table. The resulting table is stored in the module variable pair_tab . Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox real(kind=rp), intent(in), dimension(:,:) :: coordinates type( itable_t ), intent(inout) :: pair_tab Calls proc~~pt_build~~CallsGraph proc~pt_build pt_build proc~build_pt_aabbtree build_pt_aabbtree proc~pt_build->proc~build_pt_aabbtree proc~build_pt_cell_list build_pt_cell_list proc~pt_build->proc~build_pt_cell_list proc~build_pt_verlet build_pt_verlet proc~pt_build->proc~build_pt_verlet proc~build_pt_n2 build_pt_n2 proc~pt_build->proc~build_pt_n2 interface~ivector_init ivector_init proc~build_pt_aabbtree->interface~ivector_init proc~cl_build cl_build proc~build_pt_cell_list->proc~cl_build proc~cl_get_num_cells cl_get_num_cells proc~build_pt_cell_list->proc~cl_get_num_cells proc~cl_get_contents cl_get_contents proc~build_pt_cell_list->proc~cl_get_contents proc~cl_get_nbr_cells cl_get_nbr_cells proc~build_pt_cell_list->proc~cl_get_nbr_cells interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pt_build~~CalledByGraph proc~pt_build pt_build proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~pt_build proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pt_build.html"},{"title":"build_pt_n2 – BROWNPAK","text":"private subroutine build_pt_n2(simbox, coordinates, pair_tab) Builds a pair table using direct N&#94;2 looping over all pairs. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox real(kind=rp), intent(in), dimension(:,:) :: coordinates type( itable_t ), intent(inout) :: pair_tab Called by proc~~build_pt_n2~~CalledByGraph proc~build_pt_n2 build_pt_n2 proc~pt_build pt_build proc~pt_build->proc~build_pt_n2 proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~pt_build proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/build_pt_n2.html"},{"title":"build_pt_verlet – BROWNPAK","text":"private subroutine build_pt_verlet(simbox, coordinates, pair_tab) Builds a pair table using the Verlet scheme. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox real(kind=rp), intent(in), dimension(:,:) :: coordinates type( itable_t ), intent(inout) :: pair_tab Called by proc~~build_pt_verlet~~CalledByGraph proc~build_pt_verlet build_pt_verlet proc~pt_build pt_build proc~pt_build->proc~build_pt_verlet proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~pt_build proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/build_pt_verlet.html"},{"title":"build_pt_aabbtree – BROWNPAK","text":"private subroutine build_pt_aabbtree(simbox, coordinates, pair_tab) Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox real(kind=rp), intent(in), dimension(:,:) :: coordinates type( itable_t ), intent(inout) :: pair_tab Calls proc~~build_pt_aabbtree~~CallsGraph proc~build_pt_aabbtree build_pt_aabbtree interface~ivector_init ivector_init proc~build_pt_aabbtree->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~build_pt_aabbtree~~CalledByGraph proc~build_pt_aabbtree build_pt_aabbtree proc~pt_build pt_build proc~pt_build->proc~build_pt_aabbtree proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~pt_build proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/build_pt_aabbtree.html"},{"title":"build_pt_cell_list – BROWNPAK","text":"private subroutine build_pt_cell_list(simbox, coordinates, pair_tab) Builds a pair table using cell list. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox real(kind=rp), intent(in), dimension(:,:) :: coordinates type( itable_t ), intent(inout) :: pair_tab Calls proc~~build_pt_cell_list~~CallsGraph proc~build_pt_cell_list build_pt_cell_list proc~cl_get_contents cl_get_contents proc~build_pt_cell_list->proc~cl_get_contents proc~cl_build cl_build proc~build_pt_cell_list->proc~cl_build proc~cl_get_num_cells cl_get_num_cells proc~build_pt_cell_list->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~build_pt_cell_list->proc~cl_get_nbr_cells Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~build_pt_cell_list~~CalledByGraph proc~build_pt_cell_list build_pt_cell_list proc~pt_build pt_build proc~pt_build->proc~build_pt_cell_list proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~pt_build proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/build_pt_cell_list.html"},{"title":"brn_init – BROWNPAK","text":"public subroutine brn_init(n, nblks, mth, f, e) Performs initial setup. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Size of the mobility matrix. integer, intent(in) :: nblks Number of B . d W vectors to generate for the same mobility matrix. 1 <= nblks < n . character(len=4), intent(in) :: mth Method for calculating the Brownian terms. mth = 'CHOL' for\n Cholesky decomposition; mth = 'LANC' for KSP-based method. integer, intent(in), optional :: f For KSP-based method, maximum number of iterations.\n Must be present if mth = 'LANC' . f must be less than n . real(kind=rp), intent(in), optional :: e For KSP-based method, error threshold for convergence. \n Must be present if mth = 'LANC' . Called by proc~~brn_init~~CalledByGraph proc~brn_init brn_init proc~bds_init bds_init proc~bds_init->proc~brn_init proc~run run proc~run->proc~bds_init program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/brn_init.html"},{"title":"brn_finish – BROWNPAK","text":"public subroutine brn_finish() Performs cleanup. Arguments None Called by proc~~brn_finish~~CalledByGraph proc~brn_finish brn_finish proc~bds_finish bds_finish proc~bds_finish->proc~brn_finish proc~finish finish proc~finish->proc~bds_finish proc~run run proc~run->proc~finish program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/brn_finish.html"},{"title":"brn_calc_bdw – BROWNPAK","text":"public subroutine brn_calc_bdw(mob, bdw, ierr, lconv, f) Main driver routine for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix.\n On entry , contains the mobility matrix.  On return , if meth = 'CHOL' ,\n the upper triangular part is overwritten with the result of Cholesky\n decomposition.  The strictly lower triangular part is left intact. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B .d W . integer, intent(out) :: ierr Error flag. logical, intent(out), optional :: lconv If meth = 'LANC' , returns true if converged, false otherwise. integer, intent(out), optional :: f If meth = 'LANC' , the number of iterations performed. Calls proc~~brn_calc_bdw~~CallsGraph proc~brn_calc_bdw brn_calc_bdw proc~calc_bdw_cholesky calc_bdw_cholesky proc~brn_calc_bdw->proc~calc_bdw_cholesky proc~calc_bdw_lanc calc_bdw_lanc proc~brn_calc_bdw->proc~calc_bdw_lanc proc~calc_bdw_blanc calc_bdw_blanc proc~brn_calc_bdw->proc~calc_bdw_blanc dtrmm dtrmm proc~calc_bdw_cholesky->dtrmm dpotrf dpotrf proc~calc_bdw_cholesky->dpotrf dsbevd dsbevd proc~calc_bdw_blanc->dsbevd dorgqr dorgqr proc~calc_bdw_blanc->dorgqr dgeqp3 dgeqp3 proc~calc_bdw_blanc->dgeqp3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~brn_calc_bdw~~CalledByGraph proc~brn_calc_bdw brn_calc_bdw proc~calc_diffusion calc_diffusion proc~calc_diffusion->proc~brn_calc_bdw proc~integrate_em integrate_em proc~integrate_em->proc~calc_diffusion proc~integrate_se integrate_se proc~integrate_se->proc~calc_diffusion proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~bds_run->proc~integrate_se proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/brn_calc_bdw.html"},{"title":"calc_bdw_lanc – BROWNPAK","text":"private subroutine calc_bdw_lanc(mob, bdw, lconv, f, ierr) Implements Lanczos algorithm for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm ,1) array.\n On entry , contains a vector drawn from standard normal \n distribution. On return , is overwritten with the result of B . d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag. Called by proc~~calc_bdw_lanc~~CalledByGraph proc~calc_bdw_lanc calc_bdw_lanc proc~brn_calc_bdw brn_calc_bdw proc~brn_calc_bdw->proc~calc_bdw_lanc proc~calc_diffusion calc_diffusion proc~calc_diffusion->proc~brn_calc_bdw proc~integrate_em integrate_em proc~integrate_em->proc~calc_diffusion proc~integrate_se integrate_se proc~integrate_se->proc~calc_diffusion proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~bds_run->proc~integrate_se proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/calc_bdw_lanc.html"},{"title":"calc_bdw_blanc – BROWNPAK","text":"private subroutine calc_bdw_blanc(mob, bdw, lconv, f, ierr) Implements block Lanczos algorithm for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B . d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag. Calls proc~~calc_bdw_blanc~~CallsGraph proc~calc_bdw_blanc calc_bdw_blanc dorgqr dorgqr proc~calc_bdw_blanc->dorgqr dgeqp3 dgeqp3 proc~calc_bdw_blanc->dgeqp3 dsbevd dsbevd proc~calc_bdw_blanc->dsbevd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_bdw_blanc~~CalledByGraph proc~calc_bdw_blanc calc_bdw_blanc proc~brn_calc_bdw brn_calc_bdw proc~brn_calc_bdw->proc~calc_bdw_blanc proc~calc_diffusion calc_diffusion proc~calc_diffusion->proc~brn_calc_bdw proc~integrate_em integrate_em proc~integrate_em->proc~calc_diffusion proc~integrate_se integrate_se proc~integrate_se->proc~calc_diffusion proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~bds_run->proc~integrate_se proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/calc_bdw_blanc.html"},{"title":"calc_bdw_cholesky – BROWNPAK","text":"private subroutine calc_bdw_cholesky(mob, bdw, ierr) Calculates B . d W using Cholesky decomposition. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix.\n On entry , contains the mobility matrix.  On return ,\n the upper triangular part is overwritten with the result of Cholesky\n decomposition.  The strictly lower triangular part is left intact. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B . d W . integer, intent(out) :: ierr Error flag. Calls proc~~calc_bdw_cholesky~~CallsGraph proc~calc_bdw_cholesky calc_bdw_cholesky dpotrf dpotrf proc~calc_bdw_cholesky->dpotrf dtrmm dtrmm proc~calc_bdw_cholesky->dtrmm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_bdw_cholesky~~CalledByGraph proc~calc_bdw_cholesky calc_bdw_cholesky proc~brn_calc_bdw brn_calc_bdw proc~brn_calc_bdw->proc~calc_bdw_cholesky proc~calc_diffusion calc_diffusion proc~calc_diffusion->proc~brn_calc_bdw proc~integrate_em integrate_em proc~integrate_em->proc~calc_diffusion proc~integrate_se integrate_se proc~integrate_se->proc~calc_diffusion proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~bds_run->proc~integrate_se proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/calc_bdw_cholesky.html"},{"title":"brn_calc_dw – BROWNPAK","text":"public subroutine brn_calc_dw(dw) Calculates standard normally distributed random vectors. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:), target :: dw ( n , m ) array. Calls proc~~brn_calc_dw~~CallsGraph proc~brn_calc_dw brn_calc_dw proc~get_rv_gaussian get_rv_gaussian proc~brn_calc_dw->proc~get_rv_gaussian vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~brn_calc_dw~~CalledByGraph proc~brn_calc_dw brn_calc_dw proc~calc_diffusion calc_diffusion proc~calc_diffusion->proc~brn_calc_dw proc~integrate_em integrate_em proc~integrate_em->proc~calc_diffusion proc~integrate_se integrate_se proc~integrate_se->proc~calc_diffusion proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~bds_run->proc~integrate_se proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/brn_calc_dw.html"},{"title":"calc_bdw_lanc_sor – BROWNPAK","text":"private subroutine calc_bdw_lanc_sor(mob, bdw, lconv, f, ierr) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm ,1) array.\n On entry , contains a vector drawn from standard normal \n distribution. On return , is overwritten with the result of B .d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag. Contents None","tags":"","loc":"proc/calc_bdw_lanc_sor.html"},{"title":"get_uniform – BROWNPAK","text":"public function get_uniform(lb, ub) result(res) Returns a random number from a uniform distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound Return Value real(kind=rp) Calls proc~~get_uniform~~CallsGraph proc~get_uniform get_uniform vdrnguniform vdrnguniform proc~get_uniform->vdrnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_uniform.html"},{"title":"get_iuniform – BROWNPAK","text":"public function get_iuniform(lb, ub) result(res) Returns a random integer from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub Return Value integer(kind=ip) Calls proc~~get_iuniform~~CallsGraph proc~get_iuniform get_iuniform virnguniform virnguniform proc~get_iuniform->virnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_iuniform.html"},{"title":"init_stream – BROWNPAK","text":"public subroutine init_stream(fn) Initializes a BRNG stream. The stream is initialized with a seed from the file fn . If fn is an empty string, the seed is obtained from /dev/urandom . Arguments Type Intent Optional Attributes Name character(len=*) :: fn Name of the file containing the RNG seed. Calls proc~~init_stream~~CallsGraph proc~init_stream init_stream vslnewstream vslnewstream proc~init_stream->vslnewstream Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_stream~~CalledByGraph proc~init_stream init_stream proc~run run proc~run->proc~init_stream program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/init_stream.html"},{"title":"delete_stream – BROWNPAK","text":"public subroutine delete_stream() Deletes a BRNG stream. Arguments None Calls proc~~delete_stream~~CallsGraph proc~delete_stream delete_stream vsldeletestream vsldeletestream proc~delete_stream->vsldeletestream Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/delete_stream.html"},{"title":"load_stream – BROWNPAK","text":"public subroutine load_stream(fn) Loads a BRNG stream from file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Calls proc~~load_stream~~CallsGraph proc~load_stream load_stream vslloadstreamf vslloadstreamf proc~load_stream->vslloadstreamf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/load_stream.html"},{"title":"save_seed – BROWNPAK","text":"public subroutine save_seed(fn) Saves the RNG seed to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Contents None","tags":"","loc":"proc/save_seed.html"},{"title":"save_stream – BROWNPAK","text":"public subroutine save_stream(fn) Saves a BRNG stream to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Calls proc~~save_stream~~CallsGraph proc~save_stream save_stream vslsavestreamf vslsavestreamf proc~save_stream->vslsavestreamf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/save_stream.html"},{"title":"get_rv_uniform – BROWNPAK","text":"public subroutine get_rv_uniform(lb, ub, rv, block_size) Returns a random vector from a uniform distribution. If a block_size > 0 is provided, it fills rv in blocks of\n size block_size . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size Calls proc~~get_rv_uniform~~CallsGraph proc~get_rv_uniform get_rv_uniform vdrnguniform vdrnguniform proc~get_rv_uniform->vdrnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_rv_uniform~~CalledByGraph proc~get_rv_uniform get_rv_uniform proc~smbx_get_rnd_points smbx_get_rnd_points proc~smbx_get_rnd_points->proc~get_rv_uniform proc~ransphere ransphere proc~ransphere->proc~get_rv_uniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_rv_uniform.html"},{"title":"get_rv_iuniform – BROWNPAK","text":"public subroutine get_rv_iuniform(lb, ub, rv, block_size) Returns a random vector of integers from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub integer(kind=ip), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size Calls proc~~get_rv_iuniform~~CallsGraph proc~get_rv_iuniform get_rv_iuniform virnguniform virnguniform proc~get_rv_iuniform->virnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_rv_iuniform.html"},{"title":"get_rv_gaussian – BROWNPAK","text":"public subroutine get_rv_gaussian(mean, std_dev, rv, block_size) Generates a random vector of integers from a gaussian distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: std_dev real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size Calls proc~~get_rv_gaussian~~CallsGraph proc~get_rv_gaussian get_rv_gaussian vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_rv_gaussian~~CalledByGraph proc~get_rv_gaussian get_rv_gaussian proc~brn_calc_dw brn_calc_dw proc~brn_calc_dw->proc~get_rv_gaussian proc~calc_diffusion calc_diffusion proc~calc_diffusion->proc~brn_calc_dw proc~integrate_em integrate_em proc~integrate_em->proc~calc_diffusion proc~integrate_se integrate_se proc~integrate_se->proc~calc_diffusion proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~bds_run->proc~integrate_se proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_rv_gaussian.html"},{"title":"ransphere – BROWNPAK","text":"public subroutine ransphere(r) Generates a random vector from the surface of a unit sphere. Algorithm from Allen & Tildesley (ed 1) p. 349. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(3) :: r (3) Calls proc~~ransphere~~CallsGraph proc~ransphere ransphere proc~get_rv_uniform get_rv_uniform proc~ransphere->proc~get_rv_uniform vdrnguniform vdrnguniform proc~get_rv_uniform->vdrnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ransphere.html"},{"title":"str_is_letter – BROWNPAK","text":"public pure function str_is_letter(str) result(res) Returns .true. if str contains only letters ( a--z or A--Z ) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical Contents None","tags":"","loc":"proc/str_is_letter.html"},{"title":"str_is_digit – BROWNPAK","text":"public pure function str_is_digit(str) result(res) Returns .true. if str contains only digits (0,1,...,9) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical Contents None","tags":"","loc":"proc/str_is_digit.html"},{"title":"str_is_space – BROWNPAK","text":"public pure function str_is_space(str) result(res) Returns .true. if str is non-empty and contains only whitespace\n characters (tab or blankspace). Otherwise .false. is returned. Note : This function will return .false. for an empty string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical Contents None","tags":"","loc":"proc/str_is_space.html"},{"title":"str_is_comment – BROWNPAK","text":"public pure function str_is_comment(line, comment_str) result(res) Returns .true. if line is a comment, .false. other wise. line is a comment if comment_str is its first non-blank character\n  sequence. If line is an empty string or contains only blankspaces, the\n  return value is .false. If comment_str is empty, the return value is .true. . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Input string character(len=*), intent(in) :: comment_str String marking the beginning of a comment. Return Value logical Called by proc~~str_is_comment~~CalledByGraph proc~str_is_comment str_is_comment proc~readline readline proc~readline->proc~str_is_comment proc~read_config read_config proc~read_config->proc~readline proc~control_read control_read proc~control_read->proc~readline proc~run run proc~run->proc~read_config program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_is_comment.html"},{"title":"str_compact – BROWNPAK","text":"public pure function str_compact(str) result(ostr) Returns a copy of str with multiple spaces and tabs converted to\n single spaces, control characters deleted, and leading and trailing\n spaces removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable Called by proc~~str_compact~~CalledByGraph proc~str_compact str_compact proc~str_split str_split proc~str_split->proc~str_compact proc~read_config read_config proc~read_config->proc~str_split proc~run run proc~run->proc~read_config program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_compact.html"},{"title":"str_remove_stcc – BROWNPAK","text":"public pure function str_remove_stcc(str) result(ostr) Returns a copy of the string str with spaces, tabs, and\n control characters removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_remove_stcc.html"},{"title":"str_to_upper – BROWNPAK","text":"public pure function str_to_upper(str) result(ucstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to uppercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) Contents None","tags":"","loc":"proc/str_to_upper.html"},{"title":"str_to_lower – BROWNPAK","text":"public pure function str_to_lower(str) result(lcstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to lowercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) Contents None","tags":"","loc":"proc/str_to_lower.html"},{"title":"str_from_inum – BROWNPAK","text":"private pure function str_from_inum(num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Called by proc~~str_from_inum~~CalledByGraph proc~str_from_inum str_from_inum interface~str_from_num str_from_num interface~str_from_num->proc~str_from_inum proc~bond_fene bond_fene proc~bond_fene->interface~str_from_num proc~node_asstr node_asstr proc~node_asstr->interface~str_from_num proc~aabb_print aabb_print proc~aabb_print->interface~str_from_num proc~control_write control_write proc~control_write->interface~str_from_num proc~bond_kg bond_kg proc~bond_kg->interface~str_from_num proc~bond_ms bond_ms proc~bond_ms->interface~str_from_num interface~node_asstr node_asstr interface~node_asstr->proc~node_asstr proc~ia_get_bond_force ia_get_bond_force proc~ia_get_bond_force->proc~bond_fene proc~ia_get_bond_force->proc~bond_kg proc~ia_get_bond_force->proc~bond_ms proc~ia_add_bond_forces ia_add_bond_forces proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_from_inum.html"},{"title":"str_from_ilnum – BROWNPAK","text":"private pure function str_from_ilnum(num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Called by proc~~str_from_ilnum~~CalledByGraph proc~str_from_ilnum str_from_ilnum interface~str_from_num str_from_num interface~str_from_num->proc~str_from_ilnum proc~bond_fene bond_fene proc~bond_fene->interface~str_from_num proc~node_asstr node_asstr proc~node_asstr->interface~str_from_num proc~aabb_print aabb_print proc~aabb_print->interface~str_from_num proc~control_write control_write proc~control_write->interface~str_from_num proc~bond_kg bond_kg proc~bond_kg->interface~str_from_num proc~bond_ms bond_ms proc~bond_ms->interface~str_from_num interface~node_asstr node_asstr interface~node_asstr->proc~node_asstr proc~ia_get_bond_force ia_get_bond_force proc~ia_get_bond_force->proc~bond_fene proc~ia_get_bond_force->proc~bond_kg proc~ia_get_bond_force->proc~bond_ms proc~ia_add_bond_forces ia_add_bond_forces proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_from_ilnum.html"},{"title":"str_from_dnum – BROWNPAK","text":"private pure function str_from_dnum(num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Calls proc~~str_from_dnum~~CallsGraph proc~str_from_dnum str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~str_from_dnum~~CalledByGraph proc~str_from_dnum str_from_dnum interface~str_from_num str_from_num interface~str_from_num->proc~str_from_dnum proc~bond_fene bond_fene proc~bond_fene->interface~str_from_num proc~node_asstr node_asstr proc~node_asstr->interface~str_from_num proc~aabb_print aabb_print proc~aabb_print->interface~str_from_num proc~control_write control_write proc~control_write->interface~str_from_num proc~bond_kg bond_kg proc~bond_kg->interface~str_from_num proc~bond_ms bond_ms proc~bond_ms->interface~str_from_num interface~node_asstr node_asstr interface~node_asstr->proc~node_asstr proc~ia_get_bond_force ia_get_bond_force proc~ia_get_bond_force->proc~bond_fene proc~ia_get_bond_force->proc~bond_kg proc~ia_get_bond_force->proc~bond_ms proc~ia_add_bond_forces ia_add_bond_forces proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_from_dnum.html"},{"title":"str_trimzero – BROWNPAK","text":"public pure function str_trimzero(str) result(res) Deletes nonsignificant trailing zeroes from number string str. If number\n string ends in a decimal point, one trailing zero is added. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable Called by proc~~str_trimzero~~CalledByGraph proc~str_trimzero str_trimzero proc~str_from_dnum str_from_dnum proc~str_from_dnum->proc~str_trimzero interface~str_from_num str_from_num interface~str_from_num->proc~str_from_dnum proc~bond_fene bond_fene proc~bond_fene->interface~str_from_num proc~node_asstr node_asstr proc~node_asstr->interface~str_from_num proc~aabb_print aabb_print proc~aabb_print->interface~str_from_num proc~control_write control_write proc~control_write->interface~str_from_num proc~bond_kg bond_kg proc~bond_kg->interface~str_from_num proc~bond_ms bond_ms proc~bond_ms->interface~str_from_num interface~node_asstr node_asstr interface~node_asstr->proc~node_asstr proc~ia_get_bond_force ia_get_bond_force proc~ia_get_bond_force->proc~bond_fene proc~ia_get_bond_force->proc~bond_kg proc~ia_get_bond_force->proc~bond_ms proc~ia_add_bond_forces ia_add_bond_forces proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_trimzero.html"},{"title":"str_to_d – BROWNPAK","text":"public pure function str_to_d(str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value real(kind=rp) Called by proc~~str_to_d~~CalledByGraph proc~str_to_d str_to_d proc~control_read control_read proc~control_read->proc~str_to_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_to_d.html"},{"title":"str_to_i – BROWNPAK","text":"public pure function str_to_i(str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer Called by proc~~str_to_i~~CalledByGraph proc~str_to_i str_to_i proc~read_config read_config proc~read_config->proc~str_to_i proc~run run proc~run->proc~read_config program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_to_i.html"},{"title":"str_strip – BROWNPAK","text":"public pure function str_strip(str, chars, ends) result(ostr) Returns a copy of string str with the leading and trailing characters\n removed. The chars argument is a string specifying the set of characters to\n be removed.  The chars argument is not a prefix or suffix; rather, all\n combinations of its values are stripped. If ends = 'l' , only leading\n characters are removed, if ends = 'r' , only trailing characters are\n removed, and if ends = 'b' both leading and trailing characters are\n removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: chars character(len=1), intent(in) :: ends {'l', 'r', 'b'} Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_strip.html"},{"title":"str_startswith – BROWNPAK","text":"public pure function str_startswith(str, prefix, start, finish) result(res) Returns .true. if the string str starts with prefix , otherwise\n returns .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: prefix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical Called by proc~~str_startswith~~CalledByGraph proc~str_startswith str_startswith proc~read_config read_config proc~read_config->proc~str_startswith proc~run run proc~run->proc~read_config program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_startswith.html"},{"title":"str_endswith – BROWNPAK","text":"public pure function str_endswith(str, suffix, start, finish) result(res) Returns .true. if the string str ends with suffix , otherwise\n return .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical Contents None","tags":"","loc":"proc/str_endswith.html"},{"title":"str_shift – BROWNPAK","text":"public subroutine str_shift(str, n) Shifts characters in str by n positions (positive values\n denote a right shift and negative values denote a left shift). Characters\n that are shifted off the end are lost. Positions opened up by the shift \n are replaced by spaces. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str integer, intent(in) :: n Called by proc~~str_shift~~CalledByGraph proc~str_shift str_shift proc~str_insert str_insert proc~str_insert->proc~str_shift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_shift.html"},{"title":"str_insert – BROWNPAK","text":"public subroutine str_insert(str, substr, loc) Inserts the string substr into the string str at position loc . \n Characters in str starting at position loc are shifted right to\n make room for the inserted string. Trailing spaces of substr are \n removed prior to insertion. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in) :: loc Calls proc~~str_insert~~CallsGraph proc~str_insert str_insert proc~str_shift str_shift proc~str_insert->proc~str_shift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_insert.html"},{"title":"str_del – BROWNPAK","text":"public subroutine str_del(str, substr, n) Deletes first n occurrences of substring substr from string str and\n shifts characters left to fill hole. If n < 0 , all occurances are\n deleted.  If n is not explicitly provided, it defaults to removing the\n first occurrence. Trailing spaces or blanks are not considered part of substr . Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in), optional :: n Contents None","tags":"","loc":"proc/str_del.html"},{"title":"str_strip_comment – BROWNPAK","text":"public subroutine str_strip_comment(str, comment_str) Strips trailing comment from a string. The comment is assumed to begin with the sequence of characters in comment_str . If the sequence comment_str is not found within str ,\n  no changes are made. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str Input string character(len=*), intent(in) :: comment_str String indicating beginning of a comment. Called by proc~~str_strip_comment~~CalledByGraph proc~str_strip_comment str_strip_comment proc~readline readline proc~readline->proc~str_strip_comment proc~read_config read_config proc~read_config->proc~readline proc~control_read control_read proc~control_read->proc~readline proc~run run proc~run->proc~read_config program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_strip_comment.html"},{"title":"str_get_keyval – BROWNPAK","text":"public subroutine str_get_keyval(str, key, val, delimiter) Split a string str into two strings, key and val based on space\n delimiter. A non-empty non-comment string should be passed to this subroutine.\n Keys can have corresponding empty values, but keys must always be present Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=:), intent(out), allocatable :: key character(len=:), intent(out), allocatable :: val character(len=*), intent(in), optional :: delimiter Called by proc~~str_get_keyval~~CalledByGraph proc~str_get_keyval str_get_keyval program~main main program~main->proc~str_get_keyval proc~control_read control_read proc~control_read->proc~str_get_keyval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_get_keyval.html"},{"title":"str_match – BROWNPAK","text":"public subroutine str_match(str, ipos, imatch) This routine finds the delimiter in string str that matches the delimiter\n in position ipos of str . The argument imatch contains the position of\n the matching delimiter. Allowable delimiters are (), [], {}, <>. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: ipos integer, intent(out) :: imatch Contents None","tags":"","loc":"proc/str_match.html"},{"title":"str_compact_rlstr – BROWNPAK","text":"public subroutine str_compact_rlstr(str) Compact a string representing a real number, so that the same value is\n displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str string representation of a real number. Contents None","tags":"","loc":"proc/str_compact_rlstr.html"},{"title":"str_split – BROWNPAK","text":"public subroutine str_split(str, delimiter, before) Routine finds the first instance of a character from delims in the the\n string str . The characters before the found delimiter are output in before . The characters after the found delimiter are output in str .\n Repeated applications of this routine can be used to parse a string into its\n component parts. Multiple whitespaces of str are compacted into a single\n whitespace before splitting begins. If either str or delimiter is\n empty, an empty string is retured in before and str remains\n unchanged. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: delimiter character(len=:), intent(out), allocatable :: before Calls proc~~str_split~~CallsGraph proc~str_split str_split proc~str_compact str_compact proc~str_split->proc~str_compact Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~str_split~~CalledByGraph proc~str_split str_split proc~read_config read_config proc~read_config->proc~str_split proc~run run proc~run->proc~read_config program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_split.html"},{"title":"str_append – BROWNPAK","text":"public subroutine str_append(dest, source, sep) Appends a copy of the source string to the dest string, with \n optional string sep in between. It is assumed that dest is long\n enough to hold the result, otherwise an error will be generated. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: dest character(len=*), intent(in) :: source character(len=*), intent(in), optional :: sep Contents None","tags":"","loc":"proc/str_append.html"},{"title":"readline – BROWNPAK","text":"public subroutine readline(nunitr, line, comment_str, ios) Reads a line from unit=nunitr, ignoring blank lines\n  and deleting comments Arguments Type Intent Optional Attributes Name integer, intent(in) :: nunitr character(len=*), intent(inout) :: line character(len=*), intent(in) :: comment_str integer, intent(out) :: ios Calls proc~~readline~~CallsGraph proc~readline readline proc~str_strip_comment str_strip_comment proc~readline->proc~str_strip_comment proc~str_is_comment str_is_comment proc~readline->proc~str_is_comment Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readline~~CalledByGraph proc~readline readline proc~read_config read_config proc~read_config->proc~readline proc~control_read control_read proc~control_read->proc~readline proc~run run proc~run->proc~read_config program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/readline.html"},{"title":"str_from_num – BROWNPAK","text":"public interface str_from_num Generic  interface for writing a number to a string. The calling syntax is str_from_num(num, frmt) where number is a real number or an integer, format is the format desired, e.g., e15.6 , i5 , etc. Calls interface~~str_from_num~~CallsGraph interface~str_from_num str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~str_from_num~~CalledByGraph interface~str_from_num str_from_num proc~bond_fene bond_fene proc~bond_fene->interface~str_from_num proc~node_asstr node_asstr proc~node_asstr->interface~str_from_num proc~aabb_print aabb_print proc~aabb_print->interface~str_from_num proc~control_write control_write proc~control_write->interface~str_from_num proc~bond_kg bond_kg proc~bond_kg->interface~str_from_num proc~bond_ms bond_ms proc~bond_ms->interface~str_from_num interface~node_asstr node_asstr interface~node_asstr->proc~node_asstr proc~ia_get_bond_force ia_get_bond_force proc~ia_get_bond_force->proc~bond_fene proc~ia_get_bond_force->proc~bond_kg proc~ia_get_bond_force->proc~bond_ms proc~ia_add_bond_forces ia_add_bond_forces proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures str_from_inum str_from_ilnum str_from_dnum Module Procedures private pure function str_from_inum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_ilnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_dnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/str_from_num.html"},{"title":"atmcfg_delete – BROWNPAK","text":"public subroutine atmcfg_delete(this) Deallocates all memory acquired by a configuration_t object and resets\n all other components to zero. Exception: num_coeffs is not reset to\n zero. Arguments Type Intent Optional Attributes Name type( atmcfg_t ), intent(inout) :: this Called by proc~~atmcfg_delete~~CalledByGraph proc~atmcfg_delete atmcfg_delete proc~finish finish proc~finish->proc~atmcfg_delete proc~run run proc~run->proc~finish program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/atmcfg_delete.html"},{"title":"ia_bond_setup – BROWNPAK","text":"public subroutine ia_bond_setup(num_bond_types, bond_styles, bond_params) Sets up parameters for bond potentials Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_bond_types Number of bond types integer, intent(in), dimension(:) :: bond_styles Styles for each type real(kind=rp), intent(inout), dimension(:,:) :: bond_params Parameters for each type, depending on style Called by proc~~ia_bond_setup~~CalledByGraph proc~ia_bond_setup ia_bond_setup proc~ia_setup ia_setup proc~ia_setup->proc~ia_bond_setup proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_bond_setup.html"},{"title":"ia_get_bond_force – BROWNPAK","text":"public subroutine ia_get_bond_force(rij_mag, sty, params, enrg, frc, ierr) Calculates the energy & its derivative due to a bond. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between bonded atoms integer, intent(in) :: sty Style of the bond real(kind=rp), intent(in), dimension(:) :: params Parameters for bonded interaction real(kind=rp), intent(out) :: enrg Bond energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of the force due\n to this potential. integer, intent(out) :: ierr Error flag Calls proc~~ia_get_bond_force~~CallsGraph proc~ia_get_bond_force ia_get_bond_force proc~bond_harm bond_harm proc~ia_get_bond_force->proc~bond_harm proc~bond_fene bond_fene proc~ia_get_bond_force->proc~bond_fene proc~bond_kg bond_kg proc~ia_get_bond_force->proc~bond_kg proc~bond_ms bond_ms proc~ia_get_bond_force->proc~bond_ms interface~str_from_num str_from_num proc~bond_fene->interface~str_from_num proc~bond_kg->interface~str_from_num proc~bond_ms->interface~str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_get_bond_force~~CalledByGraph proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces ia_add_bond_forces proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_get_bond_force.html"},{"title":"bond_harm_set – BROWNPAK","text":"private subroutine bond_harm_set(params, k, r0) Setter for harmonic bond interaction. U = (1/2)*k*(r - r0)&#94;2 User-set parameters: params(1) = k (spring constant) params(2) = r0 (equilibrium distance) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 Contents None","tags":"","loc":"proc/bond_harm_set.html"},{"title":"bond_harm – BROWNPAK","text":"private subroutine bond_harm(r, params, enrg, frc) Calculates energy & its derivative for harmonic bond. See bond_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Called by proc~~bond_harm~~CalledByGraph proc~bond_harm bond_harm proc~ia_get_bond_force ia_get_bond_force proc~ia_get_bond_force->proc~bond_harm proc~ia_add_bond_forces ia_add_bond_forces proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bond_harm.html"},{"title":"bond_fene_set – BROWNPAK","text":"private subroutine bond_fene_set(params, k, rmax, r0) Setter for FENE bond. U = -0.5 k rmax&#94;2 log [1 - ((r - r0)/rmax)&#94;2] User-set parameters: params(1) = k params(2) = rmax params(3) = r0 Note The bond cannot extend beyond (rmax+r0), where r0 is the\n equilibrium bond length. If r0 = 0, this reduces to the standard definition\n of FENE bonds. Internally stored parameters: params(4) = rmax&#94;2 Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: r0 Contents None","tags":"","loc":"proc/bond_fene_set.html"},{"title":"bond_fene – BROWNPAK","text":"private subroutine bond_fene(r, params, enrg, frc, ierr) Calculates energy & its derivative for FENE bond. See bond_fene_set . If bond length exceeds maximum extensible spring length, an error will be\n reported by ierr = 1 . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Calls proc~~bond_fene~~CallsGraph proc~bond_fene bond_fene interface~str_from_num str_from_num proc~bond_fene->interface~str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bond_fene~~CalledByGraph proc~bond_fene bond_fene proc~ia_get_bond_force ia_get_bond_force proc~ia_get_bond_force->proc~bond_fene proc~ia_add_bond_forces ia_add_bond_forces proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bond_fene.html"},{"title":"bond_kg_set – BROWNPAK","text":"private subroutine bond_kg_set(params, k, rmax, eps, sigma) Setter for FENE bond interaction. V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] + eps W = -0.5 k rmax&#94;2 log [1 - (r/rmax)&#94;2] U = W + V, r < 2&#94;(1/6)*sigma W, r >= 2&#94;(1/6)*sigma User-set parameters: params(1) = k params(2) = rmax params(3) = eps params(4) = sigma Internally stored parameters: params(5) = rmax&#94;2 params(6) = 2&#94;(1/6)*sigma Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma Contents None","tags":"","loc":"proc/bond_kg_set.html"},{"title":"bond_kg – BROWNPAK","text":"private subroutine bond_kg(r, params, enrg, frc, ierr) Calculates energy & its derivative for Kremer-Grest bond. See bond_kg_set . If bond length exceeds maximum extensible spring length, an error will be\n reported as ierr = 1 . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Calls proc~~bond_kg~~CallsGraph proc~bond_kg bond_kg interface~str_from_num str_from_num proc~bond_kg->interface~str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bond_kg~~CalledByGraph proc~bond_kg bond_kg proc~ia_get_bond_force ia_get_bond_force proc~ia_get_bond_force->proc~bond_kg proc~ia_add_bond_forces ia_add_bond_forces proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bond_kg.html"},{"title":"bond_ms_set – BROWNPAK","text":"private subroutine bond_ms_set(params, lp, rmax) Setter for Marko-Siggia bond. U = [-(1/2)*rtilde&#94;2 + 0.25/(1-rtilde)&#94;2 + 0.25*rtilde]*(rmax/lp), r < rmax where rtilde = r/rmax. User-set parameters: params(1) = lp (persistence length) params(2) = rmax Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: lp real(kind=rp), intent(in), optional :: rmax Contents None","tags":"","loc":"proc/bond_ms_set.html"},{"title":"bond_ms – BROWNPAK","text":"private subroutine bond_ms(r, params, enrg, frc, ierr) Evaluates the potential & its derivative for Marko-Siggia bond.\n See bond_ms_set . If bond length exceeds maximum extensible spring length, an error will be\n reported as ierr = 1 . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Calls proc~~bond_ms~~CallsGraph proc~bond_ms bond_ms interface~str_from_num str_from_num proc~bond_ms->interface~str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bond_ms~~CalledByGraph proc~bond_ms bond_ms proc~ia_get_bond_force ia_get_bond_force proc~ia_get_bond_force->proc~bond_ms proc~ia_add_bond_forces ia_add_bond_forces proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bond_ms.html"},{"title":"control_read – BROWNPAK","text":"public subroutine control_read(this, fn) Reads simulation control parameters from file Arguments Type Intent Optional Attributes Name class( ctrlpar_t ), intent(out) :: this A ctrlpar_t instance. character(len=*), intent(in) :: fn Name of parameters file. Calls proc~~control_read~~CallsGraph proc~control_read control_read proc~readline readline proc~control_read->proc~readline proc~str_get_keyval str_get_keyval proc~control_read->proc~str_get_keyval proc~str_to_d str_to_d proc~control_read->proc~str_to_d proc~str_strip_comment str_strip_comment proc~readline->proc~str_strip_comment proc~str_is_comment str_is_comment proc~readline->proc~str_is_comment Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/control_read.html"},{"title":"control_write – BROWNPAK","text":"public subroutine control_write(this, fn) Write simulation parameters to file Arguments Type Intent Optional Attributes Name class( ctrlpar_t ), intent(out) :: this A ctrlpar_t instance. character(len=*), intent(in) :: fn Output file name Calls proc~~control_write~~CallsGraph proc~control_write control_write interface~str_from_num str_from_num proc~control_write->interface~str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/control_write.html"},{"title":"aabb_includes – BROWNPAK","text":"public function aabb_includes(this, other) result(res) Returns true if this includes other , false otherwise. Inclusion\n is considered in a strict sense. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical Contents None","tags":"","loc":"proc/aabb_includes.html"},{"title":"aabb_overlaps – BROWNPAK","text":"public function aabb_overlaps(this, other) result(res) Returns true if this overlaps other , false otherwise. Touching\n does not count as an overlap. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical Contents None","tags":"","loc":"proc/aabb_overlaps.html"},{"title":"aabb_union – BROWNPAK","text":"public function aabb_union(x, y) result(z) Combines AABBs x and y to return a new AABB z . Arguments Type Intent Optional Attributes Name type( aabb_t ), intent(in) :: x An aabb_t instance. type( aabb_t ), intent(in) :: y An aabb_t instance. Return Value type( aabb_t ) Called by proc~~aabb_union~~CalledByGraph proc~aabb_union aabb_union interface~operator(+) operator(+) interface~operator(+)->proc~aabb_union Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/aabb_union.html"},{"title":"aabb_init – BROWNPAK","text":"public subroutine aabb_init(this, lbnd, ubnd) Initializes an aabb_t instance from lower and upper bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(out) :: this An aabb_t instance. real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound Contents None","tags":"","loc":"proc/aabb_init.html"},{"title":"aabb_print – BROWNPAK","text":"public subroutine aabb_print(this, frmt, str) Prints an AABB. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. character(len=*), intent(in), optional :: frmt Fortran-style format string for a real number. Default: (g0.6) . character(len=:), intent(out), optional allocatable :: str If present, the output is printed to this string instead of STDOUT. Calls proc~~aabb_print~~CallsGraph proc~aabb_print aabb_print interface~str_from_num str_from_num proc~aabb_print->interface~str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/aabb_print.html"},{"title":"aabb_clear – BROWNPAK","text":"public subroutine aabb_clear(this) Clears all attributes of an AABB and sets them to zero. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. Contents None","tags":"","loc":"proc/aabb_clear.html"},{"title":"aabb_get_extent – BROWNPAK","text":"public subroutine aabb_get_extent(this, extent) Calculates the extent of an aabb . The extent of an AABB is defined as\n the difference between its upper and lower bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. real(kind=rp), intent(out), dimension(3) :: extent Extent of an AABB. Contents None","tags":"","loc":"proc/aabb_get_extent.html"},{"title":"aabb_update – BROWNPAK","text":"public subroutine aabb_update(this, lbnd, ubnd) Updates an AABB with new bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in), optional dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), optional dimension(3) :: ubnd Upper bound Contents None","tags":"","loc":"proc/aabb_update.html"},{"title":"aabb_fatten – BROWNPAK","text":"public subroutine aabb_fatten(this, frac) Fattens an AABB by a fraction of its base extent. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in) :: frac Fraction of AABB base extent. Contents None","tags":"","loc":"proc/aabb_fatten.html"},{"title":"aabb_calc_center – BROWNPAK","text":"public subroutine aabb_calc_center(this) Calculates the center of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. Contents None","tags":"","loc":"proc/aabb_calc_center.html"},{"title":"aabb_calc_srfarea – BROWNPAK","text":"public subroutine aabb_calc_srfarea(this) Calculates the surface area of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. Contents None","tags":"","loc":"proc/aabb_calc_srfarea.html"},{"title":"operator(+) – BROWNPAK","text":"public interface operator(+) Calls interface~~operator(+)~~CallsGraph interface~operator(+) operator(+) proc~aabb_union aabb_union interface~operator(+)->proc~aabb_union Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures aabb_union Module Procedures public function aabb_union (x, y) result(z) Combines AABBs x and y to return a new AABB z . Arguments Type Intent Optional Attributes Name type( aabb_t ), intent(in) :: x An aabb_t instance. type( aabb_t ), intent(in) :: y An aabb_t instance. Return Value type( aabb_t )","tags":"","loc":"interface/operator(+).html"},{"title":"ia_tether_setup – BROWNPAK","text":"public subroutine ia_tether_setup(num_tether_types, tether_styles, tether_params) Sets up parameters for tether potentials Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_tether_types Number of tether types integer, intent(in), dimension(:) :: tether_styles Styles for each type real(kind=rp), intent(inout), dimension(:,:) :: tether_params Parameters for each type, depending on style Called by proc~~ia_tether_setup~~CalledByGraph proc~ia_tether_setup ia_tether_setup proc~ia_setup ia_setup proc~ia_setup->proc~ia_tether_setup proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_tether_setup.html"},{"title":"ia_get_tether_force – BROWNPAK","text":"public subroutine ia_get_tether_force(qmag, sty, params, enrg, frc, ierr) Calculates the energy and its derivative due to a tether. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: qmag Distance between the tethered atom & the tether point integer, intent(in) :: sty Tether style real(kind=rp), intent(in), dimension(:) :: params Parameters for tether interaction real(kind=rp), intent(out) :: enrg Energy due to this tether real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Error flag Calls proc~~ia_get_tether_force~~CallsGraph proc~ia_get_tether_force ia_get_tether_force proc~teth_rigid teth_rigid proc~ia_get_tether_force->proc~teth_rigid proc~teth_harm teth_harm proc~ia_get_tether_force->proc~teth_harm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_get_tether_force~~CalledByGraph proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces ia_add_tether_forces proc~ia_add_tether_forces->proc~ia_get_tether_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_get_tether_force.html"},{"title":"teth_rigid_set – BROWNPAK","text":"private subroutine teth_rigid_set(params, r0, eps) Setter for rigid tether interaction. User-set parameters: params(1) = r0 (fixed separation distance) params(2) = eps (allowed tolerance) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: r0 real(kind=rp), intent(in), optional :: eps Contents None","tags":"","loc":"proc/teth_rigid_set.html"},{"title":"teth_rigid – BROWNPAK","text":"private subroutine teth_rigid(r, params, enrg, frc, ierr) Not implemented, needs constraint formalism. See teth_rigid_set . Calculates energy for rigid tether interaction. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Called by proc~~teth_rigid~~CalledByGraph proc~teth_rigid teth_rigid proc~ia_get_tether_force ia_get_tether_force proc~ia_get_tether_force->proc~teth_rigid proc~ia_add_tether_forces ia_add_tether_forces proc~ia_add_tether_forces->proc~ia_get_tether_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/teth_rigid.html"},{"title":"teth_harm_set – BROWNPAK","text":"private subroutine teth_harm_set(params, k, r0) Setter for harmonic tether interaction. U = (1/2)*k*(r - r0)&#94;2 User-set parameters: params(1) = k (spring constant) params(2) = r0 (equilibrium distance) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 Contents None","tags":"","loc":"proc/teth_harm_set.html"},{"title":"teth_harm – BROWNPAK","text":"private subroutine teth_harm(r, params, enrg, frc) Calculates energy and its derivative for harmonic tether interaction. See teth_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Called by proc~~teth_harm~~CalledByGraph proc~teth_harm teth_harm proc~ia_get_tether_force ia_get_tether_force proc~ia_get_tether_force->proc~teth_harm proc~ia_add_tether_forces ia_add_tether_forces proc~ia_add_tether_forces->proc~ia_get_tether_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~calc_drift calc_drift proc~calc_drift->proc~ia_calc_forces proc~integrate_em integrate_em proc~integrate_em->proc~calc_drift proc~se_fval se_fval proc~se_fval->proc~calc_drift proc~bds_run bds_run proc~bds_run->proc~integrate_em proc~run run proc~run->proc~bds_run program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/teth_harm.html"},{"title":"itbl_is_in – BROWNPAK","text":"private function itbl_is_in(this, irow, val) result(res) Returns .true. if val is in row irow , .false. otherwise. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: val Return Value logical Contents None","tags":"","loc":"proc/itbl_is_in.html"},{"title":"itbl_get_val – BROWNPAK","text":"private function itbl_get_val(this, irow, j) result(res) Returns the j th element of row irow Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: j Return Value integer Contents None","tags":"","loc":"proc/itbl_get_val.html"},{"title":"itbl_init – BROWNPAK","text":"public subroutine itbl_init(this, num_rows, ierr) Creates an empty itable_t with num_rows rows and all rows having\n zero elements. Arguments Type Intent Optional Attributes Name type( itable_t ), intent(inout) :: this integer, intent(in) :: num_rows Must be > 0 integer, intent(out), optional :: ierr Calls proc~~itbl_init~~CallsGraph proc~itbl_init itbl_init interface~ivector_init ivector_init proc~itbl_init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~itbl_init~~CalledByGraph proc~itbl_init itbl_init proc~atat_build atat_build proc~atat_build->proc~itbl_init proc~exat_build exat_build proc~exat_build->proc~itbl_init proc~atan_build atan_build proc~atan_build->proc~itbl_init proc~atbo_build atbo_build proc~atbo_build->proc~itbl_init proc~pt_init pt_init proc~pt_init->proc~itbl_init proc~pt_init->proc~atat_build proc~pt_init->proc~exat_build proc~atdh_build atdh_build proc~atdh_build->proc~itbl_init proc~ia_setup ia_setup proc~ia_setup->proc~pt_init proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/itbl_init.html"},{"title":"itbl_delete – BROWNPAK","text":"private subroutine itbl_delete(this) Deletes an itable_t . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/itbl_delete.html"},{"title":"itbl_clear – BROWNPAK","text":"private subroutine itbl_clear(this) Clears all rows. Does not deallocate memory. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/itbl_clear.html"},{"title":"itbl_append – BROWNPAK","text":"private subroutine itbl_append(this, irow, val) Appends an element val to row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: val Contents None","tags":"","loc":"proc/itbl_append.html"},{"title":"itbl_set_val – BROWNPAK","text":"private subroutine itbl_set_val(this, irow, j, val) Sets the value of the j th element of row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: j integer, intent(in) :: val Contents None","tags":"","loc":"proc/itbl_set_val.html"},{"title":"itbl_get_row – BROWNPAK","text":"private subroutine itbl_get_row(this, irow, res) Returns a pointer to the row data of irow . No bounds checking is performed. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in), target :: this integer, intent(in) :: irow integer, intent(out), dimension(:), pointer :: res Contents None","tags":"","loc":"proc/itbl_get_row.html"},{"title":"itbl_shrink_to_fit – BROWNPAK","text":"private subroutine itbl_shrink_to_fit(this, ierr) Releases additional memory to fit underlying data. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/itbl_shrink_to_fit.html"},{"title":"itbl_print – BROWNPAK","text":"private subroutine itbl_print(this) Prints an itable_t . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this Contents None","tags":"","loc":"proc/itbl_print.html"},{"title":"logger_init – BROWNPAK","text":"private subroutine logger_init(this, fn, use_stdout) Initializes a logger. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(out) :: this A logger_t instance character(len=*), intent(in) :: fn Name of the log file. If use_stdout is true, fn is ignored. logical, intent(in) :: use_stdout Write all log messages to stdout rather than a file on disk? {T/F} Contents None","tags":"","loc":"proc/logger_init.html"},{"title":"logger_finish – BROWNPAK","text":"private subroutine logger_finish(this) Cleanup routine for a logger_t instance. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(inout) :: this A logger_t instance Contents None","tags":"","loc":"proc/logger_finish.html"},{"title":"logger_log_msg – BROWNPAK","text":"private subroutine logger_log_msg(this, msg) Write a message to the log file. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(in) :: this A logger_t instance character(len=*), intent(in) :: msg Message to write to the log file Calls proc~~logger_log_msg~~CallsGraph proc~logger_log_msg logger_log_msg proc~timestring timestring proc~logger_log_msg->proc~timestring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/logger_log_msg.html"},{"title":"ia_angle_setup – BROWNPAK","text":"public subroutine ia_angle_setup(num_angle_types, angle_styles, angle_params) Sets up parameters for angle potentials Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_angle_types Number of angle types integer, intent(in), dimension(:) :: angle_styles Styles for each type real(kind=rp), intent(inout), dimension(:,:) :: angle_params Parameters for each type, depending on style Called by proc~~ia_angle_setup~~CalledByGraph proc~ia_angle_setup ia_angle_setup proc~ia_setup ia_setup proc~ia_setup->proc~ia_angle_setup proc~run run proc~run->proc~ia_setup program~main main program~main->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_angle_setup.html"},{"title":"ia_get_angle_force – BROWNPAK","text":"public subroutine ia_get_angle_force(q1, q2, sty, params, enrg, fim1, fi, fip1) Calculates the energy & force due to an angle. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 integer, intent(in) :: sty real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fim1 real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fip1 Called by proc~~ia_get_angle_force~~CalledByGraph proc~ia_get_angle_force ia_get_angle_force proc~ia_add_angle_forces ia_add_angle_forces proc~ia_add_angle_forces->proc~ia_get_angle_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_get_angle_force.html"},{"title":"ang_cos_set – BROWNPAK","text":"private subroutine ang_cos_set(params, k) Setter for angular cosine interaction. U(theta) = k*(1 - cos theta), where theta is the complementary angle between bonds i & (i+1). User-set parameters: params(1) = k Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k Contents None","tags":"","loc":"proc/ang_cos_set.html"},{"title":"node_isleaf – BROWNPAK","text":"module function node_isleaf(this) result(res) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this Return Value logical Called by proc~~node_isleaf~~CalledByGraph proc~node_isleaf node_isleaf interface~node_isleaf node_isleaf interface~node_isleaf->proc~node_isleaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/node_isleaf.html"},{"title":"node_asstr – BROWNPAK","text":"module function node_asstr(this, frmt) result(buf) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Calls proc~~node_asstr~~CallsGraph proc~node_asstr node_asstr interface~str_from_num str_from_num proc~node_asstr->interface~str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~node_asstr~~CalledByGraph proc~node_asstr node_asstr interface~node_asstr node_asstr interface~node_asstr->proc~node_asstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/node_asstr.html"},{"title":"get_num_atoms – BROWNPAK","text":"module function get_num_atoms(this) result(na) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer Called by proc~~get_num_atoms~~CalledByGraph proc~get_num_atoms get_num_atoms interface~get_num_atoms get_num_atoms interface~get_num_atoms->proc~get_num_atoms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_num_atoms.html"},{"title":"get_aabb – BROWNPAK","text":"module function get_aabb(this, ia) result(aabb) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia Return Value type( aabb_t ) Called by proc~~get_aabb~~CalledByGraph proc~get_aabb get_aabb interface~get_aabb get_aabb interface~get_aabb->proc~get_aabb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_aabb.html"},{"title":"get_height – BROWNPAK","text":"module function get_height(this) result(height) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer Called by proc~~get_height~~CalledByGraph proc~get_height get_height interface~get_height get_height interface~get_height->proc~get_height Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_height.html"},{"title":"get_max_balance – BROWNPAK","text":"module function get_max_balance(this) result(max_balance) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer Called by proc~~get_max_balance~~CalledByGraph proc~get_max_balance get_max_balance interface~get_max_balance get_max_balance interface~get_max_balance->proc~get_max_balance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_max_balance.html"},{"title":"get_srfarea_ratio – BROWNPAK","text":"module function get_srfarea_ratio(this) result(saratio) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value real(kind=rp) Called by proc~~get_srfarea_ratio~~CalledByGraph proc~get_srfarea_ratio get_srfarea_ratio interface~get_srfarea_ratio get_srfarea_ratio interface~get_srfarea_ratio->proc~get_srfarea_ratio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_srfarea_ratio.html"},{"title":"balance – BROWNPAK","text":"module function balance(this, p) result(q) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: p Return Value integer Calls proc~~balance~~CallsGraph proc~balance balance nodes nodes proc~balance->nodes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~balance~~CalledByGraph proc~balance balance interface~balance balance interface~balance->proc~balance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/balance.html"},{"title":"calc_height – BROWNPAK","text":"recursive module function calc_height(this, p) result(height) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in), optional :: p Return Value integer Called by proc~~calc_height~~CalledByGraph proc~calc_height calc_height interface~calc_height calc_height interface~calc_height->proc~calc_height Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/calc_height.html"},{"title":"fs_acquire – BROWNPAK","text":"module function fs_acquire(this) result(p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Return Value integer Called by proc~~fs_acquire~~CalledByGraph proc~fs_acquire fs_acquire interface~fs_acquire fs_acquire interface~fs_acquire->proc~fs_acquire Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fs_acquire.html"},{"title":"node_init – BROWNPAK","text":"module subroutine node_init(this) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(out) :: this Called by proc~~node_init~~CalledByGraph proc~node_init node_init interface~node_init node_init interface~node_init->proc~node_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/node_init.html"},{"title":"init – BROWNPAK","text":"module subroutine init(this, natoms, tskin) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(out) :: this integer, intent(in) :: natoms real(kind=rp), intent(in) :: tskin Calls proc~~init~~CallsGraph proc~init init interface~ivector_init ivector_init proc~init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init~~CalledByGraph proc~init init interface~init init interface~init->proc~init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/init.html"},{"title":"print – BROWNPAK","text":"recursive module subroutine print(this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in), optional :: p Called by proc~~print~~CalledByGraph proc~print print interface~print print interface~print->proc~print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/print.html"},{"title":"clear – BROWNPAK","text":"module subroutine clear(this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Called by proc~~clear~~CalledByGraph proc~clear clear interface~clear clear interface~clear->proc~clear Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/clear.html"},{"title":"delete – BROWNPAK","text":"module subroutine delete(this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Called by proc~~delete~~CalledByGraph proc~delete delete interface~delete delete interface~delete->proc~delete Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/delete.html"},{"title":"insert – BROWNPAK","text":"module subroutine insert(this, ia, pos, radius) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: pos real(kind=rp), intent(in) :: radius Called by proc~~insert~~CalledByGraph proc~insert insert interface~insert insert interface~insert->proc~insert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/insert.html"},{"title":"remove – BROWNPAK","text":"module subroutine remove(this, ia) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia Called by proc~~remove~~CalledByGraph proc~remove remove interface~remove remove interface~remove->proc~remove Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/remove.html"},{"title":"remove_all – BROWNPAK","text":"module subroutine remove_all(this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Called by proc~~remove_all~~CalledByGraph proc~remove_all remove_all interface~remove_all remove_all interface~remove_all->proc~remove_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/remove_all.html"},{"title":"update_fatm – BROWNPAK","text":"module subroutine update_fatm(this, ia, pos, radius, lstat) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: pos real(kind=rp), intent(in) :: radius logical, intent(out) :: lstat Called by proc~~update_fatm~~CalledByGraph proc~update_fatm update_fatm interface~update_fatm update_fatm interface~update_fatm->proc~update_fatm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/update_fatm.html"},{"title":"update_fatmaabb – BROWNPAK","text":"module subroutine update_fatmaabb(this, ia, lbnd, ubnd, lstat) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: lbnd real(kind=rp), intent(in), dimension(3) :: ubnd logical, intent(out) :: lstat Called by proc~~update_fatmaabb~~CalledByGraph proc~update_fatmaabb update_fatmaabb interface~update_fatmaabb update_fatmaabb interface~update_fatmaabb->proc~update_fatmaabb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/update_fatmaabb.html"},{"title":"query_watm – BROWNPAK","text":"module subroutine query_watm(this, ia, nbrs) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia type( ivector_t ), intent(inout) :: nbrs Called by proc~~query_watm~~CalledByGraph proc~query_watm query_watm interface~query_watm query_watm interface~query_watm->proc~query_watm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/query_watm.html"},{"title":"query_watmaabb – BROWNPAK","text":"module subroutine query_watmaabb(this, ia, aabb, nbrs) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia type( aabb_t ), intent(in) :: aabb type( ivector_t ), intent(inout) :: nbrs Called by proc~~query_watmaabb~~CalledByGraph proc~query_watmaabb query_watmaabb interface~query_watmaabb query_watmaabb interface~query_watmaabb->proc~query_watmaabb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/query_watmaabb.html"},{"title":"query_waabb – BROWNPAK","text":"module subroutine query_waabb(this, aabb, atms) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this type( aabb_t ), intent(in) :: aabb type( ivector_t ), intent(inout) :: atms Called by proc~~query_waabb~~CalledByGraph proc~query_waabb query_waabb interface~query_waabb query_waabb interface~query_waabb->proc~query_waabb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/query_waabb.html"},{"title":"rebuild – BROWNPAK","text":"module subroutine rebuild(this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Calls proc~~rebuild~~CallsGraph proc~rebuild rebuild interface~ivector_init ivector_init proc~rebuild->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ivector_from_array->interface~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~rebuild~~CalledByGraph proc~rebuild rebuild interface~rebuild rebuild interface~rebuild->proc~rebuild Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/rebuild.html"},{"title":"validate – BROWNPAK","text":"module subroutine validate(this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Called by proc~~validate~~CalledByGraph proc~validate validate interface~validate validate interface~validate->proc~validate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/validate.html"},{"title":"insert_leaf – BROWNPAK","text":"module subroutine insert_leaf(this, leaf) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: leaf Called by proc~~insert_leaf~~CalledByGraph proc~insert_leaf insert_leaf interface~insert_leaf insert_leaf interface~insert_leaf->proc~insert_leaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/insert_leaf.html"},{"title":"remove_leaf – BROWNPAK","text":"module subroutine remove_leaf(this, leaf) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: leaf Called by proc~~remove_leaf~~CalledByGraph proc~remove_leaf remove_leaf interface~remove_leaf remove_leaf interface~remove_leaf->proc~remove_leaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/remove_leaf.html"},{"title":"fs_return – BROWNPAK","text":"module subroutine fs_return(this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: p Called by proc~~fs_return~~CalledByGraph proc~fs_return fs_return interface~fs_return fs_return interface~fs_return->proc~fs_return Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fs_return.html"},{"title":"validate_structure – BROWNPAK","text":"recursive module subroutine validate_structure(this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: p Called by proc~~validate_structure~~CalledByGraph proc~validate_structure validate_structure interface~validate_structure validate_structure interface~validate_structure->proc~validate_structure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/validate_structure.html"},{"title":"validate_metrics – BROWNPAK","text":"recursive module subroutine validate_metrics(this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: p Called by proc~~validate_metrics~~CalledByGraph proc~validate_metrics validate_metrics interface~validate_metrics validate_metrics interface~validate_metrics->proc~validate_metrics Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/validate_metrics.html"},{"title":"aabbtree_m – BROWNPAK","text":"Implements an axis-aligned bounding box (AABB) tree.\n This code is adapted from the C++ implementation by Lester Hedges . The original\n C++ implementation can be found here . Uses constants_m strings_m vector_m aabb_m module~~aabbtree_m~~UsesGraph module~aabbtree_m aabbtree_m module~vector_m vector_m module~aabbtree_m->module~vector_m module~strings_m strings_m module~aabbtree_m->module~strings_m module~constants_m constants_m module~aabbtree_m->module~constants_m module~aabb_m aabb_m module~aabbtree_m->module~aabb_m module~vector_m->module~constants_m module~qsort_m qsort_m module~vector_m->module~qsort_m module~strings_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~aabb_m->module~strings_m module~aabb_m->module~constants_m module~qsort_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: aabbtree_sm module~~aabbtree_m~~UsedByGraph module~aabbtree_m aabbtree_m module~pairtab_m pairtab_m module~pairtab_m->module~aabbtree_m module~aabbtree_sm aabbtree_sm module~aabbtree_sm->module~aabbtree_m module~interaction_m interaction_m module~interaction_m->module~pairtab_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables NULL_NODE stack Interfaces node_isleaf node_asstr get_num_atoms get_aabb get_height get_max_balance get_srfarea_ratio balance calc_height fs_acquire node_init init print clear delete insert remove remove_all update_fatm update_fatmaabb query_watm query_watmaabb query_waabb rebuild validate insert_leaf remove_leaf fs_return validate_structure validate_metrics Derived Types node_t aabbtree_t Variables Type Visibility Attributes Name Initial integer, private, parameter :: NULL_NODE = 0 type( ivector_t ), private :: stack Interfaces interface private module function node_isleaf(this) result(res) Implementation → Is this a leaf node? Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. Return Value logical true if this is a leaf node, false otherwise. interface private module function node_asstr(this, frmt) result(buf) Implementation → Returns a string representation of a node. Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. character(len=*), intent(in), optional :: frmt Format string for real numbers, e.g. '(f15.6)'. Default: (g0.6) . Return Value character(len=:),\n  allocatable Return value interface private module function get_num_atoms(this) result(na) Implementation → Returns the number of atoms in an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value interface private module function get_aabb(this, ia) result(aabb) Implementation → Returns a copy of the AABB associated with atom with index ia . Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. Return Value type( aabb_t ) AABB of atom ia . interface private module function get_height(this) result(height) Implementation → Returns the height of an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. interface private module function get_max_balance(this) result(max_balance) Implementation → Returns the maximum difference between the height of two children\n of a node. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. interface private module function get_srfarea_ratio(this) result(saratio) Implementation → Returns the ratio of the sum of the node surface area to the surface\n area of the root node. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value real(kind=rp) Return value. interface private module function balance(this, p) result(q) Implementation → Balances an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node index Return Value integer interface private recursive module function calc_height(this, p) result(height) Implementation → Calculates the height of a subtree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default: Root of the whole\n tree. Return Value integer Return value interface private module function fs_acquire(this) result(p) Implementation → Acquires a new node from the free store and returns a pointer to it. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Return Value integer Return value interface private module subroutine node_init(this) Implementation → Initializes a node. Arguments Type Intent Optional Attributes Name class( node_t ), intent(out) :: this A node_t instance. interface private module subroutine init(this, natoms, tskin) Implementation → Initializes an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(out) :: this An aabbtree_t instance. integer, intent(in) :: natoms Estimated number of atoms to be handled by this tree. real(kind=rp), intent(in) :: tskin Thickness of the skin for fattened AABBs, as a fraction of the\n AABB base length. interface private recursive module subroutine print(this, p) Implementation → Prints a subtree of an AABB tree rooted at p in order. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default is the root of the\n whole tree. interface private module subroutine clear(this) Implementation → Clears an AABB tree. Associated memory is not deallocated. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. interface private module subroutine delete(this) Implementation → Deletes an AABB tree. All associated memory is deallocated. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. interface private module subroutine insert(this, ia, pos, radius) Implementation → Inserts an atom into an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) interface private module subroutine remove(this, ia) Implementation → Removes an atom from an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index interface private module subroutine remove_all(this) Implementation → Removes all atoms from an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. interface private module subroutine update_fatm(this, ia, pos, radius, lstat) Implementation → Updates an AABB tree for the case when an atom leaves its fattened\n AABB. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. interface private module subroutine update_fatmaabb(this, ia, lbnd, ubnd, lstat) Implementation → Updates an AABB tree for the case when an atom leaves its fattened\n AABB, with the bounds of the new AABB for the atom as input. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound of atom AABB real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound of atom AABB logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. interface private module subroutine query_watm(this, ia, nbrs) Implementation → Query an AABB tree for a set of potential neighbors of an atom. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. interface private module subroutine query_watmaabb(this, ia, aabb, nbrs) Implementation → Query an AABB tree for a set of potential neighbors of an atom & its\n bounding AABB. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. type( aabb_t ), intent(in) :: aabb Bounding AABB for atom with index ia . type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. interface private module subroutine query_waabb(this, aabb, atms) Implementation → Query an AABB tree for the set of atoms whose AABBS overlap with aabb . Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. type( aabb_t ), intent(in) :: aabb An aabb_t instance. type( ivector_t ), intent(inout) :: atms List of potential neighbors. interface private module subroutine rebuild(this) Implementation → Rebuilds an optimal AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. interface private module subroutine validate(this) Implementation → Validates an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. interface private module subroutine insert_leaf(this, leaf) Implementation → Inserts a leaf node into a tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node interface private module subroutine remove_leaf(this, leaf) Implementation → Removes a leaf node from a tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node interface private module subroutine fs_return(this, p) Implementation → Returns a node to the free store. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node pointer. interface private recursive module subroutine validate_structure(this, p) Implementation → Asserts that an AABB subtree has a valid structure. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. interface private recursive module subroutine validate_metrics(this, p) Implementation → Asserts that an AABB subtree has a valid metric. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. Derived Types type, private :: node_t Components Type Visibility Attributes Name Initial integer, public :: next = NULL_NODE integer, public :: parent = NULL_NODE integer, public :: left = NULL_NODE integer, public :: right = NULL_NODE integer, public :: height = -1 integer, public :: atom = 0 type( aabb_t ), public :: aabb Type-Bound Procedures procedure, public :: init => node_init procedure, public :: isleaf => node_isleaf procedure, public :: asstr => node_asstr type, public :: aabbtree_t Components Type Visibility Attributes Name Initial type( node_t ), public, dimension(:), allocatable :: nodes integer, public, dimension(:), allocatable :: atnd_tab Atom -> node map. integer, public :: capacity Maximum number of nodes that the tree can currently handle. This may\n increase as more atoms are inserted. integer, public :: freestore Pointer to head to the free store. integer, public :: size Number of nodes in the tree. integer, public :: root Pointer to the tree root. real(kind=rp), public :: tskin Thickness of the skin for fattened AABBs, as a fraction of the AABB\n base length. Type-Bound Procedures procedure, public :: init procedure, public :: print procedure, public :: clear procedure, public :: delete procedure, public :: insert procedure, public :: remove procedure, public :: remove_all procedure, public :: update_fatm procedure, public :: update_fatmaabb generic, public :: update => update_fatm, update_fatmaabb procedure, public :: query_watm procedure, public :: query_waabb procedure, public :: query_watmaabb generic, public :: query => query_watm, query_waabb, query_watmaabb procedure, public :: get_num_atoms procedure, public :: get_aabb procedure, public :: get_height procedure, public :: get_max_balance procedure, public :: get_srfarea_ratio procedure, public :: rebuild procedure, public :: validate procedure, private :: insert_leaf procedure, private :: remove_leaf procedure, private :: balance procedure, private :: calc_height procedure, private :: fs_acquire procedure, private :: fs_return procedure, private :: validate_structure procedure, private :: validate_metrics","tags":"","loc":"module/aabbtree_m.html"},{"title":"cell_list_m – BROWNPAK","text":"Sorts atoms using a cell list. The algorithm to build the cell list partially follows the techniques in Watanabe et\n al, 2011, “Efficient Implementations of Molecular Dynamics Simulations for\n Lennard-Jones Systems,” Prog. Theor. Phys. 126, 203–235. The pairlist is not explicitly built, rather the cells are directly\n looped over during force calculation. Uses constants_m vector_m simbox_m module~~cell_list_m~~UsesGraph module~cell_list_m cell_list_m module~constants_m constants_m module~cell_list_m->module~constants_m module~simbox_m simbox_m module~cell_list_m->module~simbox_m module~vector_m vector_m module~cell_list_m->module~vector_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~simbox_m->module~constants_m module~random_m random_m module~simbox_m->module~random_m module~vector_m->module~constants_m module~qsort_m qsort_m module~vector_m->module~qsort_m module~qsort_m->module~constants_m module~random_m->module~constants_m mkl_vsl_type mkl_vsl_type module~random_m->mkl_vsl_type mkl_vsl mkl_vsl module~random_m->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~cell_list_m~~UsedByGraph module~cell_list_m cell_list_m module~pairtab_m pairtab_m module~pairtab_m->module~cell_list_m module~interaction_m interaction_m module~interaction_m->module~pairtab_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cell_size nc_max nc nct_max nct cells cells_pos cell_nbrs cell_nbrs_pos host_cells cell_pop d Functions cl_get_num_cells Subroutines cl_init cl_set_cell_size cl_build_cell_nbrs cl_delete cl_build cl_get_contents cl_get_nbr_cells cl_print Variables Type Visibility Attributes Name Initial real(kind=rp), private, dimension(3) :: cell_size = 0.0_rp Cell size along x , y , & z . integer, private, dimension(3) :: nc_max = 0 Maximum number of cells along x , y , & z . integer, private, dimension(3) :: nc = 0 Number of cells along x , y , & z . integer, private :: nct_max = 0 Maximum total number of cells. integer, private :: nct = 0 Total of cells. integer, private, dimension(:), allocatable, target :: cells (na_max,) array. Listing atoms in each cell. integer, private, dimension(:), allocatable :: cells_pos (0:nct_max,) index array. Note: 0-based indexing. type( ivector_t ), private :: cell_nbrs Lists neighbor cells for each cell. integer, private, dimension(:), allocatable :: cell_nbrs_pos (0:nct_max,) index array. Note: 0-based indexing. integer, private, dimension(:), allocatable :: host_cells (na_max,) array. host_cells(i) stores the linear index of the cell\n containing atom i . na_max is the total number of atoms under consideration. integer, private, dimension(:), allocatable :: cell_pop (0:nct_max-1,) array storing population of each cell. Note: 0-based indexing. integer, private, parameter, dimension(3,13) :: d = reshape([1, 0, 0, 1, 1, 0, -1, 1, 0, 0, 1, 0, 0, 0, 1, -1, 0, 1, 1, 0, 1, -1, -1, 1, 0, -1, 1, 1, -1, 1, -1, 1, 1, 0, 1, 1, 1, 1, 1], [3, 13]) Functions public function cl_get_num_cells () result(res) Returns the total number of cells Arguments None Return Value integer Subroutines public subroutine cl_init (na_max, cs_min, simbox) Initializes a cell list. Arguments Type Intent Optional Attributes Name integer, intent(in) :: na_max Maximum number of atoms to be handled. real(kind=rp), intent(in) :: cs_min Minimum size (i.e. length) of a cell. type( smbx_t ), intent(in) :: simbox Simulation box public subroutine cl_set_cell_size (cs, simbox) Sets the cell size. The actual cell size may be slightly larger. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: cs type( smbx_t ), intent(in) :: simbox public subroutine cl_build_cell_nbrs () Makes a table of neighboring cells. Arguments None public subroutine cl_delete () Deallocates memory allocated in cl_init . Arguments None public subroutine cl_build (coords) Sorts atoms into cells for calculating short-range interations Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: coords public subroutine cl_get_contents (ic, res) Returns a pointer to the entries of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res public subroutine cl_get_nbr_cells (ic, res) Returns a pointer to the neighbor cells of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res public subroutine cl_print () Prints a cell list Arguments None","tags":"","loc":"module/cell_list_m.html"},{"title":"simbox_m – BROWNPAK","text":"Implements a simulation box with appropriate boundary conditions. Uses constants_m random_m module~~simbox_m~~UsesGraph module~simbox_m simbox_m module~constants_m constants_m module~simbox_m->module~constants_m module~random_m random_m module~simbox_m->module~random_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~random_m->module~constants_m mkl_vsl_type mkl_vsl_type module~random_m->mkl_vsl_type mkl_vsl mkl_vsl module~random_m->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~simbox_m~~UsedByGraph module~simbox_m simbox_m module~setup_m setup_m module~setup_m->module~simbox_m module~config_io_m config_io_m module~setup_m->module~config_io_m module~stats_m stats_m module~setup_m->module~stats_m module~interaction_m interaction_m module~setup_m->module~interaction_m module~bd_solver_m bd_solver_m module~setup_m->module~bd_solver_m module~pairtab_m pairtab_m module~pairtab_m->module~simbox_m module~cell_list_m cell_list_m module~pairtab_m->module~cell_list_m module~config_io_m->module~simbox_m module~cell_list_m->module~simbox_m module~stats_m->module~simbox_m module~interaction_m->module~simbox_m module~interaction_m->module~pairtab_m module~interaction_m->module~stats_m module~bd_solver_m->module~config_io_m module~bd_solver_m->module~stats_m module~bd_solver_m->module~interaction_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types smbx_t Subroutines smbx_init smbx_set_basis smbx_freeze smbx_unfreeze smbx_get_image smbx_wrap_all smbx_to_center smbx_to_origin smbx_get_rnd_points Derived Types type, public :: smbx_t Components Type Visibility Attributes Name Initial integer, public :: imcon real(kind=rp), public, dimension(3,3) :: basis real(kind=rp), public, dimension(3,3) :: dl_basis real(kind=rp), public :: volume logical, public :: is_deforming logical, public :: is_aligned Whether the basis vectors are aligned with the laboratory frame Type-Bound Procedures procedure, public :: init => smbx_init procedure, public :: set_basis => smbx_set_basis procedure, public :: freeze => smbx_freeze procedure, public :: unfreeze => smbx_unfreeze procedure, public :: get_image => smbx_get_image procedure, public :: wrap_all => smbx_wrap_all procedure, public :: to_center => smbx_to_center procedure, public :: to_origin => smbx_to_origin procedure, public :: get_rnd_points => smbx_get_rnd_points Subroutines public subroutine smbx_init (this, imcon) Initializes an instance of smbx_t . Can also be called to reset. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(out) :: this An instance of smbx_t . integer, intent(in) :: imcon Flag specifying boundary conditions on the simulation box. Read more… public subroutine smbx_set_basis (this, bv) Sets all three basis vectors. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(3,3) :: bv public subroutine smbx_freeze (this) Specifies this as non-deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this public subroutine smbx_unfreeze (this) Specifies this as deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this public subroutine smbx_get_image (this, r) Returns the image of r under PBC. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(3) :: r public subroutine smbx_wrap_all (this, coords) Wraps atom positions w.r.t. periodic boundary conditions. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords public subroutine smbx_to_center (this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the center \n of the box. Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com public subroutine smbx_to_origin (this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the origin.\n Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com public subroutine smbx_get_rnd_points (this, coords) Returns uniformly distributed points within the box. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(out), dimension(:,:) :: coords","tags":"","loc":"module/simbox_m.html"},{"title":"ia_external_m – BROWNPAK","text":"External potentials This module is meant to be a placeholder to any external fields that the user\n wants to add. Accordingly replace/add to the existing routines. The\n subroutines ia_external_setup and ia_add_external_forces must remain\n for interfacing to the force calculation driver routine ia_calc_forces . Style 0: None Style 1: Pulling force along +ve x-axis Style 2: Hard planar wall Uses constants_m atmcfg_m module~~ia_external_m~~UsesGraph module~ia_external_m ia_external_m module~constants_m constants_m module~ia_external_m->module~constants_m module~atmcfg_m atmcfg_m module~ia_external_m->module~atmcfg_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~atmcfg_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ia_external_m~~UsedByGraph module~ia_external_m ia_external_m module~interaction_m interaction_m module~interaction_m->module~ia_external_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_external_setup ia_add_external_forces Subroutines public subroutine ia_external_setup (num_externals, external_styles, external_params) Sets up parameters for external potentials. Usually there is nothing to\n set for externals, but this acts as a placeholder for special cases. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_externals Number of external fields integer, intent(in), dimension(:) :: external_styles Styles for each field real(kind=rp), intent(inout), dimension(:,:) :: external_params Parameters for each field, depending on style public subroutine ia_add_external_forces (num_externals, external_styles, external_params, coordinates, energy_external, forces, stress, ierr) Calculates the force and energy due to an external field and adds to energy_external , 'forces , & stress`. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_externals Number of external fields integer, intent(in), dimension(:) :: external_styles Styles for each field real(kind=rp), intent(inout), dimension(:,:) :: external_params Parameters for each field, depending on style real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(out) :: energy_external real(kind=rp), intent(inout), dimension(:,:) :: forces real(kind=rp), intent(inout), dimension(3,3) :: stress integer, intent(out) :: ierr","tags":"","loc":"module/ia_external_m.html"},{"title":"trajectory_m – BROWNPAK","text":"Routines for reading and writing frames from a trajectory file. Uses constants_m module~~trajectory_m~~UsesGraph module~trajectory_m trajectory_m module~constants_m constants_m module~trajectory_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~trajectory_m~~UsedByGraph module~trajectory_m trajectory_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~trajectory_m module~setup_m setup_m module~setup_m->module~trajectory_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables traj Derived Types trajectory_t Subroutines traj_create traj_open traj_delete traj_close traj_read traj_append_frame traj_write_frame Variables Type Visibility Attributes Name Initial type( trajectory_t ), public :: traj Derived Types type, private :: trajectory_t Components Type Visibility Attributes Name Initial integer, public :: header_size = 0 integer, public :: frame_size = 0 integer, public :: num_atoms = 0 integer, public, dimension(4) :: frmcmp = 0 character(len=:), public, allocatable :: fn integer, public :: file_id = 0 integer, public :: num_frames = 0 logical, public :: isopen = .false. Type-Bound Procedures procedure, public :: create => traj_create procedure, public :: open => traj_open procedure, public :: delete => traj_delete procedure, public :: close => traj_close procedure, public :: read => traj_read procedure, public :: append_frame => traj_append_frame procedure, public :: write_frame => traj_write_frame generic, public :: init => create, open Subroutines private subroutine traj_create (this, fn, na, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of atoms integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges private subroutine traj_open (this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr private subroutine traj_delete (this) After a call to this subroutine, all memory within this is deallocated,\n all components of this are reset to zero, and the underlying file is\n closed (if open). Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this private subroutine traj_close (this) Closes the underlying file of a trajectory_t . Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this private subroutine traj_read (this, iframe, nts, ierr, coordinates, velocities, forces, charge) Read from an open trajectory. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(in) :: this integer, intent(in) :: iframe Frame number integer(kind=ip_long), intent(out) :: nts Time step counter integer, intent(out) :: ierr Error flag real(kind=rp), intent(out), optional dimension(:,:) :: coordinates real(kind=rp), intent(out), optional dimension(:,:) :: velocities real(kind=rp), intent(out), optional dimension(:,:) :: forces real(kind=rp), intent(out), optional dimension(:) :: charge private subroutine traj_append_frame (this, nts, coordinates) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates private subroutine traj_write_frame (this, iframe, nts, coordinates) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer, intent(in) :: iframe integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates","tags":"","loc":"module/trajectory_m.html"},{"title":"ia_dihedral_m – BROWNPAK","text":"Dihedral potentials (none implemented) Uses constants_m atmcfg_m module~~ia_dihedral_m~~UsesGraph module~ia_dihedral_m ia_dihedral_m module~constants_m constants_m module~ia_dihedral_m->module~constants_m module~atmcfg_m atmcfg_m module~ia_dihedral_m->module~atmcfg_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~atmcfg_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ia_dihedral_m~~UsedByGraph module~ia_dihedral_m ia_dihedral_m module~interaction_m interaction_m module~interaction_m->module~ia_dihedral_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_dihedral_setup ia_get_dihedral_force Subroutines public subroutine ia_dihedral_setup (num_dihedral_types, dihedral_styles, dihedral_params) Sets up parameters for dihedral potentials Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_dihedral_types Number of dihedral types integer, intent(in), dimension(:) :: dihedral_styles Styles for each type real(kind=rp), intent(inout), dimension(:,:) :: dihedral_params Parameters for each type, depending on style public subroutine ia_get_dihedral_force (q1, q2, q3, sty, params, enrg, fi, fj, fk, fl) Calculates the force & energy due to a dihedral. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 real(kind=rp), intent(in), dimension(3) :: q3 integer, intent(in) :: sty real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fj real(kind=rp), intent(out), dimension(3) :: fk real(kind=rp), intent(out), dimension(3) :: fl","tags":"","loc":"module/ia_dihedral_m.html"},{"title":"qsort_m – BROWNPAK","text":"Implements quicksort for a sequence of integers and reals, in combination with\n  insertion sort for very short sequences. Quick sort routine from Brainerd, W.S., Goldberg, C.H. & Adams, J.C. (1990)\n \"Programmer's Guide to Fortran 90\", McGraw-Hill  ISBN 0-07-000248-7, pages 149-150. Modified by Alan Miller to include an associated integer array which gives\n   the positions of the elements in the original order. Modified for integer array by Sarit Dutta Uses constants_m module~~qsort_m~~UsesGraph module~qsort_m qsort_m module~constants_m constants_m module~qsort_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~qsort_m~~UsedByGraph module~qsort_m qsort_m module~vector_m vector_m module~vector_m->module~qsort_m module~connectivity_m connectivity_m module~connectivity_m->module~vector_m module~table_m table_m module~connectivity_m->module~table_m module~table_m->module~vector_m module~pairtab_m pairtab_m module~pairtab_m->module~vector_m module~pairtab_m->module~connectivity_m module~pairtab_m->module~table_m module~cell_list_m cell_list_m module~pairtab_m->module~cell_list_m module~aabbtree_m aabbtree_m module~pairtab_m->module~aabbtree_m module~cell_list_m->module~vector_m module~aabbtree_m->module~vector_m module~aabbtree_sm aabbtree_sm module~aabbtree_sm->module~aabbtree_m module~interaction_m interaction_m module~interaction_m->module~table_m module~interaction_m->module~pairtab_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines iqsort dqsort Subroutines public subroutine iqsort (list, order) Sorts a sequence of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), DIMENSION (:) :: list Sequence of integers to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence public subroutine dqsort (list, order) Sorts a sequence of reals Arguments Type Intent Optional Attributes Name real(kind=RP), intent(inout), DIMENSION (:) :: list Sequence of reals to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence","tags":"","loc":"module/qsort_m.html"},{"title":"ia_vdw_m – BROWNPAK","text":"Routines to evaulate pairwise potentials and their derivative. The following styles are available: Style 1. 12-6 LJ. See vdw_lj_set . Style 2. Gaussian. See vdw_gaussian_set . Style 3. Cosine. See vdw_cosine_set . Style 4. Screened Coulomb + LJ. See vdw_lj_coul_debye_set . Style 5. Coulomb + LJ. See vdw_lj_coul_set . Style 6. Standard DPD. See vdw_dpd_set . Uses constants_m atmcfg_m module~~ia_vdw_m~~UsesGraph module~ia_vdw_m ia_vdw_m module~constants_m constants_m module~ia_vdw_m->module~constants_m module~atmcfg_m atmcfg_m module~ia_vdw_m->module~atmcfg_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~atmcfg_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ia_vdw_m~~UsedByGraph module~ia_vdw_m ia_vdw_m module~interaction_m interaction_m module~interaction_m->module~ia_vdw_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_vdw_setup ia_get_vdw_force vdw_lj_set vdw_lj vdw_gaussian_set vdw_gaussian vdw_cosine_set vdw_cosine vdw_lj_coul_debye_set vdw_lj_coul_debye vdw_lj_coul_set vdw_lj_coul vdw_dpd_set vdw_dpd Subroutines public subroutine ia_vdw_setup (num_vdw_types, vdw_styles, vdw_params) Sets up parameters for vdw potentials Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_vdw_types Number of types of vdw interactions integer, intent(in), dimension(:) :: vdw_styles Styles for each type real(kind=rp), intent(inout), dimension(:,:) :: vdw_params Parameters for each type, depending on style public subroutine ia_get_vdw_force (rij_mag, qi, qj, sty, params, enrg, frc, ierr) Calculates the energy & its derivative due to a single interacting pair of atoms. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between two atoms real(kind=rp), intent(in) :: qi Charge on atom i real(kind=rp), intent(in) :: qj Charge on atom j integer, intent(in) :: sty Style of vdw interaction real(kind=rp), intent(in), dimension(:) :: params Parameters for vdw interaction real(kind=rp), intent(out) :: enrg Energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of force due to\n this potential. integer, intent(out) :: ierr Error flag private subroutine vdw_lj_set (params, eps, sigma, rcut) Setter for 12-6 LJ (truncated & force-shifted) interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut private pure subroutine vdw_lj (r, params, enrg, frc) Evaluates the potential and its derivative for LJ interaction. See vdw_lj_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_gaussian_set (params, A, B, rcut) Setter for gaussian interaction. The potential is truncated and\n force-shifted. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: B real(kind=rp), intent(in), optional :: rcut private pure subroutine vdw_gaussian (r, params, enrg, frc) Calculates energy & its derivative for gaussian interaction. See vdw_gaussian_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_cosine_set (params, A, rcut) Setter for cosine interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: rcut private pure subroutine vdw_cosine (r, params, enrg, frc) Evaluates the potential and its derivative for  cosine interaction.\n See vdw_cosine_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_lj_coul_debye_set (params, eps, sigma, rcut, rcut_coul, C, kappa) Setter for 12-6 LJ with screened Coulombic interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C real(kind=rp), intent(in), optional :: kappa private pure subroutine vdw_lj_coul_debye (r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for screened Coulombic interaction\ncombined with 12-6 LJ (cut & shifted). See vdw_lj_coul_debye_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_lj_coul_set (params, eps, sigma, rcut, rcut_coul, C) Setter for 12-6 LJ with Coulombic interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C private pure subroutine vdw_lj_coul (r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for Coulombic interaction\n combined with 12-6 LJ (cut & shifted). See vdw_lj_coul_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_dpd_set (params, A, rcut) Setter for standard DPD interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: rcut private pure subroutine vdw_dpd (r, params, enrg, frc) Evaluates the potential and its derivative for standard DPD interaction.\n See vdw_dpd_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc","tags":"","loc":"module/ia_vdw_m.html"},{"title":"vector_m – BROWNPAK","text":"Implements a vector as an extendable array. Uses constants_m qsort_m module~~vector_m~~UsesGraph module~vector_m vector_m module~constants_m constants_m module~vector_m->module~constants_m module~qsort_m qsort_m module~vector_m->module~qsort_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~qsort_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~vector_m~~UsedByGraph module~vector_m vector_m module~connectivity_m connectivity_m module~connectivity_m->module~vector_m module~table_m table_m module~connectivity_m->module~table_m module~table_m->module~vector_m module~pairtab_m pairtab_m module~pairtab_m->module~vector_m module~pairtab_m->module~connectivity_m module~pairtab_m->module~table_m module~cell_list_m cell_list_m module~pairtab_m->module~cell_list_m module~aabbtree_m aabbtree_m module~pairtab_m->module~aabbtree_m module~cell_list_m->module~vector_m module~aabbtree_m->module~vector_m module~aabbtree_sm aabbtree_sm module~aabbtree_sm->module~aabbtree_m module~interaction_m interaction_m module~interaction_m->module~table_m module~interaction_m->module~pairtab_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces ivector_init dvector_init assignment(=) Derived Types ivector_t dvector_t Functions ivector_get_len dvector_get_len ivector_get_val dvector_get_val ivector_pop dvector_pop Subroutines ivector_init dvector_init ivector_from_array dvector_from_array ivector_delete dvector_delete ivector_clear dvector_clear ivector_assign dvector_assign i_dvector_assign ivector_set_val dvector_set_val ivector_append dvector_append ivector_get_data dvector_get_data ivector_resize dvector_resize ivector_shrink_to_fit dvector_shrink_to_fit ivector_sort dvector_sort ivector_unique dvector_unique ivector_print dvector_print Interfaces public interface ivector_init public interface ivector_init () Arguments None public subroutine ivector_from_array (this, x) Creates an ivector with all elements from an array Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), dimension(:) :: x public interface dvector_init public interface dvector_init () Arguments None public subroutine dvector_from_array (this, x) Creates a dvector with all elements from an array Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(:) :: x public interface assignment(=) public subroutine ivector_assign (this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine dvector_assign (this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other public subroutine i_dvector_assign (this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other Derived Types type, public :: ivector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 integer, public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => ivector_delete procedure, public :: clear => ivector_clear procedure, public :: get_val => ivector_get_val procedure, public :: set_val => ivector_set_val procedure, public :: get_data => ivector_get_data procedure, public :: append => ivector_append procedure, public :: pop => ivector_pop procedure, public :: resize => ivector_resize procedure, public :: shrink_to_fit => ivector_shrink_to_fit procedure, public :: sort => ivector_sort procedure, public :: unique => ivector_unique procedure, public :: print => ivector_print type, public :: dvector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 real(kind=rp), public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => dvector_delete procedure, public :: clear => dvector_clear procedure, public :: get_val => dvector_get_val procedure, public :: set_val => dvector_set_val procedure, public :: get_data => dvector_get_data procedure, public :: append => dvector_append procedure, public :: pop => dvector_pop procedure, public :: resize => dvector_resize procedure, public :: shrink_to_fit => dvector_shrink_to_fit procedure, public :: sort => dvector_sort procedure, public :: unique => dvector_unique procedure, public :: print => dvector_print Functions public function ivector_get_len (this) result(res) Returns the length of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Return Value integer public function dvector_get_len (this) result(res) Returns the length of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Return Value integer public function ivector_get_val (this, i) result(res) Returns the ith element of an ivector . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this integer, intent(in) :: i Return Value integer public function dvector_get_val (this, i) result(res) Returns the ith element of a dvector . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rp) public function ivector_pop (this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Return Value integer public function dvector_pop (this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Return Value real(kind=rp) Subroutines public subroutine ivector_init (this, len_init, ierr) Creates an empty ivector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr public subroutine dvector_init (this, len_init, ierr) Creates an empty dvector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr public subroutine ivector_from_array (this, x) Creates an ivector with all elements from an array Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), dimension(:) :: x public subroutine dvector_from_array (this, x) Creates a dvector with all elements from an array Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(:) :: x public subroutine ivector_delete (this) Deletes an ivector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this public subroutine dvector_delete (this) Deletes a dvector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this public subroutine ivector_clear (this) Clears an ivector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this public subroutine dvector_clear (this) Clears a dvector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this public subroutine ivector_assign (this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine dvector_assign (this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other public subroutine i_dvector_assign (this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine ivector_set_val (this, i, val) Sets the value of the ith element of an ivector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: val public subroutine dvector_set_val (this, i, val) Sets the value of the ith element of a dvector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: i real(kind=rp), intent(in) :: val public subroutine ivector_append (this, val) Adds an element to the end of an ivector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: val public subroutine dvector_append (this, val) Adds an element to the end of a dvector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this real(kind=rp), intent(in) :: val public subroutine ivector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in), target :: this integer, intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend public subroutine dvector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in), target :: this real(kind=rp), intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend public subroutine ivector_resize (this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr public subroutine dvector_resize (this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr public subroutine ivector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of an ivector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional :: ierr public subroutine dvector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of a dvector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional :: ierr public subroutine ivector_sort (this, order) Sorts an ivector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order public subroutine dvector_sort (this, order) Sorts a dvector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order public subroutine ivector_unique (this) Sorts and removes all duplicate entries of an ivector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call ivector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this public subroutine dvector_unique (this) Sorts and removes all duplicate entries of a dvector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call dvector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this public subroutine ivector_print (this) Prints an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this public subroutine dvector_print (this) Prints a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this","tags":"","loc":"module/vector_m.html"},{"title":"timestamp_m – BROWNPAK","text":"Used by module~~timestamp_m~~UsedByGraph module~timestamp_m timestamp_m module~logger_m logger_m module~logger_m->module~timestamp_m module~ia_bond_m ia_bond_m module~ia_bond_m->module~logger_m program~main main program~main->module~logger_m module~setup_m setup_m program~main->module~setup_m module~setup_m->module~logger_m module~bd_solver_m bd_solver_m module~setup_m->module~bd_solver_m module~interaction_m interaction_m module~setup_m->module~interaction_m module~brown_m brown_m module~brown_m->module~logger_m module~bd_solver_m->module~logger_m module~bd_solver_m->module~brown_m module~bd_solver_m->module~interaction_m module~interaction_m->module~ia_bond_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines hms_current_hms hms_current_print hms_current_string hms_delta_print timestamp timestring Subroutines public subroutine hms_current_hms (h, m, s, mm) HMS_CURRENT_HMS returns the current HMS time as integers. Read more… Arguments Type Intent Optional Attributes Name integer(kind=4) :: h integer(kind=4) :: m integer(kind=4) :: s integer(kind=4) :: mm public subroutine hms_current_print (string) HMS_CURRENT_PRINT prints the current HMS time, and a user specified string. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: string public subroutine hms_current_string (string) HMS_CURRENT_STRING writes the current HMS data into a string. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: string public subroutine hms_delta_print (string) HMS_DELTA_PRINT prints the change in HMS time, and a user specified string. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: string public subroutine timestamp () TIMESTAMP prints the current YMDHMS date as a time stamp. Read more… Arguments None public subroutine timestring (string) TIMESTRING writes the current YMDHMS date into a string. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: string","tags":"","loc":"module/timestamp_m.html"},{"title":"interaction_m – BROWNPAK","text":"Driver routines for force & energy calculation. Uses constants_m table_m simbox_m pairtab_m ia_bond_m ia_angle_m ia_dihedral_m ia_vdw_m ia_tether_m ia_external_m control_m atmcfg_m stats_m module~~interaction_m~~UsesGraph module~interaction_m interaction_m module~ia_dihedral_m ia_dihedral_m module~interaction_m->module~ia_dihedral_m module~ia_bond_m ia_bond_m module~interaction_m->module~ia_bond_m module~ia_vdw_m ia_vdw_m module~interaction_m->module~ia_vdw_m module~ia_external_m ia_external_m module~interaction_m->module~ia_external_m module~ia_angle_m ia_angle_m module~interaction_m->module~ia_angle_m module~table_m table_m module~interaction_m->module~table_m module~simbox_m simbox_m module~interaction_m->module~simbox_m module~constants_m constants_m module~interaction_m->module~constants_m module~pairtab_m pairtab_m module~interaction_m->module~pairtab_m module~ia_tether_m ia_tether_m module~interaction_m->module~ia_tether_m module~atmcfg_m atmcfg_m module~interaction_m->module~atmcfg_m module~stats_m stats_m module~interaction_m->module~stats_m module~control_m control_m module~interaction_m->module~control_m module~ia_dihedral_m->module~constants_m module~ia_dihedral_m->module~atmcfg_m module~ia_bond_m->module~constants_m module~logger_m logger_m module~ia_bond_m->module~logger_m module~strings_m strings_m module~ia_bond_m->module~strings_m module~ia_vdw_m->module~constants_m module~ia_vdw_m->module~atmcfg_m module~ia_external_m->module~constants_m module~ia_external_m->module~atmcfg_m module~ia_angle_m->module~constants_m module~ia_angle_m->module~atmcfg_m module~table_m->module~constants_m module~vector_m vector_m module~table_m->module~vector_m module~simbox_m->module~constants_m module~random_m random_m module~simbox_m->module~random_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~pairtab_m->module~table_m module~pairtab_m->module~simbox_m module~pairtab_m->module~constants_m module~pairtab_m->module~atmcfg_m module~connectivity_m connectivity_m module~pairtab_m->module~connectivity_m module~pairtab_m->module~vector_m module~cell_list_m cell_list_m module~pairtab_m->module~cell_list_m module~aabbtree_m aabbtree_m module~pairtab_m->module~aabbtree_m module~ia_tether_m->module~constants_m module~ia_tether_m->module~atmcfg_m module~atmcfg_m->module~constants_m module~stats_m->module~simbox_m module~stats_m->module~constants_m module~stats_m->module~atmcfg_m module~stats_m->module~control_m module~stats_m->module~strings_m module~control_m->module~constants_m module~control_m->module~strings_m module~connectivity_m->module~table_m module~connectivity_m->module~constants_m module~connectivity_m->module~vector_m module~logger_m->iso_fortran_env module~timestamp_m timestamp_m module~logger_m->module~timestamp_m module~vector_m->module~constants_m module~qsort_m qsort_m module~vector_m->module~qsort_m module~strings_m->module~constants_m module~cell_list_m->module~simbox_m module~cell_list_m->module~constants_m module~cell_list_m->module~vector_m module~random_m->module~constants_m mkl_vsl_type mkl_vsl_type module~random_m->mkl_vsl_type mkl_vsl mkl_vsl module~random_m->mkl_vsl module~aabbtree_m->module~constants_m module~aabbtree_m->module~vector_m module~aabbtree_m->module~strings_m module~aabb_m aabb_m module~aabbtree_m->module~aabb_m module~qsort_m->module~constants_m module~aabb_m->module~constants_m module~aabb_m->module~strings_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~interaction_m~~UsedByGraph module~interaction_m interaction_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables pair_tab lvdw Subroutines ia_setup ia_finish ia_calc_forces ia_add_vdw_forces ia_add_bond_forces ia_add_angle_forces ia_add_dihedral_forces ia_add_tether_forces Variables Type Visibility Attributes Name Initial type( itable_t ), private :: pair_tab logical, private :: lvdw Subroutines public subroutine ia_setup (cpar, simbox, atc) Builds necessary neighbor tables and sets up parameters for potentials. Arguments Type Intent Optional Attributes Name type( ctrlpar_t ), intent(in) :: cpar type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc public subroutine ia_finish () Cleanup routine for interaction calculation. Arguments None public subroutine ia_calc_forces (simbox, atc, ierr) Calculates total forces and energies Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc integer, intent(out) :: ierr private subroutine ia_add_vdw_forces (simbox, atc, ierr) Calculates force and energy due to all short-ranged non-bonded pairwise\n interactions based on pair_tab . Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc integer, intent(out) :: ierr private subroutine ia_add_bond_forces (simbox, atc, ierr) Calculates forces & energy due to all bonds. Will add to energy_bond & and 'forces in module m_globals`. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc integer, intent(out) :: ierr private subroutine ia_add_angle_forces (simbox, atc) Calculates forces & energy due to all angles. Will add to energy_angle & 'forces`. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc private subroutine ia_add_dihedral_forces (simbox, atc) Calculates forces & energy due to all dihedrals. Will add to energy_dihedral & 'forces`. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(inout) :: atc private subroutine ia_add_tether_forces (atc, ierr) Calculates forces & energy due to all tethers. Will add to energy_tether &\n 'forces`. Tether forces are not subject to periodic boundary conditions. Arguments Type Intent Optional Attributes Name type( atmcfg_t ), intent(inout) :: atc integer, intent(out) :: ierr","tags":"","loc":"module/interaction_m.html"},{"title":"utils_math_m – BROWNPAK","text":"Various (mostly linear algebra) functions, particularly for use with small\nmatrices. Uses ieee_arithmetic constants_m module~~utils_math_m~~UsesGraph module~utils_math_m utils_math_m ieee_arithmetic ieee_arithmetic module~utils_math_m->ieee_arithmetic module~constants_m constants_m module~utils_math_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces allclose swap Functions scalar_triple_product det trace isclose allclose_rank1 allclose_rank2 allclose_rank3 get_quad_form Subroutines rad2deg deg2rad cross cross_mat outer vector_triple_product swap_integer swap_real swap_complex unitize linspace logspace identity get_diagonal add_transpose subtract_transpose multiply_transpose orth invert_mat33 eigval_33rsym dsyevc3 Interfaces public interface allclose Checks if two arrays are elementwise close within tolerance public function allclose_rank1 (a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank2 (a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank3 (a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public interface swap Swaps two arrays public elemental subroutine swap_integer (a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b public elemental subroutine swap_real (a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b public elemental subroutine swap_complex (a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b Functions public function scalar_triple_product (a, b, c) result(res) Returns the scalar triple product a .( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c Return Value real(kind=rp) public function det (A) result(res) Returns the determinant of an (N x N) matrix, where N = 2, 3, or 4. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (N,N) array, where N = 2, 3, or 4. Return Value real(kind=rp) public function trace (mat) result(res) Returns the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mat (:,:) (N,N) array Return Value real(kind=rp) public elemental function isclose (a, b, rel_tol, abs_tol) Checks if two floating point numbers of type double are close within\n  tolerance. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b real(kind=rp), intent(in), optional :: rel_tol Relative tolerance, rel_tol >= 0, default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance, abs_tol >= 0, default 0.0 Return Value logical public function allclose_rank1 (a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank2 (a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank3 (a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function get_quad_form (A, x) result(res) Calculates the quadratic form x&#94;T A x , where A is an n x n matrix and x is a\n  vector of length n Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (n,n) array real(kind=rp), intent(in), dimension(:) :: x (n,) array Return Value real(kind=rp) Subroutines public elemental subroutine rad2deg (rad, deg) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rad real(kind=rp), intent(out) :: deg public elemental subroutine deg2rad (deg, rad) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: deg real(kind=rp), intent(out) :: rad public subroutine cross (a, b, c) Calculates the cross product between two 3-element vectors Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(out), dimension(3) :: c Cross product of a and b ; c = a x b public subroutine cross_mat (a, mat) Calculates the cross product matrix of a 3-element vector. The cross\n product matrix A of a is defined as a x b = A . b ,\n where b is another 3-element vector. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(out), dimension(3,3) :: mat Cross product matrix of a public subroutine outer (a, b, c) Calculates the outer product of two vectors, . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (n,) array real(kind=rp), intent(out), dimension(:,:) :: c (m,n) array; Outer product public subroutine vector_triple_product (a, b, c, d) Returns the vector triple product d = a x ( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c real(kind=rp), intent(out), dimension(3) :: d Vector triple product public elemental subroutine swap_integer (a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b public elemental subroutine swap_real (a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b public elemental subroutine swap_complex (a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b public subroutine unitize (a) Normalizes a vector in-place. If the magnitude of the vector is nearly\n zero, no normalization takes place and the vector is returned as is with\n a warning message. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: a (m,) array public subroutine linspace (start, finish, num, val, step) Generates evenly spaced numbers over a specified interval. Both end\n points are included. If start < finish , the returned step size (if step is present) will be negative. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point real(kind=rp), intent(in) :: finish Ending point, finish /= start integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(out), optional :: step Step size public subroutine logspace (start, finish, num, val, base) Generates numbers spaced evenly on a log scale.\n  In linear space, the sequence starts at base ** start ( base to the power of start ) and ends with base ** stop Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point, base ** start is the starting value real(kind=rp), intent(in) :: finish Ending point, finish /= start , base ** start is the ending value integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(in), optional :: base Base of the logspace, default 10 public subroutine identity (mat_eye) Creates an identity matrix of size n x n. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:) :: mat_eye (n,n) array public subroutine get_diagonal (mat, d) Returns the diagonal elements of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mat (n,n) array real(kind=rp), intent(out), dimension(:) :: d (n,) array; contains the entries of the main diagonal public subroutine add_transpose (mat) Adds a square matrix and its transpose in place: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat (n,n) array public subroutine subtract_transpose (mat) Calculates the difference of a square matrix and its transpose in place: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat public subroutine multiply_transpose (A, B) Multiplies a matrix with its transpose: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (m,n) array real(kind=rp), intent(out), dimension(:,:) :: B (m,m) array public subroutine orth (a) Orthogonalizes a set of vectors in-place using Gram-Schmidt orthonormalization Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: a (m,n) array, where m <= n. The first m columns of the matrix are\n  overwritten with the orthogonal basis vectors. public subroutine invert_mat33 (a, inv_a) Inverts a 3x3 matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3,3) :: inv_a public subroutine eigval_33rsym (a, ev) Calculates the eigenvalues of a 3 x 3 real symmetric matrix. The\n eigenvalues calculated are in decreasing order. Only the diagonal and\n lower triangular part of the matrix is accessed. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3) :: ev public subroutine dsyevc3 (A, W) Author Joachim Kopp Date 2006 Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's\n analytical algorithm.\n Only the diagonal and upper triangular parts of A are accessed. The access\n is read-only. Read more… Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), DIMENSION(3,3) :: A real(kind=RP), intent(out), DIMENSION(3) :: W (3)","tags":"","loc":"module/utils_math_m.html"},{"title":"setup_m – BROWNPAK","text":"Routines for doing allocation, etc. in preparation for simulation run. Uses constants_m strings_m random_m logger_m simbox_m atmcfg_m config_io_m control_m stats_m interaction_m trajectory_m bd_solver_m module~~setup_m~~UsesGraph module~setup_m setup_m module~random_m random_m module~setup_m->module~random_m module~logger_m logger_m module~setup_m->module~logger_m module~strings_m strings_m module~setup_m->module~strings_m module~constants_m constants_m module~setup_m->module~constants_m module~simbox_m simbox_m module~setup_m->module~simbox_m module~config_io_m config_io_m module~setup_m->module~config_io_m module~atmcfg_m atmcfg_m module~setup_m->module~atmcfg_m module~stats_m stats_m module~setup_m->module~stats_m module~bd_solver_m bd_solver_m module~setup_m->module~bd_solver_m module~control_m control_m module~setup_m->module~control_m module~trajectory_m trajectory_m module~setup_m->module~trajectory_m module~interaction_m interaction_m module~setup_m->module~interaction_m module~random_m->module~constants_m mkl_vsl_type mkl_vsl_type module~random_m->mkl_vsl_type mkl_vsl mkl_vsl module~random_m->mkl_vsl module~timestamp_m timestamp_m module~logger_m->module~timestamp_m iso_fortran_env iso_fortran_env module~logger_m->iso_fortran_env module~strings_m->module~constants_m module~constants_m->iso_fortran_env module~simbox_m->module~random_m module~simbox_m->module~constants_m module~config_io_m->module~strings_m module~config_io_m->module~constants_m module~config_io_m->module~simbox_m module~config_io_m->module~atmcfg_m module~atmcfg_m->module~constants_m module~stats_m->module~strings_m module~stats_m->module~constants_m module~stats_m->module~simbox_m module~stats_m->module~atmcfg_m module~stats_m->module~control_m module~bd_solver_m->module~logger_m module~bd_solver_m->module~constants_m module~bd_solver_m->module~config_io_m module~bd_solver_m->module~atmcfg_m module~bd_solver_m->module~stats_m module~bd_solver_m->module~control_m module~bd_solver_m->module~trajectory_m module~bd_solver_m->module~interaction_m iso_c_binding iso_c_binding module~bd_solver_m->iso_c_binding module~brown_m brown_m module~bd_solver_m->module~brown_m mkl_blas mkl_blas module~bd_solver_m->mkl_blas module~control_m->module~strings_m module~control_m->module~constants_m module~trajectory_m->module~constants_m module~interaction_m->module~constants_m module~interaction_m->module~simbox_m module~interaction_m->module~atmcfg_m module~interaction_m->module~stats_m module~interaction_m->module~control_m module~ia_dihedral_m ia_dihedral_m module~interaction_m->module~ia_dihedral_m module~ia_bond_m ia_bond_m module~interaction_m->module~ia_bond_m module~ia_vdw_m ia_vdw_m module~interaction_m->module~ia_vdw_m module~ia_external_m ia_external_m module~interaction_m->module~ia_external_m module~ia_angle_m ia_angle_m module~interaction_m->module~ia_angle_m module~table_m table_m module~interaction_m->module~table_m module~ia_tether_m ia_tether_m module~interaction_m->module~ia_tether_m module~pairtab_m pairtab_m module~interaction_m->module~pairtab_m module~ia_dihedral_m->module~constants_m module~ia_dihedral_m->module~atmcfg_m module~ia_bond_m->module~logger_m module~ia_bond_m->module~strings_m module~ia_bond_m->module~constants_m module~ia_vdw_m->module~constants_m module~ia_vdw_m->module~atmcfg_m module~ia_external_m->module~constants_m module~ia_external_m->module~atmcfg_m module~ia_angle_m->module~constants_m module~ia_angle_m->module~atmcfg_m module~table_m->module~constants_m module~vector_m vector_m module~table_m->module~vector_m module~ia_tether_m->module~constants_m module~ia_tether_m->module~atmcfg_m module~pairtab_m->module~constants_m module~pairtab_m->module~simbox_m module~pairtab_m->module~atmcfg_m module~pairtab_m->module~table_m module~connectivity_m connectivity_m module~pairtab_m->module~connectivity_m module~pairtab_m->module~vector_m module~cell_list_m cell_list_m module~pairtab_m->module~cell_list_m module~aabbtree_m aabbtree_m module~pairtab_m->module~aabbtree_m module~brown_m->module~random_m module~brown_m->module~logger_m module~brown_m->module~strings_m module~brown_m->module~constants_m module~brown_m->iso_c_binding module~brown_m->mkl_blas mkl_lapack mkl_lapack module~brown_m->mkl_lapack module~connectivity_m->module~constants_m module~connectivity_m->module~table_m module~connectivity_m->module~vector_m module~vector_m->module~constants_m module~qsort_m qsort_m module~vector_m->module~qsort_m module~cell_list_m->module~constants_m module~cell_list_m->module~simbox_m module~cell_list_m->module~vector_m module~aabbtree_m->module~strings_m module~aabbtree_m->module~constants_m module~aabbtree_m->module~vector_m module~aabb_m aabb_m module~aabbtree_m->module~aabb_m module~qsort_m->module~constants_m module~aabb_m->module~strings_m module~aabb_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~setup_m~~UsedByGraph module~setup_m setup_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines run finish Subroutines public subroutine run (cpar, job_tag) Arguments Type Intent Optional Attributes Name type( ctrlpar_t ), intent(in) :: cpar character(len=*), intent(in) :: job_tag This string will be used as is, i.e. if there are leading or trailing\n white spaces, they will appear in any I/O file names. public subroutine finish (atc) Arguments Type Intent Optional Attributes Name type( atmcfg_t ), intent(inout) :: atc","tags":"","loc":"module/setup_m.html"},{"title":"config_io_m – BROWNPAK","text":"Routines for IO of config and dump files. Uses constants_m strings_m simbox_m atmcfg_m module~~config_io_m~~UsesGraph module~config_io_m config_io_m module~strings_m strings_m module~config_io_m->module~strings_m module~constants_m constants_m module~config_io_m->module~constants_m module~simbox_m simbox_m module~config_io_m->module~simbox_m module~atmcfg_m atmcfg_m module~config_io_m->module~atmcfg_m module~strings_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~simbox_m->module~constants_m module~random_m random_m module~simbox_m->module~random_m module~atmcfg_m->module~constants_m module~random_m->module~constants_m mkl_vsl_type mkl_vsl_type module~random_m->mkl_vsl_type mkl_vsl mkl_vsl module~random_m->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~config_io_m~~UsedByGraph module~config_io_m config_io_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~config_io_m module~setup_m setup_m module~setup_m->module~config_io_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines read_dump write_dump read_config write_config write_ldf write_xyz Subroutines public subroutine read_dump (nts, simbox, atc, fn) Reads from DUMP file Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(out) :: nts type( smbx_t ), intent(out) :: simbox type( atmcfg_t ), intent(out) :: atc character(len=*), intent(in) :: fn public subroutine write_dump (nts, simbox, atc, fn) Writes to DUMP file. Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: nts type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc character(len=*), intent(in) :: fn public subroutine read_config (simbox, atc, fn) Read from CONFIG file Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(out) :: simbox type( atmcfg_t ), intent(out) :: atc character(len=*), intent(in) :: fn public subroutine write_config (simbox, atc, fn, title) Write to cfg file Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc character(len=*), intent(in) :: fn character(len=*), intent(in) :: title public subroutine write_ldf (simbox, atc, fn_ld, title) Write to a LAMMPS data file. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc character(len=*), intent(in) :: fn_ld Name of the file character(len=*), intent(in) :: title Title of the configuation public subroutine write_xyz (atc, fn_xyz, title) Write to an XYZ file. Arguments Type Intent Optional Attributes Name type( atmcfg_t ), intent(in) :: atc character(len=*), intent(in) :: fn_xyz Name of the XYZ file character(len=*), intent(in) :: title Title (for the configuration)","tags":"","loc":"module/config_io_m.html"},{"title":"stats_m – BROWNPAK","text":"Computes and writes properties calculated during simulation. Uses constants_m strings_m control_m simbox_m atmcfg_m module~~stats_m~~UsesGraph module~stats_m stats_m module~strings_m strings_m module~stats_m->module~strings_m module~simbox_m simbox_m module~stats_m->module~simbox_m module~constants_m constants_m module~stats_m->module~constants_m module~atmcfg_m atmcfg_m module~stats_m->module~atmcfg_m module~control_m control_m module~stats_m->module~control_m module~strings_m->module~constants_m module~simbox_m->module~constants_m module~random_m random_m module~simbox_m->module~random_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~atmcfg_m->module~constants_m module~control_m->module~strings_m module~control_m->module~constants_m module~random_m->module~constants_m mkl_vsl_type mkl_vsl_type module~random_m->mkl_vsl_type mkl_vsl mkl_vsl module~random_m->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~stats_m~~UsedByGraph module~stats_m stats_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~stats_m module~interaction_m interaction_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~stats_m module~setup_m->module~bd_solver_m module~setup_m->module~interaction_m module~interaction_m->module~stats_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables fn_stats fu_stats bnsiz bnsiz_stress bnpop bnpop_stress bndlen bndlen_min bndlen_max energy_bond energy_bond_accu energy_angle energy_angle_accu energy_dihedral energy_dihedral_accu energy_vdw energy_vdw_accu energy_tether energy_tether_accu energy_external energy_external_accu energy_tot energy_tot_accu stress stress_accu rgsq rgsq_accu reedsq reedsq_accu span span_accu rgsq_bbone rgsq_bbone_accu rgsq_sc rgsq_sc_accu reedsq_sc reedsq_sc_accu span_bbone span_bbone_accu reev molbuf lvdw Subroutines stats_init stats_finish zero_out write_hdr stats_write stats_accumulate compute_ic1 compute_ic0 Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: fn_stats integer, private :: fu_stats integer, private :: bnsiz integer, private :: bnsiz_stress integer, private :: bnpop integer, private :: bnpop_stress real(kind=rp), public :: bndlen real(kind=rp), public :: bndlen_min real(kind=rp), public :: bndlen_max real(kind=rp), public :: energy_bond real(kind=rp), private :: energy_bond_accu real(kind=rp), public :: energy_angle real(kind=rp), private :: energy_angle_accu real(kind=rp), public :: energy_dihedral real(kind=rp), private :: energy_dihedral_accu real(kind=rp), public :: energy_vdw real(kind=rp), private :: energy_vdw_accu real(kind=rp), public :: energy_tether real(kind=rp), private :: energy_tether_accu real(kind=rp), public :: energy_external real(kind=rp), private :: energy_external_accu real(kind=rp), public :: energy_tot real(kind=rp), private :: energy_tot_accu real(kind=rp), public, dimension(3,3) :: stress real(kind=rp), private, dimension(3,3) :: stress_accu real(kind=rp), private :: rgsq real(kind=rp), private :: rgsq_accu real(kind=rp), private :: reedsq real(kind=rp), private :: reedsq_accu real(kind=rp), private, dimension(3) :: span real(kind=rp), private, dimension(3) :: span_accu real(kind=rp), private :: rgsq_bbone real(kind=rp), private :: rgsq_bbone_accu real(kind=rp), private :: rgsq_sc real(kind=rp), private :: rgsq_sc_accu real(kind=rp), private :: reedsq_sc real(kind=rp), private :: reedsq_sc_accu real(kind=rp), private, dimension(3) :: span_bbone real(kind=rp), private, dimension(3) :: span_bbone_accu real(kind=rp), private, dimension(3) :: reev real(kind=rp), private, dimension(:,:), allocatable :: molbuf logical, private :: lvdw Subroutines public subroutine stats_init (cpar, simbox, atc, job_tag) Set up for stats collection Arguments Type Intent Optional Attributes Name type( ctrlpar_t ), intent(in) :: cpar type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc character(len=*), intent(in) :: job_tag public subroutine stats_finish () Clean up for stats collection. Arguments None private subroutine zero_out () Arguments None private subroutine write_hdr (simbox, atc) Writes header of the file fn_stats . Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc public subroutine stats_write (nts, simbox, atc) Writes statistics to fn_stats . Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: nts type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc public subroutine stats_accumulate (simbox, atc) Accumulates statistics. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc private subroutine compute_ic1 (simbox, atc) Computes statistics for possibly multiple chains in a periodic domain. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox type( atmcfg_t ), intent(in) :: atc private subroutine compute_ic0 (atc) Computes statistics for a single chain in unbounded domain. Arguments Type Intent Optional Attributes Name type( atmcfg_t ), intent(in) :: atc","tags":"","loc":"module/stats_m.html"},{"title":"connectivity_m – BROWNPAK","text":"Routines for building atom->bond, atom->angle, etc. tables and excluded\n atoms table. Uses constants_m vector_m table_m module~~connectivity_m~~UsesGraph module~connectivity_m connectivity_m module~table_m table_m module~connectivity_m->module~table_m module~constants_m constants_m module~connectivity_m->module~constants_m module~vector_m vector_m module~connectivity_m->module~vector_m module~table_m->module~constants_m module~table_m->module~vector_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~vector_m->module~constants_m module~qsort_m qsort_m module~vector_m->module~qsort_m module~qsort_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~connectivity_m~~UsedByGraph module~connectivity_m connectivity_m module~pairtab_m pairtab_m module~pairtab_m->module~connectivity_m module~interaction_m interaction_m module~interaction_m->module~pairtab_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines atbo_build atan_build atdh_build atat_build exat_build Subroutines public subroutine atbo_build (num_atoms, num_bonds, bonds, atbo_tab) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_atoms integer, intent(in) :: num_bonds integer, intent(in), dimension(:,:) :: bonds type( itable_t ), intent(out) :: atbo_tab Atoms -> bonds table public subroutine atan_build (num_atoms, num_angles, angles, atan_tab) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_atoms integer, intent(in) :: num_angles integer, intent(in), dimension(:,:) :: angles type( itable_t ), intent(out) :: atan_tab Atoms -> angles table public subroutine atdh_build (num_atoms, num_dihedrals, dihedrals, atdh_tab) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_atoms integer, intent(in) :: num_dihedrals integer, intent(in), dimension(:,:) :: dihedrals type( itable_t ), intent(out) :: atdh_tab Atoms -> dihedrals table public subroutine atat_build (num_atoms, bonds, atbo_tab, atat_tab) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_atoms integer, intent(in), dimension(:,:) :: bonds type( itable_t ), intent(in) :: atbo_tab Atoms -> bonds table type( itable_t ), intent(out) :: atat_tab Atoms -> bonded atoms table (1-ring) public subroutine exat_build (num_atoms, excluded_atoms, atat_tab, exat_tab) Before a call to this first build atbo_tab. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_atoms integer, intent(in) :: excluded_atoms type( itable_t ), intent(in) :: atat_tab Atoms -> bonded atoms table type( itable_t ), intent(out) :: exat_tab Atoms -> excluded (from vdw calculation) atoms table","tags":"","loc":"module/connectivity_m.html"},{"title":"bd_solver_m – BROWNPAK","text":"Routines implementing Brownian Dynamics (BD) solver. Uses iso_c_binding mkl_blas constants_m logger_m control_m atmcfg_m interaction_m brown_m stats_m config_io_m trajectory_m module~~bd_solver_m~~UsesGraph module~bd_solver_m bd_solver_m iso_c_binding iso_c_binding module~bd_solver_m->iso_c_binding module~constants_m constants_m module~bd_solver_m->module~constants_m module~brown_m brown_m module~bd_solver_m->module~brown_m module~config_io_m config_io_m module~bd_solver_m->module~config_io_m module~atmcfg_m atmcfg_m module~bd_solver_m->module~atmcfg_m module~stats_m stats_m module~bd_solver_m->module~stats_m module~logger_m logger_m module~bd_solver_m->module~logger_m module~control_m control_m module~bd_solver_m->module~control_m mkl_blas mkl_blas module~bd_solver_m->mkl_blas module~trajectory_m trajectory_m module~bd_solver_m->module~trajectory_m module~interaction_m interaction_m module~bd_solver_m->module~interaction_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~brown_m->iso_c_binding module~brown_m->module~constants_m module~brown_m->module~logger_m module~brown_m->mkl_blas module~strings_m strings_m module~brown_m->module~strings_m module~random_m random_m module~brown_m->module~random_m mkl_lapack mkl_lapack module~brown_m->mkl_lapack module~config_io_m->module~constants_m module~config_io_m->module~atmcfg_m module~config_io_m->module~strings_m module~simbox_m simbox_m module~config_io_m->module~simbox_m module~atmcfg_m->module~constants_m module~stats_m->module~constants_m module~stats_m->module~atmcfg_m module~stats_m->module~control_m module~stats_m->module~strings_m module~stats_m->module~simbox_m module~timestamp_m timestamp_m module~logger_m->module~timestamp_m module~logger_m->iso_fortran_env module~control_m->module~constants_m module~control_m->module~strings_m module~trajectory_m->module~constants_m module~interaction_m->module~constants_m module~interaction_m->module~atmcfg_m module~interaction_m->module~stats_m module~interaction_m->module~control_m module~ia_dihedral_m ia_dihedral_m module~interaction_m->module~ia_dihedral_m module~ia_bond_m ia_bond_m module~interaction_m->module~ia_bond_m module~ia_vdw_m ia_vdw_m module~interaction_m->module~ia_vdw_m module~ia_external_m ia_external_m module~interaction_m->module~ia_external_m module~ia_angle_m ia_angle_m module~interaction_m->module~ia_angle_m module~table_m table_m module~interaction_m->module~table_m module~interaction_m->module~simbox_m module~pairtab_m pairtab_m module~interaction_m->module~pairtab_m module~ia_tether_m ia_tether_m module~interaction_m->module~ia_tether_m module~ia_dihedral_m->module~constants_m module~ia_dihedral_m->module~atmcfg_m module~ia_bond_m->module~constants_m module~ia_bond_m->module~logger_m module~ia_bond_m->module~strings_m module~ia_vdw_m->module~constants_m module~ia_vdw_m->module~atmcfg_m module~ia_external_m->module~constants_m module~ia_external_m->module~atmcfg_m module~strings_m->module~constants_m module~ia_angle_m->module~constants_m module~ia_angle_m->module~atmcfg_m module~table_m->module~constants_m module~vector_m vector_m module~table_m->module~vector_m module~simbox_m->module~constants_m module~simbox_m->module~random_m module~pairtab_m->module~constants_m module~pairtab_m->module~atmcfg_m module~pairtab_m->module~table_m module~pairtab_m->module~simbox_m module~connectivity_m connectivity_m module~pairtab_m->module~connectivity_m module~pairtab_m->module~vector_m module~cell_list_m cell_list_m module~pairtab_m->module~cell_list_m module~aabbtree_m aabbtree_m module~pairtab_m->module~aabbtree_m module~ia_tether_m->module~constants_m module~ia_tether_m->module~atmcfg_m module~random_m->module~constants_m mkl_vsl_type mkl_vsl_type module~random_m->mkl_vsl_type mkl_vsl mkl_vsl module~random_m->mkl_vsl module~connectivity_m->module~constants_m module~connectivity_m->module~table_m module~connectivity_m->module~vector_m module~vector_m->module~constants_m module~qsort_m qsort_m module~vector_m->module~qsort_m module~cell_list_m->module~constants_m module~cell_list_m->module~simbox_m module~cell_list_m->module~vector_m module~aabbtree_m->module~constants_m module~aabbtree_m->module~strings_m module~aabbtree_m->module~vector_m module~aabb_m aabb_m module~aabbtree_m->module~aabb_m module~qsort_m->module~constants_m module~aabb_m->module~constants_m module~aabb_m->module~strings_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~bd_solver_m~~UsedByGraph module~bd_solver_m bd_solver_m module~setup_m setup_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables lhdia write_traj lanc_mxitr nlmxitr kdmax nts_mobsam tim_stp lanc_tol ftol stptol nts nts_sim nts_dump nts_samp nts_log mob_fctr bdintg fn_revive psmbx patc cntr_mobsam sqrt_two_dt drift diffusion mob crd0 sol nitsol_rwork pvcrd pvfrc Subroutines bds_init bds_finish bds_run integrate_em integrate_se se_fval se_jacv calc_diffusion calc_drift calc_rpy_tensor Variables Type Visibility Attributes Name Initial logical, private :: lhdia logical, private :: write_traj integer, private :: lanc_mxitr integer, private :: nlmxitr integer, private :: kdmax integer, private :: nts_mobsam real(kind=rp), private :: tim_stp real(kind=rp), private :: lanc_tol real(kind=rp), private :: ftol real(kind=rp), private :: stptol integer(kind=ip_long), private :: nts integer(kind=ip_long), private :: nts_sim integer(kind=ip_long), private :: nts_dump integer(kind=ip_long), private :: nts_samp integer(kind=ip_long), private :: nts_log character(len=4), private :: mob_fctr character(len=4), private :: bdintg character(len=:), private, allocatable :: fn_revive type(smbx_t), private, pointer :: psmbx => null() type( atmcfg_t ), private, pointer :: patc => null() integer, private :: cntr_mobsam real(kind=rp), private :: sqrt_two_dt real(kind=rp), private, dimension(:  ), allocatable :: drift real(kind=rp), private, dimension(:,:), allocatable :: diffusion real(kind=rp), private, dimension(:,:), allocatable :: mob real(kind=rp), private, dimension(:), allocatable :: crd0 real(kind=rp), private, dimension(:), allocatable :: sol real(kind=rp), private, dimension(:), allocatable :: nitsol_rwork real(kind=rp), private, dimension(:), pointer :: pvcrd => null() real(kind=rp), private, dimension(:), pointer :: pvfrc => null() Subroutines public subroutine bds_init (cpar, num_atoms, job_tag, ierr) Initializes the BD solver. Arguments Type Intent Optional Attributes Name type( ctrlpar_t ), intent(in) :: cpar integer, intent(in) :: num_atoms character(len=*), intent(in) :: job_tag integer, intent(out) :: ierr public subroutine bds_finish () Clears up memory allocated in bds_init . Arguments None public subroutine bds_run (nts_beg, simbox, atc, ierr) Driver for BD integrator. Read more… Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: nts_beg type(smbx_t), intent(in), target :: simbox type( atmcfg_t ), intent(inout), target :: atc integer, intent(out) :: ierr Error flag private subroutine integrate_em (ierr) Performs one step of BD integration using explicit Euler-Maruyama scheme. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine integrate_se (ierr) Performs one step of BD integration using semi-implicit Euler scheme. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr public subroutine se_fval (n, xcur, fcur, rpar, ipar, ierr) Calculates the nonlinear function. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rp), intent(in), dimension(*) :: xcur real(kind=rp), intent(out), dimension(*) :: fcur real(kind=rp), intent(in), dimension(*) :: rpar integer, intent(in), dimension(*) :: ipar integer, intent(out) :: ierr public subroutine se_jacv (n, xcur, fcur, ijob, v, z, rpar, ipar, ierr) Calculates jacobian times vector product. This is a dummy subroutine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rp), intent(in), dimension(:) :: xcur real(kind=rp), intent(in), dimension(:) :: fcur integer, intent(in) :: ijob real(kind=rp), intent(in), dimension(:) :: v real(kind=rp), intent(out), dimension(:) :: z real(kind=rp), intent(in), dimension(:) :: rpar integer, intent(in), dimension(:) :: ipar integer, intent(out) :: ierr private subroutine calc_diffusion (ierr) Calculates the diffusion term of the SDE. Updates module variables diffusion and cntr_mobsam . Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine calc_drift (ierr) Calculates the drift term of the SDE. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine calc_rpy_tensor (coordinates, mob) Calculates the RPY approximation to the mobility tensor. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: coordinates (3, num_atoms*) matrix; stores the atom positions. real(kind=rp), intent(out), dimension(:,:) :: mob (3 num_atoms , 3 num_atoms ) matrix; stores the mobility tensor.","tags":"","loc":"module/bd_solver_m.html"},{"title":"pairtab_m – BROWNPAK","text":"Uses constants_m vector_m table_m simbox_m aabbtree_m cell_list_m atmcfg_m connectivity_m module~~pairtab_m~~UsesGraph module~pairtab_m pairtab_m module~connectivity_m connectivity_m module~pairtab_m->module~connectivity_m module~vector_m vector_m module~pairtab_m->module~vector_m module~table_m table_m module~pairtab_m->module~table_m module~constants_m constants_m module~pairtab_m->module~constants_m module~simbox_m simbox_m module~pairtab_m->module~simbox_m module~cell_list_m cell_list_m module~pairtab_m->module~cell_list_m module~atmcfg_m atmcfg_m module~pairtab_m->module~atmcfg_m module~aabbtree_m aabbtree_m module~pairtab_m->module~aabbtree_m module~connectivity_m->module~vector_m module~connectivity_m->module~table_m module~connectivity_m->module~constants_m module~vector_m->module~constants_m module~qsort_m qsort_m module~vector_m->module~qsort_m module~table_m->module~vector_m module~table_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~simbox_m->module~constants_m module~random_m random_m module~simbox_m->module~random_m module~cell_list_m->module~vector_m module~cell_list_m->module~constants_m module~cell_list_m->module~simbox_m module~atmcfg_m->module~constants_m module~aabbtree_m->module~vector_m module~aabbtree_m->module~constants_m module~strings_m strings_m module~aabbtree_m->module~strings_m module~aabb_m aabb_m module~aabbtree_m->module~aabb_m module~qsort_m->module~constants_m module~strings_m->module~constants_m module~random_m->module~constants_m mkl_vsl_type mkl_vsl_type module~random_m->mkl_vsl_type mkl_vsl mkl_vsl module~random_m->mkl_vsl module~aabb_m->module~constants_m module~aabb_m->module~strings_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~pairtab_m~~UsedByGraph module~pairtab_m pairtab_m module~interaction_m interaction_m module~interaction_m->module~pairtab_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables rcutoff tskin rskin_sq tskin_sq mth_ptgen exat_tab tree coordinates_save coordinates_dr Subroutines pt_init pt_delete pt_build build_pt_n2 build_pt_verlet build_pt_aabbtree build_pt_cell_list Variables Type Visibility Attributes Name Initial real(kind=rp), private :: rcutoff = 0.0_rp real(kind=rp), private :: tskin = 0.0_rp real(kind=rp), private :: rskin_sq = 0.0_rp real(kind=rp), private :: tskin_sq = 0.0_rp character(len=:), private, allocatable :: mth_ptgen Pair table generation method: {'DIR', 'VER', 'AABBT', 'CL'} type( itable_t ), private :: exat_tab type( aabbtree_t ), private :: tree real(kind=rp), private, dimension(:,:), allocatable :: coordinates_save (3, num_atoms ) array real(kind=rp), private, dimension(:,:), allocatable :: coordinates_dr (3, num_atoms ) array Subroutines public subroutine pt_init (mth, num_atoms, excl_atoms, rcut, tskn, bonds, simbox, pair_tab) Performs initial setup for building a pair list. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mth integer, intent(in) :: num_atoms integer, intent(in) :: excl_atoms real(kind=rp), intent(in) :: rcut real(kind=rp), intent(in) :: tskn integer, intent(in), dimension(:,:) :: bonds type( smbx_t ), intent(in) :: simbox type( itable_t ), intent(inout) :: pair_tab public subroutine pt_delete (pair_tab) Cleanup for pair list calculation. Arguments Type Intent Optional Attributes Name type( itable_t ), intent(inout) :: pair_tab public subroutine pt_build (simbox, coordinates, pair_tab) Builds a pair table. The resulting table is stored in the module variable pair_tab . Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox real(kind=rp), intent(in), dimension(:,:) :: coordinates type( itable_t ), intent(inout) :: pair_tab private subroutine build_pt_n2 (simbox, coordinates, pair_tab) Builds a pair table using direct N&#94;2 looping over all pairs. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox real(kind=rp), intent(in), dimension(:,:) :: coordinates type( itable_t ), intent(inout) :: pair_tab private subroutine build_pt_verlet (simbox, coordinates, pair_tab) Builds a pair table using the Verlet scheme. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox real(kind=rp), intent(in), dimension(:,:) :: coordinates type( itable_t ), intent(inout) :: pair_tab private subroutine build_pt_aabbtree (simbox, coordinates, pair_tab) Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox real(kind=rp), intent(in), dimension(:,:) :: coordinates type( itable_t ), intent(inout) :: pair_tab private subroutine build_pt_cell_list (simbox, coordinates, pair_tab) Builds a pair table using cell list. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(in) :: simbox real(kind=rp), intent(in), dimension(:,:) :: coordinates type( itable_t ), intent(inout) :: pair_tab","tags":"","loc":"module/pairtab_m.html"},{"title":"brown_m – BROWNPAK","text":"Contains routines for evaluating B . d W in the SDE for Brownian Dynamics\n simulation. Uses iso_c_binding mkl_blas mkl_lapack constants_m random_m strings_m logger_m module~~brown_m~~UsesGraph module~brown_m brown_m iso_c_binding iso_c_binding module~brown_m->iso_c_binding module~strings_m strings_m module~brown_m->module~strings_m module~constants_m constants_m module~brown_m->module~constants_m module~random_m random_m module~brown_m->module~random_m mkl_lapack mkl_lapack module~brown_m->mkl_lapack module~logger_m logger_m module~brown_m->module~logger_m mkl_blas mkl_blas module~brown_m->mkl_blas module~strings_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~random_m->module~constants_m mkl_vsl_type mkl_vsl_type module~random_m->mkl_vsl_type mkl_vsl mkl_vsl module~random_m->mkl_vsl module~logger_m->iso_fortran_env module~timestamp_m timestamp_m module~logger_m->module~timestamp_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~brown_m~~UsedByGraph module~brown_m brown_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~brown_m module~setup_m setup_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables meth sizm s dimk_min dimk_max ethres bdw_old lncv eigvlh eigvch w h_d h_sd tau matr h_bd h_bsd h_bnd tmp work iwork Subroutines brn_init brn_finish brn_calc_bdw calc_bdw_lanc calc_bdw_blanc calc_bdw_cholesky brn_calc_dw calc_bdw_lanc_sor Variables Type Visibility Attributes Name Initial character(len=4), private :: meth Method to use for generating Brownian terms. Possible values are\n'CHOL' or 'LANC'. integer, private :: sizm Size of the mobility matrix integer, private :: s Number of Brownian vectors to be generated; equivalent to block size in the\nblock Lanczos algorithm. integer, private :: dimk_min = 2 Minimum dimension of KSP integer, private :: dimk_max Maximum dimension of KSP real(kind=rp), private :: ethres = 1.0e-3_rp Error threshold for KSP-based method. real(kind=rp), private, dimension(:,:), allocatable :: bdw_old ( sizm , s ) array. Stores B.dw at previous iteration. real(kind=rp), private, dimension(:,:), allocatable :: lncv ( sizm , s*dimk_max ) array. Stores the Lanczos vectors. real(kind=rp), private, dimension(:), allocatable :: eigvlh ( s*dimk_max ,) array. Eigenvalues of the tridiagonal/block triadiagonal\n matrix H generated by the Lanczos algorithm. real(kind=rp), private, dimension(:,:), allocatable :: eigvch ( s*dimk_max , s*dimk_max ) array. Eigenvectors of the matrix H. real(kind=rp), private, dimension(:,:), allocatable :: w ( sizm , s ) array. Used for generating the Lanczos vectors. real(kind=rp), private, dimension(:), allocatable :: h_d ( dimk_max ,) array. Diagonal of the symmetric tridiagonal matrix H\n generated in case of s = 1 . real(kind=rp), private, dimension(:), allocatable :: h_sd ( dimk_max ,) array. Subdiagonal of the symmetric tridiagonal matrix H\n generated in case of s = 1 . real(kind=rp), private, dimension(:), allocatable :: tau ( s ,) array. Used in the QR decomposition of w . real(kind=rp), private, dimension(:,:), allocatable :: matr ( s , s ) array. Used in the QR decomposition of w . real(kind=rp), private, dimension(:,:), allocatable :: h_bd ( s , s*dimk_max ) array. Diagonal blocks of the matrix H.\nUsed for KSP with s > 1 . real(kind=rp), private, dimension(:,:), allocatable :: h_bsd ( s , s*dimk_max ) array. Subdiagonal blocks of the matrix H.\nUsed for KSP with s > 1 . real(kind=rp), private, dimension(:,:), allocatable :: h_bnd ( 2*s , s*dimk_max ) array. Matrix H in banded storage.\nUsed for KSP with s > 1 . real(kind=rp), private, dimension(:,:), allocatable :: tmp ( s*dimk_max , 2*s ) array used as temporary storage space. real(kind=rp), private, dimension(:), allocatable :: work Workspace array for LAPACK routines. integer, private, dimension(:), allocatable :: iwork Workspace array for LAPACK routines. Subroutines public subroutine brn_init (n, nblks, mth, f, e) Performs initial setup. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Size of the mobility matrix. integer, intent(in) :: nblks Number of B . d W vectors to generate for the same mobility matrix. 1 <= nblks < n . character(len=4), intent(in) :: mth Method for calculating the Brownian terms. mth = 'CHOL' for\n Cholesky decomposition; mth = 'LANC' for KSP-based method. integer, intent(in), optional :: f For KSP-based method, maximum number of iterations.\n Must be present if mth = 'LANC' . f must be less than n . real(kind=rp), intent(in), optional :: e For KSP-based method, error threshold for convergence. \n Must be present if mth = 'LANC' . public subroutine brn_finish () Performs cleanup. Arguments None public subroutine brn_calc_bdw (mob, bdw, ierr, lconv, f) Main driver routine for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix.\n On entry , contains the mobility matrix.  On return , if meth = 'CHOL' ,\n the upper triangular part is overwritten with the result of Cholesky\n decomposition.  The strictly lower triangular part is left intact. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B .d W . integer, intent(out) :: ierr Error flag. logical, intent(out), optional :: lconv If meth = 'LANC' , returns true if converged, false otherwise. integer, intent(out), optional :: f If meth = 'LANC' , the number of iterations performed. private subroutine calc_bdw_lanc (mob, bdw, lconv, f, ierr) Implements Lanczos algorithm for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm ,1) array.\n On entry , contains a vector drawn from standard normal \n distribution. On return , is overwritten with the result of B . d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag. private subroutine calc_bdw_blanc (mob, bdw, lconv, f, ierr) Implements block Lanczos algorithm for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B . d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag. private subroutine calc_bdw_cholesky (mob, bdw, ierr) Calculates B . d W using Cholesky decomposition. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix.\n On entry , contains the mobility matrix.  On return ,\n the upper triangular part is overwritten with the result of Cholesky\n decomposition.  The strictly lower triangular part is left intact. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B . d W . integer, intent(out) :: ierr Error flag. public subroutine brn_calc_dw (dw) Calculates standard normally distributed random vectors. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:), target :: dw ( n , m ) array. private subroutine calc_bdw_lanc_sor (mob, bdw, lconv, f, ierr) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm ,1) array.\n On entry , contains a vector drawn from standard normal \n distribution. On return , is overwritten with the result of B .d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag.","tags":"","loc":"module/brown_m.html"},{"title":"random_m – BROWNPAK","text":"Provides random number generation procedures, mostly calling\n routine from Intel MKL VSL. Uses constants_m mkl_vsl_type mkl_vsl module~~random_m~~UsesGraph module~random_m random_m mkl_vsl_type mkl_vsl_type module~random_m->mkl_vsl_type module~constants_m constants_m module~random_m->module~constants_m mkl_vsl mkl_vsl module~random_m->mkl_vsl iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~random_m~~UsedByGraph module~random_m random_m module~brown_m brown_m module~brown_m->module~random_m module~setup_m setup_m module~setup_m->module~random_m module~simbox_m simbox_m module~setup_m->module~simbox_m module~config_io_m config_io_m module~setup_m->module~config_io_m module~stats_m stats_m module~setup_m->module~stats_m module~bd_solver_m bd_solver_m module~setup_m->module~bd_solver_m module~interaction_m interaction_m module~setup_m->module~interaction_m module~simbox_m->module~random_m program~main main program~main->module~setup_m module~pairtab_m pairtab_m module~pairtab_m->module~simbox_m module~cell_list_m cell_list_m module~pairtab_m->module~cell_list_m module~config_io_m->module~simbox_m module~cell_list_m->module~simbox_m module~stats_m->module~simbox_m module~bd_solver_m->module~brown_m module~bd_solver_m->module~config_io_m module~bd_solver_m->module~stats_m module~bd_solver_m->module~interaction_m module~interaction_m->module~simbox_m module~interaction_m->module~pairtab_m module~interaction_m->module~stats_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables seed stream Functions get_uniform get_iuniform Subroutines init_stream delete_stream load_stream save_seed save_stream get_rv_uniform get_rv_iuniform get_rv_gaussian ransphere Variables Type Visibility Attributes Name Initial integer(kind=ip), private, save :: seed type(VSL_STREAM_STATE), private, save :: stream Functions public function get_uniform (lb, ub) result(res) Returns a random number from a uniform distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound Return Value real(kind=rp) public function get_iuniform (lb, ub) result(res) Returns a random integer from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub Return Value integer(kind=ip) Subroutines public subroutine init_stream (fn) Initializes a BRNG stream. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: fn Name of the file containing the RNG seed. public subroutine delete_stream () Deletes a BRNG stream. Arguments None public subroutine load_stream (fn) Loads a BRNG stream from file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine save_seed (fn) Saves the RNG seed to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine save_stream (fn) Saves a BRNG stream to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine get_rv_uniform (lb, ub, rv, block_size) Returns a random vector from a uniform distribution. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size public subroutine get_rv_iuniform (lb, ub, rv, block_size) Returns a random vector of integers from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub integer(kind=ip), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size public subroutine get_rv_gaussian (mean, std_dev, rv, block_size) Generates a random vector of integers from a gaussian distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: std_dev real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size public subroutine ransphere (r) Generates a random vector from the surface of a unit sphere. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(3) :: r (3)","tags":"","loc":"module/random_m.html"},{"title":"constants_m – BROWNPAK","text":"Various math constants. Uses iso_fortran_env module~~constants_m~~UsesGraph module~constants_m constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~constants_m~~UsedByGraph module~constants_m constants_m module~qsort_m qsort_m module~qsort_m->module~constants_m module~setup_m setup_m module~setup_m->module~constants_m module~config_io_m config_io_m module~setup_m->module~config_io_m module~atmcfg_m atmcfg_m module~setup_m->module~atmcfg_m module~stats_m stats_m module~setup_m->module~stats_m module~control_m control_m module~setup_m->module~control_m module~interaction_m interaction_m module~setup_m->module~interaction_m module~simbox_m simbox_m module~setup_m->module~simbox_m module~random_m random_m module~setup_m->module~random_m module~trajectory_m trajectory_m module~setup_m->module~trajectory_m module~strings_m strings_m module~setup_m->module~strings_m module~bd_solver_m bd_solver_m module~setup_m->module~bd_solver_m module~utils_math_m utils_math_m module~utils_math_m->module~constants_m module~config_io_m->module~constants_m module~config_io_m->module~atmcfg_m module~config_io_m->module~simbox_m module~config_io_m->module~strings_m module~atmcfg_m->module~constants_m module~stats_m->module~constants_m module~stats_m->module~atmcfg_m module~stats_m->module~control_m module~stats_m->module~simbox_m module~stats_m->module~strings_m module~control_m->module~constants_m module~control_m->module~strings_m module~interaction_m->module~constants_m module~interaction_m->module~atmcfg_m module~interaction_m->module~stats_m module~interaction_m->module~control_m module~ia_dihedral_m ia_dihedral_m module~interaction_m->module~ia_dihedral_m module~ia_vdw_m ia_vdw_m module~interaction_m->module~ia_vdw_m module~ia_external_m ia_external_m module~interaction_m->module~ia_external_m module~interaction_m->module~simbox_m module~table_m table_m module~interaction_m->module~table_m module~pairtab_m pairtab_m module~interaction_m->module~pairtab_m module~ia_bond_m ia_bond_m module~interaction_m->module~ia_bond_m module~ia_angle_m ia_angle_m module~interaction_m->module~ia_angle_m module~ia_tether_m ia_tether_m module~interaction_m->module~ia_tether_m module~ia_dihedral_m->module~constants_m module~ia_dihedral_m->module~atmcfg_m module~ia_vdw_m->module~constants_m module~ia_vdw_m->module~atmcfg_m module~vector_m vector_m module~vector_m->module~constants_m module~vector_m->module~qsort_m module~ia_external_m->module~constants_m module~ia_external_m->module~atmcfg_m module~simbox_m->module~constants_m module~simbox_m->module~random_m module~cell_list_m cell_list_m module~cell_list_m->module~constants_m module~cell_list_m->module~vector_m module~cell_list_m->module~simbox_m module~random_m->module~constants_m module~trajectory_m->module~constants_m module~table_m->module~constants_m module~table_m->module~vector_m module~pairtab_m->module~constants_m module~pairtab_m->module~atmcfg_m module~pairtab_m->module~vector_m module~pairtab_m->module~simbox_m module~pairtab_m->module~cell_list_m module~pairtab_m->module~table_m module~connectivity_m connectivity_m module~pairtab_m->module~connectivity_m module~aabbtree_m aabbtree_m module~pairtab_m->module~aabbtree_m module~brown_m brown_m module~brown_m->module~constants_m module~brown_m->module~random_m module~brown_m->module~strings_m module~connectivity_m->module~constants_m module~connectivity_m->module~vector_m module~connectivity_m->module~table_m module~ia_bond_m->module~constants_m module~ia_bond_m->module~strings_m program~main main program~main->module~constants_m program~main->module~setup_m program~main->module~control_m program~main->module~strings_m module~strings_m->module~constants_m module~ia_angle_m->module~constants_m module~ia_angle_m->module~atmcfg_m module~ia_tether_m->module~constants_m module~ia_tether_m->module~atmcfg_m module~aabbtree_m->module~constants_m module~aabbtree_m->module~vector_m module~aabbtree_m->module~strings_m module~aabb_m aabb_m module~aabbtree_m->module~aabb_m module~bd_solver_m->module~constants_m module~bd_solver_m->module~config_io_m module~bd_solver_m->module~atmcfg_m module~bd_solver_m->module~stats_m module~bd_solver_m->module~control_m module~bd_solver_m->module~interaction_m module~bd_solver_m->module~trajectory_m module~bd_solver_m->module~brown_m module~aabb_m->module~constants_m module~aabb_m->module~strings_m module~aabbtree_sm aabbtree_sm module~aabbtree_sm->module~aabbtree_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ip ip_long rp sizeof_char sizeof_int sizeof_long_int sizeof_real math_third math_pi math_pi_2 math_pi_4 math_1_pi math_2_pi math_2_sqrtpi math_sqrt2 math_cbrt2 math_sxrt2 math_sqrt1_2 math_sqrt3 math_sqrt_e math_sqrt_pi math_e math_log2e math_log10e math_ln2 math_ln10 Variables Type Visibility Attributes Name Initial integer, public, parameter :: ip = int32 Default integer precision integer, public, parameter :: ip_long = int64 Default long integer precision integer, public, parameter :: rp = real64 Default real precision integer, public, parameter :: sizeof_char = 1 Size of a char in bytes integer, public, parameter :: sizeof_int = 4 Size of a default int in bytes integer, public, parameter :: sizeof_long_int = 8 Size of a default long int in bytes integer, public, parameter :: sizeof_real = 8 Size of a default real in bytes real(kind=rp), public, parameter :: math_third = 0.333333333333333_rp real(kind=rp), public, parameter :: math_pi = 3.1415926535897931_rp pi real(kind=rp), public, parameter :: math_pi_2 = 1.5707963267948966_rp pi divided by two real(kind=rp), public, parameter :: math_pi_4 = 0.78539816339744828_rp pi divided by four real(kind=rp), public, parameter :: math_1_pi = 0.31830988618379069_rp reciprocal of pi real(kind=rp), public, parameter :: math_2_pi = 0.63661977236758138_rp two times reciprocal of pi real(kind=rp), public, parameter :: math_2_sqrtpi = 1.1283791670955126_rp two times the reciprocal of the square root of pi. real(kind=rp), public, parameter :: math_sqrt2 = 1.4142135623730951_rp square root of two real(kind=rp), public, parameter :: math_cbrt2 = 1.2599210498948732_rp cube root of two real(kind=rp), public, parameter :: math_sxrt2 = 1.122462048309373_rp sixth root of two real(kind=rp), public, parameter :: math_sqrt1_2 = 0.70710678118654746_rp reciprocal of the square root of two real(kind=rp), public, parameter :: math_sqrt3 = 1.7320508075688772_rp square root of three real(kind=rp), public, parameter :: math_sqrt_e = 1.6487212707001282_rp square root of M_E real(kind=rp), public, parameter :: math_sqrt_pi = 1.7724538509055159_rp square root of pi real(kind=rp), public, parameter :: math_e = 2.7182818284590451_rp The base of natural logarithms real(kind=rp), public, parameter :: math_log2e = 1.4426950408889634_rp The logarithm of M_E to base two real(kind=rp), public, parameter :: math_log10e = 0.43429448190325182_rp The logarithm of M_E to base 10 real(kind=rp), public, parameter :: math_ln2 = 0.69314718055994529_rp The natural logarithm of two real(kind=rp), public, parameter :: math_ln10 = 2.3025850929940459_rp The natural logarithm of 10","tags":"","loc":"module/constants_m.html"},{"title":"strings_m – BROWNPAK","text":"Many of these routines were originally written by George Benthien , some have\n been written by Sarit Dutta or gathered/modified from other authors (appropriately credited). These routines were developed primarily to aid in the reading and manipulation\n of input data from an ASCII text file. Accordingly, it is assumed that all\n characters to be processed are ASCII characters. Uses constants_m module~~strings_m~~UsesGraph module~strings_m strings_m module~constants_m constants_m module~strings_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~strings_m~~UsedByGraph module~strings_m strings_m module~ia_bond_m ia_bond_m module~ia_bond_m->module~strings_m program~main main program~main->module~strings_m module~setup_m setup_m program~main->module~setup_m module~control_m control_m program~main->module~control_m module~aabbtree_m aabbtree_m module~aabbtree_m->module~strings_m module~aabb_m aabb_m module~aabbtree_m->module~aabb_m module~setup_m->module~strings_m module~config_io_m config_io_m module~setup_m->module~config_io_m module~stats_m stats_m module~setup_m->module~stats_m module~setup_m->module~control_m module~bd_solver_m bd_solver_m module~setup_m->module~bd_solver_m module~interaction_m interaction_m module~setup_m->module~interaction_m module~brown_m brown_m module~brown_m->module~strings_m module~config_io_m->module~strings_m module~stats_m->module~strings_m module~stats_m->module~control_m module~control_m->module~strings_m module~aabb_m->module~strings_m module~aabbtree_sm aabbtree_sm module~aabbtree_sm->module~aabbtree_m module~bd_solver_m->module~brown_m module~bd_solver_m->module~config_io_m module~bd_solver_m->module~stats_m module~bd_solver_m->module~control_m module~bd_solver_m->module~interaction_m module~pairtab_m pairtab_m module~pairtab_m->module~aabbtree_m module~interaction_m->module~ia_bond_m module~interaction_m->module~stats_m module~interaction_m->module~control_m module~interaction_m->module~pairtab_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces str_from_num Functions str_is_letter str_is_digit str_is_space str_is_comment str_compact str_remove_stcc str_to_upper str_to_lower str_from_inum str_from_ilnum str_from_dnum str_trimzero str_to_d str_to_i str_strip str_startswith str_endswith Subroutines str_shift str_insert str_del str_strip_comment str_get_keyval str_match str_compact_rlstr str_split str_append readline Interfaces public interface str_from_num Generic  interface for writing a number to a string. The calling syntax is str_from_num(num, frmt) where number is a real number or an integer, format is the format desired, e.g., e15.6 , i5 , etc. private pure function str_from_inum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_ilnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_dnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Functions public pure function str_is_letter (str) result(res) Returns .true. if str contains only letters ( a--z or A--Z ) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical public pure function str_is_digit (str) result(res) Returns .true. if str contains only digits (0,1,...,9) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical public pure function str_is_space (str) result(res) Returns .true. if str is non-empty and contains only whitespace\n characters (tab or blankspace). Otherwise .false. is returned. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical public pure function str_is_comment (line, comment_str) result(res) Returns .true. if line is a comment, .false. other wise. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Input string character(len=*), intent(in) :: comment_str String marking the beginning of a comment. Return Value logical public pure function str_compact (str) result(ostr) Returns a copy of str with multiple spaces and tabs converted to\n single spaces, control characters deleted, and leading and trailing\n spaces removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable public pure function str_remove_stcc (str) result(ostr) Returns a copy of the string str with spaces, tabs, and\n control characters removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable public pure function str_to_upper (str) result(ucstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to uppercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) public pure function str_to_lower (str) result(lcstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to lowercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) private pure function str_from_inum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_ilnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_dnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable public pure function str_trimzero (str) result(res) Deletes nonsignificant trailing zeroes from number string str. If number\n string ends in a decimal point, one trailing zero is added. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable public pure function str_to_d (str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value real(kind=rp) public pure function str_to_i (str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer public pure function str_strip (str, chars, ends) result(ostr) Returns a copy of string str with the leading and trailing characters\n removed. The chars argument is a string specifying the set of characters to\n be removed.  The chars argument is not a prefix or suffix; rather, all\n combinations of its values are stripped. If ends = 'l' , only leading\n characters are removed, if ends = 'r' , only trailing characters are\n removed, and if ends = 'b' both leading and trailing characters are\n removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: chars character(len=1), intent(in) :: ends {'l', 'r', 'b'} Return Value character(len=:),\n  allocatable public pure function str_startswith (str, prefix, start, finish) result(res) Returns .true. if the string str starts with prefix , otherwise\n returns .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: prefix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical public pure function str_endswith (str, suffix, start, finish) result(res) Returns .true. if the string str ends with suffix , otherwise\n return .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical Subroutines public subroutine str_shift (str, n) Shifts characters in str by n positions (positive values\n denote a right shift and negative values denote a left shift). Characters\n that are shifted off the end are lost. Positions opened up by the shift \n are replaced by spaces. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str integer, intent(in) :: n public subroutine str_insert (str, substr, loc) Inserts the string substr into the string str at position loc . \n Characters in str starting at position loc are shifted right to\n make room for the inserted string. Trailing spaces of substr are \n removed prior to insertion. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in) :: loc public subroutine str_del (str, substr, n) Deletes first n occurrences of substring substr from string str and\n shifts characters left to fill hole. If n < 0 , all occurances are\n deleted.  If n is not explicitly provided, it defaults to removing the\n first occurrence. Trailing spaces or blanks are not considered part of substr . Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in), optional :: n public subroutine str_strip_comment (str, comment_str) Strips trailing comment from a string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str Input string character(len=*), intent(in) :: comment_str String indicating beginning of a comment. public subroutine str_get_keyval (str, key, val, delimiter) Split a string str into two strings, key and val based on space\n delimiter. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=:), intent(out), allocatable :: key character(len=:), intent(out), allocatable :: val character(len=*), intent(in), optional :: delimiter public subroutine str_match (str, ipos, imatch) This routine finds the delimiter in string str that matches the delimiter\n in position ipos of str . The argument imatch contains the position of\n the matching delimiter. Allowable delimiters are (), [], {}, <>. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: ipos integer, intent(out) :: imatch public subroutine str_compact_rlstr (str) Author Izaak Beekman Date 02/24/2015 Compact a string representing a real number, so that the same value is\n displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str string representation of a real number. public subroutine str_split (str, delimiter, before) Routine finds the first instance of a character from delims in the the\n string str . The characters before the found delimiter are output in before . The characters after the found delimiter are output in str .\n Repeated applications of this routine can be used to parse a string into its\n component parts. Multiple whitespaces of str are compacted into a single\n whitespace before splitting begins. If either str or delimiter is\n empty, an empty string is retured in before and str remains\n unchanged. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: delimiter character(len=:), intent(out), allocatable :: before public subroutine str_append (dest, source, sep) Appends a copy of the source string to the dest string, with \n optional string sep in between. It is assumed that dest is long\n enough to hold the result, otherwise an error will be generated. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: dest character(len=*), intent(in) :: source character(len=*), intent(in), optional :: sep public subroutine readline (nunitr, line, comment_str, ios) Reads a line from unit=nunitr, ignoring blank lines\n  and deleting comments Arguments Type Intent Optional Attributes Name integer, intent(in) :: nunitr character(len=*), intent(inout) :: line character(len=*), intent(in) :: comment_str integer, intent(out) :: ios","tags":"","loc":"module/strings_m.html"},{"title":"atmcfg_m – BROWNPAK","text":"Uses constants_m module~~atmcfg_m~~UsesGraph module~atmcfg_m atmcfg_m module~constants_m constants_m module~atmcfg_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~atmcfg_m~~UsedByGraph module~atmcfg_m atmcfg_m module~ia_dihedral_m ia_dihedral_m module~ia_dihedral_m->module~atmcfg_m module~ia_vdw_m ia_vdw_m module~ia_vdw_m->module~atmcfg_m module~ia_external_m ia_external_m module~ia_external_m->module~atmcfg_m module~ia_angle_m ia_angle_m module~ia_angle_m->module~atmcfg_m module~ia_tether_m ia_tether_m module~ia_tether_m->module~atmcfg_m module~setup_m setup_m module~setup_m->module~atmcfg_m module~config_io_m config_io_m module~setup_m->module~config_io_m module~stats_m stats_m module~setup_m->module~stats_m module~bd_solver_m bd_solver_m module~setup_m->module~bd_solver_m module~interaction_m interaction_m module~setup_m->module~interaction_m module~pairtab_m pairtab_m module~pairtab_m->module~atmcfg_m module~config_io_m->module~atmcfg_m module~stats_m->module~atmcfg_m module~bd_solver_m->module~atmcfg_m module~bd_solver_m->module~config_io_m module~bd_solver_m->module~stats_m module~bd_solver_m->module~interaction_m module~interaction_m->module~atmcfg_m module~interaction_m->module~ia_dihedral_m module~interaction_m->module~ia_vdw_m module~interaction_m->module~ia_external_m module~interaction_m->module~ia_angle_m module~interaction_m->module~ia_tether_m module~interaction_m->module~pairtab_m module~interaction_m->module~stats_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables mxparam Derived Types atmcfg_t Subroutines atmcfg_delete Variables Type Visibility Attributes Name Initial integer, public, parameter :: mxparam = 12 Maximum number of parameters for bonds, angles, etc. Derived Types type, public :: atmcfg_t Components Type Visibility Attributes Name Initial integer, public :: num_atom_types = 0 Number of atom_type s character(len=8), public, dimension(:), allocatable :: atom_names ( num_atom_types ,) array. Name of atoms of each type. integer, public, dimension(:), allocatable :: atom_styles ( num_atom_types ,) array. Style of atoms of each type. real(kind=rp), public, dimension(:), allocatable :: atom_mass ( num_atom_types ,) array. Mass of atoms of each type. integer, public :: num_atoms = 0 Number of atoms integer, public, dimension(:), allocatable :: atoms ( num_atoms ,) array. Read more… real(kind=rp), public, dimension(:), allocatable :: charge ( num_atoms ,) array. real(kind=rp), public, dimension(:,:), allocatable :: coordinates (3, num_atoms ) array real(kind=rp), public, dimension(:,:), allocatable :: forces (3, num_atoms ) array integer, public :: num_bond_types = 0 Number of bond_type s integer, public, dimension(:), allocatable :: bond_styles ( num_bond_types ,) array. real(kind=rp), public, dimension(:,:), allocatable :: bond_params ( mxparam , num_bond_types ) array. integer, public :: num_bonds = 0 Total number of bonds. integer, public, dimension(:,:), allocatable :: bonds (3, num_bonds ) array. Bond i is of type bt = bonds(1,i) ,  directed from\n atom bonds(2,i) to bonds(3,i) . Its style is bond_styles(bt) with\n parameters bond_params(:,bt) . integer, public :: num_angle_types = 0 Number of angle_type s integer, public, dimension(:), allocatable :: angle_styles ( num_angle_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: angle_params ( mxparam , num_angle_types ) array integer, public :: num_angles = 0 Number of angles integer, public, dimension(:,:), allocatable :: angles (4, num_angles ) array. Angle i is of type ant = angles(1,i) , incident\n to atoms angles(2,i) , angles(3,i) , and angles(4,i) . Its style is angle_styles(ant) with parameters angle_params(:,ant) . integer, public :: num_dihedral_types = 0 Number of dihedral_type s integer, public, dimension(:), allocatable :: dihedral_styles ( num_dihedral_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: dihedral_params ( mxparam , num_dihedral_types ) array integer, public :: num_dihedrals = 0 Number of dihedrals integer, public, dimension(:,:), allocatable :: dihedrals (5, num_dihedrals ) array. Dihedral i is of type dt = dihedrals(1,i) , incident\n to atoms dihedrals(2,i) , dihedrals(3,i) , dihedrals(4,i) , and dihedrals(5,i) .\n Its style is dihedral_styles(dt) with parameters dihedral_params(:,dt) . integer, public :: num_branches = 0 Total number of branches (including the backbone) integer, public, dimension(:,:), allocatable :: branches (3, num_branches ) array. Branch i is tethered to atom branches(1,i) ,\n contains branches(2,i) atoms, with the beginning atom index branches(3,i) . integer, public :: num_molecule_types = 0 Number of molecule_type s character(len=8), public, dimension(:), allocatable :: molecule_names ( num_molecule_types ,) array integer, public, dimension(:), allocatable :: molecule_pop ( num_molecule_types ,) array integer, public :: num_molecules = 0 Number of molecules integer, public, dimension(:,:), allocatable :: molecules (9, num_molecules ) array. For molecule i , its type mt = molecules(1,i) , \n containing molecules(2,i) atoms with beginning index molecules(3,i) , molecules(4,i) bonds with beginning index molecules(5,i) , molecules(6,i) angles with beginning index molecules(7,i) , and molecules(8,i) dihedrals with beginning index molecules(9,i) . real(kind=rp), public, dimension(3) :: molecule_com = 0.0_rp Center of mass of the molecule. This is used only when imcon == 0, i.e.\n for a single molecule without periodic boundaries. integer, public :: num_tether_types = 0 Number of tether_type s integer, public, dimension(:), allocatable :: tether_styles ( num_tether_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: tether_params ( mxparam , num_tether_types ) array integer, public :: num_tethers = 0 Number of tethers integer, public, dimension(:,:), allocatable :: tethers (2, num_tethers ) array. Tether i is of type tt = tethers(1,i) , tethering\n atom tethers(2,i) to a point tether_points(:,i) .\n Its style is tether_styles(tt) with parameters tether_params(:,tt) . real(kind=rp), public, dimension(:,:), allocatable :: tether_points (3, num_tethers ) array integer, public :: num_vdw_types = 0 Number of vdw_type s integer, public, dimension(:), allocatable :: vdw_styles ( num_vdw_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: vdw_params ( mxparam , num_vdw_types ) array integer, public, dimension(:,:), allocatable :: vdw_pairs (2, num_vdw_types ) array. Stores atom type of interacting pairs, such\n that at_i >= at_j. integer, public :: num_externals = 0 Number of external fields integer, public, dimension(:), allocatable :: external_styles ( num_external ,) array real(kind=rp), public, dimension(:,:), allocatable :: external_params ( mxparam , num_external ) array integer, public :: flow_style = 0 real(kind=rp), public, dimension(:), allocatable :: flow_params ( mxparam ,) array Subroutines public subroutine atmcfg_delete (this) Deallocates all memory acquired by a configuration_t object and resets\n all other components to zero. Exception: num_coeffs is not reset to\n zero. Arguments Type Intent Optional Attributes Name type( atmcfg_t ), intent(inout) :: this","tags":"","loc":"module/atmcfg_m.html"},{"title":"ia_bond_m – BROWNPAK","text":"This module contains routines to evaluate bond potentials and their\n derivative. The following styles are available: Style 0. None (only topology) Style 1. Harmonic. See bond_harm_set . Style 2. FENE. See bond_fene_set . Style 3. Kremer-Grest. See bond_kg_set . Style 4. Marko-Siggia. See bond_ms_set . Uses constants_m strings_m logger_m module~~ia_bond_m~~UsesGraph module~ia_bond_m ia_bond_m module~strings_m strings_m module~ia_bond_m->module~strings_m module~constants_m constants_m module~ia_bond_m->module~constants_m module~logger_m logger_m module~ia_bond_m->module~logger_m module~strings_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~logger_m->iso_fortran_env module~timestamp_m timestamp_m module~logger_m->module~timestamp_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ia_bond_m~~UsedByGraph module~ia_bond_m ia_bond_m module~interaction_m interaction_m module~interaction_m->module~ia_bond_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_bond_setup ia_get_bond_force bond_harm_set bond_harm bond_fene_set bond_fene bond_kg_set bond_kg bond_ms_set bond_ms Subroutines public subroutine ia_bond_setup (num_bond_types, bond_styles, bond_params) Sets up parameters for bond potentials Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_bond_types Number of bond types integer, intent(in), dimension(:) :: bond_styles Styles for each type real(kind=rp), intent(inout), dimension(:,:) :: bond_params Parameters for each type, depending on style public subroutine ia_get_bond_force (rij_mag, sty, params, enrg, frc, ierr) Calculates the energy & its derivative due to a bond. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between bonded atoms integer, intent(in) :: sty Style of the bond real(kind=rp), intent(in), dimension(:) :: params Parameters for bonded interaction real(kind=rp), intent(out) :: enrg Bond energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of the force due\n to this potential. integer, intent(out) :: ierr Error flag private subroutine bond_harm_set (params, k, r0) Setter for harmonic bond interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 private subroutine bond_harm (r, params, enrg, frc) Calculates energy & its derivative for harmonic bond. See bond_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine bond_fene_set (params, k, rmax, r0) Setter for FENE bond. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: r0 private subroutine bond_fene (r, params, enrg, frc, ierr) Calculates energy & its derivative for FENE bond. See bond_fene_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr private subroutine bond_kg_set (params, k, rmax, eps, sigma) Setter for FENE bond interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma private subroutine bond_kg (r, params, enrg, frc, ierr) Calculates energy & its derivative for Kremer-Grest bond. See bond_kg_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr private subroutine bond_ms_set (params, lp, rmax) Setter for Marko-Siggia bond. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: lp real(kind=rp), intent(in), optional :: rmax private subroutine bond_ms (r, params, enrg, frc, ierr) Evaluates the potential & its derivative for Marko-Siggia bond.\n See bond_ms_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr","tags":"","loc":"module/ia_bond_m.html"},{"title":"control_m – BROWNPAK","text":"Routines for reading and witing control file. Uses constants_m strings_m module~~control_m~~UsesGraph module~control_m control_m module~strings_m strings_m module~control_m->module~strings_m module~constants_m constants_m module~control_m->module~constants_m module~strings_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~control_m~~UsedByGraph module~control_m control_m program~main main program~main->module~control_m module~setup_m setup_m program~main->module~setup_m module~setup_m->module~control_m module~stats_m stats_m module~setup_m->module~stats_m module~bd_solver_m bd_solver_m module~setup_m->module~bd_solver_m module~interaction_m interaction_m module~setup_m->module~interaction_m module~stats_m->module~control_m module~bd_solver_m->module~control_m module~bd_solver_m->module~stats_m module~bd_solver_m->module~interaction_m module~interaction_m->module~control_m module~interaction_m->module~stats_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables mxrdln Derived Types ctrlpar_t Subroutines control_read control_write Variables Type Visibility Attributes Name Initial integer, public, parameter :: mxrdln = 1024 Maximum length of character string for input line buffer. Derived Types type, public :: ctrlpar_t Components Type Visibility Attributes Name Initial real(kind=rp), public :: rcutoff = 0.0_rp real(kind=rp), public :: tskin = 0.0_rp character(len=5), public :: mth_ptgen = '' logical, public :: lelst = .false. logical, public :: lhdia = .false. logical, public :: lvdw = .false. integer, public :: excluded_atoms = 0 character(len=4), public :: mob_fctr = '' integer, public :: lanc_mxitr = 0 real(kind=rp), public :: lanc_tol = 0.0_rp integer, public :: se_nlmxitr = 0 integer, public :: se_kdmax = 0 character(len=4), public :: bdintg = '' real(kind=rp), public, dimension(2) :: se_tol = 0.0_rp integer, public, dimension(2) :: stats_binsize = 0 real(kind=rp), public :: tim_stp = 0.0_rp integer(kind=ip_long), public :: nts_sim = 0 integer, public :: nts_mobsam = 0 integer(kind=ip_long), public :: nts_dump = 0 integer(kind=ip_long), public :: nts_samp = 0 integer(kind=ip_long), public :: nts_log = 0 logical, public :: lrevive = .false. {T, F}. Whether the simulation is restarted. logical, public :: read_seed = .false. {T, F}. Whether to initialize the random number generator by reading\n a seed from a file. If read_seed == T, the seed will be read from\n a file 'random_seed.txt' logical, public :: write_seed = .false. {T, F}. Whether to write the random number generator seed. If write_seed == T the seed will be written to a file named\n  'random_seed.txt' logical, public :: write_traj = .false. Should the trajectory be written to file? {T, F} character(len=:), public, allocatable :: fn_cfg Name of the file containing the initial configuration character(len=:), public, allocatable :: fn_revive Name of the revive file character(len=:), public, allocatable :: fn_stats Name of the statistics file character(len=:), public, allocatable :: fn_traj Name of the trajectory file Type-Bound Procedures procedure, public :: read => control_read procedure, public :: write => control_write Subroutines public subroutine control_read (this, fn) Reads simulation control parameters from file Arguments Type Intent Optional Attributes Name class( ctrlpar_t ), intent(out) :: this A ctrlpar_t instance. character(len=*), intent(in) :: fn Name of parameters file. public subroutine control_write (this, fn) Write simulation parameters to file Arguments Type Intent Optional Attributes Name class( ctrlpar_t ), intent(out) :: this A ctrlpar_t instance. character(len=*), intent(in) :: fn Output file name","tags":"","loc":"module/control_m.html"},{"title":"aabb_m – BROWNPAK","text":"Uses constants_m strings_m module~~aabb_m~~UsesGraph module~aabb_m aabb_m module~strings_m strings_m module~aabb_m->module~strings_m module~constants_m constants_m module~aabb_m->module~constants_m module~strings_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~aabb_m~~UsedByGraph module~aabb_m aabb_m module~aabbtree_m aabbtree_m module~aabbtree_m->module~aabb_m module~pairtab_m pairtab_m module~pairtab_m->module~aabbtree_m module~aabbtree_sm aabbtree_sm module~aabbtree_sm->module~aabbtree_m module~interaction_m interaction_m module~interaction_m->module~pairtab_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces operator(+) Derived Types aabb_t Functions aabb_includes aabb_overlaps aabb_union Subroutines aabb_init aabb_print aabb_clear aabb_get_extent aabb_update aabb_fatten aabb_calc_center aabb_calc_srfarea Interfaces public interface operator(+) public function aabb_union (x, y) result(z) Combines AABBs x and y to return a new AABB z . Arguments Type Intent Optional Attributes Name type( aabb_t ), intent(in) :: x An aabb_t instance. type( aabb_t ), intent(in) :: y An aabb_t instance. Return Value type( aabb_t ) Derived Types type, public :: aabb_t Components Type Visibility Attributes Name Initial real(kind=rp), public, dimension(3) :: lbnd real(kind=rp), public, dimension(3) :: ubnd real(kind=rp), public, dimension(3) :: center real(kind=rp), public :: srfarea Type-Bound Procedures procedure, public :: init => aabb_init procedure, public :: print => aabb_print procedure, public :: clear => aabb_clear procedure, public :: get_extent => aabb_get_extent procedure, public :: update => aabb_update procedure, public :: fatten => aabb_fatten procedure, public :: includes => aabb_includes procedure, public :: overlaps => aabb_overlaps procedure, private :: calc_center => aabb_calc_center procedure, private :: calc_srfarea => aabb_calc_srfarea Functions public function aabb_includes (this, other) result(res) Returns true if this includes other , false otherwise. Inclusion\n is considered in a strict sense. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical public function aabb_overlaps (this, other) result(res) Returns true if this overlaps other , false otherwise. Touching\n does not count as an overlap. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical public function aabb_union (x, y) result(z) Combines AABBs x and y to return a new AABB z . Arguments Type Intent Optional Attributes Name type( aabb_t ), intent(in) :: x An aabb_t instance. type( aabb_t ), intent(in) :: y An aabb_t instance. Return Value type( aabb_t ) Subroutines public subroutine aabb_init (this, lbnd, ubnd) Initializes an aabb_t instance from lower and upper bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(out) :: this An aabb_t instance. real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound public subroutine aabb_print (this, frmt, str) Prints an AABB. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. character(len=*), intent(in), optional :: frmt Fortran-style format string for a real number. Default: (g0.6) . character(len=:), intent(out), optional allocatable :: str If present, the output is printed to this string instead of STDOUT. public subroutine aabb_clear (this) Clears all attributes of an AABB and sets them to zero. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. public subroutine aabb_get_extent (this, extent) Calculates the extent of an aabb . The extent of an AABB is defined as\n the difference between its upper and lower bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. real(kind=rp), intent(out), dimension(3) :: extent Extent of an AABB. public subroutine aabb_update (this, lbnd, ubnd) Updates an AABB with new bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in), optional dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), optional dimension(3) :: ubnd Upper bound public subroutine aabb_fatten (this, frac) Fattens an AABB by a fraction of its base extent. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in) :: frac Fraction of AABB base extent. public subroutine aabb_calc_center (this) Calculates the center of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. public subroutine aabb_calc_srfarea (this) Calculates the surface area of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance.","tags":"","loc":"module/aabb_m.html"},{"title":"ia_tether_m – BROWNPAK","text":"Tether potentials Style 0: None Style 1: Rigid connector (not implemented)\n *Style 2: Harmonic spring. See teth_harm_set . Uses constants_m atmcfg_m module~~ia_tether_m~~UsesGraph module~ia_tether_m ia_tether_m module~constants_m constants_m module~ia_tether_m->module~constants_m module~atmcfg_m atmcfg_m module~ia_tether_m->module~atmcfg_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~atmcfg_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ia_tether_m~~UsedByGraph module~ia_tether_m ia_tether_m module~interaction_m interaction_m module~interaction_m->module~ia_tether_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_tether_setup ia_get_tether_force teth_rigid_set teth_rigid teth_harm_set teth_harm Subroutines public subroutine ia_tether_setup (num_tether_types, tether_styles, tether_params) Sets up parameters for tether potentials Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_tether_types Number of tether types integer, intent(in), dimension(:) :: tether_styles Styles for each type real(kind=rp), intent(inout), dimension(:,:) :: tether_params Parameters for each type, depending on style public subroutine ia_get_tether_force (qmag, sty, params, enrg, frc, ierr) Calculates the energy and its derivative due to a tether. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: qmag Distance between the tethered atom & the tether point integer, intent(in) :: sty Tether style real(kind=rp), intent(in), dimension(:) :: params Parameters for tether interaction real(kind=rp), intent(out) :: enrg Energy due to this tether real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Error flag private subroutine teth_rigid_set (params, r0, eps) Setter for rigid tether interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: r0 real(kind=rp), intent(in), optional :: eps private subroutine teth_rigid (r, params, enrg, frc, ierr) Not implemented, needs constraint formalism. See teth_rigid_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr private subroutine teth_harm_set (params, k, r0) Setter for harmonic tether interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 private subroutine teth_harm (r, params, enrg, frc) Calculates energy and its derivative for harmonic tether interaction. See teth_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc","tags":"","loc":"module/ia_tether_m.html"},{"title":"table_m – BROWNPAK","text":"Implements a table with contiguously stored rows. Uses constants_m vector_m module~~table_m~~UsesGraph module~table_m table_m module~constants_m constants_m module~table_m->module~constants_m module~vector_m vector_m module~table_m->module~vector_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~vector_m->module~constants_m module~qsort_m qsort_m module~vector_m->module~qsort_m module~qsort_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~table_m~~UsedByGraph module~table_m table_m module~connectivity_m connectivity_m module~connectivity_m->module~table_m module~pairtab_m pairtab_m module~pairtab_m->module~table_m module~pairtab_m->module~connectivity_m module~interaction_m interaction_m module~interaction_m->module~table_m module~interaction_m->module~pairtab_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types itable_t Functions itbl_is_in itbl_get_val Subroutines itbl_init itbl_delete itbl_clear itbl_append itbl_set_val itbl_get_row itbl_shrink_to_fit itbl_print Derived Types type, public :: itable_t Components Type Visibility Attributes Name Initial integer, public :: num_rows = 0 type( ivector_t ), public :: buffer integer, public, dimension(:), allocatable :: row_indx Type-Bound Procedures procedure, public :: delete => itbl_delete procedure, public :: clear => itbl_clear procedure, public :: append => itbl_append procedure, public :: set_val => itbl_set_val procedure, public :: is_in => itbl_is_in procedure, public :: get_val => itbl_get_val procedure, public :: get_row => itbl_get_row procedure, public :: shrink_to_fit => itbl_shrink_to_fit procedure, public :: print => itbl_print Functions private function itbl_is_in (this, irow, val) result(res) Returns .true. if val is in row irow , .false. otherwise. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: val Return Value logical private function itbl_get_val (this, irow, j) result(res) Returns the j th element of row irow Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: j Return Value integer Subroutines public subroutine itbl_init (this, num_rows, ierr) Creates an empty itable_t with num_rows rows and all rows having\n zero elements. Arguments Type Intent Optional Attributes Name type( itable_t ), intent(inout) :: this integer, intent(in) :: num_rows Must be > 0 integer, intent(out), optional :: ierr private subroutine itbl_delete (this) Deletes an itable_t . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this private subroutine itbl_clear (this) Clears all rows. Does not deallocate memory. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this private subroutine itbl_append (this, irow, val) Appends an element val to row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: val private subroutine itbl_set_val (this, irow, j, val) Sets the value of the j th element of row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: j integer, intent(in) :: val private subroutine itbl_get_row (this, irow, res) Returns a pointer to the row data of irow . No bounds checking is performed. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in), target :: this integer, intent(in) :: irow integer, intent(out), dimension(:), pointer :: res private subroutine itbl_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(out), optional :: ierr private subroutine itbl_print (this) Prints an itable_t . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this","tags":"","loc":"module/table_m.html"},{"title":"logger_m – BROWNPAK","text":"Implements a basic logger. Uses iso_fortran_env timestamp_m module~~logger_m~~UsesGraph module~logger_m logger_m iso_fortran_env iso_fortran_env module~logger_m->iso_fortran_env module~timestamp_m timestamp_m module~logger_m->module~timestamp_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~logger_m~~UsedByGraph module~logger_m logger_m module~ia_bond_m ia_bond_m module~ia_bond_m->module~logger_m program~main main program~main->module~logger_m module~setup_m setup_m program~main->module~setup_m module~setup_m->module~logger_m module~bd_solver_m bd_solver_m module~setup_m->module~bd_solver_m module~interaction_m interaction_m module~setup_m->module~interaction_m module~brown_m brown_m module~brown_m->module~logger_m module~bd_solver_m->module~logger_m module~bd_solver_m->module~brown_m module~bd_solver_m->module~interaction_m module~interaction_m->module~ia_bond_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables logger Derived Types logger_t Subroutines logger_init logger_finish logger_log_msg Variables Type Visibility Attributes Name Initial type( logger_t ), public :: logger Derived Types type, private :: logger_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: fn Name of the log file integer, public :: fu = huge(0) Unit number of the log file logical, public :: is_open = .false. Is the log file open for writing? {T/F} Type-Bound Procedures procedure, public :: init => logger_init procedure, public :: finish => logger_finish procedure, public :: log_msg => logger_log_msg Subroutines private subroutine logger_init (this, fn, use_stdout) Initializes a logger. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(out) :: this A logger_t instance character(len=*), intent(in) :: fn Name of the log file. If use_stdout is true, fn is ignored. logical, intent(in) :: use_stdout Write all log messages to stdout rather than a file on disk? {T/F} private subroutine logger_finish (this) Cleanup routine for a logger_t instance. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(inout) :: this A logger_t instance private subroutine logger_log_msg (this, msg) Write a message to the log file. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(in) :: this A logger_t instance character(len=*), intent(in) :: msg Message to write to the log file","tags":"","loc":"module/logger_m.html"},{"title":"ia_angle_m – BROWNPAK","text":"Angle potentials Style 0: None (Only topology) Style 1: Cosine. See ang_cos_set . Uses constants_m atmcfg_m module~~ia_angle_m~~UsesGraph module~ia_angle_m ia_angle_m module~constants_m constants_m module~ia_angle_m->module~constants_m module~atmcfg_m atmcfg_m module~ia_angle_m->module~atmcfg_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~atmcfg_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ia_angle_m~~UsedByGraph module~ia_angle_m ia_angle_m module~interaction_m interaction_m module~interaction_m->module~ia_angle_m module~bd_solver_m bd_solver_m module~bd_solver_m->module~interaction_m module~setup_m setup_m module~setup_m->module~interaction_m module~setup_m->module~bd_solver_m program~main main program~main->module~setup_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_angle_setup ia_get_angle_force ang_cos_set Subroutines public subroutine ia_angle_setup (num_angle_types, angle_styles, angle_params) Sets up parameters for angle potentials Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_angle_types Number of angle types integer, intent(in), dimension(:) :: angle_styles Styles for each type real(kind=rp), intent(inout), dimension(:,:) :: angle_params Parameters for each type, depending on style public subroutine ia_get_angle_force (q1, q2, sty, params, enrg, fim1, fi, fip1) Calculates the energy & force due to an angle. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 integer, intent(in) :: sty real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fim1 real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fip1 private subroutine ang_cos_set (params, k) Setter for angular cosine interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k","tags":"","loc":"module/ia_angle_m.html"},{"title":"aabbtree_sm – BROWNPAK","text":"Uses Ancestors: aabbtree_m module~~aabbtree_sm~~UsesGraph module~aabbtree_sm aabbtree_sm module~aabbtree_m aabbtree_m module~aabbtree_sm->module~aabbtree_m module~vector_m vector_m module~aabbtree_m->module~vector_m module~strings_m strings_m module~aabbtree_m->module~strings_m module~constants_m constants_m module~aabbtree_m->module~constants_m module~aabb_m aabb_m module~aabbtree_m->module~aabb_m module~vector_m->module~constants_m module~qsort_m qsort_m module~vector_m->module~qsort_m module~strings_m->module~constants_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~aabb_m->module~strings_m module~aabb_m->module~constants_m module~qsort_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Functions node_isleaf node_asstr get_num_atoms get_aabb get_height get_max_balance get_srfarea_ratio balance calc_height fs_acquire Module Subroutines node_init init print clear delete insert remove remove_all update_fatm update_fatmaabb query_watm query_watmaabb query_waabb rebuild validate insert_leaf remove_leaf fs_return validate_structure validate_metrics Module Functions module function node_isleaf (this) result(res) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this Return Value logical module function node_asstr (this, frmt) result(buf) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable module function get_num_atoms (this) result(na) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer module function get_aabb (this, ia) result(aabb) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia Return Value type( aabb_t ) module function get_height (this) result(height) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer module function get_max_balance (this) result(max_balance) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer module function get_srfarea_ratio (this) result(saratio) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value real(kind=rp) module function balance (this, p) result(q) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: p Return Value integer recursive module function calc_height (this, p) result(height) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in), optional :: p Return Value integer module function fs_acquire (this) result(p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Return Value integer Module Subroutines module subroutine node_init (this) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(out) :: this module subroutine init (this, natoms, tskin) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(out) :: this integer, intent(in) :: natoms real(kind=rp), intent(in) :: tskin recursive module subroutine print (this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in), optional :: p module subroutine clear (this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this module subroutine delete (this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this module subroutine insert (this, ia, pos, radius) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: pos real(kind=rp), intent(in) :: radius module subroutine remove (this, ia) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia module subroutine remove_all (this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this module subroutine update_fatm (this, ia, pos, radius, lstat) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: pos real(kind=rp), intent(in) :: radius logical, intent(out) :: lstat module subroutine update_fatmaabb (this, ia, lbnd, ubnd, lstat) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: lbnd real(kind=rp), intent(in), dimension(3) :: ubnd logical, intent(out) :: lstat module subroutine query_watm (this, ia, nbrs) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia type( ivector_t ), intent(inout) :: nbrs module subroutine query_watmaabb (this, ia, aabb, nbrs) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia type( aabb_t ), intent(in) :: aabb type( ivector_t ), intent(inout) :: nbrs module subroutine query_waabb (this, aabb, atms) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this type( aabb_t ), intent(in) :: aabb type( ivector_t ), intent(inout) :: atms module subroutine rebuild (this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this module subroutine validate (this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this module subroutine insert_leaf (this, leaf) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: leaf module subroutine remove_leaf (this, leaf) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: leaf module subroutine fs_return (this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: p recursive module subroutine validate_structure (this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: p recursive module subroutine validate_metrics (this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: p","tags":"","loc":"module/aabbtree_sm.html"},{"title":"main – BROWNPAK","text":"Uses constants_m strings_m logger_m control_m setup_m program~~main~~UsesGraph program~main main module~strings_m strings_m program~main->module~strings_m module~setup_m setup_m program~main->module~setup_m module~constants_m constants_m program~main->module~constants_m module~logger_m logger_m program~main->module~logger_m module~control_m control_m program~main->module~control_m module~strings_m->module~constants_m module~setup_m->module~strings_m module~setup_m->module~constants_m module~setup_m->module~logger_m module~setup_m->module~control_m module~simbox_m simbox_m module~setup_m->module~simbox_m module~atmcfg_m atmcfg_m module~setup_m->module~atmcfg_m module~config_io_m config_io_m module~setup_m->module~config_io_m module~random_m random_m module~setup_m->module~random_m module~stats_m stats_m module~setup_m->module~stats_m module~bd_solver_m bd_solver_m module~setup_m->module~bd_solver_m module~trajectory_m trajectory_m module~setup_m->module~trajectory_m module~interaction_m interaction_m module~setup_m->module~interaction_m iso_fortran_env iso_fortran_env module~constants_m->iso_fortran_env module~timestamp_m timestamp_m module~logger_m->module~timestamp_m module~logger_m->iso_fortran_env module~control_m->module~strings_m module~control_m->module~constants_m module~simbox_m->module~constants_m module~simbox_m->module~random_m module~atmcfg_m->module~constants_m module~config_io_m->module~strings_m module~config_io_m->module~constants_m module~config_io_m->module~simbox_m module~config_io_m->module~atmcfg_m module~random_m->module~constants_m mkl_vsl_type mkl_vsl_type module~random_m->mkl_vsl_type mkl_vsl mkl_vsl module~random_m->mkl_vsl module~stats_m->module~strings_m module~stats_m->module~constants_m module~stats_m->module~control_m module~stats_m->module~simbox_m module~stats_m->module~atmcfg_m module~bd_solver_m->module~constants_m module~bd_solver_m->module~logger_m module~bd_solver_m->module~control_m module~bd_solver_m->module~atmcfg_m module~bd_solver_m->module~config_io_m module~bd_solver_m->module~stats_m module~bd_solver_m->module~trajectory_m module~bd_solver_m->module~interaction_m iso_c_binding iso_c_binding module~bd_solver_m->iso_c_binding module~brown_m brown_m module~bd_solver_m->module~brown_m mkl_blas mkl_blas module~bd_solver_m->mkl_blas module~trajectory_m->module~constants_m module~interaction_m->module~constants_m module~interaction_m->module~control_m module~interaction_m->module~simbox_m module~interaction_m->module~atmcfg_m module~interaction_m->module~stats_m module~ia_dihedral_m ia_dihedral_m module~interaction_m->module~ia_dihedral_m module~ia_bond_m ia_bond_m module~interaction_m->module~ia_bond_m module~ia_vdw_m ia_vdw_m module~interaction_m->module~ia_vdw_m module~ia_external_m ia_external_m module~interaction_m->module~ia_external_m module~ia_angle_m ia_angle_m module~interaction_m->module~ia_angle_m module~table_m table_m module~interaction_m->module~table_m module~ia_tether_m ia_tether_m module~interaction_m->module~ia_tether_m module~pairtab_m pairtab_m module~interaction_m->module~pairtab_m module~ia_dihedral_m->module~constants_m module~ia_dihedral_m->module~atmcfg_m module~ia_bond_m->module~strings_m module~ia_bond_m->module~constants_m module~ia_bond_m->module~logger_m module~ia_vdw_m->module~constants_m module~ia_vdw_m->module~atmcfg_m module~ia_external_m->module~constants_m module~ia_external_m->module~atmcfg_m module~ia_angle_m->module~constants_m module~ia_angle_m->module~atmcfg_m module~table_m->module~constants_m module~vector_m vector_m module~table_m->module~vector_m module~ia_tether_m->module~constants_m module~ia_tether_m->module~atmcfg_m module~pairtab_m->module~constants_m module~pairtab_m->module~simbox_m module~pairtab_m->module~atmcfg_m module~pairtab_m->module~table_m module~connectivity_m connectivity_m module~pairtab_m->module~connectivity_m module~pairtab_m->module~vector_m module~cell_list_m cell_list_m module~pairtab_m->module~cell_list_m module~aabbtree_m aabbtree_m module~pairtab_m->module~aabbtree_m module~brown_m->module~strings_m module~brown_m->module~constants_m module~brown_m->module~logger_m module~brown_m->module~random_m module~brown_m->iso_c_binding module~brown_m->mkl_blas mkl_lapack mkl_lapack module~brown_m->mkl_lapack module~connectivity_m->module~constants_m module~connectivity_m->module~table_m module~connectivity_m->module~vector_m module~vector_m->module~constants_m module~qsort_m qsort_m module~vector_m->module~qsort_m module~cell_list_m->module~constants_m module~cell_list_m->module~simbox_m module~cell_list_m->module~vector_m module~aabbtree_m->module~strings_m module~aabbtree_m->module~constants_m module~aabbtree_m->module~vector_m module~aabb_m aabb_m module~aabbtree_m->module~aabb_m module~qsort_m->module~constants_m module~aabb_m->module~strings_m module~aabb_m->module~constants_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~main~~CallsGraph program~main main proc~run run program~main->proc~run proc~str_get_keyval str_get_keyval program~main->proc~str_get_keyval proc~finish finish proc~run->proc~finish proc~read_config read_config proc~run->proc~read_config proc~bds_init bds_init proc~run->proc~bds_init proc~stats_init stats_init proc~run->proc~stats_init proc~init_stream init_stream proc~run->proc~init_stream proc~bds_run bds_run proc~run->proc~bds_run proc~read_dump read_dump proc~run->proc~read_dump proc~ia_setup ia_setup proc~run->proc~ia_setup proc~ia_finish ia_finish proc~finish->proc~ia_finish proc~atmcfg_delete atmcfg_delete proc~finish->proc~atmcfg_delete proc~bds_finish bds_finish proc~finish->proc~bds_finish proc~stats_finish stats_finish proc~finish->proc~stats_finish proc~str_to_i str_to_i proc~read_config->proc~str_to_i proc~readline readline proc~read_config->proc~readline proc~str_startswith str_startswith proc~read_config->proc~str_startswith proc~str_split str_split proc~read_config->proc~str_split proc~brn_init brn_init proc~bds_init->proc~brn_init proc~write_hdr write_hdr proc~stats_init->proc~write_hdr proc~zero_out zero_out proc~stats_init->proc~zero_out vslnewstream vslnewstream proc~init_stream->vslnewstream str_from_num str_from_num proc~bds_run->str_from_num proc~integrate_em integrate_em proc~bds_run->proc~integrate_em proc~integrate_se integrate_se proc~bds_run->proc~integrate_se proc~write_dump write_dump proc~bds_run->proc~write_dump proc~stats_accumulate stats_accumulate proc~bds_run->proc~stats_accumulate proc~stats_write stats_write proc~bds_run->proc~stats_write proc~ia_vdw_setup ia_vdw_setup proc~ia_setup->proc~ia_vdw_setup proc~ia_dihedral_setup ia_dihedral_setup proc~ia_setup->proc~ia_dihedral_setup proc~pt_init pt_init proc~ia_setup->proc~pt_init proc~ia_tether_setup ia_tether_setup proc~ia_setup->proc~ia_tether_setup proc~ia_external_setup ia_external_setup proc~ia_setup->proc~ia_external_setup proc~ia_angle_setup ia_angle_setup proc~ia_setup->proc~ia_angle_setup proc~ia_bond_setup ia_bond_setup proc~ia_setup->proc~ia_bond_setup proc~pt_delete pt_delete proc~ia_finish->proc~pt_delete proc~str_is_comment str_is_comment proc~readline->proc~str_is_comment proc~str_strip_comment str_strip_comment proc~readline->proc~str_strip_comment proc~cl_init cl_init proc~pt_init->proc~cl_init proc~atat_build atat_build proc~pt_init->proc~atat_build proc~exat_build exat_build proc~pt_init->proc~exat_build proc~cl_set_cell_size cl_set_cell_size proc~pt_init->proc~cl_set_cell_size proc~itbl_init itbl_init proc~pt_init->proc~itbl_init proc~cl_build_cell_nbrs cl_build_cell_nbrs proc~pt_init->proc~cl_build_cell_nbrs proc~calc_drift calc_drift proc~integrate_em->proc~calc_drift proc~calc_diffusion calc_diffusion proc~integrate_em->proc~calc_diffusion proc~integrate_se->proc~calc_diffusion proc~nitsol nitsol proc~integrate_se->proc~nitsol proc~compute_ic0 compute_ic0 proc~stats_accumulate->proc~compute_ic0 proc~compute_ic1 compute_ic1 proc~stats_accumulate->proc~compute_ic1 proc~str_compact str_compact proc~str_split->proc~str_compact proc~brn_finish brn_finish proc~bds_finish->proc~brn_finish proc~stats_finish->proc~zero_out proc~cl_delete cl_delete proc~pt_delete->proc~cl_delete dsymv dsymv proc~calc_drift->dsymv proc~ia_calc_forces ia_calc_forces proc~calc_drift->proc~ia_calc_forces interface~ivector_init ivector_init proc~cl_init->interface~ivector_init proc~atat_build->proc~itbl_init proc~atat_build->interface~ivector_init proc~calc_rpy_tensor calc_rpy_tensor proc~calc_diffusion->proc~calc_rpy_tensor proc~brn_calc_dw brn_calc_dw proc~calc_diffusion->proc~brn_calc_dw proc~brn_calc_bdw brn_calc_bdw proc~calc_diffusion->proc~brn_calc_bdw proc~exat_build->proc~itbl_init proc~exat_build->interface~ivector_init proc~itbl_init->interface~ivector_init interface~ivector_init->interface~ivector_init proc~ivector_from_array ivector_from_array interface~ivector_init->proc~ivector_from_array proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~get_rv_gaussian get_rv_gaussian proc~brn_calc_dw->proc~get_rv_gaussian proc~calc_bdw_blanc calc_bdw_blanc proc~brn_calc_bdw->proc~calc_bdw_blanc proc~calc_bdw_cholesky calc_bdw_cholesky proc~brn_calc_bdw->proc~calc_bdw_cholesky proc~calc_bdw_lanc calc_bdw_lanc proc~brn_calc_bdw->proc~calc_bdw_lanc proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force dsbevd dsbevd proc~calc_bdw_blanc->dsbevd dorgqr dorgqr proc~calc_bdw_blanc->dorgqr dgeqp3 dgeqp3 proc~calc_bdw_blanc->dgeqp3 dtrmm dtrmm proc~calc_bdw_cholesky->dtrmm dpotrf dpotrf proc~calc_bdw_cholesky->dpotrf proc~pt_build pt_build proc~ia_add_vdw_forces->proc~pt_build proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force proc~ivector_from_array->interface~ivector_init proc~bond_harm bond_harm proc~ia_get_bond_force->proc~bond_harm proc~bond_fene bond_fene proc~ia_get_bond_force->proc~bond_fene proc~bond_kg bond_kg proc~ia_get_bond_force->proc~bond_kg proc~bond_ms bond_ms proc~ia_get_bond_force->proc~bond_ms proc~build_pt_cell_list build_pt_cell_list proc~pt_build->proc~build_pt_cell_list proc~build_pt_n2 build_pt_n2 proc~pt_build->proc~build_pt_n2 proc~build_pt_aabbtree build_pt_aabbtree proc~pt_build->proc~build_pt_aabbtree proc~build_pt_verlet build_pt_verlet proc~pt_build->proc~build_pt_verlet proc~teth_rigid teth_rigid proc~ia_get_tether_force->proc~teth_rigid proc~teth_harm teth_harm proc~ia_get_tether_force->proc~teth_harm proc~vdw_lj_coul_debye vdw_lj_coul_debye proc~ia_get_vdw_force->proc~vdw_lj_coul_debye proc~vdw_cosine vdw_cosine proc~ia_get_vdw_force->proc~vdw_cosine proc~vdw_gaussian vdw_gaussian proc~ia_get_vdw_force->proc~vdw_gaussian proc~vdw_lj_coul vdw_lj_coul proc~ia_get_vdw_force->proc~vdw_lj_coul proc~vdw_lj vdw_lj proc~ia_get_vdw_force->proc~vdw_lj proc~vdw_dpd vdw_dpd proc~ia_get_vdw_force->proc~vdw_dpd proc~cl_build cl_build proc~build_pt_cell_list->proc~cl_build proc~cl_get_num_cells cl_get_num_cells proc~build_pt_cell_list->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~build_pt_cell_list->proc~cl_get_nbr_cells proc~cl_get_contents cl_get_contents proc~build_pt_cell_list->proc~cl_get_contents interface~str_from_num str_from_num proc~bond_fene->interface~str_from_num proc~build_pt_aabbtree->interface~ivector_init proc~bond_kg->interface~str_from_num proc~bond_ms->interface~str_from_num proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cla key val job_tag fn_control cpar ierr icla ncla Variables Type Attributes Name Initial character(len=64) :: cla character(len=:), allocatable :: key character(len=:), allocatable :: val character(len=:), allocatable :: job_tag character(len=:), allocatable :: fn_control type( ctrlpar_t ) :: cpar integer :: ierr integer :: icla integer :: ncla","tags":"","loc":"program/main.html"},{"title":"nitbd – BROWNPAK","text":"Contents Common Blocks nitparam nitprint Variables one two rtfiv tenth half fournines DFLT_CHOICE1_EXP DFLT_CHOICE2_EXP DFLT_CHOICE2_COEF DFLT_ETA_CUTOFF DFLT_ETA_MAX DFLT_THMIN DFLT_THMAX DFLT_ETA_FIXED DFLT_PRLVL STDOUT Common Blocks common /nitparam/ Type Attributes Name Initial double precision :: choice1_exp double precision :: choice2_exp double precision :: choice2_coef double precision :: eta_cutoff double precision :: etamax double precision :: thmin double precision :: thmax double precision :: etafixed common /nitprint/ Type Attributes Name Initial integer :: iplvl integer :: ipunit Variables Type Attributes Name Initial double precision, parameter :: one = 1.0d0 double precision, parameter :: two = 2.0d0 double precision, parameter :: rtfiv = 2.23606797749978981 double precision, parameter :: tenth = 0.10d0 double precision, parameter :: half = 0.50d0 double precision, parameter :: fournines = one-1.0d-4 double precision, parameter :: DFLT_CHOICE1_EXP = (one+rtfiv)*half double precision, parameter :: DFLT_CHOICE2_EXP = two double precision, parameter :: DFLT_CHOICE2_COEF = one double precision, parameter :: DFLT_ETA_CUTOFF = tenth double precision, parameter :: DFLT_ETA_MAX = fournines double precision, parameter :: DFLT_THMIN = tenth double precision, parameter :: DFLT_THMAX = half double precision, parameter :: DFLT_ETA_FIXED = tenth integer, parameter :: DFLT_PRLVL = 0 integer, parameter :: STDOUT = 6","tags":"","loc":"blockdata/nitbd.html"},{"title":"User Guide – BROWNPAK","text":"This is BROWNPAK. It can perform the following kinds of simulations: Energy minimization (also called structure relaxation) via steepest\n  descent. Brownian dynamics (BD) Multiparticle collision dynamics (MPCD) The source code is written in F2008 compliant fortran. There is a dependency on\nthe Intel Math Kernel Library (MKL). I have compiled the code with gfortran-8.3\ncompiler and MKL 2019 Update 4. Getting the source files The simplest way is to clone using git . Of course, this requires git to be\ninstalled on your system. If you do not want to clone, it is possible to\ndownload a zip file containing the source. Let's say you want to clone. Create a directory where you want the files to live. Say this directory is foo . mkdir foo cd foo Then clone the repo from GitHub thus: git clone https://github.com/saridut/BROWNPAK.git . That's it. Directory structure The directory structure is as follows: src contains the Fortran source files. There are some unused (not required/buggy?)\n source files in src/extra . bin contains the compiled executable, named brownpak . The executable can\n  be run directly from here, or from some other location with appropriately\n  specified path to the executable. It is best not to move around the\nexecutable, rather invoke the executable from the directory where you want to\nrun it. build is the build directory. It contains a makefile. It is necessary to\n  update the paths in the makefile to suit the local system. utils contains several utilities. There are python scripts the generate\n  initial configuration, fortran routines to extract configurations, etc. tests contains testing routines for development purposes. This need not be\n  necessarily present. docs contain files for generating autogenerated Fortran documentation (using FORD . To read the\n documentation, see here . Input and output files BROWNPAK reads several input files and produces several output files. The input\nfiles are: fn_control : This file contains various directives on what simulation to run,\n  time steps, etc. The directives are provided as a list of key-value pairs. The default name\n for this file is control.txt . fn_config : This file specifies the configuration of the system of be\n  simulated, i.e. atom positions, interactions, etc. The extension for this file\n  is .cfg , though it is not mandatory. The output files are: fn_traj : This is a binary file containing the trajectory data. These have\n  extension of .bin , though not mandatory. fn_stats : This is a text file containing a minimal set of statistics.\n  Further statistics may be obtained by post processing fn_traj . During\n  equilibration, the statistics will be written to a file called fn_stats.eq . brownpak.log : Log file. Check this for progress and error messsages For energy-minimization, two other files with -rlx in their names will be\n  produced. The file fn_config-rlx.cfg contains the minimized configuration,\nand the file fn_config-rlx.txt contains the same configuration in LAMMPS data\nformat for visualization in Ovito. Compilation and running There is a makefile in build . In the makefile, the DEBUG flag should be set\nto false for production builds. For testing purposes, set DEBUG = true . The compiler name is specified via the variable FC . e.g. for intel it will be\nappropriate to use FC = ifort . I use fortran95 wrappers to MKL as well. If one\nis using a non-Intel compiler, these wrappers need to be built (see the MKL\ndocumentation on how to do this). Anyways, since I am using gfortran, I specify the location of the\nwrappers through the variable MKL_INTRFC . Furthermore, MKLROOT is the root\ndirectory of the MKL installation. For an Intel compiler, MKL_INTRFC is not\nnecessary, but MKLROOT must be specified. It may be helpful to use the Intel\nLink Line Advisor for looking up appropriate flags. Appropriate compilation flags must be\nspecified via FCFLAGS . The current flags pertain to gfortran. For debug\nbuilds, the flags should turn off optimization, raise all warnings, check\nbounds, etc.; for production builds do turn on necessary optimization (without\nbeing too aggressive), loop unrolling, interprocedural optimizations, inlining,\netc. make To clean all .o and .mod files, do make clean To remove all .o , .mod , and the executable, do make clobber To run, the simplest way is to go to bin and ./brownpak fn_control = controlfile.txt job_tag = some_number Both the arguments fn_control and job_tag are optional.\nIf you do not specify the name of the control file, it will be assumed to be control.txt . The job_tag argument is there to help running array jobs on a\ncluster. For example, with SGE job scheduler I can request array jobs numbered\nfrom 1-16 and specify job_tag=$SGE_TASK_ID . Then all output files will have\nthe numbers 1-16 appended to their file names, like traj.bin.1, traj.bin.2, etc. Instead to running the executable from bin , you can run it from some other\ndirectory as path_to_bin/brownpak fn_control = controlfile.txt job_tag = some_number The above is more convenient with running multiple jobs on a cluster. Note that once compiled, if you change the source files a recompilation is\nnecessary. Unlike some codes that you may be familiar with, changing input files\ndo not require recompilation. Structure of the control file Here is a sample control file. It is called `control.txt. sim_style 2 use_verlet_tab F rcutoff 5 . 25 D0 tskin 2 . 1 D0 use_cell_list T excluded_atoms 1 lvdw T lhdia F mob_fctr KRYL lelectrostatics F tim_stp 1 . 0 D - 2 nts_md 100 nts_eql 0 . 0 D0 nts_eql_samp 10 nts_sim 2 . 0 D3 nts_samp 10 nts_dump 10 nts_log 10 fn_cfg sample . cfg fn_revive revive . bin fn_stats stats . txt fn_traj traj . bin lrevive F read_seed F write_seed T write_eql_stats T write_traj T traj_frmcmp 1 0 0 1 traj_wmpcd F As you can see, it lists a number of keywords and their corresponding values\nseparated by whitespace. The maximum length of a line is as specified in m_globals . Note Each of the keywords in the control file is a variable listed in m_globals . Please look up the detailed description and possible set\nof allowed values there. Warning There are no checks performed on the consistency of the values provided\nin the control file. If you use unphysical values, your results may be incorrect\nor the program may crash. There can be blank lines between the keywords. Comments begin with # . If the # character is found on any line the rest of the line after # will be\ndiscarded. The keywords and the values must be separated by one or more whitespaces. I will elaborate on some specific aspects of the value format: Strings need not be quoted Booleans may be simply given as T or F instead of .true. or .false. Floats are always double precision, so please use *.D* fortran format. For\n  example, a value of 2.1 is single precision; instead specify it at 2.1D0 .\n  Other exponents are similar, e.g., 1.0D-2 for 0.01 . Values requiring uppercase letters must be given in that form, e.g. KRYL is\n  not the same a kryl . All the keywords starting with nts except nts_md are long ints. For\n  convenience these values may be given in *.D* format. Internally they will\n  be cast as long ints. mts_md is not a long int because it does not make\n  sense for it to be a large number, else the simulation will never complete. traj_frmcmp : See m_globals for details. Each element of the\n  sequence can be either 0 or 1 (separated by whitespaces), e.g. 1 1 1 1 or 1 0 0 1.\n  All four being zero is allowed, but makes no sense. Choosing nts_dump <= nts_samp is a good idea, but do not dump too frequently\n  either. Structure of the trajectory file The trajectory file is a binary file, i.e. it is a stream of bytes. The byte\norder is native. It can be read back in python (using struct to unpack), in\nfortran (opening the file with form='unformatted, access='stream' ), or in any\nother language. Warning If traj_wmpcd = T in the control file, the trajectory file can be\nextremely large. Explicit data for the position and velocities of MPCD atoms are\nrarely needed. MPCD atoms do not have forces or charge on them. I will call the trajectory file as traj.bin . It contains a header, followed by\na sequence of frames. The structure of the header is: header_size : 1 int (32 bits) frame_size : 1 int (32 bits) num_atoms : 1 int (32 bits). Number of non-MPCD atoms in the trajectory. num_mpcd_atoms : 1 int (32 bits). Number of MPCD atoms in the trajectory. frmcmp : 4 ints (32 bits each). Components of each frame, as specified by traj_frmcmp in the control file. During creation of a trajectory, num_atoms and num_mpcd_atoms are given\nto m_trajectory . Depending on m_globals , it is\npossible for an MPCD simulation to not write any MPCD data to traj.bin . This\nshould be the commonly used case. For BD/energy-minimization the value of m_globals does not matter. Following the header, there is a sequence of frame data, written according to m_globals and m_globals . Structure of the revive file The revive file is a binary dump. It contains enough information to restart the\nsimulation if lrevive = T in the control file. To see what gets dumped, please\nexamine the source for m_config_io . Interactions The following kinds of interactions are available (or can be made available with\nminimal effort): Bonds All bonds have a type called bond_type . bond_type s are assigned\nby the user. For example, in a A-B diblock polymer, the user may choose A-A bonds\nas type 1, B-B bonds as type 2, and the A-B bond as type 3. Each bond_type is completely determined by a style , called bond_style ,\nand a set of parameters, called bond_params . bond_style s are chosen from the\nlist of available styles, as specified in m_ia_bond . The number of required\nparameters depend on the chosen style. The maximum number of parameters is m_globals .  For example, in our A-B diblock, the A-A bonds can be\nof type 1, with style 3 (corresponding to Kremer-Grest bond), and a set of four\nparameters; the B-B bonds can be of type 2, and also of style 3, with a set\nof four parameters, same as or different from the parameters of A-A bonds. Angles Similar to bonds, angles have types and styles as well. See m_ia_angle .\nOnly one non-trivial style is available, as this is the most commonly used\nstyle for polymers. However, more styles can be added if necessary. Dihedrals Dihedrals are not typically used in the kind of polymer models I deal with.\nSo, only the trivial style is present. In case you need a dihedral, add the\nappropriate routines to m_ia_dihedral . Tethers Tethers are pointwise restraints on one or more atoms. There can be multiple\ntethers, see m_ia_tether . Pairwise : See m_ia_vdw for a list. External : There is no working implementation of external interactions. The\n  idea is this: I do not know what kind of external interactions you need, but I\ndo not want to restrict you into a set of predefined interactions. So, please\nmodify the module m_ia_external to your choice, while keeping the interface\nintact. I assume you are a competent Fortran programmer, so that you will\nimmediately get it when you look at m_ia_external . A guiding principle is\nthat external interactions are generally fields that act on all the atoms in the\nsytem, but in some sense this covers everything. Remember to update the\nstress as you add external interactions. Structure of the config file Here is an extremely basic config file for a bunch of MPCD atoms. Sample SIMBOX 20 0 . 0 0 . 0 0 . 0 20 0 . 0 0 . 0 0 . 0 20 IMCON 1 ATOM_TYPES 0 MPCD_ATOMS 40000 5 ATOMS 0 MOLECULE_TYPES 0 MOLECULES 0 Please see the other examples in utils/models . It is best to use the python\nscripts to generate your config files. These scripts are self-explanatory. Restarting a simulation To restart a simulation, set nts_sim to a higher value in the control file\nand start the simulations. Note that an unusual situation may happen if you are\nrestarting after your job got killed/you deliberately killed it. In this case,\nit is possible that the data written in fn_stats and fn_traj are a few time\nsteps ahead of what is in fn_dump . This is most annoying; to get rid of such\nunwanted annoyances, I have written a small python script called sync.py that\nlives at utils/sync . This script basically compares both fn_traj and fn_stats with fn_dump and shaves off the extra records. You can run it\nbefore resubmitting a killed job. Use it with care, you may lose data. Workflow: Energy minimization Create an intial configuration. Say it is in file sample.cfg . Run the programme with sim_style = 0 . Monitor fn_stats , here the output energies will be written. The minimized\n   configuration will be written to sample-rlx.cfg . Moreover sample-rlx.txt (in LAMMPS data format) will be created, which you can visualize in Ovito. If\nnecessary, rerun by setting nts_sim to a higher value. Workflow: BD/MPCD Create an initial configuration. Minimize energy if you think this will be useful. It is usually useful. Use\n   the minimized configuration as the stating configuration for BD/MPCD\nsimulation. Set sim_style = 1 (for BD) or sim_style = 2 (for MPCD) and run. Rerun if necessary. Updating documentation (for developers) API documentation (Fortran files) is generated using FORD . As required by FORD,\nthe documentation is written in Markdown. All versions of Markdown may not be\nsupported, please experiment to see what works. Whole of GFM definitely doesn't. FORD also processes a User's Guide page, also written in Markdown. The source\nfor this is index.md in docs/pages . This may change in future, as I would\nprefer this to be in reStructuredText. The html pages generated by FORD is hosted on GitHub Pages for this\n  repository. For a number of reasons, pushing newly generated html pages is\nnot straightforward. These pages are pushed to the gh-pages branch, not to master . Assume that you have cloned the repo as usual, worked on it, and now you wish to update \nthe documentation. This will be done via git worktree, as discussed by Sangsoo Nam . Commit your current work and push. From the root of the repo, first create a\nlinked worktree as follows: cd docs\ngit worktree add html gh-pages cd html This will create a linked worktree in the directory docs/html and enter it. If\nyou do git branch now, you will see the current branch to be gh-pages . docs/html is where the html pages will finally live. Now, clean it. git rm -rf . Next, create an empty file .nojekyll . This prevents Jekyll from fiddling\n  with stuff inside html . touch .nojekyll Change directory to docs . cd ../docs Create a temporary directory called docs/tmp . FORD will generate the html files here, which will be copied to docs/html . This is necessary because\nFORD deletes everything inside its output directory, including .git . mkdir tmp Run FORD. Move the html pages to html . Delete tmp . ford -o tmp brownpak.md\nmv tmp/* html/\nrm -r tmp Go in html , add, commit, and push to gh-pages . cd html\ngit add --all\ngit commit -a --allow-empty-message -m '' git push origin gh-pages Get back to docs . Then get rid of the worktree. cd ../docs\ngit worktree remove html","tags":"","loc":"page//index.html"}]}