var tipuesearch = {"pages":[{"title":" BROWNPAK ","text":"BROWNPAK Developer Info Sarit Dutta","tags":"home","loc":"index.html"},{"title":"sm_aabbtree.fpp – BROWNPAK","text":"Contents Submodules sm_aabbtree Source Code sm_aabbtree.fpp Source Code #: include 'asserts.fypp' submodule ( m_aabbtree ) sm_aabbtree implicit none contains !******************************************************************************* module subroutine node_init ( this ) class ( node_t ), intent ( out ) :: this real ( rp ), dimension ( 3 ) :: lbnd , ubnd this % next = NULL_NODE this % parent = NULL_NODE ; this % left = NULL_NODE ; this % right = NULL_NODE this % height = - 1 ; this % atom = 0 lbnd = 0.0_rp ; ubnd = 0.0_rp call this % aabb % init ( lbnd , ubnd ) end subroutine !******************************************************************************* module function node_isleaf ( this ) result ( res ) class ( node_t ), intent ( in ) :: this logical :: res res = ( this % left == null_node ) end function !******************************************************************************* module function node_asstr ( this , frmt ) result ( buf ) class ( node_t ), intent ( in ) :: this character ( len =* ), intent ( in ), optional :: frmt character ( len = :), allocatable :: buf character ( len = :), allocatable :: aabb_str buf = '{' buf = buf // 'next: ' // str_from_num ( this % next ) buf = buf // ', parent: ' // str_from_num ( this % parent ) buf = buf // ', left: ' // str_from_num ( this % left ) buf = buf // ', right: ' // str_from_num ( this % right ) buf = buf // ', height: ' // str_from_num ( this % height ) buf = buf // ', atom: ' // str_from_num ( this % atom ) if ( present ( frmt )) then call this % aabb % print ( frmt = frmt , str = aabb_str ) else call this % aabb % print ( str = aabb_str ) end if buf = buf // ', aabb: {' // aabb_str // '}' buf = buf // '}' end function !******************************************************************************* module subroutine init ( this , natoms , tskin ) class ( aabbtree_t ), intent ( out ) :: this integer , intent ( in ) :: natoms real ( rp ), intent ( in ) :: tskin integer :: i this % capacity = natoms ; this % tskin = tskin this % size = 0 allocate ( this % nodes ( this % capacity )) !Initially all nodes belong the free store. do i = 1 , this % capacity call this % nodes ( i )% init () this % nodes ( i )% next = i + 1 end do this % nodes ( this % capacity )% next = NULL_NODE this % freestore = 1 !Head of the free store points to the first node this % root = NULL_NODE allocate ( this % atnd_tab ( natoms )); this % atnd_tab = 0 !Initialize the stack call ivector_init ( stack ) end subroutine !******************************************************************************* module recursive subroutine print ( this , p ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ), optional :: p integer :: p_ p_ = this % root if ( present ( p )) p_ = p !Nothing to do for an empty tree if ( p_ == NULL_NODE ) return !If the tree is not empty call this % print ( this % nodes ( p_ )% left ) write ( * , '(i0,\": \",a)' ) p_ , this % nodes ( p_ )% asstr () call this % print ( this % nodes ( p_ )% right ) end subroutine !******************************************************************************* module subroutine clear ( this ) class ( aabbtree_t ), intent ( in out ) :: this integer :: i !Return all nodes in the tree to the free store do i = 1 , this % capacity if ( this % nodes ( i )% height < 0 ) cycle call this % fs_return ( i ) end do this % atnd_tab = 0 ; this % tskin = 0.0_rp this % root = NULL_NODE @ : ASSERT ( this % size == 0 ) call stack % clear () end subroutine !******************************************************************************* module subroutine delete ( this ) class ( aabbtree_t ), intent ( in out ) :: this if ( allocated ( this % nodes )) deallocate ( this % nodes ) if ( allocated ( this % atnd_tab )) deallocate ( this % atnd_tab ) this % capacity = 0 ; this % size = 0 ; this % tskin = 0.0_rp this % root = NULL_NODE ; this % freestore = NULL_NODE call stack % delete () end subroutine !******************************************************************************* module subroutine insert ( this , ia , pos , radius ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: ia real ( rp ), dimension ( 3 ), intent ( in ) :: pos real ( rp ), intent ( in ) :: radius real ( rp ), dimension ( 3 ) :: lbnd , ubnd , extent integer :: p !If atom already exists, nothing to do. if ( this % atnd_tab ( ia ) > 0 ) return !Get a new node from the free store p = this % fs_acquire () !Prepare the new node lbnd = pos - radius ; ubnd = pos + radius extent = ubnd - lbnd !Adjust bounds for a fattened AABB. lbnd = lbnd - this % tskin * extent ; ubnd = ubnd + this % tskin * extent !Initialize AABB with bounds call this % nodes ( p )% aabb % init ( lbnd , ubnd ) !Set atom this % nodes ( p )% atom = ia !Set node height to zero as this will be a leaf node this % nodes ( p )% height = 0 !Insert node as a leaf call this % insert_leaf ( p ) !Update atnd_tab this % atnd_tab ( ia ) = p end subroutine !******************************************************************************* module subroutine remove ( this , ia ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: ia integer :: p !Get the leaf containing atom ia. p = this % atnd_tab ( ia ) !Mark the slot in atnd_tab as vacant. this % atnd_tab ( ia ) = 0 @ : ASSERT ( p <= this % capacity ) @ : ASSERT ( this % nodes ( p )% isleaf () ) !Remove the leaf from the tree. call this % remove_leaf ( p ) !Return the removed node to the free store. call this % fs_return ( p ) end subroutine !******************************************************************************* module subroutine remove_all ( this ) class ( aabbtree_t ), intent ( in out ) :: this integer :: ia do ia = 1 , size ( this % atnd_tab ) if ( this % atnd_tab ( ia ) > 0 ) call this % remove ( ia ) end do end subroutine !******************************************************************************* module subroutine update_fatm ( this , ia , pos , radius , lstat ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: ia real ( rp ), dimension ( 3 ), intent ( in ) :: pos real ( rp ), intent ( in ) :: radius logical , intent ( out ) :: lstat real ( rp ), dimension ( 3 ) :: lbnd , ubnd lbnd = pos - radius ; ubnd = pos + radius call this % update ( ia , lbnd , ubnd , lstat ) end subroutine !******************************************************************************* module subroutine update_fatmaabb ( this , ia , lbnd , ubnd , lstat ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: ia real ( rp ), dimension ( 3 ), intent ( in ) :: lbnd real ( rp ), dimension ( 3 ), intent ( in ) :: ubnd logical , intent ( out ) :: lstat type ( aabb_t ) :: aabb integer :: p lstat = . false . !Get the leaf containing atom ia. p = this % atnd_tab ( ia ) !Initialize a new AABB call aabb % init ( lbnd , ubnd ) !No need to update if the atom is still within its fattened AABB if ( this % nodes ( p )% aabb % includes ( aabb ) ) then return else !Remove the current leaf call this % remove_leaf ( p ) !Fatten the new AABB call aabb % fatten ( this % tskin ) !Assign the new AABB this % nodes ( p )% aabb = aabb !Insert a new leaf node call this % insert_leaf ( p ) lstat = . true . end if end subroutine !******************************************************************************* module subroutine query_watm ( this , ia , nbrs ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ) :: ia type ( ivector_t ), intent ( in out ) :: nbrs integer :: p !Test overlap for atom ia against all other atoms p = this % atnd_tab ( ia ) call this % query ( ia , this % nodes ( p )% aabb , nbrs ) end subroutine !******************************************************************************* module subroutine query_watmaabb ( this , ia , aabb , nbrs ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ) :: ia type ( aabb_t ), intent ( in ) :: aabb type ( ivector_t ), intent ( in out ) :: nbrs integer :: p , ja , ierr call stack % clear () call nbrs % clear () !First push the root node onto a stack call stack % append ( this % root ) do if ( stack % len == 0 ) exit p = stack % pop () if ( p == NULL_NODE ) cycle !Test for overlap between AABBs if ( aabb % overlaps ( this % nodes ( p )% aabb ) ) then !Check if this is a leaf node if ( this % nodes ( p )% isleaf () ) then !Can't interact with itself ja = this % nodes ( p )% atom if ( ja /= ia ) call nbrs % append ( ja ) else call stack % append ( this % nodes ( p )% left ) call stack % append ( this % nodes ( p )% right ) end if end if end do end subroutine !******************************************************************************* module subroutine query_waabb ( this , aabb , atms ) class ( aabbtree_t ), intent ( in ) :: this type ( aabb_t ), intent ( in ) :: aabb type ( ivector_t ), intent ( in out ) :: atms !If tree is empty return an empty vector if ( this % size == 0 ) then call atms % clear (); return else !Test overlap of AABB against all leaf AABBs call this % query ( huge ( 0 ), aabb , atms ) end if end subroutine !******************************************************************************* module function get_num_atoms ( this ) result ( na ) class ( aabbtree_t ), intent ( in ) :: this integer :: na na = count ( this % atnd_tab > 0 ) end function !******************************************************************************* module function get_aabb ( this , ia ) result ( aabb ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ) :: ia type ( aabb_t ) :: aabb integer :: p p = this % atnd_tab ( ia ) aabb = this % nodes ( p )% aabb end function !******************************************************************************* module function get_height ( this ) result ( height ) class ( aabbtree_t ), intent ( in ) :: this integer :: height if ( this % root == NULL_NODE ) then height = 0 else height = this % nodes ( this % root )% height end if end function !******************************************************************************* module function get_max_balance ( this ) result ( max_balance ) class ( aabbtree_t ), intent ( in ) :: this integer :: max_balance integer :: i , balance , left , right max_balance = 0 !Loop over all nodes (including those in the free store) do i = 1 , this % capacity if ( this % nodes ( i )% height <= 1 ) cycle left = this % nodes ( i )% left ; right = this % nodes ( i )% right balance = abs ( this % nodes ( left )% height - this % nodes ( right )% height ) max_balance = max ( max_balance , balance ) end do end function !******************************************************************************* module function get_srfarea_ratio ( this ) result ( saratio ) class ( aabbtree_t ), intent ( in ) :: this real ( rp ) :: saratio real ( rp ) :: area_root , area_tot integer :: i if ( this % root == NULL_NODE ) then saratio = 0.0_rp ; return end if area_root = this % nodes ( this % root )% aabb % srfarea area_tot = 0.0_rp !Loop over all nodes do i = 1 , this % capacity !Ignore nodes in the free store if ( this % nodes ( i )% height < 0 ) cycle area_tot = area_tot + this % nodes ( i )% aabb % srfarea end do saratio = area_tot / area_root end function !******************************************************************************* module subroutine rebuild ( this ) class ( aabbtree_t ), intent ( in out ) :: this type ( ivector_t ) :: node_indices type ( aabb_t ) :: aabbi , aabbj , aabb real ( rp ) :: cost , cost_min integer :: counter , i , j , ind , jnd , imin , jmin integer :: indx_left , indx_right , p , hl , hr counter = 0 ; call ivector_init ( node_indices , this % size ) !Loop over all nodes and store the leaf node indices, return the rest to the !free store. do i = 1 , this % capacity !Ignore nodes in the free store if ( this % nodes ( i )% height < 0 ) cycle if ( this % nodes ( i )% isleaf () ) then this % nodes ( i )% parent = NULL_NODE call node_indices % append ( i ) counter = counter + 1 else call this % fs_return ( i ) end if end do !Rebuild tree from bottom up do if ( counter <= 1 ) exit cost_min = huge ( 0.0_rp ); imin = 0 ; jmin = 0 do i = 1 , counter ind = node_indices % get_val ( i ) aabbi = this % nodes ( ind )% aabb do j = ( i + 1 ), counter jnd = node_indices % get_val ( j ) aabbj = this % nodes ( jnd )% aabb aabb = aabbi + aabbj cost = aabb % srfarea if ( cost < cost_min ) then imin = i ; jmin = j ; cost_min = cost end if end do end do indx_left = node_indices % get_val ( imin ) indx_right = node_indices % get_val ( jmin ) hl = this % nodes ( indx_left )% height hr = this % nodes ( indx_right )% height p = this % fs_acquire () this % nodes ( p )% left = indx_left ; this % nodes ( p )% right = indx_right this % nodes ( p )% height = 1 + max ( hl , hr ) this % nodes ( p )% aabb = this % nodes ( indx_left )% aabb + this % nodes ( indx_right )% aabb this % nodes ( p )% parent = NULL_NODE this % nodes ( indx_left )% parent = p this % nodes ( indx_right )% parent = p call node_indices % set_val ( jmin , node_indices % get_val ( counter )) call node_indices % set_val ( imin , p ) counter = counter - 1 end do this % root = node_indices % get_val ( 1 ) call this % validate () end subroutine !******************************************************************************* module subroutine validate ( this ) class ( aabbtree_t ), intent ( in ) :: this integer :: num_free_nodes , p , h1 , h2 call this % validate_structure ( this % root ) call this % validate_metrics ( this % root ) num_free_nodes = 0 ; p = this % freestore do if ( p == NULL_NODE ) exit p = this % nodes ( p )% next num_free_nodes = num_free_nodes + 1 end do @ : ASSERT ( this % get_height () == this % calc_height () ) @ : ASSERT ( ( this % size + num_free_nodes ) == this % capacity ) end subroutine !******************************************************************************* module subroutine insert_leaf ( this , leaf ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: leaf type ( aabb_t ) :: aabb , leaf_aabb , combined_aabb real ( rp ) :: sa , combined_sa , old_area , new_area real ( rp ) :: cost , cost_inheritance , cost_left , cost_right integer :: p , sibling , old_parent , new_parent integer :: left , right !If the tree is empty, insert and make it root if ( this % root == NULL_NODE ) then this % root = leaf this % nodes ( this % root )% parent = NULL_NODE return end if !If the tree is not empty, find the best sibling for the node leaf_aabb = this % nodes ( leaf )% aabb p = this % root do if ( this % nodes ( p )% isleaf () ) exit left = this % nodes ( p )% left ; right = this % nodes ( p )% right sa = this % nodes ( p )% aabb % srfarea combined_aabb = this % nodes ( p )% aabb + leaf_aabb combined_sa = combined_aabb % srfarea !Cost of creating a new parent for this node & the new leaf cost = 2.0_rp * combined_sa !Minimum cost of pushing the leaf further down the tree cost_inheritance = 2.0_rp * ( combined_sa - sa ) !Cost of descending to the left if ( this % nodes ( left )% isleaf () ) then aabb = this % nodes ( left )% aabb + leaf_aabb cost_left = aabb % srfarea + cost_inheritance else aabb = this % nodes ( left )% aabb + leaf_aabb old_area = this % nodes ( left )% aabb % srfarea new_area = aabb % srfarea cost_left = ( new_area - old_area ) + cost_inheritance end if !Cost of descending to the right if ( this % nodes ( right )% isleaf () ) then aabb = this % nodes ( right )% aabb + leaf_aabb cost_right = aabb % srfarea + cost_inheritance else aabb = this % nodes ( right )% aabb + leaf_aabb old_area = this % nodes ( right )% aabb % srfarea new_area = aabb % srfarea cost_right = ( new_area - old_area ) + cost_inheritance end if !Descend according to the minimum cost if ( ( cost < cost_left ) . and . ( cost < cost_right ) ) exit !Descend if ( cost_left < cost_right ) then p = left else p = right end if end do sibling = p !Create a new parent old_parent = this % nodes ( sibling )% parent new_parent = this % fs_acquire () this % nodes ( new_parent )% parent = old_parent this % nodes ( new_parent )% aabb = this % nodes ( sibling )% aabb + leaf_aabb this % nodes ( new_parent )% height = this % nodes ( sibling )% height + 1 !Sibling was not root if ( old_parent /= NULL_NODE ) then if ( this % nodes ( old_parent )% left == sibling ) then this % nodes ( old_parent )% left = new_parent else this % nodes ( old_parent )% right = new_parent end if this % nodes ( new_parent )% left = sibling this % nodes ( new_parent )% right = leaf this % nodes ( sibling )% parent = new_parent this % nodes ( leaf )% parent = new_parent else !Sibling was the root this % nodes ( new_parent )% left = sibling this % nodes ( new_parent )% right = leaf this % nodes ( sibling )% parent = new_parent this % nodes ( leaf )% parent = new_parent this % root = new_parent end if !Walk back up the tree fixing heights and AABBs. p = this % nodes ( leaf )% parent do if ( p == NULL_NODE ) exit p = this % balance ( p ) left = this % nodes ( p )% left ; right = this % nodes ( p )% right this % nodes ( p )% height = 1 + & max ( this % nodes ( left )% height , this % nodes ( right )% height ) this % nodes ( p )% aabb = this % nodes ( left )% aabb + this % nodes ( right )% aabb p = this % nodes ( p )% parent end do end subroutine !******************************************************************************* module subroutine remove_leaf ( this , leaf ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: leaf integer :: parent , grandparent , sibling integer :: p , left , right if ( leaf == this % root ) then this % root = NULL_NODE return end if parent = this % nodes ( leaf )% parent grandparent = this % nodes ( parent )% parent if ( this % nodes ( parent )% left == leaf ) then sibling = this % nodes ( parent )% right else sibling = this % nodes ( parent )% left end if !Destroy the parent & connect the sibling to the grandparent if ( grandparent /= NULL_NODE ) then if ( this % nodes ( grandparent )% left == parent ) then this % nodes ( grandparent )% left = sibling else this % nodes ( grandparent )% right = sibling end if this % nodes ( sibling )% parent = grandparent call this % fs_return ( parent ) !Adjust ancestor bounds p = grandparent do if ( p == NULL_NODE ) exit p = this % balance ( p ) left = this % nodes ( p )% left ; right = this % nodes ( p )% right this % nodes ( p )% aabb = this % nodes ( left )% aabb + this % nodes ( right )% aabb this % nodes ( p )% height = 1 + & max ( this % nodes ( left )% height , this % nodes ( right )% height ) p = this % nodes ( p )% parent end do else this % root = sibling this % nodes ( sibling )% parent = NULL_NODE call this % fs_return ( parent ) end if end subroutine !******************************************************************************* module function balance ( this , p ) result ( q ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: p integer :: q integer :: left , right , right_left , right_right , left_right , left_left integer :: current_balance associate ( nodes => this % nodes ) @ : ASSERT ( p /= NULL_NODE ) if ( nodes ( p )% isleaf () . or . ( nodes ( p )% height < 2 ) ) then q = p return end if left = nodes ( p )% left right = nodes ( p )% right @ : ASSERT ( left <= this % capacity ) @ : ASSERT ( right <= this % capacity ) current_balance = nodes ( right )% height - nodes ( left )% height !Rotate right branch up if ( current_balance > 1 ) then right_left = nodes ( right )% left right_right = nodes ( right )% right @ : ASSERT ( right_left <= this % capacity ) @ : ASSERT ( right_right <= this % capacity ) !Swap node and its right-hand child nodes ( right )% left = p nodes ( right )% parent = nodes ( p )% parent nodes ( p )% parent = right !The node's old parent should now point to its right-hand child if ( nodes ( right )% parent /= NULL_NODE ) then if ( nodes ( nodes ( right )% parent )% left == p ) then nodes ( nodes ( right )% parent )% left = right else @ : ASSERT ( nodes ( nodes ( right )% parent )% right == p ) nodes ( nodes ( right )% parent )% right = right end if else this % root = right end if !Rotate if ( nodes ( right_left )% height > nodes ( right_right )% height ) then nodes ( right )% right = right_left nodes ( p )% right = right_right nodes ( right_right )% parent = p nodes ( p )% aabb = nodes ( left )% aabb + nodes ( right_right )% aabb nodes ( right )% aabb = nodes ( p )% aabb + nodes ( right_left )% aabb nodes ( p )% height = 1 + max ( nodes ( left )% height , nodes ( right_right )% height ) nodes ( right )% height = 1 + max ( nodes ( p )% height , nodes ( right_left )% height ) else nodes ( right )% right = right_right nodes ( p )% right = right_left nodes ( right_left )% parent = p nodes ( p )% aabb = nodes ( left )% aabb + nodes ( right_left )% aabb nodes ( right )% aabb = nodes ( p )% aabb + nodes ( right_right )% aabb nodes ( p )% height = 1 + max ( nodes ( left )% height , nodes ( right_left )% height ) nodes ( right )% height = 1 + max ( nodes ( p )% height , nodes ( right_right )% height ) end if q = right return end if !Rotate left branch up if ( current_balance < - 1 ) then left_left = nodes ( left )% left left_right = nodes ( left )% right @ : ASSERT ( left_left <= this % capacity ) @ : ASSERT ( left_right <= this % capacity ) !Swap node and its left-hand child nodes ( left )% left = p nodes ( left )% parent = nodes ( p )% parent nodes ( p )% parent = left !The node's old parent should now point to its left-hand child if ( nodes ( left )% parent /= NULL_NODE ) then if ( nodes ( nodes ( left )% parent )% left == p ) then nodes ( nodes ( left )% parent )% left = left else @ : ASSERT ( nodes ( nodes ( left )% parent )% right == p ) nodes ( nodes ( left )% parent )% right = left end if else this % root = left end if !Rotate if ( nodes ( left_left )% height > nodes ( left_right )% height ) then nodes ( left )% right = left_left nodes ( p )% left = left_right nodes ( left_right )% parent = p nodes ( p )% aabb = nodes ( right )% aabb + nodes ( left_right )% aabb nodes ( left )% aabb = nodes ( p )% aabb + nodes ( left_left )% aabb nodes ( p )% height = 1 + max ( nodes ( right )% height , nodes ( left_right )% height ) nodes ( left )% height = 1 + max ( nodes ( p )% height , nodes ( left_left )% height ) else nodes ( left )% right = left_right nodes ( p )% left = left_left nodes ( left_left )% parent = p nodes ( p )% aabb = nodes ( right )% aabb + nodes ( left_left )% aabb nodes ( left )% aabb = nodes ( p )% aabb + nodes ( left_right )% aabb nodes ( p )% height = 1 + max ( nodes ( right )% height , nodes ( left_left )% height ) nodes ( left )% height = 1 + max ( nodes ( p )% height , nodes ( left_right )% height ) end if q = left return end if q = p end associate end function !******************************************************************************* module recursive function calc_height ( this , p ) result ( height ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ), optional :: p integer :: height , p_ if ( present ( p )) then p_ = p else p_ = this % root end if if ( this % nodes ( p_ )% isleaf ()) then height = 0 else height = 1 + max ( this % calc_height ( this % nodes ( p_ )% left ), & this % calc_height ( this % nodes ( p_ )% right )) end if end function !******************************************************************************* module function fs_acquire ( this ) result ( p ) class ( aabbtree_t ), intent ( in out ) :: this integer :: p type ( node_t ), dimension (:), allocatable :: tmp integer :: n , i if ( this % freestore == NULL_NODE ) then @ : ASSERT ( this % size == this % capacity ) !Double the capacity n = this % capacity allocate ( tmp ( 2 * n ) ) tmp ( 1 : n ) = this % nodes do i = ( n + 1 ), 2 * n call tmp ( i )% init () tmp ( i )% next = i + 1 end do tmp ( n )% next = n + 1 tmp ( 2 * n )% next = NULL_NODE call move_alloc ( tmp , this % nodes ) this % capacity = 2 * n this % freestore = n + 1 end if !Acquire a new node p = this % freestore this % freestore = this % nodes ( p )% next !Increment the size of the tree this % size = this % size + 1 end function !******************************************************************************* module subroutine fs_return ( this , p ) class ( aabbtree_t ), intent ( in out ) :: this integer , intent ( in ) :: p @ : ASSERT ( p <= this % capacity ) @ : ASSERT ( 0 < this % size ) call this % nodes ( p )% init () this % nodes ( p )% next = this % freestore this % freestore = p !Decrement the size of the tree this % size = this % size - 1 end subroutine !******************************************************************************* module recursive subroutine validate_structure ( this , p ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ) :: p integer :: left , right if ( p == NULL_NODE ) return if ( p == this % root ) then @ : ASSERT ( this % nodes ( p )% parent == NULL_NODE ) end if left = this % nodes ( p )% left right = this % nodes ( p )% right if ( this % nodes ( p )% isleaf () ) then @ : ASSERT ( left == NULL_NODE ) @ : ASSERT ( right == NULL_NODE ) @ : ASSERT ( this % nodes ( p )% height == 0 ) return end if @ : ASSERT ( left <= this % capacity ) @ : ASSERT ( right <= this % capacity ) @ : ASSERT ( this % nodes ( left )% parent == p ) @ : ASSERT ( this % nodes ( right )% parent == p ) call this % validate_structure ( left ) call this % validate_structure ( right ) end subroutine !******************************************************************************* module recursive subroutine validate_metrics ( this , p ) class ( aabbtree_t ), intent ( in ) :: this integer , intent ( in ) :: p type ( aabb_t ) :: aabb integer :: left , right , height if ( p == NULL_NODE ) return left = this % nodes ( p )% left right = this % nodes ( p )% right if ( this % nodes ( p )% isleaf () ) then @ : ASSERT ( left == NULL_NODE ) @ : ASSERT ( right == NULL_NODE ) @ : ASSERT ( this % nodes ( p )% height == 0 ) return end if @ : ASSERT ( left <= this % capacity ) @ : ASSERT ( right <= this % capacity ) height = 1 + max ( this % nodes ( left )% height , this % nodes ( right )% height ) @ : ASSERT ( this % nodes ( p )% height == height ) aabb = this % nodes ( left )% aabb + this % nodes ( right )% aabb @ : ASSERT ( all ( aabb % lbnd == this % nodes ( p )% aabb % lbnd ) ) @ : ASSERT ( all ( aabb % ubnd == this % nodes ( p )% aabb % ubnd ) ) call this % validate_metrics ( left ) call this % validate_metrics ( right ) end subroutine !******************************************************************************* end submodule sm_aabbtree","tags":"","loc":"sourcefile/sm_aabbtree.fpp.html"},{"title":"m_brown.f90 – BROWNPAK","text":"Contents Modules m_brown Source Code m_brown.f90 Source Code module m_brown !! Contains routines for evaluating **B**._d_**W** in the SDE for Brownian Dynamics !! simulation. use iso_c_binding , only : c_loc , c_ptr , c_f_pointer use mkl_blas use mkl_lapack use m_precision use m_ran_num use m_strings use m_logger implicit none private public :: brn_init , brn_finish , brn_calc_dw , brn_calc_bdw character ( 4 ) :: meth !!Method to use for generating Brownian terms. Possible values are !!'CHOL' or 'LANC'. integer :: sizm !!Size of the mobility matrix integer :: s !!Number of Brownian vectors to be generated; equivalent to block size in the !!block Lanczos algorithm. integer :: dimk_min = 2 !!Minimum dimension of KSP integer :: dimk_max !!Maximum dimension of KSP real ( rp ) :: ethres = 1.0e-3_rp !!Error threshold for KSP-based method. real ( rp ), dimension (:,:), allocatable :: bdw_old !!(`sizm`, `s`) array. Stores B.dw at previous iteration. real ( rp ), dimension (:,:), allocatable :: lncv !!(`sizm`, `s*dimk_max`) array. Stores the Lanczos vectors. real ( rp ), dimension (:), allocatable :: eigvlh !!(`s*dimk_max`,) array. Eigenvalues of the tridiagonal/block triadiagonal !! matrix H generated by the Lanczos algorithm. real ( rp ), dimension (:,:), allocatable :: eigvch !!(`s*dimk_max`, `s*dimk_max`) array. Eigenvectors of the matrix H. real ( rp ), dimension (:,:), allocatable :: w !!(`sizm`, `s`) array. Used for generating the Lanczos vectors. real ( rp ), dimension (:), allocatable :: h_d !!(`dimk_max`,) array. Diagonal of the symmetric tridiagonal matrix H !! generated in case of `s = 1`. real ( rp ), dimension (:), allocatable :: h_sd !!(`dimk_max`,) array. Subdiagonal of the symmetric tridiagonal matrix H !! generated in case of `s = 1`. real ( rp ), dimension (:), allocatable :: tau !! (`s`,) array. Used in the QR decomposition of `w`. real ( rp ), dimension (:,:), allocatable :: matr !! (`s`,`s`) array. Used in the QR decomposition of `w`. real ( rp ), dimension (:,:), allocatable :: h_bd !!(`s`, `s*dimk_max`) array. Diagonal blocks of the matrix H. !!Used for KSP with `s > 1`. real ( rp ), dimension (:,:), allocatable :: h_bsd !!(`s`, `s*dimk_max`) array. Subdiagonal blocks of the matrix H. !!Used for KSP with `s > 1`. real ( rp ), dimension (:,:), allocatable :: h_bnd !!(`2*s`, `s*dimk_max`) array. Matrix H in banded storage. !!Used for KSP with `s > 1`. real ( rp ), dimension (:,:), allocatable :: tmp !!(`s*dimk_max`, `2*s`) array used as temporary storage space. real ( rp ), dimension (:), allocatable :: work !!Workspace array for LAPACK routines. integer , dimension (:), allocatable :: iwork !!Workspace array for LAPACK routines. contains !******************************************************************************* subroutine brn_init ( n , nblks , mth , f , e ) !! Performs initial setup. integer , intent ( in ) :: n !! Size of the mobility matrix. integer , intent ( in ) :: nblks !! Number of **B**._d_**W** vectors to generate for the same mobility matrix. !! `1 <= nblks < n`. character ( 4 ), intent ( in ) :: mth !! Method for calculating the Brownian terms. `mth = 'CHOL'` for !! Cholesky decomposition; `mth = 'LANC'` for KSP-based method. integer , intent ( in ), optional :: f !! For KSP-based method, maximum number of iterations. !! Must be present if `mth = 'LANC'`. `f` must be less than `n`. real ( rp ), intent ( in ), optional :: e !! For KSP-based method, error threshold for convergence. !! Must be present if `mth = 'LANC'`. sizm = n ; s = nblks ; meth = mth if ( meth == 'CHOL' ) then !Nothing to do here. else if ( meth == 'LANC' ) then dimk_max = max ( dimk_min , f ) + 1 !Adding 1 to ensure dimk_max > dimk_min ethres = e allocate ( bdw_old ( sizm , s ) ) allocate ( lncv ( sizm , s * dimk_max ) ) allocate ( eigvlh ( s * dimk_max ) ) allocate ( eigvch ( s * dimk_max , s * dimk_max ) ) allocate ( w ( sizm , s )) allocate ( tmp ( s * dimk_max , 2 * s )) if ( s == 1 ) then allocate ( h_d ( dimk_max ) ) allocate ( h_sd ( dimk_max ) ) else allocate ( tau ( s )) allocate ( matr ( s , s )) allocate ( h_bd ( s , s * dimk_max ) ) allocate ( h_bsd ( s , s * dimk_max ) ) allocate ( h_bnd ( 2 * s , s * dimk_max )) end if end if end subroutine !******************************************************************************* subroutine brn_finish () !! Performs cleanup. if ( allocated ( bdw_old )) deallocate ( bdw_old ) if ( allocated ( lncv )) deallocate ( lncv ) if ( allocated ( eigvlh )) deallocate ( eigvlh ) if ( allocated ( eigvch )) deallocate ( eigvch ) if ( allocated ( w )) deallocate ( w ) if ( allocated ( tmp )) deallocate ( tmp ) if ( allocated ( h_d )) deallocate ( h_d ) if ( allocated ( h_sd )) deallocate ( h_sd ) if ( allocated ( tau )) deallocate ( tau ) if ( allocated ( matr )) deallocate ( matr ) if ( allocated ( h_bd )) deallocate ( h_bd ) if ( allocated ( h_bsd )) deallocate ( h_bsd ) if ( allocated ( h_bnd )) deallocate ( h_bnd ) if ( allocated ( work )) deallocate ( work ) if ( allocated ( iwork )) deallocate ( iwork ) end subroutine !******************************************************************************* subroutine brn_calc_bdw ( mob , bdw , ierr , lconv , f ) !! Main driver routine for calculating **B**._d_**W**. real ( rp ), dimension (:,:), intent ( in out ) :: mob !! (`sizm`,`sizm`) symmetric positive definite matrix. !! On _entry_, contains the mobility matrix.  On _return_, if `meth = 'CHOL'`, !! the upper triangular part is overwritten with the result of Cholesky !! decomposition.  The strictly lower triangular part is left intact. real ( rp ), dimension (:,:), intent ( in out ) :: bdw !! (`sizm`,`s`) matrix. !! On _entry_, contains `s` column vectors drawn from standard normal !! distribution. On _return_, the `s` columns are overwritten with the !! result of **B**.d**W**. integer , intent ( out ) :: ierr !! Error flag. logical , intent ( out ), optional :: lconv !! If `meth = 'LANC'`, returns *true* if converged, *false* otherwise. integer , intent ( out ), optional :: f !! If `meth = 'LANC'`, the number of iterations performed. integer :: f_ logical :: lconv_ if ( meth == 'CHOL' ) then call calc_bdw_cholesky ( mob , bdw , ierr ) else if ( meth == 'LANC' ) then if ( s == 1 ) then call calc_bdw_lanc ( mob , bdw , lconv_ , f_ , ierr ) else call calc_bdw_blanc ( mob , bdw , lconv_ , f_ , ierr ) end if end if if ( present ( lconv )) lconv = lconv_ if ( present ( f )) f = f_ end subroutine !******************************************************************************* subroutine calc_bdw_lanc ( mob , bdw , lconv , f , ierr ) !! Implements Lanczos algorithm for calculating **B**._d_**W**. real ( rp ), dimension (:,:), intent ( in ) :: mob !! (`sizm`,`sizm`) symmetric positive definite matrix. real ( rp ), dimension (:,:), intent ( in out ) :: bdw !! (`sizm`,1) array. !! On _entry_, contains a vector drawn from standard normal !! distribution. On _return_, is overwritten with the result of !! **B**._d_**W**. logical , intent ( out ) :: lconv !! Returns *true* if converged, *false* otherwise. integer , intent ( out ) :: f !! The number of iterations performed. integer , intent ( out ) :: ierr !! Error flag. integer :: j , info , lwork , liwork real ( rp ), dimension ( 1 ) :: qwork !Size 1 array for workspace query. integer , dimension ( 1 ) :: qiwork !Size 1 array for workspace query. real ( rp ) :: normz , err character ( len = 256 ) :: msg lconv = . false .; ierr = 0 ; f = 0 lncv = 0.0_rp ; h_d = 0.0_rp ; h_sd = 0.0_rp eigvlh = 0.0_rp ; eigvch = 0.0_rp w = 0.0_rp ; tmp = 0.0_rp ; bdw_old = 0.0_rp !Workspace query if ((. not . allocated ( work )) . or . (. not . allocated ( iwork ))) then call dstevd ( 'V' , dimk_max , eigvlh , tmp ( 1 : dimk_max , 1 ), eigvch , dimk_max , & qwork , - 1 , qiwork , - 1 , info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_lanc> dstevd err = ' , info , & ' on workspace query' call logger % log_msg ( msg ) ierr = 1 ; return end if lwork = int ( qwork ( 1 )); liwork = qiwork ( 1 ) allocate ( work ( lwork ) ); allocate ( iwork ( liwork ) ) end if !Lanczos process normz = norm2 ( bdw (:, 1 )) lncv (:, 1 ) = bdw (:, 1 ) / normz do j = 1 , dimk_max f = f + 1 !Iteration count call dsymv ( 'L' , sizm , 1.0_rp , mob , sizm , lncv (:, j ), 1 , 0.0_rp , w (:, 1 ), 1 ) if ( j > 1 ) then w (:, 1 ) = w (:, 1 ) - h_sd ( j - 1 ) * lncv (:, j - 1 ) end if h_d ( j ) = dot_product ( w (:, 1 ), lncv (:, j )) if ( j < dimk_max ) then w (:, 1 ) = w (:, 1 ) - h_d ( j ) * lncv (:, j ) h_sd ( j ) = norm2 ( w (:, 1 )) lncv (:, j + 1 ) = w (:, 1 ) / h_sd ( j ) end if !Calculate B.dW and check for convergence if ( j >= dimk_min ) then eigvlh ( 1 : j ) = h_d ( 1 : j ) tmp ( 1 : j , 1 ) = h_sd ( 1 : j ) !Eigen decomposition of H = P * d * P&#94;T !eigvlh[1:j] <- d; eigvch[1:j,1:j] <- P call dstevd ( 'V' , j , eigvlh ( 1 : j ), tmp ( 1 : j , 1 ), eigvch , dimk_max , & work , size ( work ), iwork , size ( iwork ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a,i0)' ) '<calc_bdw_lanc> dstevd err = ' , info , & ' on iteration ' , j call logger % log_msg ( msg ) ierr = 1 ; return end if !eigvlh(1:j) <- d&#94;(1/2) eigvlh ( 1 : j ) = sqrt ( eigvlh ( 1 : j )) !tmp[1:j,1] <- d&#94;(1/2) * P&#94;T * e_1, where e_1 if the first column of !an identity matrix of size j. tmp ( 1 : j , 1 ) = eigvch ( 1 , 1 : j ) tmp ( 1 : j , 1 ) = eigvlh ( 1 : j ) * tmp ( 1 : j , 1 ) !tmp[1:j,2] <- P * tmp[1:j,1] call dgemv ( 'N' , j , j , 1.0_rp , eigvch , dimk_max , tmp ( 1 : j , 1 ), 1 , & 0.0_rp , tmp ( 1 : j , 2 ), 1 ) !bdw <- normz * lncv[:,1:j] * tmp[1:j,2] call dgemv ( 'N' , sizm , j , normz , lncv , sizm , tmp ( 1 : j , 2 ), 1 , & 0.0_rp , bdw , 1 ) !Error calculation for j > dimk_min. For j = dimk_min just save !bdw for error calculation in the next iteration. if ( j > dimk_min ) then err = norm2 ( bdw (:, 1 ) - bdw_old (:, 1 )) / norm2 ( bdw_old (:, 1 )) if ( err <= ethres ) then lconv = . true .; exit end if end if bdw_old = bdw end if end do end subroutine !******************************************************************************* subroutine calc_bdw_blanc ( mob , bdw , lconv , f , ierr ) !! Implements block Lanczos algorithm for calculating **B**._d_**W**. real ( rp ), dimension (:,:), intent ( in ) :: mob !! (`sizm`,`sizm`) symmetric positive definite matrix. real ( rp ), dimension (:,:), intent ( in out ) :: bdw !! (`sizm`,`s`) matrix. !! On _entry_, contains `s` column vectors drawn from standard normal !! distribution. On _return_, the `s` columns are overwritten with the !! result of **B**._d_**W**. logical , intent ( out ) :: lconv !! Returns *true* if converged, *false* otherwise. integer , intent ( out ) :: f !! The number of iterations performed. integer , intent ( out ) :: ierr !! Error flag. real ( rp ) :: err integer :: j , jb , irow , jcol integer :: jgbeg , jgend , igbeg , ig , jg integer :: info , lwork , liwork real ( rp ), dimension ( 1 ) :: qwork integer , dimension ( 1 ) :: qiwork character ( len = 256 ) :: msg lconv = . false .; ierr = 0 ; f = 0 lncv = 0.0_rp ; h_bd = 0.0_rp ; h_bsd = 0.0_rp eigvlh = 0.0_rp ; eigvch = 0.0_rp w = 0.0_rp ; tmp = 0.0_rp ; bdw_old = 0.0_rp tau = 0.0_rp ; matr = 0.0_rp ; h_bnd = 0.0_rp !Workspace query if (. not . allocated ( work )) then call dgeqp3 ( sizm , s , bdw , sizm , qiwork , tau , qwork , - 1 , info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_blanc> dgeqp3 err = ' , info , & ' on workspace query' call logger % log_msg ( msg ) ierr = 1 ; return end if lwork = int ( qwork ( 1 ) ) call dorgqr ( sizm , s , s , bdw , sizm , tau , qwork , - 1 , info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_blanc> dorgqr err = ' , info , & ' on workspace query' call logger % log_msg ( msg ) ierr = 1 ; return end if lwork = max ( lwork , int ( qwork ( 1 )) ) call dsbevd ( 'V' , 'L' , dimk_max * s , 2 * s - 1 , h_bnd , 2 * s , & eigvlh , eigvch , s * dimk_max , qwork , - 1 , qiwork , - 1 , info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_blanc> dsbevd err = ' , info , & ' on workspace query' call logger % log_msg ( msg ) ierr = 1 ; return end if lwork = max ( lwork , int ( qwork ( 1 )) ) liwork = qiwork ( 1 ) allocate ( work ( lwork )); allocate ( iwork ( liwork )) end if !Lanczos process !Reduced QR factorization of bdw with pivoting. The results overwrite bdw. iwork = 0 ; qwork = 0.0_rp call dgeqp3 ( sizm , s , bdw , sizm , iwork , tau , work , size ( work ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_blanc> dgeqp3 err = ' , info , & ' on iteration 0' call logger % log_msg ( msg ) ierr = 1 ; return end if !Extract the (s,s) permuted upper triangular matrix R and store it in matr. do jcol = 1 , s matr ( 1 : jcol , iwork ( jcol )) = bdw ( 1 : jcol , jcol ) end do !Extract the (sizm,s) matrix Q and store it in lncv[:,1:s]. call dorgqr ( sizm , s , s , bdw , sizm , tau , work , size ( work ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_blanc> dorgqr err = ' , info , & ' on iteration 0' call logger % log_msg ( msg ) ierr = 1 ; return end if lncv (:, 1 : s ) = bdw do j = 1 , dimk_max f = f + 1 !Iteration count !W <- mob * V_j jgbeg = ( j - 1 ) * s + 1 ; jgend = j * s call dsymm ( 'L' , 'L' , sizm , s , 1.0_rp , mob , sizm , & lncv (:, jgbeg : jgend ), sizm , 0.0_rp , w , sizm ) if ( j > 1 ) then !W -> W - V_(j-1) * H_(j-1,j) !   = W - V_(j-1) * H_(j,j-1)&#94;T, using the subdiagonal block jgbeg = ( j - 2 ) * s + 1 ; jgend = ( j - 1 ) * s call dgemm ( 'N' , 'T' , sizm , s , s , - 1.0_rp , lncv (:, jgbeg : jgend ), sizm , & h_bsd (:, jgbeg : jgend ), s , 1.0_rp , w , sizm ) end if !H_(j,j) <- V_j&#94;T * W jgbeg = ( j - 1 ) * s + 1 ; jgend = j * s call dgemm ( 'T' , 'N' , s , s , sizm , 1.0_rp , lncv (:, jgbeg : jgend ), sizm , & w , sizm , 0.0_rp , h_bd (:, jgbeg : jgend ), s ) if ( j < dimk_max ) then !W -> W - V_(j) * H_(j,j) !Note: H_(j,j) is symmetric. jgbeg = ( j - 1 ) * s + 1 ; jgend = j * s call dsymm ( 'R' , 'L' , sizm , s , - 1.0_rp , h_bd (:, jgbeg : jgend ), & s , lncv (:, jgbeg : jgend ), sizm , 1.0_rp , w , sizm ) !Reduced QR factorization of w. iwork = 0 call dgeqp3 ( sizm , s , w , sizm , iwork , tau , work , size ( work ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a,i0)' ) '<calc_bdw_blanc> dgeqp3 err = ' , info , & ' on iteration ' , j call logger % log_msg ( msg ) ierr = 1 ; return end if !Extract the (s,s) permuted upper triangular matrix R and store !it in H_(j+1,j). do jcol = 1 , s h_bsd ( 1 : jcol , ( j - 1 ) * s + iwork ( jcol )) = w ( 1 : jcol , jcol ) end do !Extract the (sizm,s) matrix Q and store it in V_(j+1). call dorgqr ( sizm , s , s , w , sizm , tau , work , size ( work ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a,i0)' ) '<calc_bdw_blanc> dorgqr err = ' , info , & ' on iteration ' , j call logger % log_msg ( msg ) ierr = 1 ; return end if jgbeg = j * s + 1 ; jgend = ( j + 1 ) * s lncv (:, jgbeg : jgend ) = w end if !Calculate B.dW and check for convergence if ( j >= dimk_min ) then jgbeg = ( j - 1 ) * s + 1 ; jgend = j * s !Create matrix H in band storage format, in preparation for eigen !decomposition with symmetric band matrix routine. h_bnd = 0.0_rp do jb = 1 , j jgbeg = ( jb - 1 ) * s ; igbeg = jgbeg do jcol = 1 , s jg = jgbeg + jcol do irow = jcol , s ig = igbeg + irow h_bnd ( ig - jg + 1 , jg ) = h_bd ( irow , jg ) end do end do end do do jb = 1 , ( j - 1 ) jgbeg = ( jb - 1 ) * s ; igbeg = jb * s do jcol = 1 , s jg = jgbeg + jcol do irow = 1 , s ig = igbeg + irow h_bnd ( ig - jg + 1 , jg ) = h_bsd ( irow , jg ) end do end do end do !Eigen decomposition of H = P * d * P&#94;T !eigvlh <- d; eigvch <- P call dsbevd ( 'V' , 'L' , j * s , 2 * s - 1 , h_bnd (:, 1 : j * s ), 2 * s , eigvlh , & eigvch , s * dimk_max , work , size ( work ), iwork , & size ( iwork ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a,i0)' ) '<calc_bdw_blanc> dsbevd err = ' , info , & ' on iteration ' , j call logger % log_msg ( msg ) ierr = 1 ; return end if !Square root of the eigen values eigvlh ( 1 : j * s ) = sqrt ( eigvlh ( 1 : j * s )) !tmp[1:j*s,1:s] <- eigvch[1:s,1:j*s]&#94;T * matr call dgemm ( 'T' , 'N' , j * s , s , s , 1.0_rp , eigvch , s * dimk_max , & matr , s , 0.0_rp , tmp (:, 1 : s ), s * dimk_max ) !tmp[1:j*s,1:s] <- eigvlh[1:j*s] * tmp[1:j*s,1:s] do jcol = 1 , s tmp ( 1 : j * s , jcol ) = eigvlh ( 1 : j * s ) * tmp ( 1 : j * s , jcol ) end do !tmp[1:j*s,s+1:2*s] <- eigvch[1:j*s,1:j*s] * tmp[1:j*s,1:s] call dgemm ( 'N' , 'N' , j * s , s , j * s , 1.0_rp , eigvch , s * dimk_max , & tmp (:, 1 : s ), s * dimk_max , 0.0_rp , tmp (:, s + 1 : 2 * s ), s * dimk_max ) !bdw <- lncv[:,1:j*s] * tmp[1:j*s,s+1:2*s] call dgemm ( 'N' , 'N' , sizm , s , j * s , 1.0_rp , lncv , sizm , & tmp (:, s + 1 : 2 * s ), s * dimk_max , 0.0_rp , bdw , sizm ) !Error calculation for j > dimk_min. For j == dimk_min just save !bdw for error calculation in the next iteration. Using 1-norm as !the matrix norm here. if ( j > dimk_min ) then err = maxval ( sum ( abs ( bdw - bdw_old ), 1 )) & / maxval ( sum ( abs ( bdw_old ), 1 )) if ( err <= ethres ) then lconv = . true .; f = j exit end if end if bdw_old = bdw end if end do end subroutine !****************************************************************************** subroutine calc_bdw_cholesky ( mob , bdw , ierr ) !! Calculates **B**._d_**W** using Cholesky decomposition. real ( rp ), dimension (:,:), intent ( in out ) :: mob !! (`sizm`,`sizm`) symmetric positive definite matrix. !! On _entry_, contains the mobility matrix.  On _return_, !! the upper triangular part is overwritten with the result of Cholesky !! decomposition.  The strictly lower triangular part is left intact. real ( rp ), dimension (:,:), intent ( in out ) :: bdw !! (`sizm`,`s`) matrix. !! On _entry_, contains `s` column vectors drawn from standard normal !! distribution. On _return_, the `s` columns are overwritten with the !! result of **B**._d_**W**. integer , intent ( out ) :: ierr !! Error flag. integer :: info character ( len = 256 ) :: msg ierr = 0 !Cholesky decomposition: mob = U&#94;T * U. The upper triangular part of mob is !overwritten with U. The strictly lower triangular part of mob is not !accessed. call dpotrf ( 'U' , sizm , mob , sizm , info ) if ( info /= 0 ) then write ( msg , '(a,i0)' ) '<calc_bdw_cholesky> dpotrf err = ' , info call logger % log_msg ( msg ) ierr = 1 ; return end if !Product of U (stored in the upper triangular part of mob) with each of the !random vectors: bdw = U*bdw if ( s == 1 ) then call dtrmv ( 'U' , 'N' , 'N' , sizm , mob , sizm , bdw (:, 1 ), 1 ) else call dtrmm ( 'L' , 'U' , 'N' , 'N' , sizm , s , 1.0_rp , mob , sizm , bdw , sizm ) end if end subroutine !******************************************************************************* subroutine brn_calc_dw ( dw ) !! Calculates standard normally distributed random vectors. real ( rp ), dimension (:,:), target , intent ( out ) :: dw !! (`n`,`m`) array. real ( rp ), dimension (:), pointer :: vec_dw type ( c_ptr ) :: loc_dw integer :: n , m n = size ( dw , 1 ); m = size ( dw , 2 ) dw = 0.0_rp loc_dw = c_loc ( dw ) call c_f_pointer ( loc_dw , vec_dw , [ n * m ]) call get_rv_gaussian ( 0.0_rp , 1.0_rp , vec_dw , 1000000 ) end subroutine !******************************************************************************* subroutine calc_bdw_lanc_sor ( mob , bdw , lconv , f , ierr ) real ( rp ), dimension (:,:), intent ( in ) :: mob !! (`sizm`,`sizm`) symmetric positive definite matrix. real ( rp ), dimension (:,:), intent ( in out ) :: bdw !! (`sizm`,1) array. !! On _entry_, contains a vector drawn from standard normal !! distribution. On _return_, is overwritten with the result of !! **B**.d**W**. logical , intent ( out ) :: lconv !! Returns *true* if converged, *false* otherwise. integer , intent ( out ) :: f !! The number of iterations performed. integer , intent ( out ) :: ierr !! Error flag. integer :: j , info , lwork , liwork , k real ( rp ), dimension ( 1 ) :: qwork !Size 1 array for workspace query. integer , dimension ( 1 ) :: qiwork !Size 1 array for workspace query. real ( rp ), dimension ( dimk_max ) :: errbnd real ( rp ), dimension ( sizm ) :: ritzv real ( rp ) :: normz , err , normm character ( len = 256 ) :: msg lconv = . false .; ierr = 0 ; f = 0 tmp = 0.0_rp ; eigvlh = 0.0_rp ; eigvch = 0.0_rp h_d = 0.0_rp ; h_sd = 0.0_rp bdw_old = 0.0_rp ; lncv = 0.0_rp ; w = 0.0_rp !Workspace query if ((. not . allocated ( work )) . or . (. not . allocated ( iwork ))) then call dstevd ( 'V' , dimk_max , eigvlh , tmp ( 1 : dimk_max , 1 ), eigvch , dimk_max , & qwork , - 1 , qiwork , - 1 , info ) if ( info /= 0 ) then write ( msg , '(a,i0,a)' ) '<calc_bdw_lanc_sor> dstevd err = ' , info , & ' on workspace query' call logger % log_msg ( msg ) ierr = 1 ; return end if lwork = int ( qwork ( 1 )); liwork = qiwork ( 1 ) allocate ( work ( lwork ) ); allocate ( iwork ( liwork ) ) end if !Lanczos process normz = norm2 ( bdw (:, 1 )) normm = maxval ( sum ( abs ( mob ), 1 )) lncv (:, 1 ) = bdw (:, 1 ) / normz do j = 1 , dimk_max f = f + 1 !Iteration count call dsymv ( 'L' , sizm , 1.0_rp , mob , sizm , lncv (:, j ), 1 , 0.0_rp , w (:, 1 ), 1 ) if ( j > 1 ) then w (:, 1 ) = w (:, 1 ) - h_sd ( j - 1 ) * lncv (:, j - 1 ) end if h_d ( j ) = dot_product ( w (:, 1 ), lncv (:, j )) if ( j < dimk_max ) then w (:, 1 ) = w (:, 1 ) - h_d ( j ) * lncv (:, j ) do k = 1 , j if ( errbnd ( k ) < sqrt ( epsilon ( 1.0_rp ) * normm )) then call dgemv ( 'N' , sizm , j , 1.0_rp , lncv , sizm , eigvch (:, k ), 1 , & 0.0_rp , ritzv , 1 ) w (:, 1 ) = w (:, 1 ) - dot_product ( ritzv , w (:, 1 )) * ritzv end if end do h_sd ( j ) = norm2 ( w (:, 1 )) lncv (:, j + 1 ) = w (:, 1 ) / h_sd ( j ) end if !Compute eigenvalues, eigenvectors and error bounds for H if ( j > 1 ) then eigvlh ( 1 : j ) = h_d ( 1 : j ) tmp ( 1 : j , 1 ) = h_sd ( 1 : j ) !Eigen decomposition of H = P * d * P&#94;T !eigvlh[1:j] <- d; eigvch[1:j,1:j] <- P call dstevd ( 'V' , j , eigvlh ( 1 : j ), tmp ( 1 : j , 1 ), eigvch , dimk_max , & work , size ( work ), iwork , size ( iwork ), info ) if ( info /= 0 ) then write ( msg , '(a,i0,a,i0)' ) '<calc_bdw_lanc_sor> dstevd err = ' , info , & ' on iteration ' , j call logger % log_msg ( msg ) ierr = 1 ; return end if errbnd ( 1 : j ) = abs ( h_sd ( j )) * eigvch ( j , 1 : j ) end if !Calculate B.dW and check for convergence if ( j >= dimk_min ) then !eigvlh(1:j) <- d&#94;(1/2) eigvlh ( 1 : j ) = sqrt ( eigvlh ( 1 : j )) !tmp[1:j,1] <- d&#94;(1/2) * P&#94;T * e_1, where e_1 if the first column of !an identity matrix of size j. tmp ( 1 : j , 1 ) = eigvch ( 1 , 1 : j ) tmp ( 1 : j , 1 ) = eigvlh ( 1 : j ) * tmp ( 1 : j , 1 ) !tmp[1:j,2] <- P * tmp[1:j,1] call dgemv ( 'N' , j , j , 1.0_rp , eigvch , dimk_max , tmp ( 1 : j , 1 ), 1 , & 0.0_rp , tmp ( 1 : j , 2 ), 1 ) !bdw <- normz * lncv[:,1:j] * tmp[1:j,2] call dgemv ( 'N' , sizm , j , normz , lncv , sizm , tmp ( 1 : j , 2 ), 1 , & 0.0_rp , bdw , 1 ) !Error calculation for j > dimk_min. For j = dimk_min just save !bdw for error calculation in the next iteration. if ( j > dimk_min ) then err = norm2 ( bdw (:, 1 ) - bdw_old (:, 1 )) / norm2 ( bdw_old (:, 1 )) !write(*,*) j, 'err = ', err if ( err <= ethres ) then lconv = . true . exit end if end if bdw_old = bdw end if end do end subroutine !******************************************************************************* end module m_brown","tags":"","loc":"sourcefile/m_brown.f90.html"},{"title":"m_ia_angle.f90 – BROWNPAK","text":"Contents Modules m_ia_angle Source Code m_ia_angle.f90 Source Code module m_ia_angle !! Angle potentials !! !! * Style 0: None (Only topology) !! * Style 1: Cosine. See [[ang_cos_set]]. use m_precision use m_constants_math use m_globals implicit none private public :: ia_angle_setup , ia_get_angle_force contains !****************************************************************************** subroutine ia_angle_setup () !! Sets up parameters for angle potentials integer :: i integer :: sty !Set angular interactions do i = 1 , num_angle_types sty = angle_styles ( i ) select case ( sty ) case ( 1 ) call ang_cos_set ( angle_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_angle_force ( q1 , q2 , typ , enrg , fim1 , fi , fip1 ) !! Calculates the energy & force due to an angle. real ( rp ), dimension ( 3 ), intent ( in ) :: q1 real ( rp ), dimension ( 3 ), intent ( in ) :: q2 integer , intent ( in ) :: typ real ( rp ), intent ( out ) :: enrg real ( rp ), dimension ( 3 ), intent ( out ) :: fim1 real ( rp ), dimension ( 3 ), intent ( out ) :: fi real ( rp ), dimension ( 3 ), intent ( out ) :: fip1 real ( rp ), dimension ( 3 ) :: q1hat , q2hat real ( rp ) :: kang real ( rp ) :: q1mag , q2mag , ctheta integer :: styl q1mag = norm2 ( q1 ); q2mag = norm2 ( q2 ) q1hat = q1 / q1mag ; q2hat = q2 / q2mag ctheta = dot_product ( q1hat , q2hat ) !Floating point correction if ( ctheta > 1.0_rp ) ctheta = 1.0_rp if ( ctheta < - 1.0_rp ) ctheta = - 1.0_rp styl = angle_styles ( typ ) select case ( styl ) case ( 1 ) kang = angle_params ( 1 , typ ) enrg = kang * ( 1.0_rp - ctheta ) fim1 = kang * ( - q2hat + ctheta * q1hat ) / q1mag fip1 = kang * ( q1hat - ctheta * q2hat ) / q2mag fi = - ( fim1 + fip1 ) case default continue end select end subroutine !******************************************************************************** subroutine ang_cos_set ( params , k ) !! Setter for angular cosine interaction. !! !!``` !!   U(theta) = k*(1 - cos theta), !!   where theta is the complementary angle between bonds i & (i+1). !!``` !! User-set parameters: !! !! params(1) = `k` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k if ( present ( k )) params ( 1 ) = k end subroutine !****************************************************************************** end module m_ia_angle","tags":"","loc":"sourcefile/m_ia_angle.f90.html"},{"title":"m_interaction.f90 – BROWNPAK","text":"Contents Modules m_interaction Source Code m_interaction.f90 Source Code module m_interaction !! Driver routines for force & energy calculation. use m_precision use m_constants_math use m_globals use m_pairtab use m_ia_bond use m_ia_angle use m_ia_dihedral use m_ia_vdw use m_ia_tether use m_ia_external implicit none private public :: ia_setup , ia_finish , ia_calc_forces contains !****************************************************************************** subroutine ia_setup () !! Builds necessary neighbor tables and sets up parameters for potentials. if ( num_vdw_types == 0 ) lvdw = . false . if ( lvdw ) then call pt_init () call ia_vdw_setup () end if if ( num_bonds > 0 ) call ia_bond_setup () if ( num_angles > 0 ) call ia_angle_setup () if ( num_dihedrals > 0 ) call ia_dihedral_setup () if ( num_tethers > 0 ) call ia_tether_setup () if ( num_externals > 0 ) call ia_external_setup () end subroutine !****************************************************************************** subroutine ia_finish () !! Cleanup routine for interaction calculation. call pt_finish () end subroutine !****************************************************************************** subroutine ia_calc_forces ( ierr ) !! Calculates total forces and energies integer , intent ( out ) :: ierr ierr = 0 !Zeroing out force, energies, & bond length forces = 0.0_rp energy_bond = 0.0_rp energy_angle = 0.0_rp energy_dihedral = 0.0_rp energy_tether = 0.0_rp energy_vdw = 0.0_rp energy_external = 0.0_rp energy_tot = 0.0_rp stress = 0.0_rp if ( num_bonds > 0 ) then bndlen = 0.0_rp bndlen_min = huge ( 0.0_rp ) bndlen_max = 0.0_rp end if !Calculation of bonded interactions if ( num_bonds > 0 ) then call ia_add_bond_forces ( ierr ) if ( ierr /= 0 ) return end if !Calculation of angular interactions if ( num_angles > 0 ) call ia_add_angle_forces () !Calculation of dihedral interactions if ( num_dihedrals > 0 ) call ia_add_dihedral_forces () !Calculation of tether interactions if ( num_tethers > 0 ) then call ia_add_tether_forces ( ierr ) if ( ierr /= 0 ) return end if !Calculation for pairwise interactions if ( lvdw ) then call ia_add_vdw_forces ( ierr ) if ( ierr /= 0 ) return end if !Calculation of external interactions if ( num_externals > 0 ) then call ia_add_external_forces ( ierr ) if ( ierr /= 0 ) return end if !Calculate total energy energy_tot = energy_bond + energy_angle + energy_dihedral + energy_vdw & + energy_tether + energy_external !Update stress considering volume for finite concentration if ( imcon /= 0 ) stress = stress / simbox % volume end subroutine !******************************************************************************** subroutine ia_add_vdw_forces ( ierr ) !! Calculates force and energy due to all short-ranged non-bonded pairwise !! interactions based on `pair_tab` and adds to `energy_vdw` & `forces` !! in module `m_globals`. integer , intent ( out ) :: ierr integer , dimension (:), pointer :: pnbrs => null () real ( rp ), dimension ( 3 ) :: ri , rj , rij , fi real ( rp ) :: rij_mag real ( rp ) :: qi , qj real ( rp ) :: enrg , frc integer :: i , j , k , at_i , at_j , typ ierr = 0 call pt_build () do i = 1 , num_atoms ri = coordinates (:, i ) qi = charge ( i ) at_i = atoms ( i ) !Getting list of neighbors of atom i using pointer pnbrs call pair_tab % get_row ( i , pnbrs ) do k = 1 , size ( pnbrs ) j = pnbrs ( k ) rj = coordinates (:, j ) qj = charge ( j ) at_j = atoms ( j ) if ( at_i < at_j ) then typ = at_j + ( 2 * num_atom_types - at_i ) * ( at_i - 1 ) / 2 else typ = at_i + ( 2 * num_atom_types - at_j ) * ( at_j - 1 ) / 2 end if rij = rj - ri if ( imcon /= 0 ) call simbox % get_image ( rij ) rij_mag = norm2 ( rij ) call ia_get_vdw_force ( rij_mag , qi , qj , typ , enrg , frc , ierr ) if ( ierr /= 0 ) return energy_vdw = energy_vdw + enrg fi = frc * rij / rij_mag !Update forces forces (:, i ) = forces (:, i ) + fi forces (:, j ) = forces (:, j ) - fi !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - rij ( 1 ) * fi ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - rij ( 2 ) * fi ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - rij ( 3 ) * fi ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - rij ( 1 ) * fi ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - rij ( 2 ) * fi ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - rij ( 3 ) * fi ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - rij ( 1 ) * fi ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - rij ( 2 ) * fi ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - rij ( 3 ) * fi ( 3 ) end do end do end subroutine !******************************************************************************** subroutine ia_add_bond_forces ( ierr ) !! Calculates forces & energy due to all bonds. Will add to !! `energy_bond` & and 'forces` in module `m_globals`. integer , intent ( out ) :: ierr real ( rp ), dimension ( 3 ) :: ri , rj , rij , fi real ( rp ) :: rij_mag real ( rp ) :: enrg , frc integer :: ibnd , typ integer :: i , j ierr = 0 do ibnd = 1 , num_bonds typ = bonds ( 1 , ibnd ) i = bonds ( 2 , ibnd ) j = bonds ( 3 , ibnd ) ri = coordinates (:, i ) rj = coordinates (:, j ) rij = rj - ri if ( imcon /= 0 ) call simbox % get_image ( rij ) rij_mag = norm2 ( rij ) bndlen = bndlen + rij_mag bndlen_min = min ( bndlen_min , rij_mag ) bndlen_max = max ( bndlen_max , rij_mag ) call ia_get_bond_force ( rij_mag , typ , enrg , frc , ierr ) if ( ierr /= 0 ) return energy_bond = energy_bond + enrg fi = frc * rij / rij_mag forces (:, i ) = forces (:, i ) + fi forces (:, j ) = forces (:, j ) - fi !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - rij ( 1 ) * fi ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - rij ( 2 ) * fi ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - rij ( 3 ) * fi ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - rij ( 1 ) * fi ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - rij ( 2 ) * fi ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - rij ( 3 ) * fi ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - rij ( 1 ) * fi ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - rij ( 2 ) * fi ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - rij ( 3 ) * fi ( 3 ) end do bndlen = bndlen / num_bonds end subroutine !******************************************************************************** subroutine ia_add_angle_forces () !! Calculates forces & energy due to all angles. Will add to !! `energy_angle` & 'forces` in module `m_globals`. real ( rp ), dimension ( 3 ) :: rim1 , ri , rip1 , q1 , q2 real ( rp ), dimension ( 3 ) :: fim1 , fi , fip1 real ( rp ) :: enrg integer :: iang integer :: typ integer :: i , im1 , ip1 do iang = 1 , num_angles typ = angles ( 1 , iang ) im1 = angles ( 2 , iang ) i = angles ( 3 , iang ) ip1 = angles ( 4 , iang ) rim1 = coordinates (:, im1 ) ri = coordinates (:, i ) rip1 = coordinates (:, ip1 ) q1 = ri - rim1 ; q2 = rip1 - ri if ( imcon /= 0 ) call simbox % get_image ( q1 ) if ( imcon /= 0 ) call simbox % get_image ( q2 ) call ia_get_angle_force ( q1 , q2 , typ , enrg , fim1 , fi , fip1 ) energy_angle = energy_angle + enrg !Update forces forces (:, im1 ) = forces (:, im1 ) + fim1 forces (:, i ) = forces (:, i ) + fi forces (:, ip1 ) = forces (:, ip1 ) + fip1 !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - q1 ( 1 ) * fim1 ( 1 ) + q2 ( 1 ) * fip1 ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - q1 ( 2 ) * fim1 ( 1 ) + q2 ( 2 ) * fip1 ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - q1 ( 3 ) * fim1 ( 1 ) + q2 ( 3 ) * fip1 ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - q1 ( 1 ) * fim1 ( 2 ) + q2 ( 1 ) * fip1 ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - q1 ( 2 ) * fim1 ( 2 ) + q2 ( 2 ) * fip1 ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - q1 ( 3 ) * fim1 ( 2 ) + q2 ( 3 ) * fip1 ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - q1 ( 1 ) * fim1 ( 3 ) + q2 ( 1 ) * fip1 ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - q1 ( 2 ) * fim1 ( 3 ) + q2 ( 2 ) * fip1 ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - q1 ( 3 ) * fim1 ( 3 ) + q2 ( 3 ) * fip1 ( 3 ) end do end subroutine !******************************************************************************** subroutine ia_add_dihedral_forces () !! Calculates forces & energy due to all dihedrals. Will add to !! `energy_dihedral` & 'forces` in module `m_globals`. real ( rp ), dimension ( 3 ) :: ri , rj , rk , rl real ( rp ), dimension ( 3 ) :: q1 , q2 , q3 real ( rp ), dimension ( 3 ) :: fi , fj , fk , fl real ( rp ) :: enrg integer :: idhd integer :: typ integer :: i , j , k , l do idhd = 1 , num_dihedrals typ = dihedrals ( 1 , idhd ) i = dihedrals ( 2 , idhd ) j = dihedrals ( 3 , idhd ) k = dihedrals ( 4 , idhd ) l = dihedrals ( 5 , idhd ) ri = coordinates (:, i ) rj = coordinates (:, j ) rk = coordinates (:, k ) rl = coordinates (:, l ) q1 = rj - ri ; q2 = rk - rj ; q3 = rl - rk if ( imcon /= 0 ) call simbox % get_image ( q1 ) if ( imcon /= 0 ) call simbox % get_image ( q2 ) if ( imcon /= 0 ) call simbox % get_image ( q3 ) call ia_get_dihedral_force ( q1 , q2 , q3 , typ , enrg , fi , fj , fk , fl ) energy_dihedral = energy_dihedral + enrg forces (:, i ) = forces (:, i ) + fi forces (:, j ) = forces (:, j ) + fj forces (:, k ) = forces (:, k ) + fk forces (:, l ) = forces (:, l ) + fl !TODO: Add the contribution to stress here. end do end subroutine !******************************************************************************** subroutine ia_add_tether_forces ( ierr ) !! Calculates forces & energy due to all tethers. Will add to `energy_tether` & !! 'forces` in module `m_globals`. Tether forces cannot be subject to !! periodic boundary conditions. integer , intent ( out ) :: ierr real ( rp ), dimension ( 3 ) :: r , tp , q , fj real ( rp ) :: qmag real ( rp ) :: enrg , frc integer :: iteth , typ , teth_iatm ierr = 0 do iteth = 1 , num_tethers typ = tethers ( 1 , iteth ) teth_iatm = tethers ( 2 , iteth ) !Index of the tethered atom tp = tether_points (:, iteth ) r = coordinates (:, teth_iatm ) q = r - tp qmag = norm2 ( q ) call ia_get_tether_force ( qmag , typ , enrg , frc , ierr ) if ( ierr /= 0 ) return fj = - frc * q / qmag energy_tether = energy_tether + enrg forces (:, teth_iatm ) = forces (:, teth_iatm ) + fj !Update stress !Sign flipped since fj, not fi is involved stress ( 1 , 1 ) = stress ( 1 , 1 ) + q ( 1 ) * fj ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) + q ( 2 ) * fj ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) + q ( 3 ) * fj ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) + q ( 1 ) * fj ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) + q ( 2 ) * fj ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) + q ( 3 ) * fj ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) + q ( 1 ) * fj ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) + q ( 2 ) * fj ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) + q ( 3 ) * fj ( 3 ) end do end subroutine !****************************************************************************** end module m_interaction","tags":"","loc":"sourcefile/m_interaction.f90.html"},{"title":"m_vector.f90 – BROWNPAK","text":"Contents Modules m_vector Source Code m_vector.f90 Source Code module m_vector !! Implements a vector as an extendable array. use m_precision use m_qsort implicit none type ivector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init integer , dimension (:), allocatable :: buffer contains procedure :: delete => ivector_delete procedure :: clear => ivector_clear procedure :: get_val => ivector_get_val procedure :: set_val => ivector_set_val procedure :: get_data => ivector_get_data procedure :: append => ivector_append procedure :: pop => ivector_pop procedure :: resize => ivector_resize procedure :: shrink_to_fit => ivector_shrink_to_fit procedure :: sort => ivector_sort procedure :: unique => ivector_unique procedure :: print => ivector_print end type ivector_t type dvector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init real ( rp ), dimension (:), allocatable :: buffer contains procedure :: delete => dvector_delete procedure :: clear => dvector_clear procedure :: get_val => dvector_get_val procedure :: set_val => dvector_set_val procedure :: get_data => dvector_get_data procedure :: append => dvector_append procedure :: pop => dvector_pop procedure :: resize => dvector_resize procedure :: shrink_to_fit => dvector_shrink_to_fit procedure :: sort => dvector_sort procedure :: unique => dvector_unique procedure :: print => dvector_print end type dvector_t interface ivector_init module procedure ivector_init module procedure ivector_from_array end interface interface dvector_init module procedure dvector_init module procedure dvector_from_array end interface interface assignment ( = ) module procedure ivector_assign module procedure dvector_assign module procedure i_dvector_assign end interface contains !****************************************************************************** !> Creates an empty *ivector* with all elements equal to zero. subroutine ivector_init ( this , len_init , ierr ) type ( ivector_t ), intent ( in out ) :: this integer , intent ( in ), optional :: len_init !! Must be > 0 integer , intent ( out ), optional :: ierr integer :: istat if ( present ( ierr )) ierr = 0 if ( present ( len_init )) then if ( len_init > 0 ) this % len_init = len_init this % len_max = 2 * len_init end if allocate ( this % buffer ( this % len_max ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for this%buffer of size' , this % len_max if ( present ( ierr )) ierr = 1 return end if this % buffer = 0 end subroutine !****************************************************************************** !> Creates an empty *dvector* with all elements equal to zero. subroutine dvector_init ( this , len_init , ierr ) type ( dvector_t ), intent ( in out ) :: this integer , intent ( in ), optional :: len_init !! Must be > 0 integer , intent ( out ), optional :: ierr integer :: istat if ( present ( ierr )) ierr = 0 if ( present ( len_init )) then if ( len_init > 0 ) this % len_init = len_init this % len_max = 2 * len_init end if allocate ( this % buffer ( this % len_max ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for this%buffer of size' , this % len_max if ( present ( ierr )) ierr = 1 return end if this % buffer = 0.0_rp end subroutine !****************************************************************************** !> Creates an *ivector* with all elements from an array subroutine ivector_from_array ( this , x ) type ( ivector_t ), intent ( in out ) :: this integer , dimension (:), intent ( in ) :: x integer , dimension (:), allocatable :: temp integer :: n call ivector_init ( this ) n = size ( x , 1 ) if ( this % len_max < n ) then allocate ( temp ( 2 * n )) temp = 0 temp ( 1 : n ) = x call move_alloc ( temp , this % buffer ) this % len = n this % len_max = 2 * n else this % buffer ( 1 : n ) = x this % len = n end if end subroutine !****************************************************************************** !> Creates a *dvector* with all elements from an array subroutine dvector_from_array ( this , x ) type ( dvector_t ), intent ( in out ) :: this real ( rp ), dimension (:), intent ( in ) :: x real ( rp ), dimension (:), allocatable :: temp integer :: n call dvector_init ( this ) n = size ( x , 1 ) if ( this % len_max < n ) then allocate ( temp ( 2 * n )) temp = 0 temp ( 1 : n ) = x call move_alloc ( temp , this % buffer ) this % len = n this % len_max = 2 * n else this % buffer ( 1 : n ) = x this % len = n end if end subroutine !****************************************************************************** !> Deletes an *ivector*. No access is allowed to this object after this call. subroutine ivector_delete ( this ) class ( ivector_t ), intent ( in out ) :: this if ( allocated ( this % buffer )) deallocate ( this % buffer ) this % len = 0 end subroutine !****************************************************************************** !> Deletes a *dvector*. No access is allowed to this object after this call. subroutine dvector_delete ( this ) class ( dvector_t ), intent ( in out ) :: this if ( allocated ( this % buffer )) deallocate ( this % buffer ) this % len = 0 end subroutine !****************************************************************************** !> Clears an *ivector*. Access allowed after a call to clear. subroutine ivector_clear ( this ) class ( ivector_t ), intent ( in out ) :: this this % len = 0 this % buffer = 0 end subroutine !****************************************************************************** !> Clears a *dvector*. Access allowed after a call to clear. subroutine dvector_clear ( this ) class ( dvector_t ), intent ( in out ) :: this this % len = 0 this % buffer = 0.0_rp end subroutine !****************************************************************************** !> Copies the contents of *ivector* `other` to *ivector* `this` !! subroutine ivector_assign ( this , other ) class ( ivector_t ), intent ( in out ) :: this class ( ivector_t ), intent ( in ) :: other integer :: n n = other % len if ( this % len >= n ) then !Copy contents if buffer is large enough this % buffer ( 1 : n ) = other % buffer this % len = n else !Need to enlarge buffer. Reallocate and copy deallocate ( this % buffer ) allocate ( this % buffer , source = other % buffer ( 1 : n )) this % len = n this % len_max = n end if end subroutine !****************************************************************************** !> Copies the contents of *dvector* `other` to *dvector* `this` !! subroutine dvector_assign ( this , other ) class ( dvector_t ), intent ( in out ) :: this class ( dvector_t ), intent ( in ) :: other integer :: n n = other % len if ( this % len >= n ) then !Copy contents if buffer is large enough this % buffer ( 1 : n ) = other % buffer ( 1 : n ) this % len = n else !Need to enlarge buffer. Reallocate and copy deallocate ( this % buffer ) allocate ( this % buffer , source = other % buffer ( 1 : n )) this % len = n this % len_max = n end if end subroutine !****************************************************************************** subroutine i_dvector_assign ( this , other ) !!  Copies the contents of *ivector* `other` to *dvector* `this`. Integers !!  are cast to reals. !\"\" class ( dvector_t ), intent ( in out ) :: this class ( ivector_t ), intent ( in ) :: other integer :: n n = other % len if ( this % len >= n ) then !Copy contents if buffer is large enough this % buffer ( 1 : n ) = dble ( other % buffer ( 1 : n )) this % len = n else !Need to enlarge buffer. Reallocate and copy deallocate ( this % buffer ) allocate ( this % buffer ( n )) this % buffer = dble ( other % buffer ( 1 : n )) this % len = n this % len_max = n end if end subroutine !****************************************************************************** !> Returns the length of an *ivector* function ivector_get_len ( this ) result ( res ) class ( ivector_t ), intent ( in ) :: this integer :: res res = this % len end function !****************************************************************************** !> Returns the length of a *dvector* function dvector_get_len ( this ) result ( res ) class ( dvector_t ), intent ( in ) :: this integer :: res res = this % len end function !****************************************************************************** !> Returns the ith element of an *ivector*. function ivector_get_val ( this , i ) result ( res ) class ( ivector_t ), intent ( in ) :: this integer , intent ( in ) :: i integer :: res if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else res = this % buffer ( i ) end if end function !****************************************************************************** !> Returns the ith element of a *dvector*. function dvector_get_val ( this , i ) result ( res ) class ( dvector_t ), intent ( in ) :: this integer , intent ( in ) :: i real ( rp ) :: res if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else res = this % buffer ( i ) end if end function !****************************************************************************** !> Sets the value of the ith element of an *ivector*. No bounds check is performed. subroutine ivector_set_val ( this , i , val ) class ( ivector_t ), intent ( in out ) :: this integer , intent ( in ) :: i integer , intent ( in ) :: val if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else this % buffer ( i ) = val end if end subroutine !****************************************************************************** !> Sets the value of the ith element of a *dvector*. No bounds check is performed. subroutine dvector_set_val ( this , i , val ) class ( dvector_t ), intent ( in out ) :: this integer , intent ( in ) :: i real ( rp ), intent ( in ) :: val if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else this % buffer ( i ) = val end if end subroutine !****************************************************************************** !> Adds an element to the end of an *ivector*. Reallocation will take place if required. subroutine ivector_append ( this , val ) class ( ivector_t ), intent ( in out ) :: this integer , intent ( in ) :: val integer , dimension (:), allocatable :: temp !Double len_max if current length is equal to len_max if ( this % len == this % len_max ) then allocate ( temp ( 2 * this % len_max )) temp = 0 temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) call move_alloc ( temp , this % buffer ) this % len_max = 2 * this % len_max end if this % buffer ( this % len + 1 ) = val this % len = this % len + 1 end subroutine !****************************************************************************** !> Adds an element to the end of a *dvector*. Reallocation will take place if required. subroutine dvector_append ( this , val ) class ( dvector_t ), intent ( in out ) :: this real ( rp ), intent ( in ) :: val real ( rp ), dimension (:), allocatable :: temp !Double len_max if current length is equal to len_max if ( this % len == this % len_max ) then allocate ( temp ( 2 * this % len_max )) temp = 0 temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) call move_alloc ( temp , this % buffer ) this % len_max = 2 * this % len_max end if this % buffer ( this % len + 1 ) = val this % len = this % len + 1 end subroutine !****************************************************************************** !> Removes the last element and returns it. Calling this method on an empty list ! will generate an error. function ivector_pop ( this ) result ( val ) class ( ivector_t ), intent ( in out ) :: this integer :: val val = this % buffer ( this % len ) this % len = this % len - 1 end function !****************************************************************************** !> Removes the last element and returns it. Calling this method on an empty list ! will generate an error. function dvector_pop ( this ) result ( val ) class ( dvector_t ), intent ( in out ) :: this real ( rp ) :: val val = this % buffer ( this % len ) this % len = this % len - 1 end function !****************************************************************************** !> Returns a pointer to the underlying data of an *ivector* ! No bounds checking is performed subroutine ivector_get_data ( this , res , ibeg , iend ) class ( ivector_t ), target , intent ( in ) :: this integer , dimension (:), pointer , intent ( out ) :: res integer , intent ( in ), optional :: ibeg integer , intent ( in ), optional :: iend integer :: ibeg_ integer :: iend_ res => null () ibeg_ = 1 iend_ = this % len if ( present ( ibeg )) then ibeg_ = ibeg end if if ( present ( iend )) then iend_ = iend end if res => this % buffer ( ibeg_ : iend_ ) end subroutine !****************************************************************************** !> Returns a pointer to the underlying data of a *dvector* ! No bounds checking is performed subroutine dvector_get_data ( this , res , ibeg , iend ) class ( dvector_t ), target , intent ( in ) :: this real ( rp ), dimension (:), pointer , intent ( out ) :: res integer , intent ( in ), optional :: ibeg integer , intent ( in ), optional :: iend integer :: ibeg_ integer :: iend_ res => null () ibeg_ = 1 iend_ = this % len if ( present ( ibeg )) then ibeg_ = ibeg end if if ( present ( iend )) then iend_ = iend end if res => this % buffer ( ibeg_ : iend_ ) end subroutine !****************************************************************************** !> Resizes a vector to a given size. Existing data is truncated if desired size !> is smaller than current size. Otherwise, the empty spaces are filled with !> zero. subroutine ivector_resize ( this , new_size , ierr ) class ( ivector_t ), intent ( in out ) :: this integer , intent ( in ) :: new_size integer , intent ( out ), optional :: ierr integer , dimension (:), allocatable :: temp integer :: istat if ( this % len_max >= new_size ) then this % buffer ( this % len + 1 : new_size ) = 0 this % len = new_size else allocate ( temp ( new_size ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for `temp` from `this%buffer`.' if ( present ( ierr )) ierr = 1 return end if temp = 0 ; temp ( 1 : this % len_max ) = this % buffer call move_alloc ( temp , this % buffer ) this % len_max = new_size ; this % len = new_size end if if ( present ( ierr )) ierr = 0 end subroutine !****************************************************************************** !> Resizes a vector to a given size. Existing data is truncated if desired size !> is smaller than current size. Otherwise, the empty spaces are filled with !> zero. subroutine dvector_resize ( this , new_size , ierr ) class ( dvector_t ), intent ( in out ) :: this integer , intent ( in ) :: new_size integer , intent ( out ), optional :: ierr real ( rp ), dimension (:), allocatable :: temp integer :: istat ierr = 0 if ( this % len_max > new_size ) then this % buffer ( this % len + 1 : new_size ) = 0.0_rp this % len = new_size else allocate ( temp ( new_size ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for `temp` from `this%buffer`.' if ( present ( ierr )) ierr = 1 return end if temp = 0.0_rp ; temp ( 1 : this % len_max ) = this % buffer call move_alloc ( temp , this % buffer ) this % len_max = new_size ; this % len = new_size end if if ( present ( ierr )) ierr = 0 end subroutine !****************************************************************************** !> Releases additional memory to fit underlying data of an *ivector* to a size !> this%len_init. subroutine ivector_shrink_to_fit ( this , ierr ) class ( ivector_t ), intent ( in out ) :: this integer , intent ( out ), optional :: ierr integer , dimension (:), allocatable :: temp integer :: istat if ( present ( ierr )) ierr = 0 if ( this % len > this % len_init ) then allocate ( temp , source = this % buffer ( 1 : this % len ), stat = istat ) else allocate ( temp ( this % len_init ), stat = istat ) temp = 0 temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) end if if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for `temp` from `this%buffer`.' if ( present ( ierr )) ierr = 1 return end if call move_alloc ( temp , this % buffer ) this % len_max = size ( this % buffer ) end subroutine !****************************************************************************** !> Releases additional memory to fit underlying data of a *dvector* to a size !> this%len_init. subroutine dvector_shrink_to_fit ( this , ierr ) class ( dvector_t ), intent ( in out ) :: this integer , intent ( out ), optional :: ierr real ( rp ), dimension (:), allocatable :: temp integer :: istat if ( present ( ierr )) ierr = 0 if ( this % len > this % len_init ) then allocate ( temp , source = this % buffer ( 1 : this % len ), stat = istat ) else allocate ( temp ( this % len_init ), stat = istat ) temp = 0.0_rp temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) end if if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for `temp` from `this%buffer`.' if ( present ( ierr )) ierr = 1 return end if call move_alloc ( temp , this % buffer ) this % len_max = size ( this % buffer ) end subroutine !****************************************************************************** !>  Sorts an *ivector* in ascending order. If `order` is provided, it will contain !!  the sorted indices.  The size of `order` must be at least `this%len`. subroutine ivector_sort ( this , order ) class ( ivector_t ), intent ( in out ) :: this integer , dimension (:), intent ( out ), optional :: order integer :: n n = this % len if ( n > 1 ) then if ( present ( order )) then call iqsort ( this % buffer ( 1 : n ), order ) else call iqsort ( this % buffer ( 1 : n )) end if end if end subroutine !****************************************************************************** !>  Sorts a *dvector* in ascending order. If `order` is provided, it will contain !!  the sorted indices.  The size of `order` must be at least `this%len`. subroutine dvector_sort ( this , order ) class ( dvector_t ), intent ( in out ) :: this integer , dimension (:), intent ( out ), optional :: order integer :: n n = this % len if ( n > 1 ) then if ( present ( order )) then call dqsort ( this % buffer ( 1 : n ), order ) else call dqsort ( this % buffer ( 1 : n )) end if end if end subroutine !****************************************************************************** !> Sorts and removes all duplicate entries of an *ivector*. Note that the internal !! buffer size remains unchanged. To reduce the buffer size, call !! `ivector_shrink_to_fit`. subroutine ivector_unique ( this ) class ( ivector_t ), intent ( in out ) :: this integer , dimension ( this % len ) :: temp integer :: n integer :: i if ( this % len < 2 ) return !Already sorted temp = this % buffer ( 1 : this % len ) call iqsort ( temp ) !The first element is unique by default this % buffer ( 1 ) = temp ( 1 ) n = 1 !Successively copy non-duplicate elements do i = 2 , this % len if ( temp ( i ) /= this % buffer ( n )) then this % buffer ( n + 1 ) = temp ( i ) n = n + 1 end if end do !Set the length to number of unique elements this % len = n end subroutine !****************************************************************************** !> Sorts and removes all duplicate entries of a *dvector*. Note that the internal !! buffer size remains unchanged. To reduce the buffer size, call !! `dvector_shrink_to_fit`. subroutine dvector_unique ( this ) class ( dvector_t ), intent ( in out ) :: this real ( rp ), dimension ( this % len ) :: temp integer :: n integer :: i if ( this % len < 2 ) return !Already sorted temp = this % buffer call dqsort ( temp ) !The first element is unique by default this % buffer ( 1 ) = temp ( 1 ) n = 1 !Successively copy non-duplicate elements do i = 2 , this % len if ( temp ( i ) /= this % buffer ( n )) then this % buffer ( n + 1 ) = temp ( i ) n = n + 1 end if end do !Set the length to number of unique elements this % len = n end subroutine !****************************************************************************** !> Prints an *ivector* subroutine ivector_print ( this ) class ( ivector_t ), intent ( in ) :: this integer :: i do i = 1 , this % len write ( * , '(i0,1x,i0)' ) i , this % buffer ( i ) end do end subroutine !****************************************************************************** !> Prints a *dvector* subroutine dvector_print ( this ) class ( dvector_t ), intent ( in ) :: this integer :: i do i = 1 , this % len write ( * , '(i0,1x,f0.15)' ) i , this % buffer ( i ) end do end subroutine !****************************************************************************** end module m_vector","tags":"","loc":"sourcefile/m_vector.f90.html"},{"title":"m_pairtab.fpp – BROWNPAK","text":"Contents Modules m_pairtab Source Code m_pairtab.fpp Source Code #: include 'asserts.fypp' module m_pairtab use m_precision use m_vector use m_table use m_aabbtree use m_globals use m_cell_list use m_connectivity implicit none private public :: pair_tab public :: pt_init , pt_finish , pt_build type ( itable_t ) :: pair_tab type ( aabbtree_t ) :: tree real ( rp ) :: rskin_sq = 0.0_rp real ( rp ) :: tskin_sq = 0.0_rp real ( rp ), dimension (:,:), allocatable :: coordinates_save !!  (3, *num_atoms*) array real ( rp ), dimension (:,:), allocatable :: coordinates_dr !!  (3, *num_atoms*) array contains !******************************************************************************* subroutine pt_init () !! Performs initial setup for building a pair list. integer :: i !Initialize and build atom -> bond table, stored in the module variable !atbo_tab in module m_connectivity. The atom -> bond table is required for !building the table for excluded atoms. call atbo_build () !Build excluded atoms table, stored in the module variable exat_tab in !module m_connectivity. call exat_build () !Delete atom -> bond table, it is no longer needed. call atbo_tab % delete () !Initialize the pair table call itbl_init ( pair_tab , num_atoms ) !The last row of pair_tab will remain empty due to Newton's third law; !this will be used in an assert statement. if ( use_verlet_tab ) then !Setup the verlet scheme rskin_sq = ( rcutoff + tskin ) ** 2 ; tskin_sq = tskin ** 2 allocate ( coordinates_save ( 3 , num_atoms ) ) allocate ( coordinates_dr ( 3 , num_atoms ) ) !Initializing to zero coordinates_save = 0.0_rp coordinates_dr = 0.0_rp else if ( use_aabbtree ) then !Setup an AABB tree and insert the atoms call tree % init ( num_atoms , tskin / rcutoff ) !Insert atoms do i = 1 , num_atoms call tree % insert ( i , coordinates (:, i ), rcutoff ) end do !Build an optimized tree call tree % rebuild () else if ( use_cell_list ) then !Setup a cell list if ( ( sim_style == 0 ) . or . ( sim_style == 1 ) ) then ! For relaxation/BD simulation the cell list is used for short range ! force calculation. call cl_init ( num_atoms , rcutoff ) call cl_set_cell_size ( rcutoff ) call cl_build_cell_nbrs () else if ( sim_style == 2 ) then ! For MPCD simulation the cell list is always used for sorting. If ! use_cell_list == .true., the cell list will also be used for force ! calculation. call cl_init ( num_atoms_tot , 1.0_rp ) !Collision cell size is 1.0. call cl_set_cell_size ( rcutoff ) !Set cell size to global cutoff call cl_build_cell_nbrs () end if else !Perform a direct N&#94;2 calculation rskin_sq = rcutoff ** 2 end if end subroutine !******************************************************************************* subroutine pt_finish () !! Cleanup for pair list calculation. if ( use_verlet_tab ) then if ( allocated ( coordinates_save )) deallocate ( coordinates_save ) if ( allocated ( coordinates_dr ) ) deallocate ( coordinates_dr ) rskin_sq = 0.0_rp ; tskin_sq = 0.0_rp else if ( use_aabbtree ) then call tree % delete () else if ( use_cell_list ) then call cl_delete () end if call pair_tab % delete () call exat_tab % delete () end subroutine !******************************************************************************* subroutine pt_build () !! Builds a pair table. The resulting table is stored in the module variable !! `pair_tab`. if ( use_verlet_tab ) then call build_pt_verlet () else if ( use_aabbtree ) then call build_pt_aabbtree () else if ( use_cell_list ) then call build_pt_cell_list () else call build_pt_n2 () end if end subroutine !****************************************************************************** subroutine build_pt_n2 () !! Builds a pair table using direct N&#94;2 looping over all pairs. integer , dimension (:), pointer :: pnbrs => null () real ( rp ), dimension ( 3 ) :: ri real ( rp ), dimension ( 3 ) :: rj real ( rp ), dimension ( 3 ) :: rij real ( rp ) :: rij_sq integer :: i , j !Clear out the pair table call pair_tab % clear () !Loop over all pairs to build list do i = 1 , num_atoms - 1 ri = coordinates (:, i ) do j = i + 1 , num_atoms !Check if atom j is an excluded atom for atom i if ( exat_tab % is_in ( i , j ) ) cycle rj = coordinates (:, j ) rij = rj - ri if ( imcon /= 0 ) call simbox % get_image ( rij ) rij_sq = sum ( rij ** 2 ) if ( rij_sq < rskin_sq ) call pair_tab % append ( i , j ) end do end do call pair_tab % get_row ( num_atoms , pnbrs ) @ : ASSERT ( size ( pnbrs ) == 0 ) !Release additional memory call pair_tab % shrink_to_fit () end subroutine !****************************************************************************** subroutine build_pt_verlet () !! Builds a pair table using the Verlet scheme. integer , dimension (:), pointer :: pnbrs => null () real ( rp ), dimension ( 3 ) :: ri real ( rp ), dimension ( 3 ) :: rj real ( rp ), dimension ( 3 ) :: rij real ( rp ) :: dr_sq_max real ( rp ) :: rij_sq logical , save :: first_call = . true . integer :: i , j !On first call no check for rebuilding if (. not . first_call ) then !Check whether rebuilding the list is necessary coordinates_dr = coordinates (:, 1 : num_atoms ) - coordinates_save if ( imcon /= 0 ) then do i = 1 , num_atoms call simbox % get_image ( coordinates_dr (:, i )) end do end if dr_sq_max = maxval ( sum ( coordinates_dr ** 2 , dim = 1 )) if ( 4 * dr_sq_max < tskin_sq ) return end if first_call = . false . !Clear out the pair table call pair_tab % clear () !Loop over all pairs to build list do i = 1 , num_atoms - 1 ri = coordinates (:, i ) do j = i + 1 , num_atoms !Check if atom j is an excluded atom for atom i if ( exat_tab % is_in ( i , j ) ) cycle rj = coordinates (:, j ) rij = rj - ri if ( imcon /= 0 ) call simbox % get_image ( rij ) rij_sq = sum ( rij ** 2 ) if ( rij_sq < rskin_sq ) call pair_tab % append ( i , j ) end do end do call pair_tab % get_row ( num_atoms , pnbrs ) @ : ASSERT ( size ( pnbrs ) == 0 ) !Release additional memory call pair_tab % shrink_to_fit () !Back up positions coordinates_save = coordinates end subroutine !******************************************************************************* subroutine build_pt_aabbtree () type ( ivector_t ) :: nbrs integer , dimension (:), pointer :: pnbrs => null () integer :: ia , inbr , ia_nbr logical :: lstat !Clear out the pair table call pair_tab % clear () !Update the AABB tree with current atom positions !do ia = 1, num_atoms !    call tree%update(ia, coordinates(:,ia), rcutoff, lstat) !end do !Insert atoms do ia = 1 , num_atoms call tree % insert ( ia , coordinates (:, ia ), rcutoff ) end do !Loop over all atoms to find neighbors and insert into pair_tab. call ivector_init ( nbrs ) do ia = 1 , num_atoms call tree % query ( ia , nbrs ) call nbrs % sort () call nbrs % get_data ( pnbrs ) do inbr = 1 , size ( pnbrs ) ia_nbr = pnbrs ( inbr ) !Check if atom ia_nbr is an excluded atom for atom ia if ( exat_tab % is_in ( ia , ia_nbr ) ) cycle if (. not . pair_tab % is_in ( ia_nbr , ia )) then call pair_tab % append ( ia , ia_nbr ) end if end do end do call pair_tab % get_row ( num_atoms , pnbrs ) @ : ASSERT ( size ( pnbrs ) == 0 ) call nbrs % delete () !Release additional memory call pair_tab % shrink_to_fit () end subroutine !****************************************************************************** subroutine build_pt_cell_list () !! Builds a pair table using cell list. type ( ivector_t ), dimension (:), allocatable :: ptaov !Pair table as an array of vectors. integer , dimension (:), pointer :: aic => null () integer , dimension (:), pointer :: ainc => null () integer , dimension (:), pointer :: nbr_cells => null () integer , dimension (:), pointer :: pnbrs => null () integer :: num_cells integer :: icell , jcell , iatm , jatm integer :: i , j , k !Clear out the pair table call pair_tab % clear () !Initialize ptaov allocate ( ptaov ( num_atoms )) do i = 1 , size ( ptaov ) call ivector_init ( ptaov ( i )) end do call cl_build ( coordinates ) num_cells = cl_get_num_cells () do icell = 0 , ( num_cells - 1 ) call cl_get_contents ( icell , aic ) call cl_get_nbr_cells ( icell , nbr_cells ) !Interaction with particles within the cell do i = 1 , size ( aic ) - 1 iatm = aic ( i ) do j = i + 1 , size ( aic ) jatm = aic ( j ) !Check if atom jatm is an excluded atom for atom iatm if ( exat_tab % is_in ( iatm , jatm ) ) cycle call ptaov ( iatm )% append ( jatm ) end do end do !Interaction with particles belonging to neighboring cells do i = 1 , size ( aic ) iatm = aic ( i ) do j = 1 , size ( nbr_cells ) jcell = nbr_cells ( j ) call cl_get_contents ( jcell , ainc ) do k = 1 , size ( ainc ) jatm = ainc ( k ) !Check if atom jatm is an excluded atom for atom iatm if ( exat_tab % is_in ( iatm , jatm ) ) cycle call ptaov ( iatm )% append ( jatm ) end do end do end do end do !Copy the entries in ptaov to pair_tab do iatm = 1 , num_atoms call ptaov ( iatm )% get_data ( pnbrs ) do j = 1 , size ( pnbrs ) call pair_tab % append ( iatm , pnbrs ( j )) end do end do call pair_tab % get_row ( num_atoms , pnbrs ) @ : ASSERT ( size ( pnbrs ) == 0 ) !Release additional memory call pair_tab % shrink_to_fit () do i = 1 , size ( ptaov ) call ptaov ( i )% delete () end do deallocate ( ptaov ) end subroutine !******************************************************************************* end module m_pairtab","tags":"","loc":"sourcefile/m_pairtab.fpp.html"},{"title":"m_ia_dihedral.f90 – BROWNPAK","text":"Contents Modules m_ia_dihedral Source Code m_ia_dihedral.f90 Source Code module m_ia_dihedral !! Dihedral potentials (none implemented) use m_precision use m_constants_math use m_globals implicit none private public :: ia_dihedral_setup , ia_get_dihedral_force contains !****************************************************************************** subroutine ia_dihedral_setup () !! Sets up parameters for dihedral potentials integer :: i integer :: sty !Set dihedral interactions do i = 1 , num_dihedral_types sty = dihedral_styles ( i ) select case ( sty ) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_dihedral_force ( q1 , q2 , q3 , typ , enrg , fi , fj , fk , fl ) !! Calculates the force & energy due to a dihedral. real ( rp ), dimension ( 3 ), intent ( in ) :: q1 real ( rp ), dimension ( 3 ), intent ( in ) :: q2 real ( rp ), dimension ( 3 ), intent ( in ) :: q3 real ( rp ), dimension ( 3 ), intent ( out ) :: fi real ( rp ), dimension ( 3 ), intent ( out ) :: fj real ( rp ), dimension ( 3 ), intent ( out ) :: fk real ( rp ), dimension ( 3 ), intent ( out ) :: fl integer , intent ( in ) :: typ real ( rp ), intent ( out ) :: enrg integer :: dhd_styl enrg = 0.0_rp fi = 0.0_rp ; fj = 0.0_rp ; fk = 0.0_rp ; fl = 0.0_rp dhd_styl = dihedral_styles ( typ ) select case ( dhd_styl ) case default continue end select end subroutine !****************************************************************************** end module m_ia_dihedral","tags":"","loc":"sourcefile/m_ia_dihedral.f90.html"},{"title":"m_stats_io.f90 – BROWNPAK","text":"Contents Modules m_stats_io Source Code m_stats_io.f90 Source Code module m_stats_io !! Computes and writes properties calculated during simulation. use m_precision use m_constants_math use m_strings use m_globals implicit none private public :: stats_init , stats_finish , stats_write integer :: fu_stats !! Unit number of file `fn_stats`. real ( rp ), dimension ( 3 ) :: span !! Span of a chain molecule. For multiple molecules this is averaged. real ( rp ) :: reedsq !! Mean squared end-to-end distance of a linear chain molecule. !! For multiple molecules this is averaged. Not defined for rings. real ( rp ) :: rgsq !! Mean squared gyration radius of a chain/ring molecule. !! For multiple molecules this is averaged. real ( rp ), dimension ( 3 ) :: reev !! End-to-end vector. Not defined for rings. real ( rp ) :: asph !! Asphericity of the entire molecule real ( rp ) :: prol !! Prolateness of the entire molecule real ( rp ) :: rgsq_bbone !! Mean squared gyration radius of the backbone of a branched !! chain/ring molecule. real ( rp ) :: rgsq_sc !! Mean squared gyration radius of the side chains of a branched !! chain/ring molecule. real ( rp ) :: reedsq_sc !! Mean squared end-to-end distance of the side chains of a branched !! chain/ring molecule. real ( rp ) :: asph_sc !! Mean asphericity of the side chains of a branched chain/ring molecule. real ( rp ) :: prol_sc !! Mean prolateness of the side chains of a branched chain/ring molecule. real ( rp ), dimension (:,:), allocatable :: molbuf !! Buffer for the largest molecule in the system contains !****************************************************************************** subroutine stats_init () !! Set up for stats collection logical :: lexists integer :: n if ( lrevive ) then !Restarting simulation !Check if file exists inquire ( file = fn_stats // trim ( adjustl ( job_tag )), exist = lexists ) if ( lexists ) then !Open existing file for appending statistics open ( newunit = fu_stats , file = fn_stats // trim ( adjustl ( job_tag )), & action = 'write' , position = 'append' , status = 'old' ) else !Open new file for writing statistics open ( newunit = fu_stats , file = fn_stats // trim ( adjustl ( job_tag )), & action = 'write' , status = 'new' ) !Write header call stats_write_hdr () end if else !New simulation !Open file for writing production (or relaxation) statistics open ( newunit = fu_stats , file = fn_stats // trim ( adjustl ( job_tag )), & action = 'write' , status = 'replace' ) !Write header call stats_write_hdr () end if !Allocate space for unwrapping molecule under PBC if ( ( imcon /= 0 ) . and . ( num_molecules > 0 ) ) then n = maxval ( molecules ( 2 ,:)) if ( n > 1 ) allocate ( molbuf ( 3 , n ) ) end if end subroutine !****************************************************************************** subroutine stats_finish () !! Closes any files opened in `stats_init`. integer :: fu logical :: lopened inquire ( file = fn_stats // trim ( adjustl ( job_tag )), number = fu , & opened = lopened ) if ( lopened ) close ( fu ) if ( allocated ( molbuf )) deallocate ( molbuf ) end subroutine !****************************************************************************** subroutine stats_write_hdr () !! Driver for writing header of file `fn_stats`. This is called only after !! appropriate files have been opened. write ( fu_stats , '(a12)' , advance = 'no' ) 'nts' if ( num_bonds > 0 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) & 'bndlen_avg' , 'bndlen_min' , 'bndlen_max' , 'energy_bond' end if if ( num_angles > 0 ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_angle' end if if ( num_dihedrals > 0 ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_dihedral' end if if ( lvdw ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_vdw' end if if ( num_tethers > 0 ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_tether' end if if ( num_externals > 0 ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_external' end if if ( sim_style == 2 ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_kin' end if write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_tot' !No further properties will be calculated for structure relaxation if ( sim_style == 0 ) then write ( fu_stats , * ) return end if !Stress (written only during production run) if ( num_atoms > 0 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'sxx' , 'syx' , 'szx' , & 'sxy' , 'syy' , 'szy' , 'sxz' , 'syz' , 'szz' end if if ( sim_style == 2 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'slv_sxx' , 'slv_syx' , 'slv_szx' , & 'slv_sxy' , 'slv_syy' , 'slv_szy' , 'slv_sxz' , 'slv_syz' , 'slv_szz' end if !Structural properties: Size (for multiple molecules these will be !averaged quantities) if ( num_bonds > 0 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'reedsq' , 'rgsq' , & 'spanx' , 'spany' , 'spanz' end if !Further structural properties (for single molecule) if ( ( imcon == 0 ) . and . ( num_bonds > 0 ) ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'reevx' , 'reevy' , & 'reevz' , 'asph' , 'prol' if ( num_branches > 0 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'rgsq_bbone' , & 'rgsq_sc' , 'reedsq_sc' , 'asph_sc' , 'prol_sc' end if if ( flow_style == 0 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'comx' , 'comy' , 'comz' end if end if write ( fu_stats , * ) end subroutine !****************************************************************************** subroutine stats_write () !! Writing statistics write ( fu_stats , '(i12)' , advance = 'no' ) nts if ( num_bonds > 0 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) & bndlen , bndlen_min , bndlen_max , energy_bond end if if ( num_angles > 0 ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_angle end if if ( num_dihedrals > 0 ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_dihedral end if if ( lvdw ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_vdw end if if ( num_tethers > 0 ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_tether end if if ( num_externals > 0 ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_external end if if ( sim_style == 2 ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_kin end if write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_tot !No further properties will be calculated for structure relaxation if ( sim_style == 0 ) then write ( fu_stats , * ) return end if !Stress (calculated only during production run) if ( num_atoms > 0 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) stress_accu end if if ( sim_style == 2 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) stress_slvnt end if !Structural properties: Size (for multiple molecules these will be !averaged quantities) if ( imcon == 0 ) then call stats_compute_ic0 () else call stats_compute_ic1 () end if if ( num_bonds > 0 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) reedsq , rgsq , span end if !Further structural properties (for single molecule in unbounded domain) if ( ( imcon == 0 ) . and . ( num_bonds > 0 ) ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) reev , asph , prol if ( num_branches > 0 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) rgsq_bbone , & rgsq_sc , reedsq_sc , asph_sc , prol_sc end if if ( flow_style == 0 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) molecule_com end if end if write ( fu_stats , * ) end subroutine !****************************************************************************** subroutine stats_compute_ic1 () !! Computes statistics for a possibly multiple chains in a periodic domain. real ( rp ), dimension ( 3 ) :: com real ( rp ) :: rgsq_im integer :: natm , nmol integer :: i , imol , ibeg rgsq = 0.0_rp ; reedsq = 0.0_rp ; span = 0.0_rp do imol = 1 , num_molecules natm = molecules ( 2 , imol ) if ( natm > 1 ) then molbuf = 0.0_rp ibeg = molecules ( 3 , imol ) do i = 1 , natm molbuf (:, i ) = coordinates (:, ibeg + i - 1 ) end do do i = 1 , natm molbuf (:, i ) = molbuf (:, i ) - molbuf (:, 1 ) call simbox % get_image ( molbuf (:, i )) end do span = span + maxval ( molbuf (:, 1 : natm ), 2 ) - minval ( molbuf (:, 1 : natm ), 2 ) reev = molbuf (:, natm ) reedsq = reedsq + sum ( reev ** 2 ) rgsq_im = 0.0_rp com = sum ( molbuf (:, 1 : natm ), 2 ) / natm do i = 1 , natm rgsq_im = rgsq_im + sum (( molbuf (:, i ) - com ) ** 2 ) end do rgsq = rgsq + rgsq_im / natm end if end do nmol = count ( molecules ( 2 ,:) > 1 ) span = span / nmol ; reedsq = reedsq / nmol ; rgsq = rgsq / nmol end subroutine !****************************************************************************** subroutine stats_compute_ic0 () !! Computes statistics for a single chain in unbounded domain. real ( rp ), dimension ( 3 ) :: gt_ev , gt_ev_sc , gt_ev_isc real ( rp ), dimension ( 3 , 3 ) :: S real ( rp ), dimension ( 3 ) :: ri real ( rp ), dimension ( 3 ) :: com , com_bbone , com_sc real ( rp ), dimension ( 3 ) :: r_tp real ( rp ) :: rgsq_isc , asph_isc , prol_isc integer :: n_sc integer :: na_bbone integer :: na_sc integer :: ibr , ia_beg , ia_end integer :: i !Number of backbone atoms if ( num_branches == 0 ) then na_bbone = num_atoms n_sc = 0 !Number of side chains else na_bbone = branches ( 2 , 1 ) n_sc = num_branches - 1 !Number of side chains end if !Zero out span = 0.0_rp ; rgsq = 0.0_rp ; reedsq = 0.0_rp asph = 0.0_rp ; prol = 0.0_rp rgsq_bbone = 0.0_rp rgsq_sc = 0.0_rp ; reedsq_sc = 0.0_rp ; asph_sc = 0.0_rp ; prol_sc = 0.0_rp gt_ev = 0.0_rp ; gt_ev_sc = 0.0_rp ; S = 0.0_rp ; reev = 0.0_rp span = maxval ( coordinates , 2 ) - minval ( coordinates , 2 ) reev = coordinates (:, na_bbone ) - coordinates (:, 1 ) reedsq = reev ( 1 ) * reev ( 1 ) + reev ( 2 ) * reev ( 2 ) + reev ( 3 ) * reev ( 3 ) com = sum ( coordinates , 2 ) / num_atoms do i = 1 , num_atoms ri = coordinates (:, i ) - com S ( 1 , 1 ) = S ( 1 , 1 ) + ri ( 1 ) * ri ( 1 ) S ( 1 , 2 ) = S ( 1 , 2 ) + ri ( 1 ) * ri ( 2 ) S ( 1 , 3 ) = S ( 1 , 3 ) + ri ( 1 ) * ri ( 3 ) S ( 2 , 2 ) = S ( 2 , 2 ) + ri ( 2 ) * ri ( 2 ) S ( 2 , 3 ) = S ( 2 , 3 ) + ri ( 2 ) * ri ( 3 ) S ( 3 , 3 ) = S ( 3 , 3 ) + ri ( 3 ) * ri ( 3 ) end do S = S / num_atoms rgsq = S ( 1 , 1 ) + S ( 2 , 2 ) + S ( 3 , 3 ) call dsyevc3 ( S , gt_ev ) call calc_shape ( gt_ev ( 1 ), gt_ev ( 3 ), gt_ev ( 2 ), asph , prol ) com_bbone = sum ( coordinates (:, 1 : na_bbone ), 2 ) / na_bbone do i = 1 , na_bbone rgsq_bbone = rgsq_bbone + sum (( coordinates (:, i ) - com_bbone ) ** 2 ) end do rgsq_bbone = rgsq_bbone / na_bbone do ibr = 2 , num_branches ia_beg = branches ( 3 , ibr ) ia_end = ia_beg + branches ( 2 , ibr ) - 1 r_tp = coordinates (:, branches ( 1 , ibr )) !Add end-to-end distance squared of this side chain reedsq_sc = reedsq_sc + sum (( coordinates (:, ia_end ) - r_tp ) ** 2 ) !Number of side chain atoms. Adding 1 for the tether point na_sc = branches ( 2 , ibr ) + 1 !Get side chain c.o.m. com_sc = r_tp + sum ( coordinates (:, ia_beg : ia_end ), 2 ) com_sc = com_sc / na_sc !Get radius of gyration squared of this side chain S = 0.0_rp ri = r_tp - com_sc S ( 1 , 1 ) = S ( 1 , 1 ) + ri ( 1 ) * ri ( 1 ) S ( 1 , 2 ) = S ( 1 , 2 ) + ri ( 1 ) * ri ( 2 ) S ( 1 , 3 ) = S ( 1 , 3 ) + ri ( 1 ) * ri ( 3 ) S ( 2 , 2 ) = S ( 2 , 2 ) + ri ( 2 ) * ri ( 2 ) S ( 2 , 3 ) = S ( 2 , 3 ) + ri ( 2 ) * ri ( 3 ) S ( 3 , 3 ) = S ( 3 , 3 ) + ri ( 3 ) * ri ( 3 ) do i = ia_beg , ia_end ri = coordinates (:, i ) - com_sc S ( 1 , 1 ) = S ( 1 , 1 ) + ri ( 1 ) * ri ( 1 ) S ( 1 , 2 ) = S ( 1 , 2 ) + ri ( 1 ) * ri ( 2 ) S ( 1 , 3 ) = S ( 1 , 3 ) + ri ( 1 ) * ri ( 3 ) S ( 2 , 2 ) = S ( 2 , 2 ) + ri ( 2 ) * ri ( 2 ) S ( 2 , 3 ) = S ( 2 , 3 ) + ri ( 2 ) * ri ( 3 ) S ( 3 , 3 ) = S ( 3 , 3 ) + ri ( 3 ) * ri ( 3 ) end do S = S / na_sc rgsq_isc = S ( 1 , 1 ) + S ( 2 , 2 ) + S ( 3 , 3 ) call dsyevc3 ( S , gt_ev_isc ) !Note: gt_ev(2) and gt_ev(3) are flipped so that the three eigen values are !in descending order call calc_shape ( gt_ev_isc ( 1 ), gt_ev_isc ( 3 ), gt_ev_isc ( 2 ), & asph_isc , prol_isc ) !Add radius of gyration, etc. of this side chain rgsq_sc = rgsq_sc + rgsq_isc gt_ev_sc = gt_ev_sc + gt_ev_isc asph_sc = asph_sc + asph_isc prol_sc = prol_sc + prol_isc end do if ( n_sc > 0 ) then rgsq_sc = rgsq_sc / n_sc reedsq_sc = reedsq_sc / n_sc gt_ev_sc = gt_ev_sc / n_sc asph_sc = asph_sc / n_sc prol_sc = prol_sc / n_sc end if end subroutine !****************************************************************************** subroutine calc_shape ( ev1 , ev2 , ev3 , asph , prol ) !! Given three eigen values of the gyration tensor, calculates asphericity !! and prolateness. Note that ev1 >= ev2 >= ev3. real ( rp ), intent ( in ) :: ev1 real ( rp ), intent ( in ) :: ev2 real ( rp ), intent ( in ) :: ev3 real ( rp ), intent ( out ) :: asph real ( rp ), intent ( out ) :: prol real ( rp ) :: rgsq real ( rp ) :: ev_av , ev1mav , ev2mav , ev3mav , evmav_sumsq rgsq = ev1 + ev2 + ev3 ev_av = rgsq * math_third ev1mav = ev1 - ev_av ev2mav = ev2 - ev_av ev3mav = ev3 - ev_av evmav_sumsq = ev1mav ** 2 + ev2mav ** 2 + ev3mav ** 2 asph = 1.5_rp * evmav_sumsq / ( rgsq * rgsq ) prol = 4 * ( ev1mav * ev2mav * ev3mav ) / (( 2 * math_third ) * evmav_sumsq ) ** 1.5 end subroutine !****************************************************************************** subroutine dsyevc3 ( a , w ) !! Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's !! analytical algorithm. !! Only the diagonal and upper triangular parts of A are accessed. The access !! is read-only. !! !! Copyright (C) 2006  Joachim Kopp ! ---------------------------------------------------------------------------- ! Parameters: !   A: The symmetric input matrix !   W: Storage buffer for eigenvalues ! ---------------------------------------------------------------------------- ! .. Arguments .. REAL ( RP ), DIMENSION ( 3 , 3 ), INTENT ( IN ) :: A REAL ( RP ), DIMENSION ( 3 ), INTENT ( OUT ) :: W ( 3 ) !.. Local Variables .. REAL ( RP ) :: M , C1 , C0 REAL ( RP ) :: DE , DD , EE , FF REAL ( RP ) :: P , SQRTP , Q , C , S , PHI !Determine coefficients of characteristic poynomial. We write !      | A   D   F  | ! A =  | D*  B   E  | !      | F*  E*  C  | DE = A ( 1 , 2 ) * A ( 2 , 3 ) DD = A ( 1 , 2 ) ** 2 EE = A ( 2 , 3 ) ** 2 FF = A ( 1 , 3 ) ** 2 M = A ( 1 , 1 ) + A ( 2 , 2 ) + A ( 3 , 3 ) C1 = ( A ( 1 , 1 ) * A ( 2 , 2 ) + A ( 1 , 1 ) * A ( 3 , 3 ) + A ( 2 , 2 ) * A ( 3 , 3 ) ) & - ( DD + EE + FF ) C0 = A ( 3 , 3 ) * DD + A ( 1 , 1 ) * EE + A ( 2 , 2 ) * FF - A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) & - 2.0_RP * A ( 1 , 3 ) * DE P = M ** 2 - 3.0_RP * C1 Q = M * ( P - ( 3.0_RP / 2.0_RP ) * C1 ) - ( 2 7.0_RP / 2.0_RP ) * C0 SQRTP = SQRT ( ABS ( P )) PHI = 2 7.0_RP * ( 0.25_RP * C1 ** 2 * ( P - C1 ) & + C0 * ( Q + ( 2 7.0_RP / 4.0_RP ) * C0 ) ) PHI = ( 1.0_RP / 3.0_RP ) * ATAN2 ( SQRT ( ABS ( PHI )), Q ) C = SQRTP * COS ( PHI ) S = ( 1.0_RP / MATH_SQRT3 ) * SQRTP * SIN ( PHI ) W ( 2 ) = ( 1.0_RP / 3.0_RP ) * ( M - C ) W ( 3 ) = W ( 2 ) + S W ( 1 ) = W ( 2 ) + C W ( 2 ) = W ( 2 ) - S END SUBROUTINE !****************************************************************************** end module m_stats_io","tags":"","loc":"sourcefile/m_stats_io.f90.html"},{"title":"m_aabb.fpp – BROWNPAK","text":"Contents Modules m_aabb Source Code m_aabb.fpp Source Code #:include 'asserts.fypp' module m_aabb use m_precision use m_strings implicit none type aabb_t real ( rp ), dimension ( 3 ) :: lbnd real ( rp ), dimension ( 3 ) :: ubnd real ( rp ), dimension ( 3 ) :: center real ( rp ) :: srfarea contains procedure :: init => aabb_init procedure :: print => aabb_print procedure :: clear => aabb_clear procedure :: get_extent => aabb_get_extent procedure :: update => aabb_update procedure :: fatten => aabb_fatten procedure :: includes => aabb_includes procedure :: overlaps => aabb_overlaps procedure , private :: calc_center => aabb_calc_center procedure , private :: calc_srfarea => aabb_calc_srfarea end type aabb_t interface operator ( + ) module procedure :: aabb_union end interface contains !******************************************************************************* subroutine aabb_init ( this , lbnd , ubnd ) !! Creates an *aabb_t* instance from lower and upper bounds. class ( aabb_t ), intent ( out ) :: this !! An *aabb_t* instance. real ( rp ), dimension ( 3 ), intent ( in ) :: lbnd !! Lower bound real ( rp ), dimension ( 3 ), intent ( in ) :: ubnd !! Upper bound @ : ASSERT ( all ( lbnd <= ubnd )) this % lbnd = lbnd ; this % ubnd = ubnd call this % calc_center () call this % calc_srfarea () end subroutine !******************************************************************************* subroutine aabb_print ( this , frmt , str ) !! Prints an AABB. class ( aabb_t ), intent ( in ) :: this !! An *aabb_t* instance. character ( len =* ), intent ( in ), optional :: frmt !! Fortran-style format string for a real number. Default: *(g0.6)*. character ( len = :), allocatable , intent ( out ), optional :: str !! If present, the output is printed to this string instead of STDOUT. character ( len = :), allocatable :: frmt_ , buf frmt_ = '(g0.6)' if ( present ( frmt )) frmt_ = trim ( adjustl ( frmt )) buf = 'lbnd: [' // str_from_num ( this % lbnd ( 1 ), frmt_ ) // ', ' & & // str_from_num ( this % lbnd ( 2 ), frmt_ ) // ', ' & & // str_from_num ( this % lbnd ( 3 ), frmt_ ) // ']' buf = buf // ', ubnd: [' // str_from_num ( this % ubnd ( 1 ), frmt_ ) // ', ' & & // str_from_num ( this % ubnd ( 2 ), frmt_ ) // ', ' & & // str_from_num ( this % ubnd ( 3 ), frmt_ ) // ']' buf = buf // ', center: [' // str_from_num ( this % center ( 1 ), frmt_ ) // ', ' & & // str_from_num ( this % center ( 2 ), frmt_ ) // ', ' & & // str_from_num ( this % center ( 3 ), frmt_ ) // ']' buf = buf // ', srfarea: ' // str_from_num ( this % srfarea , frmt_ ) if ( present ( str )) then str = buf else write ( * , * ) buf end if end subroutine !******************************************************************************* subroutine aabb_clear ( this ) !! Clears all attributes of an AABB and sets them to zero. class ( aabb_t ), intent ( in out ) :: this !! An *aabb_t* instance. this % lbnd = 0.0_rp ; this % ubnd = 0.0_rp this % center = 0.0_rp ; this % srfarea = 0.0_rp end subroutine !******************************************************************************* subroutine aabb_get_extent ( this , extent ) !! Calculates the extent of an *aabb*. The *extent* of an AABB is defined as !! the difference between its upper and lower bounds. class ( aabb_t ), intent ( in ) :: this !! An *aabb_t* instance. real ( rp ), dimension ( 3 ), intent ( out ) :: extent !! Extent of an AABB. extent = this % ubnd - this % lbnd end subroutine !******************************************************************************* subroutine aabb_update ( this , lbnd , ubnd ) !! Updates an AABB with new bounds. class ( aabb_t ), intent ( in out ) :: this !! An *aabb_t* instance. real ( rp ), dimension ( 3 ), intent ( in ), optional :: lbnd !! Lower bound real ( rp ), dimension ( 3 ), intent ( in ), optional :: ubnd !! Upper bound !Nothing to do if no bounds are present if ( (. not . present ( lbnd )) . and . (. not . present ( ubnd )) ) return !Update bounds based on input if ( present ( lbnd )) this % lbnd = lbnd if ( present ( ubnd )) this % ubnd = ubnd @ : ASSERT ( all ( this % lbnd <= this % ubnd ) ) call this % calc_center () call this % calc_srfarea () end subroutine !******************************************************************************* subroutine aabb_fatten ( this , frac ) !! Fattens an AABB by a fraction of its base extent. class ( aabb_t ), intent ( in out ) :: this !! An *aabb_t* instance. real ( rp ), intent ( in ) :: frac !! Fraction of AABB base extent. real ( rp ), dimension ( 3 ) :: extent extent = this % ubnd - this % lbnd !New bounds this % lbnd = this % lbnd - frac * extent ; this % ubnd = this % ubnd + frac * extent @ : ASSERT ( all ( this % lbnd <= this % ubnd ) ) call this % calc_center () call this % calc_srfarea () end subroutine !******************************************************************************* function aabb_includes ( this , other ) result ( res ) !! Returns *true* if *this* includes *other*, *false* otherwise. Inclusion !! is considered in a strict sense. class ( aabb_t ), intent ( in ) :: this !! An *aabb_t* instance. type ( aabb_t ), intent ( in ) :: other !! An *aabb_t* instance. logical :: res res = ( all ( this % lbnd < other % lbnd ) . and . all ( this % ubnd > other % ubnd ) ) end function !******************************************************************************* function aabb_overlaps ( this , other ) result ( res ) !! Returns *true* if *this* overlaps *other*, *false* otherwise. Touching !! does not count as an overlap. class ( aabb_t ), intent ( in ) :: this !! An *aabb_t* instance. type ( aabb_t ), intent ( in ) :: other !! An *aabb_t* instance. logical :: res res = ( all ( this % ubnd > other % lbnd ) . and . all ( other % ubnd > this % lbnd ) ) end function !******************************************************************************* function aabb_union ( x , y ) result ( z ) !! Combines AABBs *x* and *y* to return a new AABB *z*. type ( aabb_t ), intent ( in ) :: x !! An *aabb_t* instance. type ( aabb_t ), intent ( in ) :: y !! An *aabb_t* instance. type ( aabb_t ) :: z z % lbnd = merge ( x % lbnd , y % lbnd , ( x % lbnd < y % lbnd ) ) z % ubnd = merge ( x % ubnd , y % ubnd , ( x % ubnd > y % ubnd ) ) call z % calc_center () call z % calc_srfarea () end function !******************************************************************************* subroutine aabb_calc_center ( this ) !! Calculates the center of an *aabb*. class ( aabb_t ), intent ( in out ) :: this !! An *aabb_t* instance. this % center = 0.5_rp * ( this % ubnd + this % lbnd ) end subroutine !******************************************************************************* subroutine aabb_calc_srfarea ( this ) !! Calculates the surface area of an *aabb*. class ( aabb_t ), intent ( in out ) :: this !! An *aabb_t* instance. real ( rp ) :: dx , dy , dz dx = this % ubnd ( 1 ) - this % lbnd ( 1 ) dy = this % ubnd ( 2 ) - this % lbnd ( 2 ) dz = this % ubnd ( 3 ) - this % lbnd ( 3 ) this % srfarea = 2.0_rp * ( dx * dy + dx * dz + dy * dz ) end subroutine !******************************************************************************* end module m_aabb","tags":"","loc":"sourcefile/m_aabb.fpp.html"},{"title":"m_table.f90 – BROWNPAK","text":"Contents Modules m_table Source Code m_table.f90 Source Code module m_table !! Implements a table with contiguously stored rows. use m_precision use m_vector implicit none private public :: itable_t public :: itbl_init type itable_t integer :: num_rows = 0 !Must be > 0 type ( ivector_t ) :: buffer integer , dimension (:), allocatable :: row_indx contains procedure :: delete => itbl_delete procedure :: clear => itbl_clear procedure :: append => itbl_append procedure :: set_val => itbl_set_val procedure :: is_in => itbl_is_in procedure :: get_val => itbl_get_val procedure :: get_row => itbl_get_row procedure :: shrink_to_fit => itbl_shrink_to_fit procedure :: print => itbl_print end type itable_t contains !****************************************************************************** subroutine itbl_init ( this , num_rows , ierr ) !! Creates an empty *itable_t* with *num_rows* rows and all rows having !! zero elements. type ( itable_t ), intent ( in out ) :: this integer , intent ( in ) :: num_rows !! Must be > 0 integer , intent ( out ), optional :: ierr integer :: istat if ( present ( ierr )) ierr = 0 !Set initial size guess to be num_rows call ivector_init ( this % buffer , num_rows ) allocate ( this % row_indx ( num_rows + 1 ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for this%row_indx of size' , num_rows if ( present ( ierr )) ierr = 1 return end if !Set the number of rows this % num_rows = num_rows !Empty table: All rows have zero elements this % row_indx = 1 end subroutine !****************************************************************************** subroutine itbl_delete ( this ) !! Deletes an *itable_t*. No access is allowed to this object after this call. class ( itable_t ), intent ( in out ) :: this call this % buffer % delete () if ( allocated ( this % row_indx )) deallocate ( this % row_indx ) this % num_rows = 0 end subroutine !****************************************************************************** subroutine itbl_clear ( this ) !! Clears all rows. Does not deallocate memory. class ( itable_t ), intent ( in out ) :: this call this % buffer % clear () this % row_indx = 1 end subroutine !****************************************************************************** subroutine itbl_append ( this , irow , val ) !! Appends an element `val` to row *irow*. class ( itable_t ), intent ( in out ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: val call this % buffer % append ( val ) this % row_indx ( irow + 1 :) = this % row_indx ( irow + 1 :) + 1 end subroutine !****************************************************************************** subroutine itbl_set_val ( this , irow , j , val ) !! Sets the value of the *j*th element of row *irow*. class ( itable_t ), intent ( in out ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: j integer , intent ( in ) :: val integer :: k , n n = this % row_indx ( irow + 1 ) - this % row_indx ( irow ) if ( j > n ) then write ( * , * ) 'error: out-of-bounds index ' , j write ( * , * ) 'for row length' , n stop else k = this % row_indx ( irow ) + j - 1 call this % buffer % set_val ( k , val ) end if end subroutine !****************************************************************************** function itbl_is_in ( this , irow , val ) result ( res ) !! Returns .true. if *val* is in row *irow*, .false. otherwise. class ( itable_t ), intent ( in ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: val logical :: res integer :: i res = . false . do i = this % row_indx ( irow ), this % row_indx ( irow + 1 ) - 1 if ( this % buffer % get_val ( i ) == val ) then res = . true . exit end if end do end function !****************************************************************************** function itbl_get_val ( this , irow , j ) result ( res ) !! Returns the *j*th element of row *irow* class ( itable_t ), intent ( in ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: j integer :: res integer :: k , n n = this % row_indx ( irow + 1 ) - this % row_indx ( irow ) if ( j > n ) then write ( * , * ) 'error: out-of-bounds index ' , j write ( * , * ) 'for row length' , n stop else k = this % row_indx ( irow ) + j - 1 res = this % buffer % get_val ( k ) end if end function !****************************************************************************** subroutine itbl_get_row ( this , irow , res ) !! Returns a pointer to the row data of *irow*. No bounds checking is performed. class ( itable_t ), target , intent ( in ) :: this integer , intent ( in ) :: irow integer , dimension (:), pointer , intent ( out ) :: res integer :: ibeg , iend res => null () ibeg = this % row_indx ( irow ) iend = this % row_indx ( irow + 1 ) - 1 call this % buffer % get_data ( res , ibeg , iend ) end subroutine !****************************************************************************** subroutine itbl_shrink_to_fit ( this , ierr ) !! Releases additional memory to fit underlying data. class ( itable_t ), intent ( in out ) :: this integer , intent ( out ), optional :: ierr if ( present ( ierr )) then call this % buffer % shrink_to_fit ( ierr ) else call this % buffer % shrink_to_fit () end if end subroutine !****************************************************************************** subroutine itbl_print ( this ) !! Prints an *itable_t*. class ( itable_t ), intent ( in ) :: this integer :: i , j do i = 1 , this % num_rows write ( * , '(i0,\": \",2x)' , advance = 'no' ) i do j = this % row_indx ( i ), this % row_indx ( i + 1 ) - 1 write ( * , '(i0,2x)' , advance = 'no' ) this % buffer % get_val ( j ) end do write ( * , * ) end do end subroutine !****************************************************************************** end module m_table","tags":"","loc":"sourcefile/m_table.f90.html"},{"title":"m_strings.f90 – BROWNPAK","text":"Contents Modules m_strings Source Code m_strings.f90 Source Code module m_strings !! summary: Routines for string handling !! author:  George Benthien & others !! !! Many of these routines were originally written by !! [George Benthien](https://gbenthien.net/strings/str-index.html), some have !! been written by Sarit Dutta or gathered/modified from other authors (appropriately credited). !! !! These routines were developed primarily to aid in the reading and manipulation !! of input data from an ASCII text file. Accordingly, it is assumed that all !! characters to be processed are ASCII characters. use m_precision implicit none private :: str_from_inum , str_from_ilnum , str_from_dnum interface str_from_num !!  Generic  interface for writing a number to a string. The calling syntax is !!  `str_from_num(num, frmt)` where `number` is a real number or an integer, !!  `format` is the format desired, e.g., *e15.6*, *i5*, etc. module procedure str_from_inum module procedure str_from_ilnum module procedure str_from_dnum end interface str_from_num contains !****************************************************************************** pure function str_is_letter ( str ) result ( res ) !! Returns `.true.` if `str` contains only letters (*a--z* or *A--Z*) and !! `.false.` otherwise. character ( len =* ), intent ( in ) :: str logical :: res character ( len = 1 ) :: ch integer :: i res = . true . do i = 1 , len ( str ) ch = str ( i : i ) select case ( ch ) case ( 'A' : 'Z' ) cycle case ( 'a' : 'z' ) cycle case default res = . false . return end select end do end function !****************************************************************************** pure function str_is_digit ( str ) result ( res ) !! Returns `.true.` if `str` contains only digits (0,1,...,9) and !!`.false.` otherwise. character ( len =* ), intent ( in ) :: str logical :: res character ( len = 1 ) :: ch integer :: i res = . true . do i = 1 , len ( str ) ch = str ( i : i ) select case ( ch ) case ( '0' : '9' ) cycle case default res = . false . return end select end do end function !******************************************************************************* pure function str_is_space ( str ) result ( res ) !! Returns `.true.` if `str` is non-empty and contains only whitespace !! characters (tab or blankspace). Otherwise `.false.` is returned. !! !! *Note*: This function will return `.false.` for an empty string. character ( len =* ), intent ( in ) :: str logical :: res integer :: lenstr integer :: ich integer :: i lenstr = len ( str ) if ( lenstr == 0 ) then res = . false . return end if res = . true . do i = 1 , lenstr ich = iachar ( str ( i : i )) select case ( ich ) case ( 9 , 32 ) res = . true . case default res = . false . return end select end do end function !******************************************************************************* pure function str_is_comment ( line , comment_str ) result ( res ) !!  Returns `.true.` if `line` is a comment, `.false.` other wise. !! !!  `line` is a comment if `comment_str` is its first non-blank character !!  sequence. If `line` is an empty string or contains only blankspaces, the !!  return value is `.false.` If `comment_str` is empty, the return value is !!  `.true.`. character ( len =* ), intent ( in ) :: line !!  Input string character ( len =* ), intent ( in ) :: comment_str !!  String marking the beginning of a comment. logical :: res res = . false . if ( index ( adjustl ( line ), comment_str ) == 1 ) then res = . true . end if end function !******************************************************************************* pure function str_compact ( str ) result ( ostr ) !! Returns a copy of `str` with multiple spaces and tabs converted to !! single spaces, control characters deleted, and leading and trailing !! spaces removed. character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: ostr character ( len = len ( str )) :: buf character ( len = 1 ) :: ch integer :: lenstr integer :: isp , ich integer :: i , k lenstr = len ( str ) isp = 0 ; k = 0 buf = '' do i = 1 , lenstr ch = str ( i : i ) ich = iachar ( ch ) select case ( ich ) case ( 9 , 32 ) ! space or tab character if ( isp == 0 ) then k = k + 1 buf ( k : k ) = ' ' end if isp = 1 case ( 33 :) ! not a space, quote, or control character k = k + 1 buf ( k : k ) = ch isp = 0 end select end do ostr = trim ( adjustl ( buf )) end function !****************************************************************************** pure function str_remove_stcc ( str ) result ( ostr ) !! Returns a copy of the string `str` with spaces, tabs, and !! control characters removed. character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: ostr character ( len = len ( str )) :: buf character ( len = 1 ) :: ch integer :: lenstr integer :: ich integer :: k integer :: i lenstr = len ( str ) k = 0 do i = 1 , lenstr ch = str ( i : i ) ich = iachar ( ch ) select case ( ich ) case ( 0 : 32 ) ! space, tab, or control character cycle case ( 33 :) k = k + 1 buf ( k : k ) = ch end select end do ostr = trim ( adjustl ( buf )) end function !****************************************************************************** pure function str_to_upper ( str ) result ( ucstr ) !!  This function returns a string that is like the string `str` with all characters !!  that are not between a pair of quotes (\"...\" or '...') converted to uppercase. character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: ucstr integer :: ilen integer :: ioffset integer :: iquote integer :: iav integer :: iqc integer :: i ilen = len ( str ) ioffset = iachar ( 'A' ) - iachar ( 'a' ) iquote = 0 ucstr = str do i = 1 , ilen iav = iachar ( str ( i : i )) if ( ( iquote == 0 ) . and . (( iav == 34 ) . or . ( iav == 39 )) ) then iquote = 1 iqc = iav cycle end if if ( ( iquote == 1 ) . and . ( iav == iqc ) ) then iquote = 0 cycle end if if ( iquote == 1 ) cycle if ( ( iav >= iachar ( 'a' )) . and . ( iav <= iachar ( 'z' )) ) then ucstr ( i : i ) = achar ( iav + ioffset ) end if end do end function !********************************************************************** pure function str_to_lower ( str ) result ( lcstr ) !!  This function returns a string that is like the string `str` with all characters !!  that are not between a pair of quotes (\"...\" or '...') converted to lowercase. character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: lcstr integer :: ilen integer :: ioffset integer :: iquote integer :: iav integer :: iqc integer :: i ilen = len ( str ) ioffset = iachar ( 'A' ) - iachar ( 'a' ) iquote = 0 lcstr = str do i = 1 , ilen iav = iachar ( str ( i : i )) if ( ( iquote == 0 ) . and . (( iav == 34 ) . or . ( iav == 39 )) ) then iquote = 1 iqc = iav cycle end if if ( ( iquote == 1 ) . and . ( iav == iqc ) ) then iquote = 0 cycle end if if ( iquote == 1 ) cycle if ( ( iav >= iachar ( 'A' )) . and . ( iav <= iachar ( 'Z' )) ) then lcstr ( i : i ) = achar ( iav - ioffset ) end if end do end function !****************************************************************************** subroutine str_shift ( str , n ) !! Shifts characters in `str` by `n` positions (positive values !! denote a right shift and negative values denote a left shift). Characters !! that are shifted off the end are lost. Positions opened up by the shift !! are replaced by spaces. character ( len =* ), intent ( in out ) :: str integer , intent ( in ) :: n integer :: lenstr integer :: nabs lenstr = len ( str ) nabs = iabs ( n ) if ( nabs >= lenstr ) then str = repeat ( ' ' , lenstr ) return end if if ( n < 0 ) str = str ( nabs + 1 :) // repeat ( ' ' , nabs ) ! shift left if ( n > 0 ) str = repeat ( ' ' , nabs ) // str (: lenstr - nabs ) ! shift right end subroutine !****************************************************************************** subroutine str_insert ( str , substr , loc ) !! Inserts the string `substr` into the string `str` at position `loc`. !! Characters in `str` starting at position `loc` are shifted right to !! make room for the inserted string. Trailing spaces of `substr` are !! removed prior to insertion. character ( len =* ), intent ( in out ) :: str character ( len =* ), intent ( in ) :: substr integer , intent ( in ) :: loc character ( len = len ( str )) :: tempstr integer :: len_substr len_substr = len_trim ( substr ) tempstr = str ( loc :) call str_shift ( tempstr , len_substr ) tempstr ( 1 : len_substr ) = substr ( 1 : len_substr ) str ( loc :) = tempstr end subroutine !****************************************************************************** subroutine str_del ( str , substr , n ) !! Deletes first `n` occurrences of substring `substr` from string `str` and !! shifts characters left to fill hole. If `n < 0`, all occurances are !! deleted.  If `n` is not explicitly provided, it defaults to removing the !! first occurrence. Trailing spaces or blanks are not considered part of !! `substr`. character ( len =* ), intent ( in out ) :: str character ( len =* ), intent ( in ) :: substr integer , optional , intent ( in ) :: n integer :: n_ integer :: lensubstr integer :: ipos integer :: cntr n_ = 1 if ( present ( n )) n_ = n lensubstr = len_trim ( substr ) cntr = 0 do if (( n_ > 0 ) . and . ( cntr > n_ )) exit ipos = index ( str , substr ) if ( ipos == 0 ) exit str = str (: ipos - 1 ) // str ( ipos + lensubstr :) cntr = cntr + 1 end do end subroutine !********************************************************************** subroutine str_strip_comment ( str , comment_str ) !!  Strips trailing comment from a string. !! !!  The comment is assumed to begin with the sequence of characters in !!  `comment_str`. If the sequence `comment_str` is not found within `str`, !!  no changes are made. character ( len =* ), intent ( in out ) :: str !!  Input string character ( len =* ), intent ( in ) :: comment_str !!  String indicating beginning of a comment. integer :: ipos ipos = index ( adjustl ( str ), comment_str ) if ( ipos /= 0 ) then str = str ( 1 :( ipos - 1 )) end if end subroutine !********************************************************************** subroutine str_get_keyval ( str , key , val , delimiter ) !! Split a string `str` into two strings, `key` and `val` based on space !! delimiter. !! !! A non-empty non-comment string should be passed to this subroutine. !! Keys can have corresponding empty values, but keys must always be present character ( len =* ), intent ( in ) :: str character ( len = :), allocatable , intent ( out ) :: key character ( len = :), allocatable , intent ( out ) :: val character ( len =* ), intent ( in ), optional :: delimiter character ( len = :), allocatable :: delimiter_ character ( len = :), allocatable :: str_just integer :: m integer :: n !blankspace is represented as the integer 32 in ascii chart. delimiter_ = achar ( 32 ) if ( present ( delimiter )) delimiter_ = delimiter str_just = trim ( adjustl ( str )) n = len ( str_just ) m = index ( str_just , delimiter_ ) if ( m == 0 ) then key = str_just val = '' else key = trim ( str_just ( 1 : m - 1 )) val = str_just ( m + len_trim ( delimiter_ ): n ) end if val = trim ( adjustl ( val )) end subroutine !****************************************************************************** subroutine str_match ( str , ipos , imatch ) !! This routine finds the delimiter in string `str` that matches the delimiter !! in position `ipos` of `str`. The argument `imatch` contains the position of !! the matching delimiter. Allowable delimiters are (), [], {}, <>. character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: ipos integer , intent ( out ) :: imatch character ( len = 1 ) :: delim1 character ( len = 1 ) :: delim2 character ( len = 1 ) :: ch integer :: lenstr integer :: istart integer :: iend integer :: inc integer :: idelim2 integer :: isum integer :: i lenstr = len_trim ( str ) delim1 = str ( ipos : ipos ) select case ( delim1 ) case ( '(' ) idelim2 = iachar ( delim1 ) + 1 istart = ipos + 1 iend = lenstr inc = 1 case ( ')' ) idelim2 = iachar ( delim1 ) - 1 istart = ipos - 1 iend = 1 inc =- 1 case ( '[' , '{' , '<' ) idelim2 = iachar ( delim1 ) + 2 istart = ipos + 1 iend = lenstr inc = 1 case ( ']' , '}' , '>' ) idelim2 = iachar ( delim1 ) - 2 istart = ipos - 1 iend = 1 inc =- 1 case default write ( * , * ) delim1 , ' is not a valid delimiter' return end select if ( istart < 1 . or . istart > lenstr ) then write ( * , * ) delim1 , ' has no matching delimiter' return end if delim2 = achar ( idelim2 ) ! matching delimiter isum = 1 do i = istart , iend , inc ch = str ( i : i ) if ( ch /= delim1 . and . ch /= delim2 ) cycle if ( ch == delim1 ) isum = isum + 1 if ( ch == delim2 ) isum = isum - 1 if ( isum == 0 ) exit end do if ( isum /= 0 ) then write ( * , * ) delim1 , ' has no matching delimiter' return end if imatch = i end subroutine !********************************************************************** pure function str_from_inum ( num , frmt ) result ( str ) integer , intent ( in ) :: num character ( len = :), allocatable :: str character ( len =* ), optional , intent ( in ) :: frmt character ( len = :), allocatable :: frmt_ character ( len = 24 ) :: buf frmt_ = '(i0)' if ( present ( frmt )) frmt_ = frmt write ( buf , frmt_ ) num str = trim ( adjustl ( buf )) end function !********************************************************************** pure function str_from_ilnum ( num , frmt ) result ( str ) integer ( ip_long ), intent ( in ) :: num character ( len = :), allocatable :: str character ( len =* ), optional , intent ( in ) :: frmt character ( len = :), allocatable :: frmt_ character ( len = 24 ) :: buf frmt_ = '(i0)' if ( present ( frmt )) frmt_ = frmt write ( buf , frmt_ ) num str = trim ( adjustl ( buf )) end function !********************************************************************** pure function str_from_dnum ( num , frmt ) result ( str ) real ( rp ), intent ( in ) :: num character ( len = :), allocatable :: str character ( len =* ), optional , intent ( in ) :: frmt character ( len = :), allocatable :: frmt_ character ( len = 32 ) :: buf frmt_ = '(g0.15)' if ( present ( frmt )) frmt_ = frmt write ( buf , frmt_ ) num str = str_trimzero ( buf ) end function !****************************************************************************** subroutine str_compact_rlstr ( str ) !! author: Izaak Beekman !! date: 02/24/2015 !! !! Compact a string representing a real number, so that the same value is !! displayed with fewer characters. character ( len =* ), intent ( in out ) :: str !! string representation of a real number. character ( len = len ( str )) :: significand character ( len = len ( str )) :: expnt character ( len = 2 ) :: separator integer :: exp_start integer :: decimal_pos integer :: sig_trim integer :: exp_trim integer :: i !! counter str = adjustl ( str ) exp_start = scan ( str , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( str , '-+' , back = . true .) decimal_pos = scan ( str , '.' ) if ( exp_start /= 0 ) separator = str ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then !possibly signed, exponent-less float significand = str sig_trim = len_trim ( significand ) do i = len_trim ( significand ), decimal_pos + 2 , - 1 !look from right to left at 0s !but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do str = trim ( significand ( 1 : sig_trim )) else if ( exp_start > decimal_pos ) then !float has exponent significand = str ( 1 : exp_start - 1 ) sig_trim = len_trim ( significand ) do i = len_trim ( significand ), decimal_pos + 2 , - 1 !look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do expnt = adjustl ( str ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( str ( exp_start + 1 :)) end if exp_trim = 1 do i = 1 ,( len_trim ( expnt ) - 1 ) !look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit end if end do str = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable end if end subroutine !******************************************************************************* pure function str_trimzero ( str ) result ( res ) !! Deletes nonsignificant trailing zeroes from number string str. If number !! string ends in a decimal point, one trailing zero is added. character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: res character ( len = len ( str )) :: buf character ( len = 10 ) :: sexp character ( len = 1 ) :: ch integer :: ipos integer :: lbuf integer :: i buf = str ipos = scan ( str , 'eE' ) if ( ipos > 0 ) then sexp = buf ( ipos :) buf = buf ( 1 : ipos - 1 ) endif lbuf = len_trim ( buf ) do i = lbuf , 1 , - 1 ch = buf ( i : i ) if ( ch == '0' ) cycle if ( ch == '.' ) then buf = buf ( 1 : i ) // '0' if ( ipos > 0 ) buf = trim ( buf ) // trim ( sexp ) exit endif buf = buf ( 1 : i ) exit end do if ( ipos > 0 ) buf = trim ( buf ) // trim ( sexp ) res = trim ( adjustl ( buf )) end function !*********************************************************************** pure function str_to_d ( str ) result ( res ) character ( len =* ), intent ( in ) :: str real ( rp ) :: res read ( str , * ) res end function !*********************************************************************** pure function str_to_i ( str ) result ( res ) character ( len =* ), intent ( in ) :: str integer :: res read ( str , * ) res end function !*********************************************************************** pure function str_strip ( str , chars , ends ) result ( ostr ) !! Returns a copy of string `str` with the leading and trailing characters !! removed. The `chars` argument is a string specifying the set of characters to !! be removed.  The `chars` argument is not a prefix or suffix; rather, all !! combinations of its values are stripped. If `ends = 'l'`, only leading !! characters are removed, if `ends = 'r'`, only trailing characters are !! removed, and if `ends = 'b'` both leading and trailing characters are !! removed. character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: chars character ( len = 1 ), intent ( in ) :: ends !! {'l', 'r', 'b'} character ( len = :), allocatable :: ostr integer :: lenstr integer :: ibeg integer :: iend lenstr = len ( str ) select case ( ends ) case ( 'l' ) ibeg = verify ( str , chars ) iend = lenstr case ( 'r' ) ibeg = 1 iend = verify ( str , chars , . true .) case ( 'b' ) ibeg = verify ( str , chars ) iend = verify ( str , chars , . true .) case default ibeg = 1 iend = lenstr end select if (( ibeg == 0 ) . or . ( iend == 0 )) then ostr = '' else ostr = str ( ibeg : iend ) end if end function !********************************************************************** subroutine str_split ( str , delimiter , before ) !! Routine finds the first instance of a character from `delims` in the the !! string `str`. The characters before the found delimiter are output in !! `before`. The characters after the found delimiter are output in `str`. !! Repeated applications of this routine can be used to parse a string into its !! component parts. Multiple whitespaces of `str` are compacted into a single !! whitespace before splitting begins. If either `str` or `delimiter` is !! empty, an empty string is retured in `before` and `str` remains !! unchanged. character ( len =* ), intent ( in out ) :: str character ( len =* ), intent ( in ) :: delimiter character ( len = :), allocatable , intent ( out ) :: before integer :: lenstr integer :: lendelim integer :: ipos str = str_compact ( str ) lenstr = len ( str ) lendelim = len ( delimiter ) if ( ( lenstr == 0 ) . or . ( lendelim == 0 ) ) then ! `str` or `delimiter` is empty before = '' return end if ipos = index ( str , delimiter ) if ( ipos == 0 ) then ! string does not contain any delimiter before = '' return else before = str ( 1 :( ipos - 1 )) str = str (( ipos + lendelim - 1 ):) end if end subroutine !********************************************************************** subroutine str_append ( dest , source , sep ) !! Appends a copy of the `source` string to the `dest` string, with !! optional string `sep` in between. It is assumed that `dest` is long !! enough to hold the result, otherwise an error will be generated. character ( len =* ), intent ( in out ) :: dest character ( len =* ), intent ( in ) :: source character ( len =* ), optional , intent ( in ) :: sep character ( len = :), allocatable :: sep_ integer :: len_dest integer :: len_source integer :: len_sep_ integer :: ipos sep_ = '' if ( present ( sep )) sep_ = sep len_dest = len_trim ( dest ) len_source = len_trim ( adjustl ( source )) len_sep_ = len ( sep_ ) ipos = len_dest + 1 if ( len_sep_ > 0 ) then dest ( ipos :( ipos + len_sep_ ) ) = sep_ ipos = ipos + len_sep_ + 1 end if dest ( ipos :( ipos + len_source ) ) = trim ( adjustl ( source )) end subroutine !********************************************************************** pure function str_startswith ( str , prefix , start , finish ) result ( res ) !! Returns `.true.` if the string `str` starts with `prefix`, otherwise !! returns `.false.`. With optional `start`, test beginning at that position. !! With optional `finish`, stop comparing beyond that position. character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: prefix integer , optional , intent ( in ) :: start integer , optional , intent ( in ) :: finish logical :: res integer :: ibeg integer :: iend ibeg = 1 ; iend = len ( str ) if ( present ( start )) ibeg = start if ( present ( finish )) iend = finish !Return .false. if prefix is longer than str(ibeg:iend) if ( len ( prefix ) > ( iend - ibeg + 1 )) then res = . false . return end if if ( index ( str ( ibeg : iend ), prefix ) == 1 ) then res = . true . else res = . false . end if end function !********************************************************************** pure function str_endswith ( str , suffix , start , finish ) result ( res ) !! Returns `.true.` if the string `str` ends with `suffix`, otherwise !! return `.false.`. With optional `start`, test beginning at that position. !! With optional `finish`, stop comparing beyond that position. character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: suffix integer , optional , intent ( in ) :: start integer , optional , intent ( in ) :: finish logical :: res integer :: ibeg integer :: iend integer :: iloc ibeg = 1 ; iend = len ( str ) if ( present ( start )) ibeg = start if ( present ( finish )) iend = finish !Return .false. if suffix is longer than str(ibeg:iend) if ( len ( suffix ) > ( iend - ibeg + 1 )) then res = . false . return end if ! Getting last occurrance of suffix iloc = index ( str ( ibeg : iend ), suffix , back = . true .) if ( ( iloc + len ( suffix ) - 1 ) == iend ) then res = . true . else res = . false . end if end function !****************************************************************************** subroutine readline ( nunitr , line , comment_str , ios ) !!  Reads a line from unit=nunitr, ignoring blank lines !!  and deleting comments integer , intent ( in ) :: nunitr character ( len =* ), intent ( in out ) :: line character ( len =* ), intent ( in ) :: comment_str integer , intent ( out ) :: ios do read ( nunitr , '(a)' , iostat = ios ) line ! read input line if ( ios /= 0 ) return if (( len_trim ( line ) /= 0 ) . and . (. not . str_is_comment ( line , comment_str ))) then call str_strip_comment ( line , comment_str ) exit end if end do end subroutine !****************************************************************************** end module m_strings","tags":"","loc":"sourcefile/m_strings.f90.html"},{"title":"m_constants_math.f90 – BROWNPAK","text":"Contents Modules m_constants_math Source Code m_constants_math.f90 Source Code module m_constants_math !! Various math constants. use m_precision implicit none real ( rp ), parameter :: math_third = 0.333333333333333_rp !>pi real ( rp ), parameter :: math_pi = 3.1415926535897931_rp !>pi divided by two real ( rp ), parameter :: math_pi_2 = 1.5707963267948966_rp !>pi divided by four real ( rp ), parameter :: math_pi_4 = 0.78539816339744828_rp !>reciprocal of pi real ( rp ), parameter :: math_1_pi = 0.31830988618379069_rp !>two times reciprocal of pi real ( rp ), parameter :: math_2_pi = 0.63661977236758138_rp !>two times the reciprocal of the square root of pi. real ( rp ), parameter :: math_2_sqrtpi = 1.1283791670955126_rp !>square root of two real ( rp ), parameter :: math_sqrt2 = 1.4142135623730951_rp !>cube root of two real ( rp ), parameter :: math_cbrt2 = 1.2599210498948732_rp !>sixth root of two real ( rp ), parameter :: math_sxrt2 = 1.122462048309373_rp !>reciprocal of the square root of two real ( rp ), parameter :: math_sqrt1_2 = 0.70710678118654746_rp !>square root of three real ( rp ), parameter :: math_sqrt3 = 1.7320508075688772_rp !>square root of M_E real ( rp ), parameter :: math_sqrt_e = 1.6487212707001282_rp !>square root of pi real ( rp ), parameter :: math_sqrt_pi = 1.7724538509055159_rp !>The base of natural logarithms real ( rp ), parameter :: math_e = 2.7182818284590451_rp !>The logarithm of M_E to base two real ( rp ), parameter :: math_log2e = 1.4426950408889634_rp !>The logarithm of M_E to base 10 real ( rp ), parameter :: math_log10e = 0.43429448190325182_rp !>The natural logarithm of two real ( rp ), parameter :: math_ln2 = 0.69314718055994529_rp !>The natural logarithm of 10 real ( rp ), parameter :: math_ln10 = 2.3025850929940459_rp end module m_constants_math","tags":"","loc":"sourcefile/m_constants_math.f90.html"},{"title":"m_cell_list.f90 – BROWNPAK","text":"Contents Modules m_cell_list Source Code m_cell_list.f90 Source Code module m_cell_list !! Sorts atoms using a cell list. !! !! The algorithm to build the cell list partially follows the techniques in Watanabe et !! al, 2011, “Efficient Implementations of Molecular Dynamics Simulations for !! Lennard-Jones Systems,” Prog. Theor. Phys. 126, 203–235. !! !! The pairlist is not explicitly built, rather the cells are directly !! looped over during force calculation. use m_precision use m_vector use m_globals , only : simbox implicit none private public :: cl_init , cl_delete , cl_print , & cl_set_cell_size , cl_build , cl_build_cell_nbrs , & cl_get_num_cells , cl_get_contents , cl_get_nbr_cells real ( rp ), dimension ( 3 ) :: cell_size = 0.0_rp !! Cell size along *x*, *y*, & *z*. integer , dimension ( 3 ) :: nc_max = 0 !! Maximum number of cells along *x*, *y*, & *z*. integer , dimension ( 3 ) :: nc = 0 !! Number of cells along *x*, *y*, & *z*. integer :: nct_max = 0 !! Maximum total number of cells. integer :: nct = 0 !! Total of cells. integer , dimension (:), allocatable , target :: cells !! *(na_max,)* array. Listing atoms in each cell. integer , dimension (:), allocatable :: cells_pos !! *(0:nct_max,)* index array. Note: 0-based indexing. type ( ivector_t ) :: cell_nbrs !! Lists neighbor cells for each cell. integer , dimension (:), allocatable :: cell_nbrs_pos !! *(0:nct_max,)* index array. Note: 0-based indexing. integer , dimension (:), allocatable :: host_cells !! *(na_max,)* array. *host_cells(i)* stores the linear index of the cell !! containing atom *i*. *na_max* is the total number of atoms under consideration. integer , dimension (:), allocatable :: cell_pop !! *(0:nct_max-1,)* array storing population of each cell. Note: 0-based indexing. integer , dimension ( 3 , 13 ), parameter :: d = reshape ( [ & & 1 , 0 , 0 , & & 1 , 1 , 0 , - 1 , 1 , 0 , 0 , 1 , 0 , & & 0 , 0 , 1 , - 1 , 0 , 1 , 1 , 0 , 1 , & & - 1 , - 1 , 1 , 0 , - 1 , 1 , 1 , - 1 , 1 , & & - 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 ], [ 3 , 13 ] ) contains !****************************************************************************** subroutine cl_init ( na_max , cs_min ) !! Initializes a cell list. integer , intent ( in ) :: na_max !! Maximum number of atoms to be handled. real ( rp ), intent ( in ) :: cs_min !! Minimum size (i.e. length) of a cell. integer :: nelem !The following defines an upper bound on the number of cells nc_max ( 1 ) = ceiling ( simbox % basis ( 1 , 1 ) / cs_min ) nc_max ( 2 ) = ceiling ( simbox % basis ( 2 , 2 ) / cs_min ) nc_max ( 3 ) = ceiling ( simbox % basis ( 3 , 3 ) / cs_min ) nct_max = product ( nc_max ) allocate ( cells ( na_max )) allocate ( cells_pos ( 0 : nct_max )) allocate ( host_cells ( na_max )) allocate ( cell_pop ( 0 : nct_max - 1 )) !Provisional allocation with nelem (arbitrary) elements, !will expand/contract later. nelem = 8 call ivector_init ( cell_nbrs , nelem ) allocate ( cell_nbrs_pos ( 0 : nelem )) end subroutine !****************************************************************************** subroutine cl_set_cell_size ( cs ) !! Sets the cell size. The actual cell size may be slightly larger. real ( rp ), intent ( in ) :: cs nc ( 1 ) = floor ( simbox % basis ( 1 , 1 ) / cs ) nc ( 2 ) = floor ( simbox % basis ( 2 , 2 ) / cs ) nc ( 3 ) = floor ( simbox % basis ( 3 , 3 ) / cs ) nct = product ( nc ) cell_size ( 1 ) = simbox % basis ( 1 , 1 ) / nc ( 1 ) cell_size ( 2 ) = simbox % basis ( 2 , 2 ) / nc ( 2 ) cell_size ( 3 ) = simbox % basis ( 3 , 3 ) / nc ( 3 ) end subroutine !****************************************************************************** subroutine cl_build_cell_nbrs () !! Makes a table of neighboring cells. integer :: j integer :: ncx , ncy , ncz integer :: icx , icy , icz , ic integer :: jcx , jcy , jcz , jc if ( size ( cell_nbrs_pos ) < ( nct + 1 ) ) then deallocate ( cell_nbrs_pos ) allocate ( cell_nbrs_pos ( 0 : nct )) end if ncx = nc ( 1 ); ncy = nc ( 2 ); ncz = nc ( 3 ) cell_nbrs_pos ( 0 ) = 1 do icz = 0 , ncz - 1 do icy = 0 , ncy - 1 do icx = 0 , ncx - 1 ic = icz * ncx * ncy + icy * ncx + icx cell_nbrs_pos ( ic + 1 ) = cell_nbrs_pos ( ic ) do j = 1 , 13 jcx = modulo ( icx + d ( 1 , j ), ncx ) jcy = modulo ( icy + d ( 2 , j ), ncy ) jcz = modulo ( icz + d ( 3 , j ), ncz ) jc = jcz * ncx * ncy + jcy * ncx + jcx call cell_nbrs % append ( jc ) cell_nbrs_pos ( ic + 1 ) = cell_nbrs_pos ( ic + 1 ) + 1 end do end do end do end do call cell_nbrs % shrink_to_fit () end subroutine !****************************************************************************** subroutine cl_delete () !! Deallocates memory allocated in `cl_init`. if ( allocated ( cells )) deallocate ( cells ) if ( allocated ( cells_pos )) deallocate ( cells_pos ) call cell_nbrs % delete () if ( allocated ( cell_nbrs_pos )) deallocate ( cell_nbrs_pos ) if ( allocated ( host_cells )) deallocate ( host_cells ) if ( allocated ( cell_pop )) deallocate ( cell_pop ) cell_size = 0.0_rp nc_max = 0 ; nc = 0 nct_max = 0 ; nct = 0 end subroutine !****************************************************************************** subroutine cl_build ( coords ) !! Sorts atoms into cells for calculating short-range interations real ( rp ), dimension (:,:), intent ( in ) :: coords real ( rp ), dimension ( 3 ) :: ri integer :: na , iatm , j integer :: ncx , ncy , ncz integer :: icx , icy , icz , ic cells = 0 host_cells = 0 cell_pop = 0 ncx = nc ( 1 ); ncy = nc ( 2 ); ncz = nc ( 3 ) na = size ( coords , 2 ) !Loop over particles and put into cells do iatm = 1 , na ri = coords (:, iatm ) icx = int ( ri ( 1 ) / cell_size ( 1 ) ) icy = int ( ri ( 2 ) / cell_size ( 2 ) ) icz = int ( ri ( 3 ) / cell_size ( 3 ) ) if (( icx < 0 ) . or . ( icy < 0 ) . or . ( icz < 0 )) then print * , ri stop end if !If atoms are exactly on the box edge if ( icx > ( ncx - 1 ) ) icx = ncx - 1 if ( icy > ( ncy - 1 ) ) icy = ncy - 1 if ( icz > ( ncz - 1 ) ) icz = ncz - 1 ic = icz * ncx * ncy + icy * ncx + icx host_cells ( iatm ) = ic cell_pop ( ic ) = cell_pop ( ic ) + 1 end do !Loop over all cells to set up pointers cells_pos ( 0 ) = 1 do ic = 0 , ( nct - 1 ) cells_pos ( ic + 1 ) = cells_pos ( ic ) + cell_pop ( ic ) end do !Loop over all atoms do iatm = 1 , na ic = host_cells ( iatm ) j = cells_pos ( ic ) cells ( j ) = iatm cells_pos ( ic ) = cells_pos ( ic ) + 1 end do !Loop over all cells to set up pointers cells_pos ( 0 ) = 1 do ic = 0 , ( nct - 1 ) cells_pos ( ic + 1 ) = cells_pos ( ic ) + cell_pop ( ic ) end do end subroutine !****************************************************************************** function cl_get_num_cells () result ( res ) !! Returns the total number of cells integer :: res res = nct end function !****************************************************************************** subroutine cl_get_contents ( ic , res ) !! Returns a pointer to the entries of cell with linear index *ic*. integer , intent ( in ) :: ic integer , dimension (:), pointer , intent ( out ) :: res integer :: ibeg , iend res => null () ibeg = cells_pos ( ic ); iend = cells_pos ( ic + 1 ) - 1 res => cells ( ibeg : iend ) end subroutine !****************************************************************************** subroutine cl_get_nbr_cells ( ic , res ) !! Returns a pointer to the neighbor cells of cell with linear index *ic*. integer , intent ( in ) :: ic integer , dimension (:), pointer , intent ( out ) :: res integer :: ibeg , iend res => null () ibeg = cell_nbrs_pos ( ic ); iend = cell_nbrs_pos ( ic + 1 ) - 1 call cell_nbrs % get_data ( res , ibeg , iend ) end subroutine !******************************************************************************** subroutine cl_print () !! Prints a cell list integer , dimension (:), pointer :: aic => null () integer , dimension (:), pointer :: nbrc => null () integer :: ncx , ncy , ncz integer :: icx , icy , icz , ic ncx = nc ( 1 ); ncy = nc ( 2 ); ncz = nc ( 3 ) write ( * , '(\"ncx: \", i0, \" ncy: \", i0, \" ncz: \", i0)' ) ncx , ncy , ncz write ( * , '(\"lcx: \", g0.6, \" lcy: \", g0.6, \" lcz: \", g0.6)' ) cell_size write ( * , * ) 'CELL CONTENTS' do icz = 0 , ncz - 1 do icy = 0 , ncy - 1 do icx = 0 , ncx - 1 ic = icz * ncx * ncy + icy * ncx + icx call cl_get_contents ( ic , aic ) if ( size ( aic ) > 0 ) then write ( * , '(\"(\",i0,\",\",i0,\",\",i0,\")[\",i0,\"] \")' , advance = 'no' ) icx , icy , icz , ic write ( * , * ) size ( aic ), aic end if end do end do end do write ( * , * ) write ( * , * ) 'NBR CELLS' do icz = 0 , ncz - 1 do icy = 0 , ncy - 1 do icx = 0 , ncx - 1 ic = icz * ncx * ncy + icy * ncx + icx call cl_get_nbr_cells ( ic , nbrc ) write ( * , '(\"(\",i0,\",\",i0,\",\",i0,\")[\",i0,\"] \")' , advance = 'no' ) icx , icy , icz , ic write ( * , * ) size ( nbrc ), nbrc end do end do end do end subroutine !******************************************************************************** end module m_cell_list","tags":"","loc":"sourcefile/m_cell_list.f90.html"},{"title":"m_connectivity.f90 – BROWNPAK","text":"Contents Modules m_connectivity Source Code m_connectivity.f90 Source Code module m_connectivity !! Routines for building atom->bond, atom->angle, etc. tables and excluded !! atoms table. use m_precision use m_vector use m_table use m_globals implicit none private public :: atbo_build , atan_build , atdh_build , exat_build public :: atbo_tab , atan_tab , atdh_tab , exat_tab type ( itable_t ) :: atbo_tab !! Atoms -> bonds table type ( itable_t ) :: atan_tab !! Atoms -> angles table type ( itable_t ) :: atdh_tab !! Atoms -> dihedrals table type ( itable_t ) :: atat_tab !! Atoms -> bonded atoms table (1-ring) type ( itable_t ) :: exat_tab !! Atoms -> excluded atoms (from vdw calculation) table contains !******************************************************************************** subroutine atbo_build () type ( ivector_t ), dimension (:), allocatable :: buf_map integer :: iatm , jatm , ibnd integer :: j !Build table as list of lists allocate ( buf_map ( num_atoms )) do iatm = 1 , num_atoms call ivector_init ( buf_map ( iatm )) end do do ibnd = 1 , num_bonds iatm = bonds ( 2 , ibnd ) jatm = bonds ( 3 , ibnd ) call buf_map ( iatm )% append ( ibnd ) call buf_map ( jatm )% append ( ibnd ) end do !Sort in ascending order do iatm = 1 , num_atoms if ( buf_map ( iatm )% len > 1 ) call buf_map ( iatm )% sort () end do !Copy over to table call itbl_init ( atbo_tab , num_atoms ) do iatm = 1 , num_atoms do j = 1 , buf_map ( iatm )% len jatm = buf_map ( iatm )% get_val ( j ) call atbo_tab % append ( iatm , jatm ) end do end do !Delete list of lists table do iatm = 1 , num_atoms call buf_map ( iatm )% delete () end do deallocate ( buf_map ) !Release additional memory call atbo_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine atan_build () type ( ivector_t ), dimension (:), allocatable :: buf_map integer :: iatm , jatm , katm , iang integer :: j !Build table as list of lists allocate ( buf_map ( num_atoms )) do iatm = 1 , num_atoms call ivector_init ( buf_map ( iatm )) end do do iang = 1 , num_angles iatm = angles ( 2 , iang ) jatm = angles ( 3 , iang ) katm = angles ( 4 , iang ) call buf_map ( iatm )% append ( iang ) call buf_map ( jatm )% append ( iang ) call buf_map ( katm )% append ( iang ) end do !Sort in ascending order do iatm = 1 , num_atoms if ( buf_map ( iatm )% len > 1 ) call buf_map ( iatm )% sort () end do !Copy over to table call itbl_init ( atan_tab , num_atoms ) do iatm = 1 , num_atoms do j = 1 , buf_map ( iatm )% len jatm = buf_map ( iatm )% get_val ( j ) call atan_tab % append ( iatm , jatm ) end do end do !Delete list of lists table do iatm = 1 , num_atoms call buf_map ( iatm )% delete () end do deallocate ( buf_map ) !Release additional memory call atan_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine atdh_build () type ( ivector_t ), dimension (:), allocatable :: buf_map integer :: iatm , jatm , katm , latm , idhd integer :: j !Build table as list of lists allocate ( buf_map ( num_atoms )) do iatm = 1 , num_atoms call ivector_init ( buf_map ( iatm )) end do do idhd = 1 , num_dihedrals iatm = dihedrals ( 2 , idhd ) jatm = dihedrals ( 3 , idhd ) katm = dihedrals ( 4 , idhd ) latm = dihedrals ( 5 , idhd ) call buf_map ( iatm )% append ( idhd ) call buf_map ( jatm )% append ( idhd ) call buf_map ( katm )% append ( idhd ) call buf_map ( latm )% append ( idhd ) end do !Sort in ascending order do iatm = 1 , num_atoms if ( buf_map ( iatm )% len > 1 ) call buf_map ( iatm )% sort () end do !Copy over to table call itbl_init ( atdh_tab , num_atoms ) do iatm = 1 , num_atoms do j = 1 , buf_map ( iatm )% len jatm = buf_map ( iatm )% get_val ( j ) call atdh_tab % append ( iatm , jatm ) end do end do !Delete list of lists table do iatm = 1 , num_atoms call buf_map ( iatm )% delete () end do deallocate ( buf_map ) !Release additional memory call atdh_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine atat_build () integer , dimension (:), pointer :: inc_bonds => null () type ( ivector_t ) :: excl_atms integer :: iatm , jatm , jbnd , jbnd_atm1 , jbnd_atm2 integer :: j !Initialize table call itbl_init ( atat_tab , num_atoms ) !List of excluded atoms call ivector_init ( excl_atms ) do iatm = 1 , num_atoms call excl_atms % clear () !Get incident bonds call atbo_tab % get_row ( iatm , inc_bonds ) !Add atoms from each of the incident bonds, excluding iatom do j = 1 , size ( inc_bonds ) jbnd = inc_bonds ( j ) jbnd_atm1 = bonds ( 2 , jbnd ) jbnd_atm2 = bonds ( 3 , jbnd ) if ( jbnd_atm1 /= iatm ) call excl_atms % append ( jbnd_atm1 ) if ( jbnd_atm2 /= iatm ) call excl_atms % append ( jbnd_atm2 ) end do !Sort and remove duplicates. These are the atoms in the 1-ring. call excl_atms % unique () !Add to atat_tab. Note that iatm does not appear in the atat table !for iatm. do j = 1 , excl_atms % len jatm = excl_atms % get_val ( j ) call atat_tab % append ( iatm , jatm ) end do end do !Release additional memory call atat_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine exat_build () integer , dimension (:), pointer :: nbr_atms => null () integer , dimension (:), pointer :: nbr2_atms => null () integer , dimension (:), pointer :: nbr3_atms => null () type ( ivector_t ) :: excl_atms integer :: iatm , jatm , j2atm , j3atm integer :: j , j2 , j3 !Build atat_tab. This is the 1-ring neighborhood of each atom. call atat_build () call atat_tab % shrink_to_fit () !Debug statements !print*, 'ATAT_TAB' !call atat_tab%print() !Initialize table call itbl_init ( exat_tab , num_atoms ) !List of excluded atoms call ivector_init ( excl_atms ) do iatm = 1 , num_atoms call excl_atms % clear () if ( excluded_atoms > 0 ) then !Get atoms in 1-ring neighborhood call atat_tab % get_row ( iatm , nbr_atms ) !Add atoms to excluded atoms list. First adding iatm itself. call excl_atms % append ( iatm ) do j = 1 , size ( nbr_atms ) jatm = nbr_atms ( j ) call excl_atms % append ( jatm ) !Atoms for second ring neighbors if ( excluded_atoms > 1 ) then call atat_tab % get_row ( jatm , nbr2_atms ) do j2 = 1 , size ( nbr2_atms ) j2atm = nbr2_atms ( j2 ) call excl_atms % append ( j2atm ) !Atoms for third ring neighbors if ( excluded_atoms > 2 ) then call atat_tab % get_row ( j2atm , nbr3_atms ) do j3 = 1 , size ( nbr3_atms ) j3atm = nbr3_atms ( j3 ) call excl_atms % append ( j3atm ) end do !Finished adding all third ring neighbors end if end do !Finished adding all second ring neighbors end if !Finished adding all first ring neighbors end do end if !Sort and remove duplicates call excl_atms % unique () !Add to exat_tab. Note that iatom appears in the excluded atoms list for !iatom. do j = 1 , excl_atms % len jatm = excl_atms % get_val ( j ) call exat_tab % append ( iatm , jatm ) end do end do !Release additional memory call exat_tab % shrink_to_fit () !atat_tab no longer required call atat_tab % delete () end subroutine !******************************************************************************** end module m_connectivity","tags":"","loc":"sourcefile/m_connectivity.f90.html"},{"title":"m_logger.f90 – BROWNPAK","text":"Contents Modules m_logger Source Code m_logger.f90 Source Code module m_logger !! Implements a basic logger. use iso_fortran_env , only : output_unit implicit none private public :: logger_init , logger type logger_t character ( len = :), allocatable :: fn !! Name of the log file integer :: fu = huge ( 0 ) !! Unit number of the log file logical :: is_open = . false . !! Is the log file open for writing? {T/F} contains procedure :: finish => logger_finish procedure :: log_msg => logger_log_msg end type logger_t interface logger_init module procedure logger_init end interface type ( logger_t ) :: logger contains !******************************************************************************** subroutine logger_init ( this , fn , use_stdout ) !! Initializes a logger. type ( logger_t ), intent ( in out ) :: this !! A `logger_t` instance character ( len =* ), intent ( in ) :: fn !! Name of the log file. If `use_stdout` is true, `fn` is ignored. logical , intent ( in ) :: use_stdout !! Write all log messages to stdout rather than a file on disk? {T/F} integer :: ierr !Create a new log file and open it for writing. if ( use_stdout ) then this % fu = output_unit this % is_open = . true . else open ( newunit = this % fu , file = fn , action = 'write' , status = 'replace' , & iostat = ierr ) if ( ierr /= 0 ) then write ( * , '(a,i0)' ) 'error in opening log file; err code = ' , ierr else this % fn = fn this % is_open = . true . end if end if call this % log_msg ( 'start log' ) end subroutine !******************************************************************************** subroutine logger_finish ( this ) !! Cleanup routine for a `logger_t` instance. class ( logger_t ), intent ( in out ) :: this !! A `logger_t` instance call this % log_msg ( 'end log' ) if ( this % is_open . and . ( this % fu /= output_unit )) then close ( this % fu ) this % is_open = . false . this % fu = huge ( 0 ) end if end subroutine !******************************************************************************** subroutine logger_log_msg ( this , msg ) !! Write a message to the log file. class ( logger_t ), intent ( in ) :: this !! A `logger_t` instance character ( len =* ), intent ( in ) :: msg !! Message to write to the log file character ( len = 40 ) :: timstmp call timestring ( timstmp ) write ( this % fu , \"('[',a,']',1x,a)\" ) trim ( adjustl ( timstmp )), & trim ( adjustl ( msg )) flush ( this % fu ) end subroutine !******************************************************************************** subroutine timestring ( string ) !! TIMESTRING writes the current YMDHMS date into a string. ! !  Example: ! !    STRING = '31 May 2001   9:45:54.872 AM' ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    06 August 2005 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Output, character ( len = * ) STRING, contains the date information. !    A character length of 40 should always be sufficient. ! implicit none character ( len = 8 ) :: ampm integer :: d integer :: h integer :: m integer :: mm character ( len = 6 ), parameter , dimension ( 12 ) :: month = ( / & 'Jan   ' , 'Feb   ' , 'March ' , 'April ' , & 'May   ' , 'June  ' , 'July  ' , 'Aug   ' , & 'Sept  ' , 'Oct   ' , 'Nov   ' , 'Dec   ' / ) integer :: n integer :: s character ( len =* ) string integer :: values ( 8 ) integer :: y call date_and_time ( values = values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( string , '(i2.2,1x,a,1x,i4,1x,i0,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & d , trim ( month ( m ) ), y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) return end subroutine !******************************************************************************** end module m_logger","tags":"","loc":"sourcefile/m_logger.f90.html"},{"title":"m_qsort.f90 – BROWNPAK","text":"Contents Modules m_qsort Source Code m_qsort.f90 Source Code MODULE m_qsort !!  Implements quicksort for a sequence of integers and reals, in combination with !!  insertion sort for very short sequences. !! !! - Quick sort routine from Brainerd, W.S., Goldberg, C.H. & Adams, J.C. (1990) !! \"Programmer's Guide to Fortran 90\", McGraw-Hill  ISBN 0-07-000248-7, pages 149-150. !! - Modified by Alan Miller to include an associated integer array which gives !!   the positions of the elements in the original order. !! - Modified for integer array by Sarit Dutta USE M_PRECISION IMPLICIT NONE CONTAINS !****************************************************************************** RECURSIVE SUBROUTINE iqsort ( list , order ) !!  Sorts a sequence of integers IMPLICIT NONE INTEGER , DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of integers to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE iqsort !****************************************************************************** RECURSIVE SUBROUTINE dqsort ( list , order ) !!  Sorts a sequence of reals !\"\" IMPLICIT NONE REAL ( RP ), DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of reals to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE dqsort !****************************************************************************** END MODULE m_qsort","tags":"","loc":"sourcefile/m_qsort.f90.html"},{"title":"m_config_io.f90 – BROWNPAK","text":"Contents Modules m_config_io Source Code m_config_io.f90 Source Code module m_config_io !! Routines for IO of config and dump files. use m_precision use m_strings use m_simbox use m_globals implicit none contains !****************************************************************************** subroutine read_dump ( fn ) !! Reads from DUMP file character ( len =* ), intent ( in ) :: fn real ( rp ), dimension ( 3 , 3 ) :: mat integer :: fu logical :: lvel open ( newunit = fu , file = fn , access = 'stream' , form = 'unformatted' , & action = 'read' , status = 'old' ) read ( fu ) leql , nts read ( fu ) mat call simbox % set_basis ( mat ) read ( fu ) imcon read ( fu ) num_atom_types allocate ( atom_names ( num_atom_types )) allocate ( atom_styles ( num_atom_types )) allocate ( atom_mass ( num_atom_types )) read ( fu ) atom_names , atom_styles , atom_mass read ( fu ) mpcd_avnc , num_mpcd_atoms read ( fu ) num_atoms , num_atoms_tot allocate ( atoms ( num_atoms )) read ( fu ) atoms allocate ( coordinates ( 3 , num_atoms_tot )) read ( fu ) coordinates read ( fu ) lvel if ( lvel ) then allocate ( velocities ( 3 , num_atoms_tot )) read ( fu ) velocities end if allocate ( charge ( num_atoms )) read ( fu ) charge read ( fu ) num_bond_types if ( num_bond_types > 0 ) then allocate ( bond_styles ( num_bond_types )) allocate ( bond_params ( mxparam , num_bond_types )) read ( fu ) bond_styles , bond_params end if read ( fu ) num_bonds if ( num_bonds > 0 ) then allocate ( bonds ( 3 , num_bonds )) read ( fu ) bonds end if read ( fu ) num_angle_types if ( num_angle_types > 0 ) then allocate ( angle_styles ( num_angle_types )) allocate ( angle_params ( mxparam , num_angle_types )) read ( fu ) angle_styles , angle_params end if read ( fu ) num_angles if ( num_angles > 0 ) then allocate ( angles ( 4 , num_angles )) read ( fu ) angles end if read ( fu ) num_dihedral_types if ( num_dihedral_types > 0 ) then allocate ( dihedral_styles ( num_dihedral_types )) allocate ( dihedral_params ( mxparam , num_dihedral_types )) read ( fu ) dihedral_styles , dihedral_params end if read ( fu ) num_dihedrals if ( num_dihedrals > 0 ) then allocate ( dihedrals ( 5 , num_dihedrals )) read ( fu ) dihedrals end if read ( fu ) num_branches if ( num_branches > 0 ) then allocate ( branches ( 3 , num_branches )) read ( fu ) branches end if read ( fu ) num_molecule_types allocate ( molecule_names ( num_molecule_types )) allocate ( molecule_pop ( num_molecule_types )) read ( fu ) molecule_names , molecule_pop read ( fu ) num_molecules allocate ( molecules ( 9 , num_molecules )) read ( fu ) molecules read ( fu ) num_tether_types if ( num_tether_types > 0 ) then allocate ( tether_styles ( num_tether_types )) allocate ( tether_params ( mxparam , num_tether_types )) read ( fu ) tether_styles , tether_params end if read ( fu ) num_tethers if ( num_tethers > 0 ) then allocate ( tethers ( 2 , num_tethers )) allocate ( tether_points ( 3 , num_tethers )) read ( fu ) tethers , tether_points end if read ( fu ) num_vdw_types if ( num_vdw_types > 0 ) then allocate ( vdw_styles ( num_vdw_types )) allocate ( vdw_pairs ( 2 , num_vdw_types )) allocate ( vdw_params ( mxparam , num_vdw_types )) read ( fu ) vdw_pairs , vdw_styles , vdw_params end if read ( fu ) num_externals if ( num_externals > 0 ) then allocate ( external_styles ( num_externals )) allocate ( external_params ( mxparam , num_externals )) read ( fu ) external_styles , external_params end if read ( fu ) flow_style if ( flow_style /= 0 ) then allocate ( flow_params ( mxparam )) read ( fu ) flow_params end if if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) read ( fu ) molecule_com close ( fu ) end subroutine !****************************************************************************** subroutine write_dump ( fn ) !! Writes to DUMP file. character ( len =* ), intent ( in ) :: fn integer :: fu logical :: lvel open ( newunit = fu , file = fn , access = 'stream' , form = 'unformatted' , & action = 'write' , status = 'replace' ) write ( fu ) leql , nts write ( fu ) simbox % basis write ( fu ) imcon write ( fu ) num_atom_types , atom_names , atom_styles , atom_mass write ( fu ) mpcd_avnc , num_mpcd_atoms write ( fu ) num_atoms , num_atoms_tot write ( fu ) atoms write ( fu ) coordinates if ( allocated ( velocities )) then !A logical indicating whether velocities are written lvel = . true . write ( fu ) lvel , velocities else lvel = . false . write ( fu ) lvel end if write ( fu ) charge write ( fu ) num_bond_types if ( num_bond_types > 0 ) write ( fu ) bond_styles , bond_params write ( fu ) num_bonds if ( num_bonds > 0 ) write ( fu ) bonds write ( fu ) num_angle_types if ( num_angle_types > 0 ) write ( fu ) angle_styles , angle_params write ( fu ) num_angles if ( num_angles > 0 ) write ( fu ) angles write ( fu ) num_dihedral_types if ( num_dihedral_types > 0 ) write ( fu ) dihedral_styles , dihedral_params write ( fu ) num_dihedrals if ( num_dihedrals > 0 ) write ( fu ) dihedrals write ( fu ) num_branches if ( num_branches > 0 ) write ( fu ) branches write ( fu ) num_molecule_types , molecule_names , molecule_pop write ( fu ) num_molecules , molecules write ( fu ) num_tether_types if ( num_tether_types > 0 ) write ( fu ) tether_styles , tether_params write ( fu ) num_tethers if ( num_tethers > 0 ) write ( fu ) tethers , tether_points write ( fu ) num_vdw_types if ( num_vdw_types > 0 ) write ( fu ) vdw_pairs , vdw_styles , vdw_params write ( fu ) num_externals if ( num_externals > 0 ) write ( fu ) external_styles , external_params write ( fu ) flow_style if ( flow_style /= 0 ) write ( fu ) flow_params if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) write ( fu ) molecule_com close ( fu ) end subroutine !****************************************************************************** subroutine read_config ( fn ) !! Read from CONFIG file character ( len =* ), intent ( in ) :: fn character ( len = mxrdln ) :: line character ( len = :), allocatable :: word real ( rp ), dimension ( 3 , 3 ) :: mat integer :: i , it , npar , ibr integer :: fu , ios open ( newunit = fu , file = fn , action = 'read' , status = 'old' ) do call readline ( fu , line , '#' , ios ) if ( ios /= 0 ) exit line = adjustl ( line ) if ( str_startswith ( line , 'SIMBOX' )) then !Read simulation box size into lattice vectors defining the box read ( fu , * ) mat (:, 1 ) read ( fu , * ) mat (:, 2 ) read ( fu , * ) mat (:, 3 ) call simbox % set_basis ( mat ) end if if ( str_startswith ( line , 'IMCON' )) then !Read box boundary condition call str_split ( line , ' ' , word ) imcon = str_to_i ( line ) end if if ( str_startswith ( line , 'ATOM_TYPES' )) then call str_split ( line , ' ' , word ) num_atom_types = str_to_i ( line ) allocate ( atom_names ( num_atom_types )) allocate ( atom_styles ( num_atom_types )) allocate ( atom_mass ( num_atom_types )) do it = 1 , num_atom_types read ( fu , * ) atom_names ( it ), atom_styles ( it ), atom_mass ( it ) end do end if if ( str_startswith ( line , 'MPCD_ATOMS' )) then call str_split ( line , ' ' , word ) call str_split ( line , ' ' , word ) num_mpcd_atoms = str_to_i ( word ) mpcd_avnc = str_to_i ( line ) end if if ( str_startswith ( line , 'ATOMS' )) then call str_split ( line , ' ' , word ) num_atoms = str_to_i ( line ) num_atoms_tot = num_mpcd_atoms + num_atoms allocate ( atoms ( num_atoms )) allocate ( charge ( num_atoms )) allocate ( coordinates ( 3 , num_atoms_tot )) do i = 1 , num_atoms read ( fu , * ) atoms ( i ), charge ( i ), coordinates (:, i ) end do end if if ( str_startswith ( line , 'BOND_TYPES' )) then call str_split ( line , ' ' , word ) num_bond_types = str_to_i ( line ) allocate ( bond_styles ( num_bond_types )) allocate ( bond_params ( mxparam , num_bond_types )) bond_params = 0.0_rp do it = 1 , num_bond_types call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) bond_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) bond_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'BONDS' )) then call str_split ( line , ' ' , word ) num_bonds = str_to_i ( line ) allocate ( bonds ( 3 , num_bonds )) do i = 1 , num_bonds read ( fu , * ) bonds (:, i ) end do end if if ( str_startswith ( line , 'ANGLE_TYPES' )) then call str_split ( line , ' ' , word ) num_angle_types = str_to_i ( line ) allocate ( angle_styles ( num_angle_types )) allocate ( angle_params ( mxparam , num_angle_types )) angle_params = 0.0_rp do it = 1 , num_angle_types call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) angle_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) angle_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'ANGLES' )) then call str_split ( line , ' ' , word ) num_angles = str_to_i ( line ) allocate ( angles ( 4 , num_angles )) do i = 1 , num_angles read ( fu , * ) angles (:, i ) end do end if if ( str_startswith ( line , 'DIHEDRAL_TYPES' )) then call str_split ( line , ' ' , word ) num_dihedral_types = str_to_i ( line ) allocate ( dihedral_styles ( num_dihedral_types )) allocate ( dihedral_params ( mxparam , num_dihedral_types )) dihedral_params = 0.0_rp do it = 1 , num_dihedral_types call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) dihedral_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) dihedral_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'DIHEDRALS' )) then call str_split ( line , ' ' , word ) num_dihedrals = str_to_i ( line ) allocate ( dihedrals ( 5 , num_dihedrals )) do i = 1 , num_dihedrals read ( fu , * ) dihedrals (:, i ) end do end if if ( str_startswith ( line , 'BRANCHES' )) then call str_split ( line , ' ' , word ) num_branches = str_to_i ( line ) allocate ( branches ( 3 , num_branches )) do ibr = 1 , num_branches read ( fu , * ) branches (:, ibr ) end do end if if ( str_startswith ( line , 'MOLECULE_TYPES' )) then call str_split ( line , ' ' , word ) num_molecule_types = str_to_i ( line ) allocate ( molecule_names ( num_molecule_types )) allocate ( molecule_pop ( num_molecule_types )) do it = 1 , num_molecule_types read ( fu , * ) molecule_names ( it ), molecule_pop ( it ) end do end if if ( str_startswith ( line , 'MOLECULES' )) then call str_split ( line , ' ' , word ) num_molecules = str_to_i ( line ) allocate ( molecules ( 9 , num_molecules )) do i = 1 , num_molecules read ( fu , * ) molecules (:, i ) end do end if if ( str_startswith ( line , 'TETHER_TYPES' )) then call str_split ( line , ' ' , word ) num_tether_types = str_to_i ( line ) allocate ( tether_styles ( num_tether_types )) allocate ( tether_params ( mxparam , num_tether_types )) tether_params = 0.0_rp do it = 1 , num_tether_types call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) tether_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) tether_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'TETHERS' )) then call str_split ( line , ' ' , word ) num_tethers = str_to_i ( line ) allocate ( tethers ( 2 , num_tethers )) allocate ( tether_points ( 3 , num_tethers )) do i = 1 , num_tethers read ( fu , * ) tethers (:, i ), tether_points (:, i ) end do end if if ( str_startswith ( line , 'VDW' )) then call str_split ( line , ' ' , word ) num_vdw_types = str_to_i ( line ) allocate ( vdw_styles ( num_vdw_types )) allocate ( vdw_pairs ( 2 , num_vdw_types )) allocate ( vdw_params ( mxparam , num_vdw_types )) vdw_params = 0.0_rp do it = 1 , num_vdw_types call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) vdw_pairs ( 1 , it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) vdw_pairs ( 2 , it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) vdw_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) vdw_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'EXTERNAL' )) then call str_split ( line , ' ' , word ) num_externals = str_to_i ( line ) allocate ( external_styles ( num_externals )) allocate ( external_params ( mxparam , num_externals )) external_params = 0.0_rp do it = 1 , num_externals call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) external_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) external_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'FLOW_FIELD' )) then allocate ( flow_params ( mxparam )) flow_params = 0.0_rp call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) flow_style = str_to_i ( word ) if ( flow_style > 0 ) then call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) flow_params ( 1 : npar ) end if end if end if end do close ( fu ) end subroutine !******************************************************************************* subroutine write_config ( fn , title ) !! Write to cfg file character ( len =* ), intent ( in ) :: fn character ( len =* ), intent ( in ) :: title integer :: fu integer :: i , it open ( newunit = fu , file = fn , action = 'write' , status = 'replace' ) write ( fu , '(a)' ) '#' // trim ( adjustl ( title )) write ( fu , '(a)' ) 'version 1.0' write ( fu , * ) write ( fu , '(a)' ) 'SIMBOX' write ( fu , '(3(g0.8,2x))' ) simbox % basis (:, 1 ) write ( fu , '(3(g0.8,2x))' ) simbox % basis (:, 2 ) write ( fu , '(3(g0.8,2x))' ) simbox % basis (:, 3 ) write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'IMCON' , imcon write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ATOM_TYPES' , num_atom_types do it = 1 , num_atom_types write ( fu , '(a,2x,i0,2x,g0.6)' ) trim ( adjustl ( atom_names ( it ))), & atom_styles ( it ), atom_mass ( it ) end do if ( num_mpcd_atoms > 0 ) then write ( fu , * ) write ( fu , '(a,2x, i0,2x,i0)' ) 'MPCD_ATOMS' , num_mpcd_atoms , mpcd_avnc end if write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ATOMS' , num_atoms do i = 1 , num_atoms write ( fu , '(i0,2x,*(g0.14,2x))' ) atoms ( i ), charge ( i ), coordinates (:, i ) end do if ( num_bonds > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'BOND_TYPES' , num_bond_types do it = 1 , num_bond_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) bond_styles ( it ), & size ( bond_params , 1 ), bond_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'BONDS' , num_bonds do i = 1 , num_bonds write ( fu , '(*(i0,2x))' ) bonds (:, i ) end do end if if ( num_angles > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ANGLE_TYPES' , num_angle_types do it = 1 , num_angle_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) angle_styles ( it ), & size ( angle_params , 1 ), angle_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ANGLES' , num_angles do i = 1 , num_angles write ( fu , '(*(i0,2x))' ) angles (:, i ) end do end if if ( num_dihedrals > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'DIHEDRAL_TYPES' , num_dihedral_types do it = 1 , num_dihedral_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) dihedral_styles ( it ), & size ( dihedral_params , 1 ), dihedral_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'DIHEDRALS' , num_dihedrals do i = 1 , num_dihedrals write ( fu , '(*(i0,2x))' ) dihedrals (:, i ) end do end if if ( num_branches > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'BRANCHES' , num_branches do i = 1 , num_branches write ( fu , '(*(i0,2x))' ) branches (:, i ) end do end if write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'MOLECULE_TYPES' , num_molecule_types do it = 1 , num_molecule_types write ( fu , '(a,2x,i0)' ) trim ( adjustl ( molecule_names ( it ))), molecule_pop ( it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'MOLECULES' , num_molecules do i = 1 , num_molecules write ( fu , '(*(i0,2x))' ) molecules (:, i ) end do if ( num_tethers > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'TETHER_TYPES' , num_tether_types do it = 1 , num_tether_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) tether_styles ( it ), & size ( tether_params , 1 ), tether_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'TETHERS' , num_tethers do i = 1 , num_tethers write ( fu , '(2(i0,2x),3(g0.6,2x))' ) tethers (:, i ), tether_points (:, i ) end do end if if ( num_vdw_types > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'VDW' , num_vdw_types do it = 1 , num_vdw_types write ( fu , '(2(i0,2x),i0,2x,i0,2x,*(g0.6,2x))' ) vdw_pairs (:, it ), & vdw_styles ( it ), size ( vdw_params , 1 ), vdw_params (:, it ) end do end if if ( num_externals > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'EXTERNAL' , num_externals do it = 1 , num_externals write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) external_styles ( it ), & size ( external_params , 1 ), external_params (:, it ) end do end if write ( fu , * ) write ( fu , '(a)' ) 'FLOW_FIELD' write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' , advance = 'no' ) flow_style if ( flow_style > 0 ) then write ( fu , '(i0,2x,*(g0.6,2x))' ) size ( flow_params ), flow_params else write ( fu , * ) end if close ( fu ) end subroutine !****************************************************************************** subroutine write_ldf ( fn_ld , title , with_mpcd_atoms ) !! Write to a LAMMPS data file. character ( len =* ), intent ( in ) :: fn_ld !! Name of the file character ( len =* ), intent ( in ) :: title !! Title of the configuation logical , intent ( in ), optional :: with_mpcd_atoms !! Include MPCD atoms in the file? {T, F} real ( rp ), dimension ( 3 ) :: tilt_factors real ( rp ) :: chge logical :: with_mpcd_atoms_ integer :: fu_ld integer :: cntr_atm , iatm_beg , natm integer :: i , iatm , imol if ( present ( with_mpcd_atoms )) then with_mpcd_atoms_ = with_mpcd_atoms else with_mpcd_atoms_ = . false . end if open ( newunit = fu_ld , file = fn_ld , action = 'write' ) !Header write ( fu_ld , '(a)' ) '#' // trim ( adjustl ( title )) if ( with_mpcd_atoms_ ) then write ( fu_ld , '(i0,2x,a)' ) num_atoms_tot , 'atoms' write ( fu_ld , '(i0,2x,a)' ) num_atom_types + 1 , 'atom types' else write ( fu_ld , '(i0,2x,a)' ) num_atoms , 'atoms' write ( fu_ld , '(i0,2x,a)' ) num_atom_types , 'atom types' end if if ( num_bonds > 0 ) then write ( fu_ld , '(i0,2x,a)' ) num_bonds , 'bonds' write ( fu_ld , '(i0,2x,a)' ) num_bond_types , 'bond types' end if if ( num_angles > 0 ) then write ( fu_ld , '(i0,2x,a)' ) num_angles , 'angles' write ( fu_ld , '(i0,2x,a)' ) num_angle_types , 'angle types' end if if ( num_dihedrals > 0 ) then write ( fu_ld , '(i0,2x,a)' ) num_dihedrals , 'dihedrals' write ( fu_ld , '(i0,2x,a)' ) num_dihedral_types , 'dihedral types' end if !Simulation box & tilt factors write ( fu_ld , '(a,2x,g0.6,2x,a)' ) '0.0' , simbox % basis ( 1 , 1 ), 'xlo xhi' write ( fu_ld , '(a,2x,g0.6,2x,a)' ) '0.0' , simbox % basis ( 2 , 2 ), 'ylo yhi' write ( fu_ld , '(a,2x,g0.6,2x,a)' ) '0.0' , simbox % basis ( 3 , 3 ), 'zlo zhi' write ( fu_ld , '(a)' ) '0.0 0.0 0.0 xy xz yz' !TODO: Triclinic box !   tilt_factors(1) = dot_product(simbox%basis(:,1)/norm2(simbox%basis(:,1)), & !       simbox%basis(:,2)/norm2(simbox%basis(:,2))) !   tilt_factors(2) = dot_product(simbox%basis(:,1)/norm2(simbox%basis(:,1)), & !       simbox%basis(:,3)/norm2(simbox%basis(:,3))) !   tilt_factors(3) = dot_product(simbox%basis(:,2)/norm2(simbox%basis(:,2)), & !       simbox%basis(:,3)/norm2(simbox%basis(:,3))) !   tilt_factors = acos(tilt_factors) !   write(fu_ld,'(3(g0.6,2x),a)') tilt_factors, 'xy xz yz' !Body: Atoms write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Atoms # full' write ( fu_ld , * ) cntr_atm = 1 do imol = 1 , num_molecules natm = molecules ( 2 , imol ) iatm_beg = molecules ( 3 , imol ) do i = 1 , natm iatm = iatm_beg + i - 1 write ( fu_ld , '(i0,2x,i0,2x,i0,2x,4(g0.8,2x))' ) cntr_atm , imol , & atoms ( iatm ), charge ( iatm ), coordinates (:, iatm ) cntr_atm = cntr_atm + 1 end do end do if ( with_mpcd_atoms_ ) then imol = 0 ; chge = 0.0_rp !No charge on MPCD atoms do i = num_atoms + 1 , num_atoms_tot write ( fu_ld , '(i0,2x,i0,2x,i0,2x,4(g0.8,2x))' ) cntr_atm , imol , & ( num_atom_types + 1 ), chge , coordinates (:, i ) cntr_atm = cntr_atm + 1 end do end if !Body: Bonds if ( num_bonds > 0 ) then write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Bonds' write ( fu_ld , * ) do i = 1 , num_bonds write ( fu_ld , '(i0,2x,3(i0,2x))' ) i , bonds (:, i ) end do end if !Body: Angles if ( num_angles > 0 ) then write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Angles' write ( fu_ld , * ) do i = 1 , num_angles write ( fu_ld , '(i0,2x,4(i0,2x))' ) i , angles (:, i ) end do end if !Body: Dihedrals if ( num_dihedrals > 0 ) then write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Dihedrals' write ( fu_ld , * ) do i = 1 , num_dihedrals write ( fu_ld , '(i0,2x,5(i0,2x))' ) i , dihedrals (:, i ) end do end if close ( fu_ld ) end subroutine !******************************************************************************* subroutine write_xyz ( fn_xyz , title , with_mpcd_atoms ) !! Write to an XYZ file. character ( len =* ), intent ( in ) :: fn_xyz !! Name of the XYZ file character ( len =* ), intent ( in ) :: title !! Title (for the configuration) logical , intent ( in ), optional :: with_mpcd_atoms !! Include MPCD atoms in the file? {T, F} integer :: iatm integer :: na integer :: fu_xyz if ( present ( with_mpcd_atoms )) then if ( with_mpcd_atoms ) then na = num_atoms_tot else na = num_atoms end if else na = num_atoms end if open ( newunit = fu_xyz , file = fn_xyz , action = 'write' ) write ( fu_xyz , '(i0)' ) na write ( fu_xyz , '(a)' ) title do iatm = 1 , na write ( fu_xyz , '(3(g0.7,2x))' ) coordinates (:, iatm ) end do close ( fu_xyz ) end subroutine !******************************************************************************* end module m_config_io","tags":"","loc":"sourcefile/m_config_io.f90.html"},{"title":"m_setup.f90 – BROWNPAK","text":"Contents Modules m_setup Source Code m_setup.f90 Source Code module m_setup !! Routines for doing allocation, etc. in preparation for simulation run. use m_precision use m_ran_num use m_simbox use m_globals use m_config_io use m_interaction use m_bd_solver use m_mpcd use m_relax use m_stats_io implicit none contains !******************************************************************************* subroutine setup () integer :: ierr ierr = 0 !Initialize random number generator if ( read_seed ) then call init_stream ( 'random_seed.txt' // trim ( adjustl ( job_tag ))) else call init_stream ( '' ) end if if ( write_seed ) call save_seed ( 'random_seed.txt' // trim ( adjustl ( job_tag ))) !Create the simulation box. Its attributes will change later based on input !data. call smbx_init ( simbox ) !Read configuration from files if ( lrevive ) then !Restarting simulation: Read revive file call read_dump ( fn_revive // trim ( adjustl ( job_tag ))) else !New simulation: Read initial configuration file call read_config ( fn_cfg // trim ( adjustl ( job_tag ))) nts = 0 end if !Allocate memory for forces. Forces are not saved in revive file or !in config file as they can be calculated from position data. !MPCD particles do not have any forces acting on them. allocate ( forces ( 3 , num_atoms ) ) forces = 0.0_rp !Initialize stats collection call stats_init () !Set up interactions call ia_setup () !Set up solver. No need to set up for structure relaxation. if ( sim_style == 1 ) then call bds_init ( ierr ) else if ( sim_style == 2 ) then call mpcd_init ( ierr ) end if if ( ierr /= 0 ) call finish () end subroutine !******************************************************************************* subroutine run () if ( sim_style == 0 ) then call rlx_run () else if ( sim_style == 1 ) then call bds_run () else if ( sim_style == 2 ) then call mpcd_run () end if end subroutine !******************************************************************************* subroutine config_clear () !! Clears out all configuration related variables in module `m_globals`. num_atom_types = 0 ; num_atoms = 0 if ( allocated ( atom_names )) deallocate ( atom_names ) if ( allocated ( atom_styles )) deallocate ( atom_styles ) if ( allocated ( atom_mass )) deallocate ( atom_mass ) if ( allocated ( atoms )) deallocate ( atoms ) if ( allocated ( coordinates )) deallocate ( coordinates ) if ( allocated ( velocities )) deallocate ( velocities ) if ( allocated ( forces )) deallocate ( forces ) if ( allocated ( charge )) deallocate ( charge ) num_bond_types = 0 ; num_bonds = 0 if ( allocated ( bond_styles )) deallocate ( bond_styles ) if ( allocated ( bond_params )) deallocate ( bond_params ) if ( allocated ( bonds )) deallocate ( bonds ) num_angle_types = 0 ; num_angles = 0 if ( allocated ( angle_styles )) deallocate ( angle_styles ) if ( allocated ( angle_params )) deallocate ( angle_params ) if ( allocated ( angles )) deallocate ( angles ) num_dihedral_types = 0 ; num_dihedrals = 0 if ( allocated ( dihedral_styles )) deallocate ( dihedral_styles ) if ( allocated ( dihedral_params )) deallocate ( dihedral_params ) if ( allocated ( dihedrals )) deallocate ( dihedrals ) num_branches = 0 if ( allocated ( branches )) deallocate ( branches ) num_molecule_types = 0 ; num_molecules = 0 if ( allocated ( molecule_names )) deallocate ( molecule_names ) if ( allocated ( molecule_pop )) deallocate ( molecule_pop ) if ( allocated ( molecules )) deallocate ( molecules ) num_tether_types = 0 ; num_tethers = 0 if ( allocated ( tether_styles )) deallocate ( tether_styles ) if ( allocated ( tether_params )) deallocate ( tether_params ) if ( allocated ( tethers )) deallocate ( tethers ) if ( allocated ( tether_points )) deallocate ( tether_points ) num_vdw_types = 0 if ( allocated ( vdw_styles )) deallocate ( vdw_styles ) if ( allocated ( vdw_params )) deallocate ( vdw_params ) if ( allocated ( vdw_pairs )) deallocate ( vdw_pairs ) num_externals = 0 if ( allocated ( external_styles )) deallocate ( external_styles ) if ( allocated ( external_params )) deallocate ( external_params ) if ( allocated ( flow_params )) deallocate ( flow_params ) end subroutine !******************************************************************************* subroutine finish () if ( sim_style == 1 ) then call bds_finish () else if ( sim_style == 2 ) then call mpcd_finish () end if call ia_finish () call stats_finish () call config_clear () end subroutine !******************************************************************************* end module m_setup","tags":"","loc":"sourcefile/m_setup.f90.html"},{"title":"m_simbox.f90 – BROWNPAK","text":"Contents Modules m_simbox Source Code m_simbox.f90 Source Code module m_simbox !! Implements a simulation box with appropriate boundary conditions. use m_precision use m_constants_math use m_ran_num implicit none type smbx_t real ( rp ), dimension ( 3 , 3 ) :: basis real ( rp ), dimension ( 3 , 3 ) :: dl_basis real ( rp ) :: volume logical :: is_deforming logical :: is_aligned !! Whether the basis vectors are aligned with the laboratory frame contains procedure :: set_basis => smbx_set_basis procedure :: freeze => smbx_freeze procedure :: unfreeze => smbx_unfreeze procedure :: get_image => smbx_get_image procedure :: wrap_all => smbx_wrap_all procedure :: to_center => smbx_to_center procedure :: get_rnd_points => smbx_get_rnd_points end type smbx_t contains !******************************************************************************** subroutine smbx_init ( this ) !!Creates an instance of *smbx_t*. Can also be called to reset. type ( smbx_t ), intent ( in out ) :: this !Initialize to an identity matrix this % basis = 0.0_rp this % basis ( 1 , 1 ) = 1.0_rp this % basis ( 2 , 2 ) = 1.0_rp this % basis ( 3 , 3 ) = 1.0_rp this % volume = 1.0_rp this % dl_basis = this % basis this % is_deforming = . false . this % is_aligned = . true . end subroutine !******************************************************************************** subroutine smbx_set_basis ( this , bv ) !!Sets all three basis vectors. class ( smbx_t ), intent ( in out ) :: this real ( rp ), dimension ( 3 , 3 ), intent ( in ) :: bv real ( rp ), dimension ( 3 ) :: a , b , c this % basis = bv a = this % basis (:, 1 ); b = this % basis (:, 2 ); c = this % basis (:, 3 ) this % volume = a ( 1 ) * ( b ( 2 ) * c ( 3 ) - c ( 2 ) * b ( 3 ) ) - a ( 2 ) * ( b ( 1 ) * c ( 3 ) - c ( 1 ) * b ( 3 ) ) & + a ( 3 ) * ( b ( 1 ) * c ( 2 ) - c ( 1 ) * b ( 2 ) ) end subroutine !******************************************************************************** subroutine smbx_freeze ( this ) !!Specifies *this* as non-deforming. class ( smbx_t ), intent ( in out ) :: this this % is_deforming = . false . end subroutine !******************************************************************************** subroutine smbx_unfreeze ( this ) !!Specifies *this* as deforming. class ( smbx_t ), intent ( in out ) :: this this % is_deforming = . true . end subroutine !******************************************************************************** subroutine smbx_get_image ( this , r ) !!Returns the image of *r* under PBC. !https://scicomp.stackexchange.com/questions/20165/periodic-boundary-conditions-for-triclinic-box class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension ( 3 ), intent ( in out ) :: r real ( rp ), dimension ( 3 ) :: rf if ( this % is_aligned ) then r ( 1 ) = r ( 1 ) - this % basis ( 1 , 1 ) * nint ( r ( 1 ) / this % basis ( 1 , 1 ) ) r ( 2 ) = r ( 2 ) - this % basis ( 2 , 2 ) * nint ( r ( 2 ) / this % basis ( 2 , 2 ) ) r ( 3 ) = r ( 3 ) - this % basis ( 3 , 3 ) * nint ( r ( 3 ) / this % basis ( 3 , 3 ) ) else rf = matmul ( this % dl_basis , r ) rf = rf - nint ( rf ) r = matmul ( this % basis , rf ) end if end subroutine !******************************************************************************** subroutine smbx_wrap_all ( this , coords ) !!Wraps atom positions w.r.t. periodic boundary conditions. !https://scicomp.stackexchange.com/questions/20165/periodic-boundary-conditions-for-triclinic-box class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension (:,:), intent ( in out ) :: coords real ( rp ), dimension ( 3 ) :: rf real ( rp ), dimension ( 3 ) :: diag integer :: n , i n = size ( coords , 2 ) if ( this % is_aligned ) then diag = [ this % basis ( 1 , 1 ), this % basis ( 2 , 2 ), this % basis ( 3 , 3 )] do i = 1 , n coords (:, i ) = coords (:, i ) - diag * floor ( coords (:, i ) / diag ) end do else do i = 1 , n rf = matmul ( this % dl_basis , coords (:, i )) rf = rf - floor ( rf ) coords (:, i ) = matmul ( this % basis , rf ) end do end if end subroutine !******************************************************************************** subroutine smbx_to_center ( this , coords , com ) !!Adjusts atom positions such that the c.o.m. of the atoms is at the center !! of the box. Assumes all atoms to have the same mass and aligned axis. !! Optionally returns the original c.o.m. class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension (:,:), intent ( in out ) :: coords real ( rp ), dimension ( 3 ), intent ( out ), optional :: com real ( rp ), dimension ( 3 ) :: half_diag , com_ integer :: n , i half_diag = 0.5_rp * [ this % basis ( 1 , 1 ), this % basis ( 2 , 2 ), this % basis ( 3 , 3 )] n = size ( coords , 2 ) com_ = sum ( coords , 2 ) / n do i = 1 , n coords (:, i ) = coords (:, i ) - com_ + half_diag end do if ( present ( com )) com = com_ - half_diag end subroutine !******************************************************************************** subroutine smbx_get_rnd_points ( this , coords ) !!Returns uniformly distributed points within the box. class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension (:,:), intent ( out ) :: coords real ( rp ), dimension ( 3 ) :: r integer :: n , i n = size ( coords , 2 ) do i = 1 , n call get_rv_uniform ( 0.0_rp , 1.0_rp , r ) coords (:, i ) = matmul ( this % basis , r ) end do end subroutine !******************************************************************************** end module m_simbox","tags":"","loc":"sourcefile/m_simbox.f90.html"},{"title":"m_mpcd.f90 – BROWNPAK","text":"Contents Modules m_mpcd Source Code m_mpcd.f90 Source Code module m_mpcd !! Routines implementing the MPCD solver. use m_precision use m_constants_math use m_utils_math use m_strings use m_logger use m_ran_num use m_globals use m_cell_list use m_interaction , only : ia_calc_forces use m_stats_io use m_config_io use f95_precision use lapack95 implicit none private public :: mpcd_init , mpcd_run , mpcd_finish real ( rp ), dimension (:), allocatable :: mass !! *(num_atoms_tot,)* array. Stores mass of each atom (including MPCD !! atoms). The mass of each MPCD atom is taken as unity. real ( rp ), dimension (:), allocatable :: buf_aic !! Buffer for atoms in cell storing mass, coordinates, & velocities. !! For *nc* atoms, the first *nc* elements stores the mass, the next !! *3\\*nc* elements stores the coordinates, and the next *3\\*nc* elements !! store the velocities. The velocities part of this buffer may be overwritten !! for relative velocity calculations. contains !******************************************************************************* subroutine mpcd_init ( ierr ) !! Initializes the MPCD solver. integer , intent ( out ) :: ierr integer :: i , at_i logical :: lexists ierr = 0 !Allocate memory for velocities if ( . not . allocated ( velocities ) ) then allocate ( velocities ( 3 , num_atoms_tot ) ) velocities = 0.0_rp end if !Mass of each atom if ( . not . allocated ( mass ) ) then allocate ( mass ( num_atoms_tot ) ) mass = 1.0_rp do i = 1 , num_atoms at_i = atoms ( i ) mass ( i ) = atom_mass ( at_i ) end do end if !In case of new simulation, need to assign MPCD atom positions. if (. not . lrevive ) then call simbox % get_rnd_points ( coordinates (:, num_atoms + 1 : num_atoms_tot ) ) end if !Allocate buffer for atoms in a cell. Setting it to thrice the average !number of MPCD atoms per cell. Each atom has 7 quantities (mass, !coordinates, & velocities) associated with it. The buffer will be expanded !if necessary. allocate ( buf_aic ( 7 * ( 3 * mpcd_avnc )) ) buf_aic = 0.0_rp !Opening trajectory file if ( write_traj ) then if ( lrevive ) then !Append (write) to existing (new) trajectory file !Check if trajectory file exists inquire ( file = fn_traj // trim ( adjustl ( job_tag )), exist = lexists ) if ( lexists ) then !Open existing file for appending call traj % open ( fn_traj // trim ( adjustl ( job_tag )), 'rw' , ierr ) if ( ierr /= 0 ) return else !Create new trajectory file if ( traj_wmpcd ) then !With MPCD data call traj % create ( fn_traj // trim ( adjustl ( job_tag )), & num_atoms , num_mpcd_atoms , traj_frmcmp ) else !Without MPCD data call traj % create ( fn_traj // trim ( adjustl ( job_tag )), & num_atoms , 0 , traj_frmcmp ) end if end if else !Create new trajectory file if ( traj_wmpcd ) then !With MPCD data call traj % create ( fn_traj // trim ( adjustl ( job_tag )), & num_atoms , num_mpcd_atoms , traj_frmcmp ) else !Without MPCD data call traj % create ( fn_traj // trim ( adjustl ( job_tag )), & num_atoms , 0 , traj_frmcmp ) end if end if end if end subroutine !****************************************************************************** subroutine mpcd_finish () !! Clean up MPCD solver. if ( allocated ( mass )) deallocate ( mass ) if ( allocated ( buf_aic )) deallocate ( buf_aic ) call traj % close () end subroutine !****************************************************************************** subroutine mpcd_run () !! Driver for MPCD integrator. !! !! Repeatedly calls [[mpcd_stream]] and [[mpcd_collide]] to update atom !! positions. !! !! Handling of flow field is not imlemented yet. If a non-zero `flow_style` !! is specified, it will be set to zero. integer :: ierr ierr = 0 if ( flow_style /= 0 ) flow_style = 0 !Log & dump starting configuration call logger % log_msg ( '<mpcd_run> nts: ' // str_from_num ( nts )) call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) !Production run do while ( nts < nts_sim ) call mpcd_stream ( ierr ) if ( ierr /= 0 ) return call mpcd_collide () nts = nts + 1 !Logging if ( mod ( nts , nts_log ) == 0 ) then call logger % log_msg ( '<mpcd_run> nts: ' // str_from_num ( nts )) end if !Dump revive file if ( mod ( nts , nts_dump ) == 0 ) then call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end if if ( mod ( nts , nts_samp ) == 0 ) then !Write stats call stats_write () !Write traj if ( write_traj ) call traj % append_frame ( nts , coordinates , & velocities , forces , charge ) end if end do !Dump the final configuration call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end subroutine !****************************************************************************** subroutine mpcd_stream ( ierr ) !! Performs one step of streaming. integer , intent ( out ) :: ierr real ( rp ) :: dt_md real ( rp ) :: half_dt integer :: i , istp dt_md = tim_stp / nts_md half_dt = 0.5_rp * dt_md istp = 0 !Set cell size to collision cells if ( use_cell_list ) call cl_set_cell_size ( rcutoff ) !Setting these to zero for the case num_atoms = 0. energy_tot = 0.0_rp stress = 0.0_rp !Update non-MPCD atoms via MD steps if ( num_atoms > 0 ) then do while ( istp < nts_md ) !Update velocities over a half-step do i = 1 , num_atoms velocities (:, i ) = velocities (:, i ) + half_dt * forces (:, i ) / mass ( i ) end do !Update position over full step do i = 1 , num_atoms coordinates (:, i ) = coordinates (:, i ) + dt_md * velocities (:, i ) end do !Wrap around periodic boundaries call simbox % wrap_all ( coordinates (:, 1 : num_atoms )) !Update forces over full step call ia_calc_forces ( ierr ) if ( ierr /= 0 ) return !Update velocities over full step do i = 1 , num_atoms velocities (:, i ) = velocities (:, i ) + half_dt * forces (:, i ) / mass ( i ) end do istp = istp + 1 end do end if !Update MPCD particles over a streaming step do i = num_atoms + 1 , num_atoms_tot coordinates (:, i ) = coordinates (:, i ) + tim_stp * velocities (:, i ) end do !Wrap MPCD particles around periodic boundaries call simbox % wrap_all ( coordinates (:, num_atoms + 1 :)) end subroutine !****************************************************************************** subroutine mpcd_collide () !! Performs one step of MPCD collision. real ( rp ), dimension ( 3 ) :: gsv real ( rp ), dimension ( 3 ) :: ri , vi , com , vcom , vrcom real ( rp ), dimension ( 3 ) :: angmom , angvel real ( rp ), dimension ( 3 , 3 ) :: mat_mi , inv_mat_mi real ( rp ), dimension ( 3 , 3 ) :: stress_kin integer , dimension (:), pointer :: aic => null () real ( rp ) :: mass_tot , massi , var integer :: num_cells , na_cell integer :: ofstc , ofstv integer :: i , iatm , icell , ibeg , iend !Grid shift vector call get_rv_uniform ( - 0.5_rp , 0.5_rp , gsv ) !Forward shift do i = 1 , num_atoms_tot coordinates (:, i ) = coordinates (:, i ) + gsv end do !Wrap around periodic boundaries call simbox % wrap_all ( coordinates ) !Set cell size to collision cells call cl_set_cell_size ( 1.0_rp ) call cl_build ( coordinates ) num_cells = cl_get_num_cells () !Momentum exchange via collision, velocity update (MPC-AT+a version) !Loop over all collision cells do icell = 0 , ( num_cells - 1 ) !Get cell contents call cl_get_contents ( icell , aic ) !Number of atoms in cell na_cell = size ( aic ) !For fewer than 2 atoms, no need for relative velocities. if ( na_cell < 2 ) cycle !Check if cell velocity buffer needs to be expanded if ( size ( buf_aic ) < 7 * na_cell ) then deallocate ( buf_aic ) allocate ( buf_aic ( 7 * na_cell ) ) end if !Populate buf_aic ofstc = na_cell ; ofstv = na_cell + 3 * na_cell do i = 1 , size ( aic ) iatm = aic ( i ) buf_aic ( i ) = mass ( iatm ) ibeg = ofstc + 3 * i - 2 ; iend = ofstc + 3 * i buf_aic ( ibeg : iend ) = coordinates (:, iatm ) ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i buf_aic ( ibeg : iend ) = velocities (:, iatm ) end do !Total mass, center-of-mass, & c.o.m. velocity com = 0.0_rp ; vcom = 0.0_rp ; mass_tot = 0.0_rp do i = 1 , na_cell mass_tot = mass_tot + buf_aic ( i ) ibeg = ofstc + 3 * i - 2 ; iend = ofstc + 3 * i com = com + buf_aic ( i ) * buf_aic ( ibeg : iend ) ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i vcom = vcom + buf_aic ( i ) * buf_aic ( ibeg : iend ) end do com = com / mass_tot vcom = vcom / mass_tot !Draw relative velocities & store in the buf_aic. This overwrites the !existing velocities. ibeg = ofstv + 1 ; iend = ofstv + 3 * na_cell call get_rv_gaussian ( 0.0_rp , 1.0_rp , buf_aic ( ibeg : iend ) ) !Multiply by the variance, i.e. kT/m do i = 1 , na_cell var = 1.0_rp / buf_aic ( i ) ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i buf_aic ( ibeg : iend ) = var * buf_aic ( ibeg : iend ) end do !Calcuate the mean of the relative velocities. vrcom = 0.0_rp do i = 1 , na_cell ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i vrcom = vrcom + buf_aic ( i ) * buf_aic ( ibeg : iend ) end do vrcom = vrcom / mass_tot !Subtract off the c.o.m. position & vrcom do i = 1 , na_cell ibeg = ofstc + 3 * i - 2 ; iend = ofstc + 3 * i buf_aic ( ibeg : iend ) = buf_aic ( ibeg : iend ) - com ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i buf_aic ( ibeg : iend ) = buf_aic ( ibeg : iend ) - vrcom end do !Add the relative velocities to the c.o.m. velocity. This produces new !velocities that do not conserve angular momentum, i.e. this is !MPC-AT-a. do i = 1 , na_cell ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i buf_aic ( ibeg : iend ) = buf_aic ( ibeg : iend ) + vcom end do !For only two atoms in the cell, the above is equivalent to MPC-AT+a. !Just copy the velocities back and move on to the next cell. if ( na_cell == 2 ) then !Explicitly unrolling the loop over i as i = 1 & i = 2. i = 1 ; iatm = aic ( i ); ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i velocities (:, iatm ) = buf_aic ( ibeg : iend ) i = 2 ; iatm = aic ( i ); ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i velocities (:, iatm ) = buf_aic ( ibeg : iend ) cycle end if !Calculate moment of intertia matrix (symmetric) about the c.o.m. and angular !momentum. mat_mi = 0.0_rp ; angmom = 0.0_rp do i = 1 , na_cell massi = buf_aic ( i ) ri = buf_aic ( ofstc + 3 * i - 2 : ofstc + 3 * i ) mat_mi ( 1 , 1 ) = mat_mi ( 1 , 1 ) + massi * ( ri ( 2 ) ** 2 + ri ( 3 ) ** 2 ) mat_mi ( 2 , 1 ) = mat_mi ( 2 , 1 ) - massi * ( ri ( 2 ) * ri ( 1 ) ) mat_mi ( 3 , 1 ) = mat_mi ( 3 , 1 ) - massi * ( ri ( 3 ) * ri ( 1 ) ) mat_mi ( 2 , 2 ) = mat_mi ( 2 , 2 ) + massi * ( ri ( 1 ) ** 2 + ri ( 3 ) ** 2 ) mat_mi ( 3 , 2 ) = mat_mi ( 3 , 2 ) - massi * ( ri ( 3 ) * ri ( 2 ) ) mat_mi ( 3 , 3 ) = mat_mi ( 3 , 3 ) + massi * ( ri ( 1 ) ** 2 + ri ( 2 ) ** 2 ) vi = buf_aic ( ofstv + 3 * i - 2 : ofstv + 3 * i ) call cross ( ri , vi , vrcom ) !Using vrcom as a buffer here angmom = angmom + massi * vrcom end do !Update the symmetric elements mat_mi ( 1 , 2 ) = mat_mi ( 2 , 1 ) mat_mi ( 1 , 3 ) = mat_mi ( 3 , 1 ) mat_mi ( 2 , 3 ) = mat_mi ( 3 , 2 ) !Solve for angular velocity. If the mat_mi is singular, do a least !squares solutions. Else, get the explicit inverse and multiply. !Checking determinant against a small value 1E-8. if ( det ( mat_mi ) > 1.0E-10_rp ) then !Invert the moment of inertia matrix call invert_mat33 ( mat_mi , inv_mat_mi ) !Solve for angular velocity angvel = matmul ( inv_mat_mi , - angmom ) else !TODO: The following must be replaced with a more efficient SVD !routine for 3 x 3 matrices. As of now, calling LAPACK for !least-squares solution. angmom = - angmom call gelsy ( mat_mi , angmom ) angvel = angmom end if !Correct velocities to enforce angular mometum conservation do i = 1 , na_cell iatm = aic ( i ) massi = buf_aic ( i ) ri = buf_aic ( ofstc + 3 * i - 2 : ofstc + 3 * i ) call cross ( angvel , ri , vi ) !Using vi as a buffer here ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i buf_aic ( ibeg : iend ) = buf_aic ( ibeg : iend ) + vi end do !Copy back do i = 1 , na_cell iatm = aic ( i ) ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i velocities (:, iatm ) = buf_aic ( ibeg : iend ) end do end do !Reverse shift do i = 1 , num_atoms_tot coordinates (:, i ) = coordinates (:, i ) - gsv end do !Wrap around periodic boundaries call simbox % wrap_all ( coordinates ) !Update energy and stress energy_kin = 0.0_rp stress_kin = 0.0_rp stress_slvnt = 0.0_rp mass_tot = 0.0_rp ; com = 0.0_rp ; vcom = 0.0_rp do i = 1 , num_atoms_tot massi = mass ( i ) mass_tot = mass_tot + massi com = com + massi * coordinates (:, i ) vcom = vcom + massi * velocities (:, i ) end do com = com / mass_tot vcom = vcom / mass_tot do i = 1 , num_atoms massi = mass ( i ) energy_kin = energy_kin + 0.5_rp * massi * sum ( velocities (:, i ) ** 2 ) vi = velocities (:, i ) - vcom stress_kin ( 1 , 1 ) = stress_kin ( 1 , 1 ) + massi * vi ( 1 ) * vi ( 1 ) stress_kin ( 2 , 1 ) = stress_kin ( 2 , 1 ) + massi * vi ( 2 ) * vi ( 1 ) stress_kin ( 3 , 1 ) = stress_kin ( 3 , 1 ) + massi * vi ( 3 ) * vi ( 1 ) stress_kin ( 1 , 2 ) = stress_kin ( 1 , 2 ) + massi * vi ( 1 ) * vi ( 2 ) stress_kin ( 2 , 2 ) = stress_kin ( 2 , 2 ) + massi * vi ( 2 ) * vi ( 2 ) stress_kin ( 3 , 2 ) = stress_kin ( 3 , 2 ) + massi * vi ( 3 ) * vi ( 2 ) stress_kin ( 1 , 3 ) = stress_kin ( 1 , 3 ) + massi * vi ( 1 ) * vi ( 3 ) stress_kin ( 2 , 3 ) = stress_kin ( 2 , 3 ) + massi * vi ( 2 ) * vi ( 3 ) stress_kin ( 3 , 3 ) = stress_kin ( 3 , 3 ) + massi * vi ( 3 ) * vi ( 3 ) end do do i = num_atoms + 1 , num_atoms_tot !Mass of MPCD particles is 1 (non-dimensionalized form). energy_kin = energy_kin + 0.5_rp * sum ( velocities (:, i ) ** 2 ) vi = velocities (:, i ) - vcom stress_slvnt ( 1 , 1 ) = stress_slvnt ( 1 , 1 ) + vi ( 1 ) * vi ( 1 ) stress_slvnt ( 2 , 1 ) = stress_slvnt ( 2 , 1 ) + vi ( 2 ) * vi ( 1 ) stress_slvnt ( 3 , 1 ) = stress_slvnt ( 3 , 1 ) + vi ( 3 ) * vi ( 1 ) stress_slvnt ( 1 , 2 ) = stress_slvnt ( 1 , 2 ) + vi ( 1 ) * vi ( 2 ) stress_slvnt ( 2 , 2 ) = stress_slvnt ( 2 , 2 ) + vi ( 2 ) * vi ( 2 ) stress_slvnt ( 3 , 2 ) = stress_slvnt ( 3 , 2 ) + vi ( 3 ) * vi ( 2 ) stress_slvnt ( 1 , 3 ) = stress_slvnt ( 1 , 3 ) + vi ( 1 ) * vi ( 3 ) stress_slvnt ( 2 , 3 ) = stress_slvnt ( 2 , 3 ) + vi ( 2 ) * vi ( 3 ) stress_slvnt ( 3 , 3 ) = stress_slvnt ( 3 , 3 ) + vi ( 3 ) * vi ( 3 ) end do energy_tot = energy_tot + energy_kin stress_kin = stress_kin / simbox % volume stress = stress + stress_kin stress_slvnt = stress_slvnt / simbox % volume end subroutine !****************************************************************************** end module m_mpcd","tags":"","loc":"sourcefile/m_mpcd.f90.html"},{"title":"m_bd_solver.f90 – BROWNPAK","text":"Contents Modules m_bd_solver Source Code m_bd_solver.f90 Source Code module m_bd_solver !! Routines implementing Brownian Dynamics (BD) solver. use iso_c_binding , only : c_loc , c_ptr , c_f_pointer use mkl_blas use mkl_rci use m_precision use m_constants_math use m_logger use m_globals use m_interaction use m_brown use m_stats_io use m_config_io implicit none private public :: bds_init , bds_run , bds_finish integer :: cntr_mobsam real ( rp ) :: sqrt_two_dt integer :: nlmxitr = 150 integer :: lmxitr = 150 real ( rp ) :: tol_res = 1.0e-6_rp real ( rp ) :: tol_upd = 1.0e-8_rp real ( rp ) :: atol = 0.0_rp real ( rp ) :: rtol = 1.0e-6_rp real ( rp ), dimension (: ), allocatable :: drift real ( rp ), dimension (:,:), allocatable :: diffusion real ( rp ), dimension (:,:), allocatable :: mob real ( rp ), dimension (:), allocatable :: crd0 real ( rp ), dimension (:), allocatable :: crdk real ( rp ), dimension (:), allocatable :: fvalk real ( rp ), dimension (:), allocatable :: fval real ( rp ), dimension (:), allocatable :: rhs real ( rp ), dimension (:), allocatable :: sol real ( rp ), dimension (:), allocatable :: fgmres_tmp real ( rp ), dimension (:), allocatable :: crdn real ( rp ), dimension (:), allocatable :: h2 real ( rp ), dimension (:), allocatable :: h3 real ( rp ), dimension (:), pointer :: pvcrd real ( rp ), dimension (:), pointer :: pvfrc contains !******************************************************************************* subroutine bds_init ( ierr ) !! Initializes the BD solver. integer , intent ( out ) :: ierr integer :: ltmp logical :: lexists type ( c_ptr ) :: loc ierr = 0 sqrt_two_dt = sqrt ( 2.0_rp * tim_stp ) !Assign pointers loc = c_loc ( coordinates ) call c_f_pointer ( loc , pvcrd , [ 3 * num_atoms ]) loc = c_loc ( forces ) call c_f_pointer ( loc , pvfrc , [ 3 * num_atoms ]) !Allocate memory for BD drift-diffusion SDE if ( bdintg == 'EM' ) then allocate ( drift ( 3 * num_atoms )) if ( lhdia ) then allocate ( mob ( 3 * num_atoms , 3 * num_atoms )) allocate ( diffusion ( 3 * num_atoms , nts_mobsam )) if ( mob_fctr == 'CHOL' ) then call brn_init ( 3 * num_atoms , nts_mobsam , mob_fctr ) else if ( mob_fctr == 'LANC' ) then call brn_init ( 3 * num_atoms , nts_mobsam , mob_fctr , & lanc_mxitr , lanc_tol ) end if cntr_mobsam = 0 else allocate ( diffusion ( 3 * num_atoms , 1 )) end if end if if ( bdintg == 'SE' ) then allocate ( crd0 ( 3 * num_atoms )) allocate ( crdk ( 3 * num_atoms )) allocate ( fvalk ( 3 * num_atoms )) allocate ( fval ( 3 * num_atoms )) allocate ( rhs ( 3 * num_atoms )) allocate ( sol ( 3 * num_atoms )) ltmp = ( 2 * lmxitr + 1 ) * 3 * num_atoms + lmxitr * ( lmxitr + 9 ) / 2 + 1 allocate ( fgmres_tmp ( ltmp )) allocate ( drift ( 3 * num_atoms )) if ( lhdia ) then allocate ( mob ( 3 * num_atoms , 3 * num_atoms )) allocate ( diffusion ( 3 * num_atoms , nts_mobsam )) if ( mob_fctr == 'CHOL' ) then call brn_init ( 3 * num_atoms , nts_mobsam , mob_fctr ) else if ( mob_fctr == 'LANC' ) then call brn_init ( 3 * num_atoms , nts_mobsam , mob_fctr , & lanc_mxitr , lanc_tol ) end if cntr_mobsam = 0 else allocate ( diffusion ( 3 * num_atoms , 1 )) end if end if if ( bdintg == 'RK' ) then !Works only with `mob_fctr = CHOL` allocate ( crdn ( 3 * num_atoms )) allocate ( h2 ( 3 * num_atoms )) allocate ( h3 ( 3 * num_atoms )) allocate ( drift ( 3 * num_atoms )) if ( lhdia ) then allocate ( mob ( 3 * num_atoms , 3 * num_atoms )) allocate ( diffusion ( 3 * num_atoms , 2 * nts_mobsam )) call brn_init ( 3 * num_atoms , 2 * nts_mobsam , 'CHOL' ) cntr_mobsam = 0 else allocate ( diffusion ( 3 * num_atoms , 2 )) end if end if !Opening trajectory file if ( write_traj ) then if ( lrevive ) then !Append (write) to existing (new) trajectory file !Check if trajectory file exists inquire ( file = fn_traj // trim ( adjustl ( job_tag )), exist = lexists ) if ( lexists ) then !Open existing file for appending call traj % open ( fn_traj // trim ( adjustl ( job_tag )), 'rw' , ierr ) if ( ierr /= 0 ) return else !Create new trajectory file call traj % create ( fn_traj // trim ( adjustl ( job_tag )), num_atoms , & 0 , traj_frmcmp ) end if else !Create new trajectory file call traj % create ( fn_traj // trim ( adjustl ( job_tag )), num_atoms , & 0 , traj_frmcmp ) end if end if end subroutine !****************************************************************************** subroutine bds_finish () !! Clears up memory allocated in [[bds_init]]. call brn_finish () call traj % close () if ( allocated ( mob )) deallocate ( mob ) if ( allocated ( drift )) deallocate ( drift ) if ( allocated ( diffusion )) deallocate ( diffusion ) if ( allocated ( crd0 )) deallocate ( crd0 ) if ( allocated ( crdk )) deallocate ( crdk ) if ( allocated ( fvalk )) deallocate ( fvalk ) if ( allocated ( fval )) deallocate ( fval ) if ( allocated ( rhs )) deallocate ( rhs ) if ( allocated ( sol )) deallocate ( sol ) if ( allocated ( fgmres_tmp )) deallocate ( fgmres_tmp ) if ( allocated ( crdn )) deallocate ( crdn ) if ( allocated ( h2 )) deallocate ( h2 ) if ( allocated ( h3 )) deallocate ( h3 ) end subroutine !****************************************************************************** subroutine bds_run () !! Driver for BD integrator. !! !! Repeatedly calls [[integrate_em]] or [[integrate_se]] or [[integrate_rk]] !! to update atom positions. real ( rp ), dimension ( 3 ) :: com real ( rp ), dimension ( 3 , 3 ) :: delta integer :: ierr integer :: counter ierr = 0 !For isolated untethered molecule, ensure c.o.m. is at the center of the !box. if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) then call simbox % to_center ( coordinates ) end if !Log & dump starting configuration call logger % log_msg ( 'nts = ' // str_from_num ( nts )) call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) counter = 0 do while ( nts < nts_sim ) if ( bdintg == 'EM' ) then call integrate_em ( ierr ) else if ( bdintg == 'SE' ) then call integrate_se ( ierr ) else if ( bdintg == 'RK' ) then call integrate_rk ( ierr ) end if if ( ierr /= 0 ) return !Accumulate stress counter = counter + 1 delta = stress - stress_accu stress_accu = stress_accu + ( delta / counter ) nts = nts + 1 !Apply boundary conditions: For isolated untethered molecule, !update molecule_com & bring c.o.m. to the center of the box. if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) then call simbox % to_center ( coordinates , com ) molecule_com = molecule_com + com end if !For PBC, wrap atom positions if ( imcon /= 0 ) call simbox % wrap_all ( coordinates ) !Logging if ( mod ( nts , nts_log ) == 0 ) then call logger % log_msg ( 'nts = ' // str_from_num ( nts )) end if !Dump revive file if ( mod ( nts , nts_dump ) == 0 ) then call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end if if ( mod ( nts , nts_samp ) == 0 ) then !Write stats call stats_write () !Write traj if ( write_traj ) call traj % append_frame ( nts , coordinates , & velocities , forces , charge ) !Empty stress accumulator stress_accu = 0.0_rp ; counter = 0 end if end do !Dump the final configuration call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end subroutine !****************************************************************************** subroutine integrate_em ( ierr ) !! Performs one step of BD integration using explicit Euler-Maruyama scheme. integer , intent ( out ) :: ierr ierr = 0 !Calculate the diffusion term call calc_diffusion ( ierr ) if ( ierr /= 0 ) return !Calculate the drift term call calc_drift ( ierr ) if ( ierr /= 0 ) return !Update positions if ( lhdia ) then pvcrd = pvcrd + drift + diffusion (:, cntr_mobsam ) if ( cntr_mobsam == nts_mobsam ) cntr_mobsam = 0 else pvcrd = pvcrd + drift + diffusion (:, 1 ) end if end subroutine !****************************************************************************** subroutine integrate_se ( ierr ) !! Performs one step of BD integration using semi-implicit Euler scheme. integer , intent ( out ) :: ierr real ( rp ) :: err_res , err_upd real ( rp ) :: nrm2_fval0 integer :: k , itercount logical :: lconv character ( len = 256 ) :: msg ierr = 0 ; lconv = . false . !Calculate the diffusion term call calc_diffusion ( ierr ) if ( ierr /= 0 ) return !Evaluate the nonlinear function arising out of discretizing the SDE in !semi-implicit form crd0 = pvcrd !Coordinates at the end of last time step call se_calc_fval ( ierr ) if ( ierr /= 0 ) return !Save the norm of the function value nrm2_fval0 = norm2 ( fval ) !Update coordinates via NR iterations do k = 1 , nlmxitr !Save the coordinates and the function value crdk = pvcrd ; fvalk = fval !Solve the linear system call se_linsolve ( lconv , itercount , ierr ) if ( lconv ) then !write(msg,'(a,i0,a)')  & !    'fgmres iterations at convergence = ', itercount !call logger%log_msg(msg) else write ( msg , '(a)' ) 'fgmres failed to converge' call logger % log_msg ( msg ) end if if ( ierr /= 0 ) return !Update the coordinates pvcrd = crdk + 0.25_rp * sol !Evaluate the function call se_calc_fval ( ierr ) if ( ierr /= 0 ) return !Calculate errors err_upd = norm2 ( sol ) / norm2 ( pvcrd ) err_res = norm2 ( fval ) / nrm2_fval0 !write(*,*) 'err_upd = ', err_upd, ' err_res = ', err_res lconv = . false . if (( err_upd <= tol_upd ) . or . ( err_res <= tol_res )) then lconv = . true . !write(msg,'(a,i0)') 'newton iterations at convergence = ', k !call logger%log_msg(msg) exit end if end do if (. not . lconv ) then write ( msg , '(a,es12.5)' ) 'newton iterations not converged. err_res = ' , & err_res call logger % log_msg ( msg ) ierr = 1 end if if ( lhdia ) then if ( cntr_mobsam == nts_mobsam ) cntr_mobsam = 0 end if end subroutine !****************************************************************************** subroutine se_calc_fval ( ierr ) integer , intent ( out ) :: ierr ierr = 0 ; fval = 0.0_rp call calc_drift ( ierr ) if ( ierr /= 0 ) return if ( lhdia ) then fval = pvcrd - drift - crd0 - diffusion (:, cntr_mobsam ) else fval = pvcrd - drift - crd0 - diffusion (:, 1 ) end if end subroutine !****************************************************************************** subroutine se_linsolve ( lconv , itercount , ierr ) !! Solves the linear system using fgmres. logical , intent ( out ) :: lconv integer , intent ( out ) :: itercount integer , intent ( out ) :: ierr real ( rp ) :: nrm2crdk , nrm2v , epsn , eps , reps integer :: ibeg , iend integer :: n , rci_request integer , dimension ( 128 ) :: ipar real ( rp ), dimension ( 128 ) :: dpar character ( len = 256 ) :: msg lconv = . false .; ierr = 0 nrm2crdk = norm2 ( crdk ) epsn = sqrt ( epsilon ( 0.0_rp ) * ( 1.0_rp + nrm2crdk )) n = 3 * num_atoms sol = 1.0_rp ; rhs = - fvalk ; fgmres_tmp = 0.0_rp !Initialize fgmres solver call dfgmres_init ( n , sol , rhs , rci_request , ipar , dpar , fgmres_tmp ) if ( rci_request < 0 ) then call logger % log_msg ( '<dfgmres_init> failed.' ) end if ipar ( 2 ) = logger % fu ipar ( 9 ) = 1 !Perform residual stopping test ipar ( 10 ) = 0 !No user-defined stopping tests ipar ( 12 ) = 1 !Test for zero norm of the next generated vector ipar ( 15 ) = lmxitr dpar ( 1 ) = rtol !Relative tolerance dpar ( 2 ) = atol !Absolute tolerance !Preliminary check for fgmres solver call dfgmres_check ( n , sol , rhs , rci_request , ipar , dpar , fgmres_tmp ) if ( rci_request < 0 ) then call logger % log_msg ( '<dfgmres_check> failed.' ) end if do call dfgmres ( n , sol , rhs , rci_request , ipar , dpar , fgmres_tmp ) if ( rci_request == 0 ) then !solution found call dfgmres_get ( n , sol , rhs , rci_request , ipar , dpar , fgmres_tmp ,& itercount ) lconv = . true . exit else if ( rci_request == 1 ) then !Perform matrix-vector multiplication ibeg = ipar ( 22 ); iend = ibeg + n - 1 nrm2v = norm2 ( fgmres_tmp ( ibeg : iend )) eps = epsn / nrm2v ; reps = 1.0_rp / eps !print*, eps pvcrd = crdk + eps * fgmres_tmp ( ibeg : iend ) call se_calc_fval ( ierr ) ibeg = ipar ( 23 ); iend = ibeg + n - 1 fgmres_tmp ( ibeg : iend ) = ( fval - fvalk ) * reps !print*, fgmres_tmp(ibeg:iend) !stop else !fgmres failed write ( msg , '(a,i0)' ) '<dfgmres> failed, err code = ' , rci_request call logger % log_msg ( msg ) ierr = 1 exit end if end do end subroutine !****************************************************************************** subroutine integrate_rk ( ierr ) !! Performs one step of BD integration using explicit RK scheme. integer , intent ( out ) :: ierr real ( rp ), parameter :: sixth = 1.0_rp / 6.0_rp real ( rp ), parameter :: two_third = 2.0_rp / 3.0_rp integer :: j ierr = 0 ; diffusion = 0.0_rp !Early return for no HI if (. not . lhdia ) then !Calculate standard Gaussian vectors call brn_calc_dw ( diffusion ) diffusion = sqrt ( tim_stp ) * diffusion diffusion (:, nts_mobsam + 1 :) = diffusion (:, nts_mobsam + 1 :) / math_sqrt3 diffusion (:, nts_mobsam + 1 :) = ( diffusion (:, nts_mobsam + 1 :) & + diffusion (:, 1 : nts_mobsam ) ) * 0.5_rp * tim_stp return end if !Diffusion term with HI if ( cntr_mobsam == 0 ) then !Calculate the mobility matrix call calc_rpy_tensor ( mob ) !Calculate standard Gaussian vectors call brn_calc_dw ( diffusion ) diffusion = sqrt ( tim_stp ) * diffusion diffusion (:, nts_mobsam + 1 :) = diffusion (:, nts_mobsam + 1 :) / math_sqrt3 diffusion (:, nts_mobsam + 1 :) = ( diffusion (:, nts_mobsam + 1 :) & + diffusion (:, 1 : nts_mobsam ) ) * 0.5_rp * tim_stp !Calculate the Brownian vectors call brn_calc_bdw ( mob , diffusion , ierr ) if ( ierr /= 0 ) return !Cholesky decomposition overwrites the upper triangular part of mob !with the factorization result U. Putting the diagonal elements !back to unity (for RPY) as U is no longer needed. The lower !triangular part of mob will be used in calculating drift. do j = 1 , 3 * num_atoms mob ( j , j ) = 1.0_rp end do end if cntr_mobsam = cntr_mobsam + 1 h2 = pvcrd ; h3 = pvcrd ; crdn = pvcrd call calc_drift ( ierr ) if ( ierr /= 0 ) return h2 = h2 + drift ; h3 = h3 + 0.25_rp * drift ; crdn = crdn + sixth * drift pvcrd = h2 call calc_drift ( ierr ) if ( ierr /= 0 ) return h3 = h3 + 0.25_rp * drift ; crdn = crdn + sixth * drift h3 = h3 + diffusion (:, nts_mobsam + cntr_mobsam ) * sqrt_two_dt * 1.5_rp pvcrd = h3 call calc_drift ( ierr ) if ( ierr /= 0 ) return crdn = crdn + two_third * drift + sqrt_two_dt * diffusion (:, cntr_mobsam ) pvcrd = crdn if ( lhdia ) then if ( cntr_mobsam == nts_mobsam ) cntr_mobsam = 0 end if end subroutine !****************************************************************************** subroutine calc_diffusion ( ierr ) !! Calculates the diffusion term of the SDE. Updates module variables !!`diffusion` and `cntr_mobsam`. integer , intent ( out ) :: ierr integer :: j , f logical :: lconv character ( len = 256 ) :: msg diffusion = 0.0_rp ; ierr = 0 !Early return for no HI if (. not . lhdia ) then !Calculate standard Gaussian vectors call brn_calc_dw ( diffusion ) diffusion = sqrt_two_dt * diffusion return end if !Diffusion term with HI if ( cntr_mobsam == 0 ) then !Calculate the mobility matrix call calc_rpy_tensor ( mob ) !Calculate standard Gaussian vectors call brn_calc_dw ( diffusion ) !Calculate the Brownian vectors if ( mob_fctr == 'CHOL' ) then call brn_calc_bdw ( mob , diffusion , ierr ) if ( ierr /= 0 ) return !Cholesky decomposition overwrites the upper triangular part of mob !with the factorization result U. Putting the diagonal elements !back to unity (for RPY) as U is no longer needed. The lower !triangular part of mob will be used in calculating drift. do j = 1 , 3 * num_atoms mob ( j , j ) = 1.0_rp end do else if ( mob_fctr == 'LANC' ) then call brn_calc_bdw ( mob , diffusion , ierr , lconv , f ) if ( ierr /= 0 ) return if (. not . lconv ) then write ( msg , '(a,i0)' ) '<brn_calc_bdw> not converged. nts = ' , nts call logger % log_msg ( msg ) end if end if diffusion = sqrt_two_dt * diffusion end if cntr_mobsam = cntr_mobsam + 1 end subroutine !****************************************************************************** subroutine calc_drift ( ierr ) !! Calculates the drift term of the SDE. integer , intent ( out ) :: ierr integer :: i drift = 0.0_rp ; ierr = 0 !Update forces call ia_calc_forces ( ierr ) if ( ierr /= 0 ) return !Calculate ambient flow velocity at the atom locations. select case ( flow_style ) case ( 1 ) !Steady simple shear: Flow along x, gradient along y do i = 1 , num_atoms drift ( 3 * i - 2 ) = flow_params ( 1 ) * coordinates ( 2 , i ) end do case ( 2 ) !Steady planar extension in x-y plane do i = 1 , num_atoms drift ( 3 * i - 2 ) = flow_params ( 1 ) * coordinates ( 1 , i ) drift ( 3 * i - 1 ) = - flow_params ( 1 ) * coordinates ( 2 , i ) end do case ( 3 ) !Steady uniaxial extension along x do i = 1 , num_atoms drift ( 3 * i - 2 ) = flow_params ( 1 ) * coordinates ( 1 , i ) drift ( 3 * i - 1 ) = - 0.5_rp * flow_params ( 1 ) * coordinates ( 2 , i ) drift ( 3 * i ) = - 0.5_rp * flow_params ( 1 ) * coordinates ( 3 , i ) end do case default continue end select !drift <- mob * forces + drift. Only the lower triangular part of !mob is accessed. if ( lhdia ) then call dsymv ( 'L' , 3 * num_atoms , 1.0_rp , mob , 3 * num_atoms , & pvfrc , 1 , 1.0_rp , drift , 1 ) else drift = drift + pvfrc end if drift = tim_stp * drift end subroutine !****************************************************************************** subroutine calc_rpy_tensor ( mob ) !! Calculates the RPY approximation to the mobility tensor. real ( rp ), dimension (:,:), intent ( out ) :: mob !! (3*num_atoms*, 3*num_atoms*) matrix; stores the mobility tensor. real ( rp ), dimension ( 3 ) :: ri , rj , rij real ( rp ), dimension ( 3 , 3 ) :: matrpy real ( rp ) :: rijm , irijm , irijm2 real ( rp ) :: c1 , c2 , consij integer :: i , j mob = 0.0_rp !Calculate the RPY tensor (in strictly upper triangular form) do j = 2 , num_atoms rj = coordinates (:, j ) do i = 1 , ( j - 1 ) ri = coordinates (:, i ) rij = rj - ri rijm = norm2 ( rij ) irijm = 1.0_rp / rijm irijm2 = irijm * irijm if ( rijm >= 2.0_rp ) then C1 = 1.0_rp + ( 2.0_rp / 3.0_rp ) * irijm2 C2 = 1.0_rp - 2.0_rp * irijm2 consij = 0.75_rp * irijm else C1 = 1.0_rp - 9.0_rp * rijm / ( 3 2.0_rp ) C2 = 3.0_rp * rijm / ( 3 2.0_rp ) consij = 1.0_rp end if matrpy ( 1 , 1 ) = consij * ( C1 + C2 * rij ( 1 ) * rij ( 1 ) * irijm2 ) matrpy ( 2 , 1 ) = consij * ( C2 * rij ( 2 ) * rij ( 1 ) * irijm2 ) matrpy ( 3 , 1 ) = consij * ( C2 * rij ( 3 ) * rij ( 1 ) * irijm2 ) matrpy ( 1 , 2 ) = consij * ( C2 * rij ( 1 ) * rij ( 2 ) * irijm2 ) matrpy ( 2 , 2 ) = consij * ( C1 + C2 * rij ( 2 ) * rij ( 2 ) * irijm2 ) matrpy ( 3 , 2 ) = consij * ( C2 * rij ( 3 ) * rij ( 2 ) * irijm2 ) matrpy ( 1 , 3 ) = consij * ( C2 * rij ( 1 ) * rij ( 3 ) * irijm2 ) matrpy ( 2 , 3 ) = consij * ( C2 * rij ( 2 ) * rij ( 3 ) * irijm2 ) matrpy ( 3 , 3 ) = consij * ( C1 + C2 * rij ( 3 ) * rij ( 3 ) * irijm2 ) mob ( 3 * i - 2 : 3 * i , 3 * j - 2 : 3 * j ) = matrpy end do end do !Copy strictly upper triangular part to strictly lower triangular part. do j = 2 , 3 * num_atoms do i = 1 , j - 1 mob ( j , i ) = mob ( i , j ) end do end do !Put one on the diagonal. do j = 1 , 3 * num_atoms mob ( j , j ) = 1.0_rp end do end subroutine !****************************************************************************** end module m_bd_solver","tags":"","loc":"sourcefile/m_bd_solver.f90.html"},{"title":"m_globals.f90 – BROWNPAK","text":"Contents Modules m_globals Source Code m_globals.f90 Source Code module m_globals !! Global variables, primarily dealing with system configuration !! and simulation execution. use m_precision use m_trajectory use m_simbox use m_logger implicit none !General integer , parameter :: mxrdln = 1024 !! Maximum length of character string for input line buffer. integer , parameter :: mxparam = 12 !! Maximum number of parameters for bonds, angles, etc. !Simulation box type ( smbx_t ) :: simbox !! Simulation box. integer :: imcon = 0 !! Flag specifying boundary conditions on the simulation box. !! !! * *imcon = 0*: Unbounded domain. While not explicitly enforced this !!    is useful only for a single molecule. The dynamics is performed in the !!    c.o.m. frame of reference. !! !! * *imcon = 1*: PBC along *x*, *y*, & *z*. There are no restrictions on !!    the number of molecules. !Particle configuration: Atoms integer :: num_atom_types = 0 !! Number of *atom_type*s character ( len = 8 ), dimension (:), allocatable :: atom_names !! (*num_atom_types*,) array. Name of atoms of each type. integer , dimension (:), allocatable :: atom_styles !! (*num_atom_types*,) array. Style of atoms of each type. real ( rp ), dimension (:), allocatable :: atom_mass !! (*num_atom_types*,) array. Mass of atoms of each type. integer :: mpcd_avnc = 0 !! Average number of MPCD atoms per collision cell integer :: num_mpcd_atoms = 0 !!  Number of MPCD atoms integer :: num_atoms = 0 !!  Number of atoms (excluding MPCD atoms) integer :: num_atoms_tot = 0 !!  Total number of atoms (includes MPCD atoms) integer , dimension (:), allocatable :: atoms !! (*num_atoms*,) array. !! !! For atom *i*, its type *at = atoms(i)*, with style !! *atom_styles(at)*, name *atom_names(at)*, mass *atom_mass(at)*, charge !! *charge(i)*, position *coordinates(:,i)*, velocity *velocities(:,i)*, !! orientation (if the style requires) *orientations(:,i)*. The force acting on atom *i* !! is *forces(:,i)*. real ( rp ), dimension (:), allocatable :: charge !! (*num_atoms*,) array. real ( rp ), dimension (:,:), allocatable , target :: coordinates !!  (3, *num_atoms_tot*) array real ( rp ), dimension (:,:), allocatable :: orientation !!  (4, *num_atoms*) array real ( rp ), dimension (:,:), allocatable , target :: velocities !! (3, *num_atoms_tot*) array. The first *num_atoms* columns stores !! velocities of non-MPCD atoms, the rest, i.e *num_atoms+1* to !! *num_atoms_tot*, store velocities of MPCD atoms. real ( rp ), dimension (:,:), allocatable , target :: forces !!  (3, *num_atoms_tot*) array !Particle configuration: Bonds integer :: num_bond_types = 0 !!  Number of *bond_type*s integer , dimension (:), allocatable :: bond_styles !!  (*num_bond_types*,) array. real ( rp ), dimension (:,:), allocatable :: bond_params !!  (*mxparam*,*num_bond_types*) array. integer :: num_bonds = 0 !!  Total number of bonds. integer , dimension (:,:), allocatable :: bonds !! (3, *num_bonds*) array. Bond *i* is of type *bt = bonds(1,i)*,  directed from !! atom *bonds(2,i)* to *bonds(3,i)*. Its style is *bond_styles(bt)* with !! parameters *bond_params(:,bt)*. !Particle configuration: Angles integer :: num_angle_types = 0 !!  Number of *angle_type*s integer , dimension (:), allocatable :: angle_styles !!  (*num_angle_types*,) array real ( rp ), dimension (:,:), allocatable :: angle_params !!  (*mxparam*, *num_angle_types*) array integer :: num_angles = 0 !!  Number of angles integer , dimension (:,:), allocatable :: angles !! (4, *num_angles*) array. Angle *i* is of type *ant = angles(1,i)*, incident !! to atoms *angles(2,i)*, *angles(3,i)*, and *angles(4,i)*. Its style is !! *angle_styles(ant)* with parameters *angle_params(:,ant)*. !Particle configuration: Dihedrals integer :: num_dihedral_types = 0 !!  Number of *dihedral_type*s integer , dimension (:), allocatable :: dihedral_styles !!  (*num_dihedral_types*,) array real ( rp ), dimension (:,:), allocatable :: dihedral_params !!  (*mxparam*, *num_dihedral_types*) array integer :: num_dihedrals = 0 !!  Number of dihedrals integer , dimension (:,:), allocatable :: dihedrals !! (5, *num_dihedrals*) array. Dihedral *i* is of type *dt = dihedrals(1,i)*, incident !! to atoms *dihedrals(2,i)*, *dihedrals(3,i)*, *dihedrals(4,i)*, and *dihedrals(5,i)*. !! Its style is *dihedral_styles(dt)* with parameters *dihedral_params(:,dt)*. !Particle configuration: Branches integer :: num_branches = 0 !! Total number of branches (including the backbone) integer , dimension (:,:), allocatable :: branches !! (3,*num_branches*) array. Branch *i* is tethered to atom *branches(1,i)*, !! contains *branches(2,i)* atoms, with the beginning atom index *branches(3,i)*. !Particle configuration: Molecules integer :: num_molecule_types = 0 !!  Number of *molecule_type*s character ( len = 8 ), dimension (:), allocatable :: molecule_names !! (*num_molecule_types*,) array integer , dimension (:), allocatable :: molecule_pop !! (*num_molecule_types*,) array integer :: num_molecules = 0 !!  Number of molecules integer , dimension (:,:), allocatable :: molecules !! (9,*num_molecules*) array. For molecule *i*, its type *mt = molecules(1,i)*, !! containing *molecules(2,i)* atoms with beginning index *molecules(3,i)*, !! *molecules(4,i)* bonds with beginning index *molecules(5,i)*, !! *molecules(6,i)* angles with beginning index *molecules(7,i)*, and !! *molecules(8,i)* dihedrals with beginning index *molecules(9,i)*. real ( rp ), dimension ( 3 ) :: molecule_com = 0.0_rp !! Center of mass of the molecule. This is used only when imcon == 0, i.e. !! for a single molecule without periodic boundaries. !Particle configuration: Tethers integer :: num_tether_types = 0 !!  Number of *tether_type*s integer , dimension (:), allocatable :: tether_styles !!  (*num_tether_types*,) array real ( rp ), dimension (:,:), allocatable :: tether_params !!  (*mxparam*, *num_tether_types*) array integer :: num_tethers = 0 !!  Number of tethers integer , dimension (:,:), allocatable :: tethers !! (2, *num_tethers*) array. Tether *i* is of type *tt = tethers(1,i)*, tethering !! atom *tethers(2,i)* to a point *tether_points(:,i)*. !! Its style is *tether_styles(tt)* with parameters *tether_params(:,tt)*. real ( rp ), dimension (:,:), allocatable :: tether_points !!  (3, *num_tethers*) array !Particle configuration: VDW (pair) interactions integer :: num_vdw_types = 0 !!  Number of *vdw_type*s integer , dimension (:), allocatable :: vdw_styles !!  (*num_vdw_types*,) array real ( rp ), dimension (:,:), allocatable :: vdw_params !!  (*mxparam*, *num_vdw_types*) array integer , dimension (:,:), allocatable :: vdw_pairs !!  (2, *num_vdw_types*) array. Stores atom type of interacting pairs, such !! that at_i >= at_j. !Particle configuration: External force field integer :: num_externals = 0 !!  Number of external fields integer , dimension (:), allocatable :: external_styles !!  (*num_external*,) array real ( rp ), dimension (:,:), allocatable :: external_params !!  (*mxparam*, *num_external*) array !Particle configuration: Flow field integer :: flow_style = 0 real ( rp ), dimension (:), allocatable :: flow_params !!  (*mxparam*,) array !End of configuration related globals !Variables controlling runtime behavior integer :: sim_style = 1 !! '0': Structure relaxation, '1' : Brownian dynamics, '2' : MPCD logical :: leql = . true . !! Is the system equilibrating? {T, F} logical :: lrevive = . false . !! Is this a restart run? {T, F}. real ( rp ) :: tim_stp !! BD/MPCD time step size integer ( ip_long ) :: nts !! Counter for BD/MPCD time steps integer ( ip ) :: nts_md = 1 !! Number of MD steps per MPCD step integer ( ip_long ) :: nts_log = 1 !! Interval for logging (in BD time steps) integer ( ip_long ) :: nts_dump = 1 !! Interval for dumping to revive file (in BD time steps) integer ( ip_long ) :: nts_samp = 1 !! Interval for sampling statistics (in BD time steps) integer ( ip_long ) :: nts_eql = 0 !! Number of BD time steps for equilibration integer ( ip_long ) :: nts_eql_samp = 1 !! Sampling interval during equilibration (in BD time steps) integer ( ip_long ) :: nts_sim = 0 !! Total number of BD time steps in production run integer ( ip ) :: nts_mobsam = 1 !! Number of time steps for which the same mobility tensor is used for BD !! with HI. If `nts_mobsam == 1`, mobility is updated every step. logical :: use_verlet_tab = . false . !! Use Verlet neighbor table? {T, F} logical :: use_aabbtree = . false . !! Use AABB tree for pairwise interactions? {T, F} real ( rp ) :: rcutoff = 0.0_rp !! Cut off for short-ranged interaction. Also used as the radius of the !! skin sphere for short-ranged forces real ( rp ) :: tskin = 0.0_rp !!  Thickness of the skin sphere (same for all) logical :: use_cell_list = . false . !! Use cell list for short-range interactions? {T, F} !End of Variables controlling runtime behavior !Variables for I/O character ( len = :), allocatable :: fn_cfg !! Name of the file containing the initial configuration character ( len = :), allocatable :: fn_revive !! Name of the revive file character ( len = :), allocatable :: fn_traj !! Name of the trajectory file character ( len = :), allocatable :: fn_stats !! Name of the statistics file type ( trajectory_t ) :: traj !! Trajectory object character ( len = 8 ) :: job_tag = '' !! A tag useful for array jobs, available only as a command line argument logical :: read_seed = . false . !! {T, F} !! !! Whether to initialize the random number generator by reading a seed from !! a file. If `read_seed` == T, the seed will be read from a file !! 'random_seed.txt' logical :: write_seed = . false . !! {T, F} !! !!  Whether to write the random number generator seed. If !!  `write_seed` == T the seed will be written to a file named !!  'random_seed.txt' logical :: write_traj = . false . !! Should the trajectory be written to file? {T, F} integer , dimension ( 4 ) :: traj_frmcmp = 0 !! Control for what gets written to a trajectory frame. !! 1: coordinates; 2: velocities; 3: forces; 4: charge logical :: traj_wmpcd = . false . !! Depending on the values in *traj_frmcmp*, whether the corresponding !! quantities for the MPCD atoms are written as well. !End of variables for I/O !Miscellaneous variables real ( rp ), dimension ( 3 , 3 ) :: stress = 0.0_rp !! Stress tensor due to non-MPCD atoms real ( rp ), dimension ( 3 , 3 ) :: stress_accu = 0.0_rp !! Stress tensor accumulator due to non-MPCD atoms real ( rp ), dimension ( 3 , 3 ) :: stress_slvnt = 0.0_rp !! Stress tensor due to MPCD atoms (solvent) real ( rp ) :: energy_kin = 0.0_rp !! Kinetic energy real ( rp ) :: energy_bond = 0.0_rp !! Bond energy real ( rp ) :: energy_angle = 0.0_rp !! Angle energy real ( rp ) :: energy_dihedral = 0.0_rp !! Dihedral energy real ( rp ) :: energy_vdw = 0.0_rp !! vdw interaction energy real ( rp ) :: energy_tether = 0.0_rp !! Energetic contribution from tethers real ( rp ) :: energy_external = 0.0_rp !! Energetic contribution from external fields real ( rp ) :: energy_tot = 0.0_rp !! Total energy real ( rp ) :: bndlen = 0.0_rp !! Average bond length real ( rp ) :: bndlen_min = 0.0_rp !! Minimum bond length real ( rp ) :: bndlen_max = 0.0_rp !! Maximum bond length integer :: excluded_atoms = 0 !! Control for excluded atoms in vdw calculation. !! 0: No exclusion, 1: exclude 1-ring bonded neighbors, !! 2: exclude 2-ring bonded neighbors, 3: exclude 3-ring bonded neighbors. logical :: lvdw = . true . !! Whether to calculate VDW interactions character ( len = 4 ) :: bdintg !! Integration method {'EM', 'SE', 'RK'} character ( len = 4 ) :: mob_fctr !! Factorization method for mobility matrix {'CHOL', 'LANC'} integer :: lanc_mxitr !! Maximum number of iterations for Lanczos algorithm real ( rp ) :: lanc_tol = 1.0e-3_rp !! Error tolerance for Lanczos algorithm logical :: lhdia = . true . !! Whether to include hydrodynamic interactions in BD logical :: lelectrostatics = . false . !! Whether to calculate electrostatic interactions !End of miscellaneous variables end module m_globals","tags":"","loc":"sourcefile/m_globals.f90.html"},{"title":"m_control_io.f90 – BROWNPAK","text":"Contents Modules m_control_io Source Code m_control_io.f90 Source Code module m_control_io !! Routines for reading and witing control file. use m_precision use m_strings use m_globals implicit none contains !****************************************************************************** subroutine read_control ( fn ) !! Reads simulation parameters from file character ( len =* ), intent ( in ) :: fn !! Name of parameters file. character ( len = :), allocatable :: key character ( len = :), allocatable :: val character ( len = mxrdln ) :: line character ( len = 1 ) :: cstr = '#' !Comment string integer :: fu integer :: ios open ( newunit = fu , file = fn , action = 'read' , status = 'old' ) do call readline ( fu , line , cstr , ios ) if ( ios /= 0 ) return call str_get_keyval ( line , key , val ) if ( key == 'sim_style' ) read ( val , * ) sim_style if ( key == 'use_verlet_tab' ) read ( val , * ) use_verlet_tab if ( key == 'use_aabbtree' ) read ( val , * ) use_aabbtree if ( key == 'rcutoff' ) rcutoff = str_to_d ( val ) if ( key == 'tskin' ) tskin = str_to_d ( val ) if ( key == 'use_cell_list' ) read ( val , * ) use_cell_list if ( key == 'excluded_atoms' ) excluded_atoms = str_to_i ( val ) if ( key == 'lvdw' ) read ( val , * ) lvdw if ( key == 'lhdia' ) read ( val , * ) lhdia if ( key == 'mob_fctr' ) read ( val , * ) mob_fctr if ( key == 'lanc_mxitr' ) read ( val , * ) lanc_mxitr if ( key == 'lanc_tol' ) read ( val , * ) lanc_tol if ( key == 'lanc_tol' ) read ( val , * ) lanc_tol if ( key == 'bdintg' ) read ( val , * ) bdintg if ( key == 'tim_stp' ) tim_stp = str_to_d ( val ) if ( key == 'nts_md' ) nts_md = int ( str_to_d ( val )) if ( key == 'nts_sim' ) nts_sim = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_mobsam' ) nts_mobsam = int ( str_to_d ( val )) if ( key == 'nts_dump' ) nts_dump = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_samp' ) nts_samp = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_eql_samp' ) nts_eql_samp = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_eql' ) nts_eql = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_log' ) nts_log = int ( str_to_d ( val ), ip_long ) if ( key == 'fn_cfg' ) fn_cfg = val if ( key == 'fn_revive' ) fn_revive = val if ( key == 'fn_stats' ) fn_stats = val if ( key == 'fn_traj' ) fn_traj = val if ( key == 'lrevive' ) read ( val , * ) lrevive if ( key == 'read_seed' ) read ( val , * ) read_seed if ( key == 'write_seed' ) read ( val , * ) write_seed if ( key == 'write_traj' ) read ( val , * ) write_traj if ( key == 'traj_frmcmp' ) read ( val , * ) traj_frmcmp if ( key == 'traj_wmpcd' ) read ( val , * ) traj_wmpcd end do close ( fu ) end subroutine !****************************************************************************** subroutine write_control ( fn ) !! Write simulation parameters to file character ( len =* ), intent ( in ) :: fn !! File name integer :: fu open ( newunit = fu , file = fn , action = 'write' , status = 'unknown' ) write ( fu , '(a,t20,a)' ) 'sim_style' , sim_style write ( fu , '(a,t20,l1)' ) 'use_verlet_tab' , use_verlet_tab write ( fu , '(a,t20,l1)' ) 'use_aabbtree' , use_aabbtree write ( fu , '(a,t20,g0.6)' ) 'rcutoff' , rcutoff write ( fu , '(a,t20,g0.6)' ) 'tskin' , tskin write ( fu , '(a,t20,l1)' ) 'use_cell_list' , use_cell_list write ( fu , '(a,t20,i0)' ) 'excluded_atoms' , excluded_atoms write ( fu , '(a,t20,l1)' ) 'lvdw' , lvdw write ( fu , '(a,t20,l1)' ) 'lhdia' , lhdia write ( fu , '(a,t20,a)' ) 'mob_fctr' , mob_fctr write ( fu , '(a,t20,i0)' ) 'lanc_mxitr' , lanc_mxitr write ( fu , '(a,t20,g0.6)' ) 'lanc_tol' , lanc_tol write ( fu , '(a,t20,a)' ) 'bdintg' , bdintg write ( fu , '(a,t20,l1)' ) 'lelectrostatics' , lelectrostatics write ( fu , * ) write ( fu , '(a,t20,g0.6)' ) 'tim_stp' , tim_stp write ( fu , '(a,t20,i0)' ) 'nts_md' , nts_md write ( fu , '(a,t20,i0)' ) 'nts_sim' , nts_sim write ( fu , '(a,t20,i0)' ) 'nts_mobsam' , nts_mobsam write ( fu , '(a,t20,i0)' ) 'nts_dump' , nts_dump write ( fu , '(a,t20,i0)' ) 'nts_samp' , nts_samp write ( fu , '(a,t20,i0)' ) 'nts_eql' , nts_eql write ( fu , '(a,t20,i0)' ) 'nts_eql_samp' , nts_eql_samp write ( fu , '(a,t20,i0)' ) 'nts_log' , nts_log write ( fu , * ) write ( fu , '(a,t20,a)' ) 'fn_cfg' , fn_cfg write ( fu , '(a,t20,a)' ) 'fn_revive' , fn_revive write ( fu , '(a,t20,a)' ) 'fn_stats' , fn_stats write ( fu , '(a,t20,a)' ) 'fn_traj' , fn_traj write ( fu , * ) write ( fu , '(a,t20,l1)' ) 'lrevive' , lrevive write ( fu , '(a,t20,l1)' ) 'read_seed' , read_seed write ( fu , '(a,t20,l1)' ) 'write_seed' , write_seed write ( fu , '(a,t20,l1)' ) 'write_traj' , write_traj write ( fu , '(a,t20,*(i0,2x))' ) 'traj_frmcmp' , traj_frmcmp write ( fu , '(a,t20,l1)' ) 'traj_wmpcd' , traj_wmpcd close ( fu ) end subroutine !****************************************************************************** end module m_control_io","tags":"","loc":"sourcefile/m_control_io.f90.html"},{"title":"m_utils_math.f90 – BROWNPAK","text":"Contents Modules m_utils_math Source Code m_utils_math.f90 Source Code module m_utils_math !!Various (mostly linear algebra) functions, particularly for use with small !!matrices. use , intrinsic :: ieee_arithmetic , only : ieee_is_nan , ieee_is_finite use m_constants_math use m_precision implicit none interface allclose !! Checks if two arrays are elementwise close within tolerance module procedure allclose_rank1 module procedure allclose_rank2 module procedure allclose_rank3 end interface interface swap !! Swaps two arrays module procedure swap_integer module procedure swap_real module procedure swap_complex end interface swap contains !************************************************************************ elemental subroutine rad2deg ( rad , deg ) real ( rp ), intent ( in ) :: rad real ( rp ), intent ( out ) :: deg deg = ( 18 0.0_rp / math_pi ) * rad end subroutine !************************************************************************ elemental subroutine deg2rad ( deg , rad ) real ( rp ), intent ( in ) :: deg real ( rp ), intent ( out ) :: rad rad = ( math_pi / 18 0.0_rp ) * deg end subroutine !************************************************************************ subroutine cross ( a , b , c ) !!  Calculates the cross product between two 3-element vectors real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( in ) :: b real ( rp ), dimension ( 3 ), intent ( out ) :: c !! Cross product of `a` and `b`; **c** = **a** x **b** c ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end subroutine !****************************************************************************** subroutine cross_mat ( a , mat ) !! Calculates the cross product matrix of a 3-element vector. The cross !! product matrix **A** of **a** is defined as **a** x **b** = **A** . **b**, !! where **b** is another 3-element vector. real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 , 3 ), intent ( out ) :: mat !! Cross product matrix of `a` mat = 0.0_rp mat ( 2 , 1 ) = a ( 3 ) mat ( 3 , 1 ) = - a ( 2 ) mat ( 1 , 2 ) = - a ( 3 ) mat ( 3 , 2 ) = a ( 1 ) mat ( 1 , 3 ) = a ( 2 ) mat ( 2 , 3 ) = - a ( 1 ) end subroutine !****************************************************************************** subroutine outer ( a , b , c ) !! Calculates the outer product of two vectors, c_{ij} = a_i  b_j. real ( rp ), dimension (:), intent ( in ) :: a !! (m,) array real ( rp ), dimension (:), intent ( in ) :: b !! (n,) array real ( rp ), dimension (:,:), intent ( out ) :: c !! (m,n) array; Outer product integer :: m , n integer :: i , j m = size ( a ) n = size ( b ) do j = 1 , n do i = 1 , m c ( i , j ) = a ( i ) * b ( j ) end do end do end subroutine !****************************************************************************** function scalar_triple_product ( a , b , c ) result ( res ) !! Returns the scalar triple product **a**.(**b** x **c**) real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( in ) :: b real ( rp ), dimension ( 3 ), intent ( in ) :: c real ( rp ) :: res res = a ( 1 ) * ( b ( 2 ) * c ( 3 ) - c ( 2 ) * b ( 3 ) ) - a ( 2 ) * ( b ( 1 ) * c ( 3 ) - c ( 1 ) * b ( 3 ) ) & + a ( 3 ) * ( b ( 1 ) * c ( 2 ) - c ( 1 ) * b ( 2 ) ) end function !****************************************************************************** subroutine vector_triple_product ( a , b , c , d ) !! Returns the vector triple product **d** = **a** x (**b** x **c**) real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( in ) :: b real ( rp ), dimension ( 3 ), intent ( in ) :: c real ( rp ), dimension ( 3 ), intent ( out ) :: d !! Vector triple product d = b * ( a ( 1 ) * c ( 1 ) + a ( 2 ) * c ( 2 ) + a ( 3 ) * c ( 3 ) ) & - c * ( a ( 1 ) * b ( 1 ) + a ( 2 ) * b ( 2 ) + a ( 3 ) * b ( 3 ) ) end subroutine !****************************************************************************** function det ( A ) result ( res ) !!  Returns the determinant of an (N x N) matrix, where N = 2, 3, or 4. !! !!  Original routine by [David Simpson](http://www.davidgsimpson.com/software.html) !!  @note For a general NxN matrix do an LU decomp !\"\" real ( rp ), dimension (:,:), intent ( in ) :: A !! (N,N) array, where N = 2, 3, or 4. real ( rp ) :: res integer :: nrows nrows = size ( A , 1 ) if ( nrows == 2 ) then res = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) else if ( nrows == 3 ) then res = A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 1 , 1 ) * A ( 2 , 3 ) * A ( 3 , 2 ) & - A ( 1 , 2 ) * A ( 2 , 1 ) * A ( 3 , 3 ) + A ( 1 , 2 ) * A ( 2 , 3 ) * A ( 3 , 1 ) & + A ( 1 , 3 ) * A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 1 , 3 ) * A ( 2 , 2 ) * A ( 3 , 1 ) else if ( nrows == 4 ) then res = A ( 1 , 1 ) * ( A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) & + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) & + A ( 2 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) ) & - A ( 1 , 2 ) * ( A ( 2 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) & + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) & + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 )) ) & + A ( 1 , 3 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) & + A ( 2 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) & + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )) ) & - A ( 1 , 4 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) & + A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 )) & + A ( 2 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )) ) else stop 'matrix size must be 2, 3, or 4' end if end function !****************************************************************************** function trace ( mat ) result ( res ) !! Returns the trace of a square matrix real ( rp ), intent ( in ) :: mat (:,:) !! (N,N) array real ( rp ) :: res integer :: nrows integer :: i nrows = size ( mat , 1 ) res = 0.0_rp do i = 1 , nrows res = res + mat ( i , i ) end do end function !****************************************************************************** elemental logical function isclose ( a , b , rel_tol , abs_tol ) !!  Checks if two floating point numbers of type double are close within !!  tolerance. !! !!  Based on python implementation at !!  <https://github.com/PythonCHB/close_pep/blob/master/is_close.py>. !!  The *method='weak'* option is used here. !\"\" real ( rp ), intent ( in ) :: a real ( rp ), intent ( in ) :: b real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance, `rel_tol` >= 0, default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance, `abs_tol` >= 0, default 0.0 real ( rp ) :: rel_tol_ real ( rp ) :: abs_tol_ real ( rp ) :: diff rel_tol_ = 1e-10_rp abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol if ( a == b ) then ! short-circuit exact equality isclose = . true . end if if ((. not . ieee_is_finite ( a )) . or . (. not . ieee_is_finite ( b ))) then ! Includes the case of two infinities of opposite sign, or ! one infinity and one finite number. Two infinities of opposite sign ! would otherwise have an infinite relative tolerance. isclose = . false . end if diff = abs ( b - a ) isclose = ( (( diff <= abs ( rel_tol_ * b )) . or . ( diff <= abs ( rel_tol_ * a ))) & . or . ( diff <= abs_tol_ ) ) end function !****************************************************************************** logical function allclose_rank1 ( a , b , rel_tol , abs_tol ) !!  Checks if two rank-1 floating point arrays of type double are close within !!  tolerance. !\"\" real ( rp ), dimension (:), intent ( in ) :: a !! (m,) array real ( rp ), dimension (:), intent ( in ) :: b !! (m,) array real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance; default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance; default 0.0 real ( rp ) :: rel_tol_ = 1e-10_rp real ( rp ) :: abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol allclose_rank1 = all ( isclose ( a , b , rel_tol_ , abs_tol_ )) end function logical function allclose_rank2 ( a , b , rel_tol , abs_tol ) !!  Checks if two rank-2 floating point arrays of type double are close within !!  tolerance. !\"\" real ( rp ), dimension (:,:), intent ( in ) :: a !! (m,n) array real ( rp ), dimension (:,:), intent ( in ) :: b !! (m,n) array real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance; default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance; default 0.0 real ( rp ) :: rel_tol_ = 1e-10_rp real ( rp ) :: abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol allclose_rank2 = all ( isclose ( a , b , rel_tol_ , abs_tol_ )) end function logical function allclose_rank3 ( a , b , rel_tol , abs_tol ) !!  Checks if two rank-3 floating point arrays of type double are close within !!  tolerance. !\"\" real ( rp ), dimension (:,:,:), intent ( in ) :: a !! (m,n,p) array real ( rp ), dimension (:,:,:), intent ( in ) :: b !! (m,n,p) array real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance; default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance; default 0.0 real ( rp ) :: rel_tol_ = 1e-10_rp real ( rp ) :: abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol allclose_rank3 = all ( isclose ( a , b , rel_tol_ , abs_tol_ )) end function !****************************************************************************** elemental subroutine swap_integer ( a , b ) integer , intent ( in out ) :: a integer , intent ( in out ) :: b integer :: temp temp = a a = b b = temp end subroutine elemental subroutine swap_real ( a , b ) real ( rp ), intent ( in out ) :: a real ( rp ), intent ( in out ) :: b real ( rp ) :: temp temp = a a = b b = temp end subroutine elemental subroutine swap_complex ( a , b ) complex ( rp ), intent ( in out ) :: a complex ( rp ), intent ( in out ) :: b complex ( rp ) :: temp temp = a a = b b = temp end subroutine !****************************************************************************** subroutine unitize ( a ) !! Normalizes a vector in-place. If the magnitude of the vector is nearly !! zero, no normalization takes place and the vector is returned as is with !! a warning message. real ( rp ), dimension (:), intent ( in out ) :: a !! (m,) array real ( rp ) :: norm norm = norm2 ( a ) if ( isclose ( norm , 0.0_rp , rel_tol = 1.e-15_rp , abs_tol = 0.0_rp )) then write ( * , * ) '[unitize] norm close to zero' else a = a / norm2 ( a ) end if end subroutine !****************************************************************************** subroutine linspace ( start , finish , num , val , step ) !! Generates evenly spaced numbers over a specified interval. Both end !! points are included. If `start` < `finish`, the returned step size (if !! `step` is present) will be negative. !\"\" real ( rp ), intent ( in ) :: start !! Starting point real ( rp ), intent ( in ) :: finish !! Ending point, `finish` /= `start` integer , intent ( in ) :: num !! Number of values to generate, `num >= 2` real ( rp ), dimension (:), intent ( out ) :: val !! (`num`,) array; Generated values real ( rp ), intent ( out ), optional :: step !! Step size real ( rp ) :: step_ integer :: i if ( num < 2 ) then write ( * , * ) '[linspace] `num` must be >= 2' stop end if if ( num < size ( val )) then write ( * , * ) '[linspace] `size(val)` must be >= `num`' stop end if if ( start == finish ) then write ( * , * ) '[linspace] `start` must not be equal to `finish`' stop end if val = 0.0_rp step_ = ( finish - start ) / ( num - 1 ) if ( present ( step )) step = step_ val ( 1 ) = start val ( num ) = finish do i = 2 , ( num - 1 ) val ( i ) = start + ( i - 1 ) * step_ end do end subroutine !****************************************************************************** subroutine logspace ( start , finish , num , val , base ) !!  Generates numbers spaced evenly on a log scale. !!  In linear space, the sequence starts at `base ** start` !!  (`base` to the power of `start`) and ends with `base ** stop` !\"\" real ( rp ), intent ( in ) :: start !! Starting point, `base ** start` is the starting value real ( rp ), intent ( in ) :: finish !! Ending point, `finish` /= `start`,  `base ** start` !! is the ending value integer , intent ( in ) :: num !! Number of values to generate, `num >= 2` real ( rp ), dimension (:), intent ( out ) :: val !! (`num`,) array; Generated values real ( rp ), intent ( in ), optional :: base !! Base of the logspace, default 10 real ( rp ) :: base_ integer :: i if ( num < 2 ) then write ( * , * ) 'logspace `num` must be >= 2' stop end if if ( num < size ( val )) then write ( * , * ) 'logspace `size(val)` must be >= `num`' stop end if if ( start == finish ) then write ( * , * ) 'logspace `start` must not be equal to `finish`' stop end if val = 0.0_rp base_ = 1 0.0_rp if ( present ( base )) base_ = base call linspace ( start , finish , num , val ) do i = 1 , num val ( i ) = base_ ** val ( i ) end do end subroutine !****************************************************************************** subroutine identity ( mat_eye ) !! Creates an identity matrix of size n x n. real ( rp ), dimension (:,:), intent ( out ) :: mat_eye !! (n,n) array integer :: nrows integer :: i nrows = size ( mat_eye , 1 ) mat_eye = 0.0_rp do i = 1 , nrows mat_eye ( i , i ) = 1.0_rp end do end subroutine !****************************************************************************** subroutine get_diagonal ( mat , d ) !! Returns the diagonal elements of a square matrix. real ( rp ), dimension (:,:), intent ( in ) :: mat !! (n,n) array real ( rp ), dimension (:), intent ( out ) :: d !! (n,) array; contains the entries of the main diagonal integer :: n integer :: i n = size ( mat , 1 ) do i = 1 , n d ( i ) = mat ( i , i ) end do end subroutine !****************************************************************************** subroutine add_transpose ( mat ) !! Adds a square matrix and its transpose in place: A_{ij} = A_{ij } + A_{ji} real ( rp ), dimension (:,:), intent ( in out ) :: mat !! (n,n) array integer :: n integer :: i integer :: j n = size ( mat , 1 ) !Dealing with the upper triangular part (including diagonal) do j = 1 , n do i = 1 , j mat ( i , j ) = mat ( i , j ) + mat ( j , i ) end do end do !Dealing with the strictly lower triangular part (i.e. excluding diagonal) do j = 1 , ( n - 1 ) do i = ( j + 1 ), n mat ( i , j ) = mat ( j , i ) end do end do end subroutine !****************************************************************************** subroutine subtract_transpose ( mat ) !! Calculates the difference of a square matrix and its transpose in place: !! A_{ij} = A_{ij } - A_{ji} real ( rp ), dimension (:,:), intent ( in out ) :: mat integer :: n integer :: i integer :: j n = size ( mat , 1 ) !Dealing with the strictly upper triangular part (i.e. excluding diagonal) do j = 2 , n do i = 1 , ( j - 1 ) mat ( i , j ) = mat ( i , j ) - mat ( j , i ) end do end do !Dealing with the strictly lower triangular part (i.e. excluding diagonal) do j = 1 , ( n - 1 ) do i = ( j + 1 ), n mat ( i , j ) = - mat ( j , i ) end do end do !Putting the diagonal to zero do i = 1 , n mat ( i , j ) = 0.0_rp end do end subroutine !****************************************************************************** subroutine multiply_transpose ( A , B ) !! Multiplies a matrix with its transpose: !! \\mathbf{\\mathrm{B}} = \\mathbf{\\mathrm{A}} \\cdot \\mathbf{\\mathrm{A}}&#94;T !\"\" real ( rp ), dimension (:,:), intent ( in ) :: A !! (m,n) array real ( rp ), dimension (:,:), intent ( out ) :: B !! (m,m) array !A is m x n, A&#94;T is n x m, so B is m x m B = matmul ( A , transpose ( A )) end subroutine !****************************************************************************** function get_quad_form ( A , x ) result ( res ) !!  Calculates the quadratic form *x&#94;T A x*, where A is an *n x n* matrix and *x* is a !!  vector of length *n* !\"\" real ( rp ), dimension (:,:), intent ( in ) :: A !! (n,n) array real ( rp ), dimension (:), intent ( in ) :: x !! (n,) array real ( rp ) :: res integer :: n integer :: i , j n = size ( A , 2 ) res = 0.0_rp do j = 1 , n do i = 1 , n res = res + A ( i , j ) * x ( j ) * x ( i ) end do end do end function !****************************************************************************** subroutine orth ( a ) !! Orthogonalizes a set of vectors in-place using Gram-Schmidt orthonormalization !! !! *Reference:* Golub and Van Loan, Matrix Computations, 3rd edition, Section 5.2.8, !! Algorithm 5.2.5, p. 231. real ( rp ), dimension (:,:), intent ( in out ) :: a !! (m,n) array, where m <= n. The first m columns of the matrix are !!  overwritten with the orthogonal basis vectors. integer :: m integer :: i , j m = size ( a , 1 ) do i = 1 , m a ( i ,:) = a ( i ,:) / norm2 ( a ( i ,:)) do j = ( i + 1 ), m a ( j ,:) = a ( j ,:) - dot_product ( a ( j ,:), a ( i ,:)) * a ( i ,:) end do end do end subroutine !****************************************************************************** subroutine invert_mat33 ( a , inv_a ) !! Inverts a 3x3 matrix. !! !!*Reference:* https://www.geometrictools.com/Documentation/LaplaceExpansionTheorem.pdf real ( rp ), dimension ( 3 , 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 , 3 ), intent ( out ) :: inv_a real ( rp ) :: det_a inv_a ( 1 , 1 ) = a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 ) inv_a ( 2 , 1 ) = - ( a ( 2 , 1 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 1 )) inv_a ( 3 , 1 ) = a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 ) inv_a ( 1 , 2 ) = - ( a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 2 )) inv_a ( 2 , 2 ) = a ( 1 , 1 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 1 ) inv_a ( 3 , 2 ) = - ( a ( 1 , 1 ) * a ( 3 , 2 ) - a ( 1 , 2 ) * a ( 3 , 1 )) inv_a ( 1 , 3 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ) inv_a ( 2 , 3 ) = - ( a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 1 )) inv_a ( 3 , 3 ) = a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 ) !Determinant det_a = a ( 1 , 1 ) * inv_a ( 1 , 1 ) + a ( 1 , 2 ) * inv_a ( 2 , 1 ) + a ( 1 , 3 ) * inv_a ( 3 , 1 ) inv_a = inv_a / det_a end subroutine !****************************************************************************** subroutine eigval_33rsym ( a , ev ) !! Calculates the eigenvalues of a 3 x 3 real symmetric matrix. The !! eigenvalues calculated are in decreasing order. Only the diagonal and !! lower triangular part of the matrix is accessed. !! !! *Reference:* https://en.wikipedia.org/wiki/Eigenvalue_algorithm#cite_note-Smith-12 !! !! See also David Eberly's notes and implementation at !! https://www.geometrictools.com/Documentation/RobustEigenSymmetric3x3.pdf real ( rp ), dimension ( 3 , 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( out ) :: ev real ( rp ), dimension ( 3 , 3 ) :: eye real ( rp ), dimension ( 3 , 3 ) :: b real ( rp ) :: p , q , r real ( rp ) :: p1 , p2 real ( rp ) :: phi !Sum of the elements in the lower triangular part p1 = a ( 2 , 1 ) ** 2 + a ( 3 , 1 ) ** 2 + a ( 3 , 2 ) ** 2 if ( isclose ( p1 , 0.0_rp ) ) then !Matrix a is diagonal ev ( 1 ) = a ( 1 , 1 ); ev ( 2 ) = a ( 2 , 2 ); ev ( 3 ) = a ( 3 , 3 ) return else q = ( a ( 1 , 1 ) + a ( 2 , 2 ) + a ( 3 , 3 )) / 3.0_rp p2 = ( a ( 1 , 1 ) - q ) ** 2 + ( a ( 2 , 2 ) - q ) ** 2 + ( a ( 3 , 3 ) - q ) ** 2 + 2 * p1 p = sqrt ( p2 / 6.0_rp ) call identity ( eye ) b = ( a - q * eye ) / p r = 0.5_rp * det ( b ) !r must be within [-1, 1] in exact computation; but need to handle !slightly out of range in computation. if ( r <= - 1.0_rp ) then phi = math_pi / 3.0_rp else if ( r >= 1.0_rp ) then phi = 0.0_rp else phi = acos ( r ) / 3.0_rp end if !Eigen values are ordered as ev(3) <= ev(2) <= ev(1) ev ( 1 ) = q + 2 * p * cos ( phi ) ev ( 3 ) = q + 2 * p * cos ( phi + ( 2 * math_pi / 3.0_rp )) ev ( 2 ) = 3 * q - ev ( 1 ) - ev ( 3 ) end if end subroutine !****************************************************************************** subroutine dsyevc3 ( a , w ) !!author: Joachim Kopp !!date: 2006 !! !! Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's !! analytical algorithm. !! Only the diagonal and upper triangular parts of A are accessed. The access !! is read-only. !! !! Copyright (C) 2006  Joachim Kopp ! ---------------------------------------------------------------------------- ! Parameters: !   A: The symmetric input matrix !   W: Storage buffer for eigenvalues ! ---------------------------------------------------------------------------- ! .. Arguments .. REAL ( RP ), DIMENSION ( 3 , 3 ), INTENT ( IN ) :: A REAL ( RP ), DIMENSION ( 3 ), INTENT ( OUT ) :: W ( 3 ) !.. Local Variables .. REAL ( RP ) :: M , C1 , C0 REAL ( RP ) :: DE , DD , EE , FF REAL ( RP ) :: P , SQRTP , Q , C , S , PHI !Determine coefficients of characteristic poynomial. We write !      | A   D   F  | ! A =  | D*  B   E  | !      | F*  E*  C  | DE = A ( 1 , 2 ) * A ( 2 , 3 ) DD = A ( 1 , 2 ) ** 2 EE = A ( 2 , 3 ) ** 2 FF = A ( 1 , 3 ) ** 2 M = A ( 1 , 1 ) + A ( 2 , 2 ) + A ( 3 , 3 ) C1 = ( A ( 1 , 1 ) * A ( 2 , 2 ) + A ( 1 , 1 ) * A ( 3 , 3 ) + A ( 2 , 2 ) * A ( 3 , 3 ) ) & - ( DD + EE + FF ) C0 = A ( 3 , 3 ) * DD + A ( 1 , 1 ) * EE + A ( 2 , 2 ) * FF - A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) & - 2.0_RP * A ( 1 , 3 ) * DE P = M ** 2 - 3.0_RP * C1 Q = M * ( P - ( 3.0_RP / 2.0_RP ) * C1 ) - ( 2 7.0_RP / 2.0_RP ) * C0 SQRTP = SQRT ( ABS ( P )) PHI = 2 7.0_RP * ( 0.25_RP * C1 ** 2 * ( P - C1 ) & + C0 * ( Q + ( 2 7.0_RP / 4.0_RP ) * C0 ) ) PHI = ( 1.0_RP / 3.0_RP ) * ATAN2 ( SQRT ( ABS ( PHI )), Q ) C = SQRTP * COS ( PHI ) S = ( 1.0_RP / MATH_SQRT3 ) * SQRTP * SIN ( PHI ) W ( 2 ) = ( 1.0_RP / 3.0_RP ) * ( M - C ) W ( 3 ) = W ( 2 ) + S W ( 1 ) = W ( 2 ) + C W ( 2 ) = W ( 2 ) - S END SUBROUTINE !****************************************************************************** end module m_utils_math","tags":"","loc":"sourcefile/m_utils_math.f90.html"},{"title":"m_ia_vdw.f90 – BROWNPAK","text":"Contents Modules m_ia_vdw Source Code m_ia_vdw.f90 Source Code module m_ia_vdw !! Routines to evaulate pairwise potentials and their derivative. !! !! The following styles are available: !! !! * Style 1. 12-6 LJ. See [[vdw_lj_set]]. !! * Style 2. Gaussian. See [[vdw_gaussian_set]]. !! * Style 3. Cosine. See [[vdw_cosine_set]]. !! * Style 4. Screened Coulomb + LJ. See [[vdw_lj_coul_debye_set]]. !! * Style 5. Coulomb + LJ. See [[vdw_lj_coul_set]]. !! * Style 6. Standard DPD. See [[vdw_dpd_set]]. use m_precision use m_constants_math use m_globals implicit none private public :: ia_vdw_setup , ia_get_vdw_force contains !****************************************************************************** subroutine ia_vdw_setup () !! Sets up parameters for vdw potentials integer :: i integer :: sty !Set vdw interactions do i = 1 , num_vdw_types sty = vdw_styles ( i ) select case ( sty ) case ( 1 ) call vdw_lj_set ( vdw_params (:, i )) case ( 2 ) call vdw_gaussian_set ( vdw_params (:, i )) case ( 3 ) call vdw_cosine_set ( vdw_params (:, i )) case ( 4 ) call vdw_lj_coul_debye_set ( vdw_params (:, i )) case ( 5 ) call vdw_lj_coul_set ( vdw_params (:, i )) case ( 6 ) call vdw_dpd_set ( vdw_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_vdw_force ( rij_mag , qi , qj , typ , enrg , frc , ierr ) !! Calculates the energy & its derivative due to a single interacting pair of atoms. real ( rp ), intent ( in ) :: rij_mag !! Distance between two atoms real ( rp ), intent ( in ) :: qi !! Charge on atom i real ( rp ), intent ( in ) :: qj !! Charge on atom j integer , intent ( in ) :: typ !! Type of vdw interaction real ( rp ), intent ( out ) :: enrg !! Energy real ( rp ), intent ( out ) :: frc !! Derivative of the potential. This is the magnitude of force due to !! this potential. integer , intent ( out ) :: ierr !! Error flag integer :: styl ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp styl = vdw_styles ( typ ) select case ( styl ) case ( 1 ) call vdw_lj ( rij_mag , vdw_params (:, typ ), enrg , frc ) case ( 2 ) call vdw_gaussian ( rij_mag , vdw_params (:, typ ), enrg , frc ) case ( 3 ) call vdw_cosine ( rij_mag , vdw_params (:, typ ), enrg , frc ) case ( 4 ) call vdw_lj_coul_debye ( rij_mag , qi * qj , vdw_params (:, typ ), enrg , frc ) case ( 5 ) call vdw_lj_coul ( rij_mag , qi * qj , vdw_params (:, typ ), enrg , frc ) case ( 6 ) call vdw_dpd ( rij_mag , vdw_params (:, typ ), enrg , frc ) case default continue end select end subroutine !****************************************************************************** subroutine vdw_lj_set ( params , eps , sigma , rcut ) !! Setter for 12-6 LJ (truncated & force-shifted) interaction. !! !! The potential `U` is given by: !!``` !!   V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] !!   U = V - V(rcut) - (r - rcut)*dV/dr, r < rcut, !!       0, r >= rcut !!``` !! where `dV/dr` is evaluated at `r = rcut`. !! !! User-set parameters: !! !! * params(1) = `eps` !! * params(2) = `sigma` !! * params(3) = `rcut` !! !! Internally stored parameters: !! !! * params(4) = `V(rcut)` !! * params(5) = `dV/dr(rcut)` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ), intent ( in ), optional :: rcut real ( rp ) :: eps_ , sigma_ , rcut_ real ( rp ) :: pot_rcut , pot_deriv_rcut real ( rp ) :: sir , sir2 , sir6 , sir12 if ( present ( eps )) params ( 1 ) = eps if ( present ( sigma )) params ( 2 ) = sigma if ( present ( rcut )) params ( 3 ) = rcut eps_ = params ( 1 ); sigma_ = params ( 2 ); rcut_ = params ( 3 ) sir = sigma_ / rcut_ sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 pot_rcut = 4 * eps_ * ( sir12 - sir6 ) pot_deriv_rcut = - 24 * eps_ * ( 2 * sir12 - sir6 ) / rcut_ params ( 4 ) = pot_rcut params ( 5 ) = pot_deriv_rcut end subroutine !****************************************************************************** pure subroutine vdw_lj ( r , params , enrg , frc ) !! Evaluates the potential and its derivative for LJ interaction. See !! [[vdw_lj_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: eps , sigma , rcut real ( rp ) :: pot_rcut , pot_deriv_rcut real ( rp ) :: sir , sir2 , sir6 , sir12 enrg = 0.0_rp ; frc = 0.0_rp eps = params ( 1 ); sigma = params ( 2 ); rcut = params ( 3 ) pot_rcut = params ( 4 ) pot_deriv_rcut = params ( 5 ) if ( r < rcut ) then sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = 4 * eps * ( sir12 - sir6 ) - pot_rcut - ( r - rcut ) * pot_deriv_rcut frc = - 24 * eps * ( 2 * sir12 - sir6 ) / r - pot_deriv_rcut end if end subroutine !****************************************************************************** subroutine vdw_gaussian_set ( params , A , B , rcut ) !! Setter for gaussian interaction. The potential is truncated and !! force-shifted. !! !! The potential `U` is given by: !!``` !!   V = A*exp(-B*r&#94;2) !!   U = V - V(rcut) - (r - rcut)*dV/dr, r < rcut !!       0, r >= rcut, !!``` !! where `dV/dr` is evaluated at `r = rcut`. !! !! User-set parameters: !! !! * params(1) = `A` !! * params(2) = `B` !! * params(3) = `rcut` !! !! Internally stored parameters: !! !! * params(4) = `V(rcut)` !! * params(5) = `dV/dr(rcut)` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: A real ( rp ), intent ( in ), optional :: B real ( rp ), intent ( in ), optional :: rcut real ( rp ) :: pot_rcut , pot_deriv_rcut if ( present ( A )) params ( 1 ) = A if ( present ( B )) params ( 2 ) = B if ( present ( rcut )) params ( 3 ) = rcut pot_rcut = params ( 1 ) * exp ( - params ( 2 ) * params ( 3 ) ** 2 ) pot_deriv_rcut = - 2.0_rp * params ( 1 ) * params ( 2 ) * params ( 3 ) & * exp ( - params ( 2 ) * params ( 3 ) ** 2 ) params ( 4 ) = pot_rcut params ( 5 ) = pot_deriv_rcut end subroutine !****************************************************************************** pure subroutine vdw_gaussian ( r , params , enrg , frc ) !! Calculates energy & its derivative for gaussian interaction. See !! [[vdw_gaussian_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: A , B , rcut , pot_rcut , pot_deriv_rcut real ( rp ) :: exrs enrg = 0.0_rp ; frc = 0.0_rp A = params ( 1 ); B = params ( 2 ); rcut = params ( 3 ) pot_rcut = params ( 4 ); pot_deriv_rcut = params ( 5 ) if ( r < rcut ) then exrs = exp ( - B * r * r ) enrg = A * exrs - pot_rcut - ( r - rcut ) * pot_deriv_rcut frc = - 2 * A * B * r * exrs - pot_deriv_rcut end if end subroutine !****************************************************************************** subroutine vdw_cosine_set ( params , A , rcut ) !! Setter for cosine interaction. !! !! The potential `U` is given by: !!``` !!   U = A*[1 + cos(pi*r/rcut)], r < rcut !!       0, r >= rcut !!``` !! The potential as well as its derivative is zero at `r = rcut`. !! !! User-set parameters: !! !! * params(1) = `A` !! * params(2) = `rcut` !! !! Internally stored parameters: !! !! * None real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: A real ( rp ), intent ( in ), optional :: rcut if ( present ( A )) params ( 1 ) = A if ( present ( rcut )) params ( 2 ) = rcut end subroutine !****************************************************************************** pure subroutine vdw_cosine ( r , params , enrg , frc ) !! Evaluates the potential and its derivative for  cosine interaction. !! See [[vdw_cosine_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: A , rcut , pf , pr enrg = 0.0_rp ; frc = 0.0_rp A = params ( 1 ); rcut = params ( 2 ) pf = math_pi / rcut ; pr = pf * r if ( r < rcut ) then enrg = A * ( 1.0_rp + cos ( pr ) ) frc = - A * pf * sin ( pr ) end if end subroutine !****************************************************************************** subroutine vdw_lj_coul_debye_set ( params , eps , sigma , rcut , rcut_coul , C , kappa ) !! Setter for 12-6 LJ with screened Coulombic interaction. !! !! The potential `U` is given by: !!``` !! V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] !! W = C*qi*qj*exp(-kappa*r)/r !! if rcut_coul > 0: !!     U = V - V(rcut) + W - W(rcut_coul), r < rcut !!         W - W(rcut_coul), rcut <= r < rcut_coul !!         0, r >= rcut_coul !! if rcut_coul <= 0: !!     U = V - V(rcut) + W, r < rcut !!         W, r >= rcut !!``` !! !!- The LJ potential `V` is cut & shifted at `r = rcut`. !!- If `rcut_coul > 0`, the screened Coulombic potential `W` is cut & shifted !! at `r = rcut_coul`. !!- If `rcut_coul <= 0`, no cutoff is applied on `W`. !!- `rcut_coul` must be >= `rcut`. !! !! User-set parameters: !! !! * params(1) = `eps` !! * params(2) = `sigma` !! * params(3) = `rcut` !! * params(4) = `rcut_coul` !! * params(5) = `C` !! * params(6) = `kappa` !! !! Internally stored parameters: !! !! * params(7) = `V(rcut)` !! * params(8) = `C*exp(-kappa*rcut_coul)/rcut_coul` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ), intent ( in ), optional :: rcut real ( rp ), intent ( in ), optional :: rcut_coul real ( rp ), intent ( in ), optional :: C real ( rp ), intent ( in ), optional :: kappa real ( rp ) :: eps_ , sigma_ , rcut_ , rcut_coul_ , C_ , kappa_ real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 if ( present ( eps )) params ( 1 ) = eps if ( present ( sigma )) params ( 2 ) = sigma if ( present ( rcut )) params ( 3 ) = rcut if ( present ( rcut_coul )) params ( 4 ) = rcut_coul if ( present ( C )) params ( 5 ) = C if ( present ( kappa )) params ( 6 ) = kappa eps_ = params ( 1 ); sigma_ = params ( 2 ); rcut_ = params ( 3 ) rcut_coul_ = params ( 4 ); C_ = params ( 5 ); kappa_ = params ( 6 ) sir = sigma_ / rcut_ sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 pot_rcut = 4 * eps_ * ( sir12 - sir6 ) if ( rcut_coul_ > 0.0_rp ) then pot_rcut_coul = C_ * exp ( - kappa_ * rcut_coul_ ) / rcut_coul_ else pot_rcut_coul = 0.0_rp end if params ( 7 ) = pot_rcut params ( 8 ) = pot_rcut_coul end subroutine !****************************************************************************** pure subroutine vdw_lj_coul_debye ( r , qiqj , params , enrg , frc ) !!Evaluates the potential and its derivative for screened Coulombic interaction !!combined with 12-6 LJ (cut & shifted). See [[vdw_lj_coul_debye_set]]. real ( rp ), intent ( in ) :: r real ( rp ), intent ( in ) :: qiqj real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: eps , sigma , rcut , rcut_coul , C , kappa real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 , ekr enrg = 0.0_rp ; frc = 0.0_rp eps = params ( 1 ); sigma = params ( 2 ); rcut = params ( 3 ) rcut_coul = params ( 4 ); C = params ( 5 ); kappa = params ( 6 ) pot_rcut = params ( 7 ); pot_rcut_coul = params ( 8 ) ekr = C * qiqj * exp ( - kappa * r ) / r if ( rcut_coul > 0.0_rp ) then !Coulombic cutoff at rcut_coul if ( r < rcut_coul ) then enrg = ekr - qiqj * pot_rcut_coul frc = - ekr * ( 1 + kappa * r ) / r end if else !No Coulombic cutoff enrg = ekr frc = - ekr * ( 1 + kappa * r ) / r end if if ( r < rcut ) then sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = enrg + 4 * eps * ( sir12 - sir6 ) - pot_rcut frc = frc - 24 * eps * ( 2 * sir12 - sir6 ) / r end if end subroutine !****************************************************************************** subroutine vdw_lj_coul_set ( params , eps , sigma , rcut , rcut_coul , C ) !! Setter for 12-6 LJ with Coulombic interaction. !! !! The potential `U` is given by: !!``` !! V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] !! W = C*qi*qj/r !! if rcut_coul > 0: !!     U = V - V(rcut) + W - W(rcut_coul), r < rcut !!         W - W(rcut_coul), rcut <= r < rcut_coul !!         0, r >= rcut_coul !! if rcut_coul <= 0: !!     U = V - V(rcut) + W, r < rcut !!         W, r >= rcut !!``` !! - The LJ potential `V` is cut & shifted at `r = rcut`. !! - If `rcut_coul > 0`, the Coulombic potential `W` is cut & shifted at `r = rcut_coul`. !! - If `rcut_coul <= 0`, no cutoff is applied on `W`. !! - `rcut_coul` must be >= `rcut`. !! !! User-set parameters: !! !! * params(1) = `eps` !! * params(2) = `sigma` !! * params(3) = `rcut` !! * params(4) = `rcut_coul` !! * params(5) = `C` !! !! Internally stored parameters: !! !! * params(6) = `V(rcut)` !! * params(7) = `C/rcut_coul` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ), intent ( in ), optional :: rcut real ( rp ), intent ( in ), optional :: rcut_coul real ( rp ), intent ( in ), optional :: C real ( rp ) :: eps_ , sigma_ , rcut_ , rcut_coul_ , C_ real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 if ( present ( eps )) params ( 1 ) = eps if ( present ( sigma )) params ( 2 ) = sigma if ( present ( rcut )) params ( 3 ) = rcut if ( present ( rcut_coul )) params ( 4 ) = rcut_coul if ( present ( C )) params ( 5 ) = C eps_ = params ( 1 ); sigma_ = params ( 2 ); rcut_ = params ( 3 ) rcut_coul_ = params ( 4 ); C_ = params ( 5 ) sir = sigma_ / rcut_ sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 pot_rcut = 4 * eps_ * ( sir12 - sir6 ) if ( rcut_coul_ > 0.0_rp ) then pot_rcut_coul = C_ / rcut_coul_ else pot_rcut_coul = 0.0_rp end if params ( 6 ) = pot_rcut params ( 7 ) = pot_rcut_coul end subroutine !****************************************************************************** pure subroutine vdw_lj_coul ( r , qiqj , params , enrg , frc ) !! Evaluates the potential and its derivative for Coulombic interaction !! combined with 12-6 LJ (cut & shifted). See [[vdw_lj_coul_set]]. real ( rp ), intent ( in ) :: r real ( rp ), intent ( in ) :: qiqj real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: eps , sigma , rcut , rcut_coul , C real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 , ekr enrg = 0.0_rp ; frc = 0.0_rp eps = params ( 1 ); sigma = params ( 2 ); rcut = params ( 3 ) rcut_coul = params ( 4 ); C = params ( 5 ) pot_rcut = params ( 6 ); pot_rcut_coul = params ( 7 ) ekr = C * qiqj / r if ( rcut_coul > 0.0_rp ) then !Coulombic cutoff at rcut_coul if ( r < rcut_coul ) then enrg = ekr - qiqj * pot_rcut_coul frc = - ekr / r end if else !No Coulombic cutoff enrg = ekr frc = - ekr / r end if if ( r < rcut ) then sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = enrg + 4 * eps * ( sir12 - sir6 ) - pot_rcut frc = frc - 24 * eps * ( 2 * sir12 - sir6 ) / r end if end subroutine !****************************************************************************** subroutine vdw_dpd_set ( params , A , rcut ) !! Setter for standard DPD interaction. !! !! The potential `U` is given by: !!``` !!   U = (A/2)*rcut*(1 - (r/rcut))&#94;2, r < rcut !        0, r >= rcut !!``` !! !! User-set parameters: !! !! * params(1) = `A` !! * params(2) = `rcut` !! !! Internally stored parameters: !! !! * None real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: A real ( rp ), intent ( in ), optional :: rcut if ( present ( A )) params ( 1 ) = A if ( present ( rcut )) params ( 2 ) = rcut end subroutine !****************************************************************************** pure subroutine vdw_dpd ( r , params , enrg , frc ) !! Evaluates the potential and its derivative for standard DPD interaction. !! See [[vdw_dpd_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: A , rcut , ir enrg = 0.0_rp ; frc = 0.0_rp A = params ( 1 ); rcut = params ( 2 ) ir = 1.0_rp - ( r / rcut ) if ( r < rcut ) then enrg = 0.5_rp * A * rcut * ir * ir frc = - A * ir end if end subroutine !****************************************************************************** end module m_ia_vdw","tags":"","loc":"sourcefile/m_ia_vdw.f90.html"},{"title":"m_precision.f90 – BROWNPAK","text":"Contents Modules m_precision Source Code m_precision.f90 Source Code module m_precision use , intrinsic :: iso_fortran_env , only : int32 , int64 , real64 implicit none integer , parameter :: ip = int32 !! Default integer precision integer , parameter :: ip_long = int64 !! Default long integer precision integer , parameter :: rp = real64 !! Default real precision integer , parameter :: sizeof_char = 1 !! Size of a char in bytes integer , parameter :: sizeof_int = 4 !! Size of a default int in bytes integer , parameter :: sizeof_long_int = 8 !! Size of a default long int in bytes integer , parameter :: sizeof_real = 8 !! Size of a default real in bytes end module m_precision","tags":"","loc":"sourcefile/m_precision.f90.html"},{"title":"main.f90 – BROWNPAK","text":"Contents Programs main Source Code main.f90 Source Code program main use m_precision use m_strings use m_logger use m_globals , only : job_tag use m_control_io , only : read_control use m_setup , only : setup , finish , run implicit none !******************************************************************************* character ( len = 64 ) :: cla character ( len = :), allocatable :: key character ( len = :), allocatable :: val character ( len = :), allocatable :: fn_control character ( len = 128 ) :: msg integer :: ierr integer :: icla integer :: ncla ! number of command line arguments, without the command name integer ( int64 ) :: ccbeg , ccend , crate !Two command line arguments may be provided -- (i) fn_control=val and !(ii) job_tag=val fn_control = 'control.txt' ncla = command_argument_count () do icla = 1 , ncla call get_command_argument ( icla , value = cla , status = ierr ) if ( ierr > 0 ) then write ( * , '(a,1x,i0)' ) \"read failure for command argument\" , icla stop else if ( ierr == - 1 ) then write ( * , '(a,1x,i0)' ) \"command argument truncated\" , icla stop end if call str_get_keyval ( cla , key , val , '=' ) if ( key == 'fn_control' ) then fn_control = val else if ( key == 'job_tag' ) then job_tag = '.' // val end if end do call read_control ( fn_control ) call logger_init ( logger , 'brownpak.log' // job_tag , . true .) call setup () call system_clock ( ccbeg , crate ) call run () call system_clock ( ccend , crate ) write ( msg , '(a,es12.5)' ) 'execution time(s) = ' , ( ccend - ccbeg ) / real ( crate , rp ) call logger % log_msg ( msg ) call logger % finish () call finish () !******************************************************************************* end program","tags":"","loc":"sourcefile/main.f90.html"},{"title":"m_trajectory.f90 – BROWNPAK","text":"Contents Modules m_trajectory Source Code m_trajectory.f90 Source Code module m_trajectory !! Routines for reading and writing frames from a trajectory file. use m_precision implicit none type trajectory_t integer :: header_size = 0 integer :: frame_size = 0 integer :: num_atoms = 0 integer :: num_mpcd_atoms = 0 integer :: num_atoms_tot = 0 integer , dimension ( 4 ) :: frmcmp = 0 character ( len = :), allocatable :: fn integer :: file_id = 0 integer :: num_frames = 0 logical :: isopen = . false . contains procedure :: create => traj_create procedure :: open => traj_open procedure :: clear => traj_clear procedure :: close => traj_close procedure :: read => traj_read procedure :: append_frame => traj_append_frame procedure :: write_frame => traj_write_frame generic :: init => create , open end type trajectory_t contains !****************************************************************************** subroutine traj_create ( this , fn , na , nam , frmcmp ) !!  Creates a `trajectory_t` object with a new underlying file named `fn`.  If !!  `fn` already exists, it will be truncated.  The file `fn` is opened for both !!  reading and writing. class ( trajectory_t ), intent ( out ) :: this !! *trajectory_t* instance. character ( len =* ), intent ( in ) :: fn !! Name of the underlying trajectory file. integer , intent ( in ) :: na !! Number of non-MPCD atoms integer , intent ( in ) :: nam !! Number of MPCD atoms, pass zero to indicate no data from MPCD !! particles are present. integer , dimension ( 4 ), intent ( in ) :: frmcmp !! Binary flags indicating whether that component is present in a frame. !! frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces, !! frmcmp(4): charges integer :: nat , file_id nat = na + nam this % num_atoms = na ; this % num_mpcd_atoms = nam ; this % num_atoms_tot = nat this % frmcmp = frmcmp !Frame components: nts, coordinates, velocities, forces, charge !nts data this % frame_size = sizeof_long_int !Coordinate data if ( frmcmp ( 1 ) /= 0 ) this % frame_size = this % frame_size + 3 * nat * sizeof_real !Velocity data if ( frmcmp ( 2 ) /= 0 ) this % frame_size = this % frame_size + 3 * nat * sizeof_real !Force data if ( frmcmp ( 3 ) /= 0 ) this % frame_size = this % frame_size + 3 * na * sizeof_real !Charge data if ( frmcmp ( 4 ) /= 0 ) this % frame_size = this % frame_size + na * sizeof_real ! Representation of header: !     * 1 int for `header_size` !     * 1 int for `frame_size` !     * 2 ints:  `num_atoms`, `num_mpcd_atoms` !     * 4 ints:  `frmcmp` this % header_size = 8 * sizeof_int !Create trajectory file open ( newunit = file_id , file = fn , access = 'stream' , form = 'unformatted' , & action = 'readwrite' , status = 'replace' ) this % fn = fn this % file_id = file_id this % num_frames = 0 this % isopen = . true . write ( this % file_id ) this % header_size write ( this % file_id ) this % frame_size write ( this % file_id ) this % num_atoms , this % num_mpcd_atoms , this % frmcmp end subroutine !****************************************************************************** subroutine traj_open ( this , fn , mode , ierr ) !!  Creates a `trajectory_t` object with a prexisting underlying file named !!  `fn`.  If `fn` does not exist, an error will be generated. If !!  `mode` == 'rw', the file `fn` is opened for both reading and writing. !!  If `mode` == 'r', the file `fn` is opened only for reading. !\"\" class ( trajectory_t ), intent ( out ) :: this character ( len =* ), intent ( in ) :: fn character ( len =* ), intent ( in ) :: mode integer , intent ( out ) :: ierr integer ( ip_long ) :: file_size ierr = 0 this % fn = fn !Readwrite mode if ( mode == 'rw' ) then open ( newunit = this % file_id , file = this % fn , access = 'stream' , & form = 'unformatted' , action = 'readwrite' , status = 'old' ) !Readonly mode else if ( mode == 'r' ) then open ( newunit = this % file_id , file = this % fn , access = 'stream' , & form = 'unformatted' , action = 'read' , status = 'old' ) !Unknown mode else ierr = 1 ; return end if this % isopen = . true . !Get size of the file inquire ( unit = this % file_id , size = file_size ) read ( this % file_id ) this % header_size read ( this % file_id ) this % frame_size read ( this % file_id ) this % num_atoms , this % num_mpcd_atoms , this % frmcmp this % num_atoms_tot = this % num_atoms + this % num_mpcd_atoms !Integer division to find `num_frames` this % num_frames = int (( file_size - this % header_size ) / this % frame_size , ip ) end subroutine !****************************************************************************** subroutine traj_clear ( this ) !! After a call to this subroutine, all memory within `this` is deallocated, !! all components of `this` are reset to zero, and the underlying file is !! closed (if open). class ( trajectory_t ), intent ( in out ) :: this call this % close () if ( allocated ( this % fn )) deallocate ( this % fn ) this % header_size = 0 this % frame_size = 0 this % num_atoms = 0 this % num_mpcd_atoms = 0 this % num_atoms_tot = 0 this % frmcmp = 0 this % file_id = 0 this % num_frames = 0 end subroutine !****************************************************************************** subroutine traj_close ( this ) !! Closes the underlying file of a `trajectory_t`. class ( trajectory_t ), intent ( in out ) :: this if ( this % isopen ) then close ( this % file_id ) this % isopen = . false . end if end subroutine !****************************************************************************** subroutine traj_read ( this , iframe , nts , ierr , mflag , & coordinates , velocities , forces , charge ) !! Read from an open trajectory. class ( trajectory_t ), intent ( in ) :: this integer , intent ( in ) :: iframe !! Frame number integer ( ip_long ), intent ( out ) :: nts !! Time step counter integer , intent ( out ) :: ierr !! Error flag integer , intent ( in ), optional :: mflag !! 1: Only non-MPCD data, 2: Only MPCD data, 3: All data real ( rp ), dimension (:,:), intent ( out ), optional :: coordinates real ( rp ), dimension (:,:), intent ( out ), optional :: velocities real ( rp ), dimension (:,:), intent ( out ), optional :: forces real ( rp ), dimension (:), intent ( out ), optional :: charge integer ( ip_long ) :: offset_frm integer ( ip_long ) :: offset_if integer ( ip_long ) :: offset_tot integer :: na , nat , nam ierr = 0 na = this % num_atoms ; nam = this % num_mpcd_atoms ; nat = this % num_atoms_tot if ( iframe > this % num_frames ) then write ( * , * ) '`iframe`' , iframe , 'out of bounds for `num_frames`' , this % num_frames ierr = 1 return end if select case ( mflag ) case ( 1 ) if ( na == 0 ) then write ( * , * ) 'No data for non-MPCD atoms' ; ierr = 1 ; return end if case ( 2 ) if ( nam == 0 ) then write ( * , * ) 'No data for MPCD atoms' ; ierr = 1 ; return end if case ( 3 ) if ( nat == 0 ) then write ( * , * ) 'No data for any atoms' ; ierr = 1 ; return end if case default write ( * , * ) 'Unknown mflag = ' , mflag ; ierr = 1 ; return end select offset_frm = this % frame_size offset_frm = ( iframe - 1 ) * offset_frm + this % header_size + 1 read ( this % file_id , pos = offset_frm ) nts if ( present ( coordinates )) then if ( this % frmcmp ( 1 ) /= 1 ) then write ( * , * ) 'No coordinate data in frame' ; ierr = 1 ; return else select case ( mflag ) case ( 1 ) offset_if = sizeof_long_int offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) coordinates (:, 1 : na ) case ( 2 ) offset_if = sizeof_long_int + 3 * na * sizeof_real offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) coordinates (:, 1 : nam ) case ( 3 ) offset_if = sizeof_long_int offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) coordinates (:, 1 : nat ) end select end if end if if ( present ( velocities )) then if ( this % frmcmp ( 2 ) /= 1 ) then write ( * , * ) 'No velocity data in frame' ; ierr = 1 ; return else select case ( mflag ) case ( 1 ) offset_if = sizeof_long_int + 3 * nat * sizeof_real * this % frmcmp ( 1 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) velocities (:, 1 : na ) case ( 2 ) offset_if = sizeof_long_int + 3 * nat * sizeof_real * this % frmcmp ( 1 ) & + 3 * na * sizeof_real * this % frmcmp ( 2 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) velocities (:, 1 : nam ) case ( 3 ) offset_if = sizeof_long_int + 3 * nat * sizeof_real * this % frmcmp ( 1 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) velocities (:, 1 : nat ) end select end if end if if ( present ( forces )) then if ( this % frmcmp ( 3 ) /= 1 ) then write ( * , * ) 'No force data in frame' ; ierr = 1 ; return else offset_if = sizeof_long_int + 3 * nat * sizeof_real * this % frmcmp ( 1 ) & + 3 * nat * sizeof_real * this % frmcmp ( 2 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) forces (:, 1 : na ) end if end if if ( present ( charge )) then if ( this % frmcmp ( 4 ) /= 1 ) then write ( * , * ) 'No charge data in frame' ; ierr = 1 ; return else offset_if = sizeof_long_int + 3 * nat * sizeof_real * this % frmcmp ( 1 ) & + 3 * nat * sizeof_real * this % frmcmp ( 2 ) & + 3 * na * sizeof_real * this % frmcmp ( 3 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) charge ( 1 : na ) end if end if end subroutine !****************************************************************************** subroutine traj_append_frame ( this , nts , coordinates , velocities , forces , charge ) !! Write a frame to an open trajectory class ( trajectory_t ), intent ( in out ) :: this integer ( ip_long ), intent ( in ) :: nts real ( rp ), dimension (:,:), intent ( in ) :: coordinates real ( rp ), dimension (:,:), intent ( in ) :: velocities real ( rp ), dimension (:,:), intent ( in ) :: forces real ( rp ), dimension (:), intent ( in ) :: charge integer :: iframe iframe = this % num_frames + 1 call this % write_frame ( iframe , nts , coordinates , velocities , forces , charge ) end subroutine !****************************************************************************** subroutine traj_write_frame ( this , iframe , nts , coordinates , velocities , forces , charge ) !! Write a frame to an open trajectory class ( trajectory_t ), intent ( in out ) :: this integer , intent ( in ) :: iframe integer ( ip_long ), intent ( in ) :: nts real ( rp ), dimension (:,:), intent ( in ) :: coordinates real ( rp ), dimension (:,:), intent ( in ) :: velocities real ( rp ), dimension (:,:), intent ( in ) :: forces real ( rp ), dimension (:), intent ( in ) :: charge integer ( ip_long ) :: offset integer :: na , nat , nam na = this % num_atoms ; nam = this % num_mpcd_atoms ; nat = this % num_atoms_tot ! Added one to handle appending a frame if ( iframe > this % num_frames + 1 ) then write ( * , * ) '`iframe`' , iframe , 'out of bounds for `num_frames`' , & ( this % num_frames + 1 ) return end if offset = this % frame_size offset = ( iframe - 1 ) * offset + this % header_size + 1 write ( this % file_id , pos = offset ) nts if ( this % frmcmp ( 1 ) == 1 ) then if ( this % num_atoms == 0 ) then write ( this % file_id ) coordinates (:, na + 1 :) else if ( this % num_mpcd_atoms == 0 ) then write ( this % file_id ) coordinates (:, 1 : na ) else write ( this % file_id ) coordinates (:, 1 : nat ) end if end if if ( this % frmcmp ( 2 ) == 1 ) then if ( this % num_atoms == 0 ) then write ( this % file_id ) velocities (:, na + 1 :) else if ( this % num_mpcd_atoms == 0 ) then write ( this % file_id ) velocities (:, 1 : na ) else write ( this % file_id ) velocities (:, 1 : nat ) end if end if if ( this % frmcmp ( 3 ) == 1 ) write ( this % file_id ) forces if ( this % frmcmp ( 4 ) == 1 ) write ( this % file_id ) charge if ( iframe == this % num_frames + 1 ) this % num_frames = this % num_frames + 1 end subroutine !****************************************************************************** end module m_trajectory","tags":"","loc":"sourcefile/m_trajectory.f90.html"},{"title":"m_aabbtree.f90 – BROWNPAK","text":"Contents Modules m_aabbtree Source Code m_aabbtree.f90 Source Code module m_aabbtree use m_precision use m_strings use m_vector use m_aabb implicit none private public :: aabbtree_t integer , parameter :: NULL_NODE = 0 type node_t integer :: next = NULL_NODE integer :: parent = NULL_NODE integer :: left = NULL_NODE integer :: right = NULL_NODE integer :: height = - 1 integer :: atom = 0 type ( aabb_t ) :: aabb contains procedure :: init => node_init procedure :: isleaf => node_isleaf procedure :: asstr => node_asstr end type node_t type ( ivector_t ) :: stack type aabbtree_t type ( node_t ), dimension (:), allocatable :: nodes integer , dimension (:), allocatable :: atnd_tab !! Atom -> node map. integer :: capacity !! Maximum number of nodes that the tree can currently handle. This may !! increase as more atoms are inserted. integer :: freestore !! Pointer to head to the free store. integer :: size !! Number of nodes in the tree. integer :: root !! Pointer to the tree root. real ( rp ) :: tskin !! Thickness of the skin for fattened AABBs, as a fraction of the AABB !! base length. contains procedure :: init procedure :: print procedure :: clear procedure :: delete procedure :: insert procedure :: remove procedure :: remove_all procedure :: update_fatm procedure :: update_fatmaabb generic :: update => update_fatm , update_fatmaabb procedure :: query_watm procedure :: query_waabb procedure :: query_watmaabb generic :: query => query_watm , query_waabb , query_watmaabb procedure :: get_num_atoms procedure :: get_aabb procedure :: get_height procedure :: get_max_balance procedure :: get_srfarea_ratio procedure :: rebuild procedure :: validate procedure , private :: insert_leaf procedure , private :: remove_leaf procedure , private :: balance procedure , private :: calc_height procedure , private :: fs_acquire procedure , private :: fs_return procedure , private :: validate_structure procedure , private :: validate_metrics end type aabbtree_t interface module subroutine node_init ( this ) !! Initializes a node. class ( node_t ), intent ( out ) :: this !! A *node_t* instance. end subroutine module function node_isleaf ( this ) result ( res ) !! Is this a leaf node? class ( node_t ), intent ( in ) :: this !! A *node_t* instance. logical :: res !! *true* if this is a leaf node, *false* otherwise. end function module function node_asstr ( this , frmt ) result ( buf ) !! Returns a string representation of a node. class ( node_t ), intent ( in ) :: this !! A *node_t* instance. character ( len =* ), intent ( in ), optional :: frmt !! Format string for real numbers, e.g. '(f15.6)'. Default: *(g0.6)*. character ( len = :), allocatable :: buf !! Return value end function module subroutine init ( this , natoms , tskin ) !! Initializes an AABB tree. class ( aabbtree_t ), intent ( out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: natoms !! Estimated number of atoms to be handled by this tree. real ( rp ), intent ( in ) :: tskin !! Thickness of the skin for fattened AABBs, as a fraction of the !! AABB base length. end subroutine module recursive subroutine print ( this , p ) !! Prints a subtree of an AABB tree rooted at `p` in order. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ), optional :: p !! Pointer to the root of the subtree. Default is the root of the !! whole tree. end subroutine module subroutine clear ( this ) !! Clears an AABB tree. Associated memory is not deallocated. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. end subroutine module subroutine delete ( this ) !! Deletes an AABB tree. All associated memory is deallocated. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. end subroutine module subroutine insert ( this , ia , pos , radius ) !! Inserts an atom into an AABB tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index real ( rp ), dimension ( 3 ), intent ( in ) :: pos !! Atom position real ( rp ), intent ( in ) :: radius !! Atom radius (or cutoff distance for point particles) end subroutine module subroutine remove ( this , ia ) !! Removes an atom from an AABB tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index end subroutine module subroutine remove_all ( this ) !! Removes all atoms from an AABB tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. end subroutine module subroutine update_fatm ( this , ia , pos , radius , lstat ) !! Updates an AABB tree for the case when an atom leaves its fattened !! AABB. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index real ( rp ), dimension ( 3 ), intent ( in ) :: pos !! Atom position real ( rp ), intent ( in ) :: radius !! Atom radius (or cutoff distance for point particles) logical , intent ( out ) :: lstat !! *true* if the atom was reinserted, *false* otherwise. end subroutine module subroutine update_fatmaabb ( this , ia , lbnd , ubnd , lstat ) !! Updates an AABB tree for the case when an atom leaves its fattened !! AABB, with the bounds of the new AABB for the atom as input. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index real ( rp ), dimension ( 3 ), intent ( in ) :: lbnd !! Lower bound of atom AABB real ( rp ), dimension ( 3 ), intent ( in ) :: ubnd !! Upper bound of atom AABB logical , intent ( out ) :: lstat !! *true* if the atom was reinserted, *false* otherwise. end subroutine module subroutine query_watm ( this , ia , nbrs ) !! Query an AABB tree for a set of potential neighbors of an atom. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index type ( ivector_t ), intent ( in out ) :: nbrs !! List of potential neighbors. end subroutine module subroutine query_watmaabb ( this , ia , aabb , nbrs ) !! Query an AABB tree for a set of potential neighbors of an atom & its !! bounding AABB. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index. type ( aabb_t ), intent ( in ) :: aabb !! Bounding AABB for atom with index `ia`. type ( ivector_t ), intent ( in out ) :: nbrs !! List of potential neighbors. end subroutine module subroutine query_waabb ( this , aabb , atms ) !! Query an AABB tree for the set of atoms whose AABBS overlap with !! `aabb`. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. type ( aabb_t ), intent ( in ) :: aabb !! An *aabb_t* instance. type ( ivector_t ), intent ( in out ) :: atms !! List of potential neighbors. end subroutine module function get_num_atoms ( this ) result ( na ) !! Returns the number of atoms in an AABB tree. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer :: na !! Return value end function module function get_aabb ( this , ia ) result ( aabb ) !! Returns a copy of the AABB associated with atom with index `ia`. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: ia !! Atom index. type ( aabb_t ) :: aabb !! AABB of atom `ia`. end function module function get_height ( this ) result ( height ) !! Returns the height of an AABB tree. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer :: height !! Return value. end function module function get_max_balance ( this ) result ( max_balance ) !! Returns the maximum difference between the height of two children !! of a node. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer :: max_balance !! Return value. end function module function get_srfarea_ratio ( this ) result ( saratio ) !! Returns the ratio of the sum of the node surface area to the surface !! area of the root node. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. real ( rp ) :: saratio !! Return value. end function module subroutine rebuild ( this ) !! Rebuilds an optimal AABB tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. end subroutine module subroutine validate ( this ) !! Validates an AABB tree. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. end subroutine module subroutine insert_leaf ( this , leaf ) !! Inserts a leaf node into a tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: leaf !! Pointer to a leaf node end subroutine module subroutine remove_leaf ( this , leaf ) !! Removes a leaf node from a tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: leaf !! Pointer to a leaf node end subroutine module function balance ( this , p ) result ( q ) !! Balances an AABB tree. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: p !! Node index integer :: q end function module recursive function calc_height ( this , p ) result ( height ) !! Calculates the height of a subtree. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ), optional :: p !! Pointer to the root of the subtree. Default: Root of the whole !! tree. integer :: height !! Return value end function module function fs_acquire ( this ) result ( p ) !! Acquires a new node from the free store and returns a pointer to it. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer :: p !! Return value end function module subroutine fs_return ( this , p ) !! Returns a node to the free store. class ( aabbtree_t ), intent ( in out ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: p !! Node pointer. end subroutine module recursive subroutine validate_structure ( this , p ) !! Asserts that an AABB subtree has a valid structure. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: p !! Pointer to the root of the subtree. end subroutine module recursive subroutine validate_metrics ( this , p ) !! Asserts that an AABB subtree has a valid metric. class ( aabbtree_t ), intent ( in ) :: this !! An *aabbtree_t* instance. integer , intent ( in ) :: p !! Pointer to the root of the subtree. end subroutine end interface !******************************************************************************* end module m_aabbtree","tags":"","loc":"sourcefile/m_aabbtree.f90.html"},{"title":"m_ia_tether.f90 – BROWNPAK","text":"Contents Modules m_ia_tether Source Code m_ia_tether.f90 Source Code module m_ia_tether !! Tether potentials !! !! *Style 0: None !! *Style 1: Rigid connector (not implemented) !! *Style 2: Harmonic spring. See [[teth_harm_set]]. use m_precision use m_constants_math use m_globals implicit none private public :: ia_tether_setup , ia_get_tether_force contains !****************************************************************************** subroutine ia_tether_setup () !! Sets up parameters for tether potentials integer :: i integer :: sty !Set tether interactions do i = 1 , num_tether_types sty = tether_styles ( i ) select case ( sty ) case ( 1 ) call teth_rigid_set ( tether_params (:, i )) case ( 2 ) call teth_harm_set ( tether_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_tether_force ( qmag , teth_typ , enrg , frc , ierr ) !! Calculates the energy and its derivative due to a tether. real ( rp ), intent ( in ) :: qmag !! Distance between the tethered atom & the tether point integer , intent ( in ) :: teth_typ real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr integer :: teth_styl ierr = 0 enrg = 0.0_rp ; frc = 0.0_rp teth_styl = tether_styles ( teth_typ ) select case ( teth_styl ) case ( 1 ) call teth_rigid ( qmag , tether_params (:, teth_typ ), enrg , frc , ierr ) case ( 2 ) call teth_harm ( qmag , tether_params (:, teth_typ ), enrg , frc ) case default continue end select end subroutine !******************************************************************************** subroutine teth_rigid_set ( params , r0 , eps ) !! Setter for rigid tether interaction. !! !! User-set parameters: !! !! * params(1) = `r0` (fixed separation distance) !! * params(2) = `eps` (allowed tolerance) real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: r0 real ( rp ), intent ( in ), optional :: eps if ( present ( r0 )) params ( 1 ) = r0 if ( present ( eps )) params ( 2 ) = eps end subroutine !******************************************************************************** subroutine teth_rigid ( r , params , enrg , frc , ierr ) !! Not implemented, needs constraint formalism. See [[teth_rigid_set]]. !! !! Calculates energy for rigid tether interaction. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp if ( abs ( r - params ( 1 )) < params ( 2 ) ) then enrg = 0.0_rp ; frc = 0.0_rp else ierr = 1 return end if end subroutine !******************************************************************************** !params(1) = k, params(2) = r0 (equilibrium distance) subroutine teth_harm_set ( params , k , r0 ) !! Setter for harmonic tether interaction. !! !!``` !!  U = (1/2)*k*(r - r0)&#94;2 !!``` !! User-set parameters: !! !! * params(1) = `k` (spring constant) !! * params(2) = `r0` (equilibrium distance) real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: r0 if ( present ( k )) params ( 1 ) = k if ( present ( r0 )) params ( 2 ) = r0 end subroutine !******************************************************************************** subroutine teth_harm ( r , params , enrg , frc ) !! Calculates energy and its derivative for harmonic tether interaction. See !! [[teth_harm_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc enrg = 0.5_rp * params ( 1 ) * ( r - params ( 2 )) * ( r - params ( 2 )) frc = params ( 1 ) * ( r - params ( 2 )) end subroutine !****************************************************************************** end module m_ia_tether","tags":"","loc":"sourcefile/m_ia_tether.f90.html"},{"title":"m_verlet.f90 – BROWNPAK","text":"Contents Modules m_verlet Source Code m_verlet.f90 Source Code module m_verlet !! Routines for building Verlet neighbor table. use m_precision use m_vector use m_table use m_globals implicit none private public :: verlet_init , verlet_build , verlet_delete public :: verlet_tab type ( itable_t ) :: verlet_tab !! Verlet table real ( rp ), dimension (:,:), allocatable :: coordinates_save !!  (3, *num_atoms*) array real ( rp ), dimension (:,:), allocatable :: coordinates_dr !!  (3, *num_atoms*) array real ( rp ) :: rskin_sq = 0.0_rp real ( rp ) :: tskin_sq = 0.0_rp contains !****************************************************************************** subroutine verlet_init ( rskin , tskin ) real ( rp ), intent ( in ) :: rskin real ( rp ), intent ( in ) :: tskin rskin_sq = rskin ** 2 tskin_sq = tskin ** 2 call itbl_init ( verlet_tab , num_atoms - 1 ) allocate ( coordinates_save ( 3 , num_atoms ) ) allocate ( coordinates_dr ( 3 , num_atoms ) ) !Initializing to zero coordinates_save = 0.0_rp coordinates_dr = 0.0_rp end subroutine !****************************************************************************** subroutine verlet_delete () if ( allocated ( coordinates_save )) deallocate ( coordinates_save ) if ( allocated ( coordinates_dr ) ) deallocate ( coordinates_dr ) call verlet_tab % delete () end subroutine !****************************************************************************** subroutine verlet_build () real ( rp ), dimension ( 3 ) :: ri real ( rp ), dimension ( 3 ) :: rj real ( rp ), dimension ( 3 ) :: rij real ( rp ) :: dr_sq_max real ( rp ) :: rij_sq logical , save :: first_call = . true . integer :: i , j !On first call no check for rebuilding if (. not . first_call ) then !Check whether rebuilding the list is necessary coordinates_dr = coordinates (:, 1 : num_atoms ) - coordinates_save if ( imcon /= 0 ) then do i = 1 , num_atoms call simbox % get_image ( coordinates_dr (:, i )) end do end if dr_sq_max = maxval ( sum ( coordinates_dr ** 2 , dim = 1 )) if ( 4 * dr_sq_max < tskin_sq ) then return end if end if first_call = . false . !Clear table call verlet_tab % clear () !Loop over all pairs to build list do i = 1 , num_atoms - 1 ri = coordinates (:, i ) do j = i + 1 , num_atoms rj = coordinates (:, j ) rij = rj - ri if ( imcon /= 0 ) call simbox % get_image ( rij ) rij_sq = sum ( rij ** 2 ) if ( rij_sq < rskin_sq ) call verlet_tab % append ( i , j ) end do end do !Release additional memory call verlet_tab % shrink_to_fit () !Back up positions coordinates_save = coordinates (:, 1 : num_atoms ) end subroutine !******************************************************************************** end module m_verlet","tags":"","loc":"sourcefile/m_verlet.f90.html"},{"title":"m_ran_num.f90 – BROWNPAK","text":"Contents Modules m_ran_num Source Code m_ran_num.f90 Source Code module m_ran_num !!  Provides random number generation procedures, mostly calling !! routine from Intel MKL VSL. use m_precision use mkl_vsl_type use mkl_vsl implicit none private public :: & init_stream , & delete_stream , & load_stream , & save_stream , & save_seed , & get_iuniform , & get_rv_iuniform , & get_uniform , & get_rv_uniform , & get_rv_gaussian , & ransphere integer ( ip ), save :: seed type ( VSL_STREAM_STATE ), save :: stream contains !******************************************************************* subroutine init_stream ( fn ) !! Initializes a BRNG stream. !! The stream is initialized with a seed from the file `fn`. If !! `fn` is an empty string, the seed is obtained from `/dev/urandom`. character ( len =* ) :: fn !! Name of the file containing the RNG seed. integer ( ip ) :: fu integer ( ip ) :: stat if ( len_trim ( fn ) == 0 ) then open ( newunit = fu , file = '/dev/urandom' , action = 'read' , & form = 'unformatted' , access = 'stream' , status = 'old' ) read ( fu ) seed close ( fu ) seed = abs ( seed ) else open ( newunit = fu , file = fn , action = 'read' , status = 'old' ) read ( fu , * ) seed close ( fu ) end if stat = vslNewStream ( stream , VSL_BRNG_MT19937 , seed ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslNewStream' end if end subroutine !******************************************************************* subroutine delete_stream () !! Deletes a BRNG stream. integer ( ip ) :: stat stat = vslDeleteStream ( stream ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslDeleteStream' end if end subroutine !******************************************************************* subroutine load_stream ( fn ) !! Loads a BRNG stream from file `fn`. character ( len =* ), intent ( in ) :: fn integer ( ip ) :: stat stat = vslLoadStreamF ( stream , fn ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslLoadStream' end if end subroutine !******************************************************************* subroutine save_seed ( fn ) !! Saves the RNG seed to file `fn`. character ( len =* ), intent ( in ) :: fn integer ( ip ) :: fu open ( newunit = fu , file = fn , action = 'write' , status = 'replace' ) write ( fu , * ) seed close ( fu ) end subroutine !******************************************************************* subroutine save_stream ( fn ) !! Saves a BRNG stream to file `fn`. character ( len =* ), intent ( in ) :: fn integer ( ip ) :: stat stat = vslSaveStreamF ( stream , fn ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslSaveStream' end if end subroutine !******************************************************************* function get_uniform ( lb , ub ) result ( res ) !! Returns a random number from a uniform distribution. real ( rp ), intent ( in ) :: lb !! Lower bound real ( rp ), intent ( in ) :: ub !! Upper bound real ( rp ) :: res real ( rp ), dimension ( 1 ) :: rv integer ( ip ) :: stat stat = vdrnguniform ( VSL_RNG_METHOD_UNIFORM_STD_ACCURATE , stream , & 1 , rv , lb , ub ) res = rv ( 1 ) end function !******************************************************************* subroutine get_rv_uniform ( lb , ub , rv , block_size ) !! Returns a random vector from a uniform distribution. !! If a `block_size > 0` is provided, it fills `rv` in blocks of !! size `block_size`. real ( rp ), intent ( in ) :: lb !! Lower bound real ( rp ), intent ( in ) :: ub !! Upper bound real ( rp ), dimension (:), intent ( out ) :: rv integer ( ip ), intent ( in ), optional :: block_size integer ( ip ) :: stat integer ( ip ) :: num_blocks integer ( ip ) :: size_rv integer ( ip ) :: ini integer ( ip ) :: fin integer ( ip ) :: n if (. not . present ( block_size )) then stat = vdrnguniform ( VSL_RNG_METHOD_UNIFORM_STD_ACCURATE , stream , & size ( rv ), rv , lb , ub ) else size_rv = size ( rv ) num_blocks = ceiling ( size_rv / real ( block_size )) ini = 0 fin = 0 do if ( fin >= size_rv ) then exit end if if ( size_rv <= block_size ) then n = size_rv else if (( size_rv - fin ) < block_size ) then n = size_rv - fin else n = block_size end if ini = fin + 1 fin = fin + n stat = vdrnguniform ( VSL_RNG_METHOD_UNIFORM_STD_ACCURATE , stream , & n , rv ( ini : fin ), lb , ub ) end do end if end subroutine !******************************************************************* function get_iuniform ( lb , ub ) result ( res ) !! Returns a random integer from a uniform distribution. integer ( ip ), intent ( in ) :: lb integer ( ip ), intent ( in ) :: ub integer ( ip ) :: res integer ( ip ), dimension ( 1 ) :: rv integer ( ip ) :: stat stat = virnguniform ( VSL_RNG_METHOD_UNIFORM_STD , stream , & 1 , rv , lb , ub ) res = rv ( 1 ) end function !******************************************************************* subroutine get_rv_iuniform ( lb , ub , rv , block_size ) !! Returns a random vector of integers from a uniform distribution. integer ( ip ), intent ( in ) :: lb integer ( ip ), intent ( in ) :: ub integer ( ip ), dimension (:), intent ( out ) :: rv integer ( ip ), intent ( in ), optional :: block_size integer ( ip ) :: stat integer ( ip ) :: num_blocks integer ( ip ) :: size_rv integer ( ip ) :: ini integer ( ip ) :: fin integer ( ip ) :: n if (. not . present ( block_size )) then stat = virnguniform ( VSL_RNG_METHOD_UNIFORM_STD , stream , & size ( rv ), rv , lb , ub ) else size_rv = size ( rv ) num_blocks = ceiling ( size_rv / real ( block_size )) ini = 0 fin = 0 do if ( fin >= size_rv ) then exit end if if ( size_rv <= block_size ) then n = size_rv else if (( size_rv - fin ) < block_size ) then n = size_rv - fin else n = block_size end if ini = fin + 1 fin = fin + n stat = virnguniform ( VSL_RNG_METHOD_UNIFORM_STD , stream , & n , rv ( ini : fin ), lb , ub ) end do end if end subroutine !******************************************************************* subroutine get_rv_gaussian ( mean , std_dev , rv , block_size ) !! Generates a random vector of integers from a gaussian distribution. real ( rp ), intent ( in ) :: mean real ( rp ), intent ( in ) :: std_dev real ( rp ), dimension (:), intent ( out ) :: rv integer ( ip ), intent ( in ), optional :: block_size integer ( ip ) :: stat integer ( ip ) :: num_blocks integer ( ip ) :: size_rv integer ( ip ) :: ini integer ( ip ) :: fin integer ( ip ) :: n if (. not . present ( block_size )) then stat = vdrnggaussian ( VSL_RNG_METHOD_GAUSSIAN_BOXMULLER , stream , & size ( rv ), rv , mean , std_dev ) else size_rv = size ( rv ) num_blocks = ceiling ( size_rv / real ( block_size )) ini = 0 fin = 0 do if ( fin >= size_rv ) then exit end if if ( size_rv <= block_size ) then n = size_rv else if (( size_rv - fin ) < block_size ) then n = size_rv - fin else n = block_size end if ini = fin + 1 fin = fin + n stat = vdrnggaussian ( VSL_RNG_METHOD_GAUSSIAN_BOXMULLER , stream , & n , rv ( ini : fin ), mean , std_dev ) end do end if end subroutine !******************************************************************* subroutine ransphere ( r ) !! Generates a random vector from the surface of a unit sphere. !! !! Algorithm from Allen & Tildesley (ed 1) p. 349. real ( rp ), dimension ( 3 ), intent ( out ) :: r ( 3 ) real ( rp ), dimension ( 2 ) :: zeta real ( rp ) :: zetasq real ( rp ) :: rt r = 0.0_rp zetasq = 2.0_rp ! Any value greater than 1 do call get_rv_uniform ( - 1.0_rp , 1.0_rp , zeta ) zetasq = zeta ( 1 ) * zeta ( 1 ) + zeta ( 2 ) * zeta ( 2 ) rt = sqrt ( 1.0_rp - zetasq ) r ( 1 ) = 2.0_rp * zeta ( 1 ) * rt r ( 2 ) = 2.0_rp * zeta ( 2 ) * rt r ( 3 ) = 1.0_rp - 2.0_rp * zetasq if ( zetasq <= 1.0_rp ) exit end do end subroutine !******************************************************************* end module m_ran_num","tags":"","loc":"sourcefile/m_ran_num.f90.html"},{"title":"m_ia_external.f90 – BROWNPAK","text":"Contents Modules m_ia_external Source Code m_ia_external.f90 Source Code module m_ia_external !! External potentials !! !! This module is meant to be a placeholder to any external fields that the user !! wants to add. Accordingly replace/add to the existing routines. The !! subroutines [[ia_external_setup]] and [[ia_add_external_forces]] must remain !! for interfacing to the force calculation driver routine [[ia_calc_forces]]. !! !! * Style 0: None !! * Style 1: Pulling force along +ve x-axis !! * Style 2: Hard planar wall use m_precision use m_constants_math use m_globals implicit none private public :: ia_external_setup , ia_add_external_forces contains !****************************************************************************** subroutine ia_external_setup () !! Sets up parameters for external potentials. Usually there is nothing to !! set for externals, but this acts as a placeholder for special cases. integer :: i integer :: sty !Set external interactions do i = 1 , num_externals sty = external_styles ( i ) select case ( sty ) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_add_external_forces ( ierr ) !! Calculates the force and energy due to an external field and adds to !! `energy_external`, 'forces`, & `stress` in module `m_globals`. integer , intent ( out ) :: ierr real ( rp ) :: enrg real ( rp ) :: frcx , v , sn integer :: iext integer :: styl , iatm , m ierr = 0 do iext = 1 , num_externals styl = external_styles ( iext ) select case ( styl ) case ( 1 ) ! Pulling force along +ve x-axis. iatm = int ( external_params ( 1 , iext )) frcx = external_params ( 2 , iext ) enrg = - frcx * ( coordinates ( 1 , iatm ) - coordinates ( 1 , 1 )) energy_external = energy_external + enrg forces ( 1 , iatm ) = forces ( 1 , iatm ) + frcx case ( 2 ) ! Rigid walls. Need to modify this (or another case) for repulsive walls. enrg = 0.0_rp m = int ( external_params ( 1 , iext )) v = external_params ( 2 , iext ) sn = external_params ( 3 , iext ) if ( sn > 0.0_rp ) then if ( any ( coordinates ( m ,:) < v ) ) ierr = 1 else if ( any ( coordinates ( m ,:) > v ) ) ierr = 1 end if case default continue end select end do !Need to update stress end subroutine !****************************************************************************** end module m_ia_external","tags":"","loc":"sourcefile/m_ia_external.f90.html"},{"title":"m_relax.f90 – BROWNPAK","text":"Contents Modules m_relax Source Code m_relax.f90 Source Code module m_relax !! Performs structure relaxation (energy minimization) using steepest descent. !! !! Atom positions evolve following the gradient direction, in steps of size !! `tim_stp`. If `tim_stp` is too large, bond constraints are likely to be !! violated. !! !! If MPCD atoms are present, they do not take part in structure relaxation. use m_precision use m_ran_num use m_strings use m_globals use m_interaction , only : ia_calc_forces use m_stats_io use m_config_io implicit none private public :: rlx_run contains !****************************************************************************** subroutine rlx_run () !! Driver for relaxation character ( len = :), allocatable :: fn_ldf , fn_rlx real ( rp ), parameter :: abs_tol = 1.0E-3_rp real ( rp ), parameter :: rel_tol = 1.0E-8_rp real ( rp ) :: enrg0 , enrg_dif integer :: ierr logical :: zf , has_converged fn_rlx = str_strip ( fn_cfg , '.cfg' , 'r' ) // '-rlx.cfg' fn_ldf = str_strip ( fn_cfg , '.cfg' , 'r' ) // '-rlx.txt' ierr = 0 !For isolated untethered molecule, ensure c.o.m. is at the center of the !box. if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) then call simbox % to_center ( coordinates ) end if !Log & dump starting configuration call logger % log_msg ( '<rlx_run> nts = ' // str_from_num ( nts )) call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) !Relaxation run has_converged = . false . !Assume a very high initial energy enrg0 = huge ( 1.0_rp ) do while ( nts < nts_sim ) if ( has_converged ) exit call rlx_integrate ( ierr , zf ) nts = nts + 1 !For isolated untethered molecule bring c.o.m. to the center of the box if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) then call simbox % to_center ( coordinates ) end if !Wrap around periodic boundaries if ( imcon /= 0 ) call simbox % wrap_all ( coordinates (:, 1 : num_atoms )) !Logging if ( mod ( nts , nts_log ) == 0 ) then call logger % log_msg ( '<rlx_run> nts: ' // str_from_num ( nts )) end if !Dump revive file if ( mod ( nts , nts_dump ) == 0 ) then call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end if !Relaxation stats if ( mod ( nts , nts_samp ) == 0 ) call stats_write () !Convergence check !I am not using relative tolerance here. if ( zf ) has_converged = . true . enrg_dif = abs ( energy_tot - enrg0 ) if ( enrg_dif <= ( rel_tol * energy_tot + abs_tol ) ) has_converged = . true . enrg0 = energy_tot end do !Log end of run if ( ierr /= 0 ) then call logger % log_msg ( '<rlx_run> Relaxation completed with violations' ) else call logger % log_msg ( '<rlx_run> Relaxation completed' ) end if !Dump the final configuration call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) !Export final configuration to config & ldf files call write_config ( fn_rlx // trim ( adjustl ( job_tag )), ' ' ) call write_ldf ( fn_ldf // trim ( adjustl ( job_tag )), ' ' ) end subroutine !****************************************************************************** subroutine rlx_integrate ( ierr , zf ) !! Performs one step of relaxation integer , intent ( out ) :: ierr logical , intent ( out ) :: zf real ( rp ) :: scale_factor integer :: i zf = . false . !Calculate forces call ia_calc_forces ( ierr ) !If all forces are zero, nothing to do if ( all ( forces == 0.0_rp ) ) then zf = . true . return end if scale_factor = 1.0_rp / maxval ( abs ( forces )) forces = scale_factor * forces scale_factor = 1.0_rp / sum ( forces ** 2 ) forces = scale_factor * forces !Update position do i = 1 , num_atoms coordinates (:, i ) = coordinates (:, i ) + tim_stp * forces (:, i ) end do end subroutine !******************************************************************************** end module m_relax","tags":"","loc":"sourcefile/m_relax.f90.html"},{"title":"m_ia_bond.f90 – BROWNPAK","text":"Contents Modules m_ia_bond Source Code m_ia_bond.f90 Source Code module m_ia_bond !! This module contains routines to evaluate bond potentials and their !! derivative. !! !! The following styles are available: !! !! * Style 0. None (only topology) !! * Style 1. Harmonic. See [[bond_harm_set]]. !! * Style 2. FENE. See [[bond_fene_set]]. !! * Style 3. Kremer-Grest. See [[bond_kg_set]]. !! * Style 4. Marko-Siggia. See [[bond_ms_set]]. use m_precision use m_constants_math use m_strings use m_globals use m_logger implicit none private public :: ia_bond_setup , ia_get_bond_force contains !****************************************************************************** subroutine ia_bond_setup () !! Sets up parameters for bond potentials integer :: i integer :: sty !Set bond interactions do i = 1 , num_bond_types sty = bond_styles ( i ) select case ( sty ) case ( 1 ) call bond_harm_set ( bond_params (:, i )) case ( 2 ) call bond_fene_set ( bond_params (:, i )) case ( 3 ) call bond_kg_set ( bond_params (:, i )) case ( 4 ) call bond_ms_set ( bond_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_bond_force ( rij_mag , bnd_typ , enrg , frc , ierr ) !! Calculates the energy & its derivative due to a bond. real ( rp ), intent ( in ) :: rij_mag !! Distance between bonded atoms integer , intent ( in ) :: bnd_typ !! Type of the bond real ( rp ), intent ( out ) :: enrg !! Bond energy real ( rp ), intent ( out ) :: frc !! Derivative of the potential. This is the magnitude of the force due !! to this potential. integer , intent ( out ) :: ierr !! Error flag integer :: bnd_styl ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp bnd_styl = bond_styles ( bnd_typ ) select case ( bnd_styl ) case ( 1 ) call bond_harm ( rij_mag , bond_params (:, bnd_typ ), enrg , frc ) case ( 2 ) call bond_fene ( rij_mag , bond_params (:, bnd_typ ), enrg , frc , ierr ) case ( 3 ) call bond_kg ( rij_mag , bond_params (:, bnd_typ ), enrg , frc , ierr ) case ( 4 ) call bond_ms ( rij_mag , bond_params (:, bnd_typ ), enrg , frc , ierr ) case default continue end select end subroutine !******************************************************************************** subroutine bond_harm_set ( params , k , r0 ) !! Setter for harmonic bond interaction. !! !!``` !!  U = (1/2)*k*(r - r0)&#94;2 !!``` !! User-set parameters: !! !! * params(1) = `k` (spring constant) !! * params(2) = `r0` (equilibrium distance) real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: r0 if ( present ( k )) params ( 1 ) = k if ( present ( r0 )) params ( 2 ) = r0 end subroutine !******************************************************************************** subroutine bond_harm ( r , params , enrg , frc ) !! Calculates energy & its derivative for harmonic bond. See [[bond_harm_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc enrg = 0.5_rp * params ( 1 ) * ( r - params ( 2 )) * ( r - params ( 2 )) frc = params ( 1 ) * ( r - params ( 2 )) end subroutine !******************************************************************************** subroutine bond_fene_set ( params , k , rmax , r0 ) !! Setter for FENE bond. !! !!``` !!  U = -0.5 k rmax&#94;2 log [1 - ((r - r0)/rmax)&#94;2] !!``` !! !! User-set parameters: !! !! * params(1) = `k` !! * params(2) = `rmax` !! * params(3) = `r0` !! !! @Note The bond cannot extend beyond (rmax+r0), where r0 is the !! equilibrium bond length. If r0 = 0, this reduces to the standard definition !! of FENE bonds. !! !! Internally stored parameters: !! !! * params(4) = `rmax&#94;2` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: rmax real ( rp ), intent ( in ), optional :: r0 if ( present ( k )) params ( 1 ) = k if ( present ( rmax )) params ( 2 ) = rmax if ( present ( r0 )) params ( 3 ) = r0 params ( 4 ) = params ( 2 ) * params ( 2 ) end subroutine !******************************************************************************** subroutine bond_fene ( r , params , enrg , frc , ierr ) !! Calculates energy & its derivative for FENE bond. See [[bond_fene_set]]. !! !! If bond length exceeds maximum extensible spring length, an error will be !! reported by `ierr = 1`. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr real ( rp ) :: k , rmax , r0 real ( rp ) :: extn , extnsq , rmaxsq ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp k = params ( 1 ); rmax = params ( 2 ); r0 = params ( 3 ); rmaxsq = params ( 4 ) extn = r - r0 ; extnsq = extn * extn if ( r >= ( rmax + r0 ) ) then ierr = 1 call logger % log_msg ( '<bond_fene> bondlength too large' ) call logger % log_msg ( '<bond_fene> r = ' // str_from_num ( r )) return else enrg = - 0.5_rp * k * rmaxsq * log ( 1.0_rp - extnsq / rmaxsq ) frc = k * extn / ( 1.0_rp - extnsq / rmaxsq ) end if end subroutine !****************************************************************************** subroutine bond_kg_set ( params , k , rmax , eps , sigma ) !! Setter for FENE bond interaction. !! !!``` !!   V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] + eps !!   W = -0.5 k rmax&#94;2 log [1 - (r/rmax)&#94;2] !!   U = W + V, r < 2&#94;(1/6)*sigma !!       W, r >= 2&#94;(1/6)*sigma !!``` !! User-set parameters: !! !! * params(1) = `k` !! * params(2) = `rmax` !! * params(3) = `eps` !! * params(4) = `sigma` !! !! Internally stored parameters: !! !! * params(5) = `rmax&#94;2` !! * params(6) = `2&#94;(1/6)*sigma` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: rmax real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ) :: k_ , rmax_ , eps_ , sigma_ if ( present ( k )) params ( 1 ) = k if ( present ( rmax )) params ( 2 ) = rmax if ( present ( eps )) params ( 3 ) = eps if ( present ( sigma )) params ( 4 ) = sigma k_ = params ( 1 ); rmax_ = params ( 2 ); eps_ = params ( 3 ); sigma_ = params ( 4 ) params ( 5 ) = rmax_ ** 2 params ( 6 ) = math_sxrt2 * sigma_ end subroutine !******************************************************************************** subroutine bond_kg ( r , params , enrg , frc , ierr ) !! Calculates energy & its derivative for Kremer-Grest bond. See [[bond_kg_set]]. !! !! If bond length exceeds maximum extensible spring length, an error will be !! reported as `ierr = 1`. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr real ( rp ) :: k , rmax , eps , sigma real ( rp ) :: rmaxsq , rcut real ( rp ) :: rsq , sir , sir2 , sir12 , sir6 ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp k = params ( 1 ); rmax = params ( 2 ); eps = params ( 3 ); sigma = params ( 4 ) rmaxsq = params ( 5 ); rcut = params ( 6 ) rsq = r * r if ( r >= rmax ) then ierr = 1 call logger % log_msg ( '<bond_kg> r > rmax' ) call logger % log_msg ( '<bond_kg> r = ' // str_from_num ( r )) return else if ( ( r >= rcut ) . and . ( r < rmax ) ) then enrg = - 0.5_rp * k * rmaxsq * log ( 1.0_rp - rsq / rmaxsq ) frc = k * r / ( 1.0_rp - rsq / rmaxsq ) else sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = - 0.5_rp * k * rmaxsq * log ( 1.0_rp - rsq / rmaxsq ) & + 4 * eps * ( sir12 - sir6 ) + eps frc = k * r / ( 1.0_rp - rsq / rmaxsq ) - 24 * eps * ( 2 * sir12 - sir6 ) / r end if end subroutine !****************************************************************************** subroutine bond_ms_set ( params , lp , rmax ) !! Setter for Marko-Siggia bond. !! !!``` !!   U = [-(1/2)*rtilde&#94;2 + 0.25/(1-rtilde)&#94;2 + 0.25*rtilde]*(rmax/lp), r < rmax !!   where rtilde = r/rmax. !!``` !! !! User-set parameters: !! !! * params(1) = `lp` (persistence length) !! * params(2) = `rmax` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: lp real ( rp ), intent ( in ), optional :: rmax if ( present ( lp )) params ( 1 ) = lp if ( present ( rmax )) params ( 2 ) = rmax end subroutine !******************************************************************************** subroutine bond_ms ( r , params , enrg , frc , ierr ) !! Evaluates the potential & its derivative for Marko-Siggia bond. !! See [[bond_ms_set]]. !! !! If bond length exceeds maximum extensible spring length, an error will be !! reported as `ierr = 1`. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr real ( rp ) :: lp , rmax , rtilde , rrtilde ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp lp = params ( 1 ); rmax = params ( 2 ) if ( r >= rmax ) then ierr = 1 call logger % log_msg ( '<bond_ms> r > rmax' ) call logger % log_msg ( '<bond_ms> r = ' // str_from_num ( r )) return else rtilde = r / rmax ; rrtilde = 1.0_rp / ( 1.0_rp - rtilde ) enrg = ( - 0.5 * rtilde * rtilde + 0.25_rp * rrtilde * rrtilde + 0.25 * rtilde ) * ( rmax / lp ) frc = ( - rtilde - 0.25_rp * rrtilde * rrtilde + 0.25_rp ) / lp end if end subroutine !****************************************************************************** end module m_ia_bond","tags":"","loc":"sourcefile/m_ia_bond.f90.html"},{"title":"ivector_t – BROWNPAK ","text":"type, public :: ivector_t Contents Variables len_init len len_max buffer Type-Bound Procedures delete clear get_val set_val get_data append pop resize shrink_to_fit sort unique print Source Code ivector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 integer, public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => ivector_delete public subroutine ivector_delete (this) Deletes an ivector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this procedure, public :: clear => ivector_clear public subroutine ivector_clear (this) Clears an ivector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this procedure, public :: get_val => ivector_get_val public function ivector_get_val (this, i) result(res) Returns the ith element of an ivector . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this integer, intent(in) :: i Return Value integer procedure, public :: set_val => ivector_set_val public subroutine ivector_set_val (this, i, val) Sets the value of the ith element of an ivector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: val procedure, public :: get_data => ivector_get_data public subroutine ivector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in), target :: this integer, intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend procedure, public :: append => ivector_append public subroutine ivector_append (this, val) Adds an element to the end of an ivector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: val procedure, public :: pop => ivector_pop public function ivector_pop (this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Return Value integer procedure, public :: resize => ivector_resize public subroutine ivector_resize (this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr procedure, public :: shrink_to_fit => ivector_shrink_to_fit public subroutine ivector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of an ivector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional :: ierr procedure, public :: sort => ivector_sort public subroutine ivector_sort (this, order) Sorts an ivector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order procedure, public :: unique => ivector_unique public subroutine ivector_unique (this) Sorts and removes all duplicate entries of an ivector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call ivector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this procedure, public :: print => ivector_print public subroutine ivector_print (this) Prints an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Source Code type ivector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init integer , dimension (:), allocatable :: buffer contains procedure :: delete => ivector_delete procedure :: clear => ivector_clear procedure :: get_val => ivector_get_val procedure :: set_val => ivector_set_val procedure :: get_data => ivector_get_data procedure :: append => ivector_append procedure :: pop => ivector_pop procedure :: resize => ivector_resize procedure :: shrink_to_fit => ivector_shrink_to_fit procedure :: sort => ivector_sort procedure :: unique => ivector_unique procedure :: print => ivector_print end type ivector_t","tags":"","loc":"type/ivector_t.html"},{"title":"dvector_t – BROWNPAK ","text":"type, public :: dvector_t Contents Variables len_init len len_max buffer Type-Bound Procedures delete clear get_val set_val get_data append pop resize shrink_to_fit sort unique print Source Code dvector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 real(kind=rp), public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => dvector_delete public subroutine dvector_delete (this) Deletes a dvector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this procedure, public :: clear => dvector_clear public subroutine dvector_clear (this) Clears a dvector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this procedure, public :: get_val => dvector_get_val public function dvector_get_val (this, i) result(res) Returns the ith element of a dvector . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rp) procedure, public :: set_val => dvector_set_val public subroutine dvector_set_val (this, i, val) Sets the value of the ith element of a dvector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: i real(kind=rp), intent(in) :: val procedure, public :: get_data => dvector_get_data public subroutine dvector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in), target :: this real(kind=rp), intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend procedure, public :: append => dvector_append public subroutine dvector_append (this, val) Adds an element to the end of a dvector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this real(kind=rp), intent(in) :: val procedure, public :: pop => dvector_pop public function dvector_pop (this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Return Value real(kind=rp) procedure, public :: resize => dvector_resize public subroutine dvector_resize (this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr procedure, public :: shrink_to_fit => dvector_shrink_to_fit public subroutine dvector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of a dvector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional :: ierr procedure, public :: sort => dvector_sort public subroutine dvector_sort (this, order) Sorts a dvector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order procedure, public :: unique => dvector_unique public subroutine dvector_unique (this) Sorts and removes all duplicate entries of a dvector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call dvector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this procedure, public :: print => dvector_print public subroutine dvector_print (this) Prints a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Source Code type dvector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init real ( rp ), dimension (:), allocatable :: buffer contains procedure :: delete => dvector_delete procedure :: clear => dvector_clear procedure :: get_val => dvector_get_val procedure :: set_val => dvector_set_val procedure :: get_data => dvector_get_data procedure :: append => dvector_append procedure :: pop => dvector_pop procedure :: resize => dvector_resize procedure :: shrink_to_fit => dvector_shrink_to_fit procedure :: sort => dvector_sort procedure :: unique => dvector_unique procedure :: print => dvector_print end type dvector_t","tags":"","loc":"type/dvector_t.html"},{"title":"aabb_t – BROWNPAK ","text":"type, public :: aabb_t Contents Variables lbnd ubnd center srfarea Type-Bound Procedures init print clear get_extent update fatten includes overlaps calc_center calc_srfarea Source Code aabb_t Components Type Visibility Attributes Name Initial real(kind=rp), public, dimension(3) :: lbnd real(kind=rp), public, dimension(3) :: ubnd real(kind=rp), public, dimension(3) :: center real(kind=rp), public :: srfarea Type-Bound Procedures procedure, public :: init => aabb_init public subroutine aabb_init (this, lbnd, ubnd) Creates an aabb_t instance from lower and upper bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(out) :: this An aabb_t instance. real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound procedure, public :: print => aabb_print public subroutine aabb_print (this, frmt, str) Prints an AABB. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. character(len=*), intent(in), optional :: frmt Fortran-style format string for a real number. Default: (g0.6) . character(len=:), intent(out), optional allocatable :: str If present, the output is printed to this string instead of STDOUT. procedure, public :: clear => aabb_clear public subroutine aabb_clear (this) Clears all attributes of an AABB and sets them to zero. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. procedure, public :: get_extent => aabb_get_extent public subroutine aabb_get_extent (this, extent) Calculates the extent of an aabb . The extent of an AABB is defined as\n the difference between its upper and lower bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. real(kind=rp), intent(out), dimension(3) :: extent Extent of an AABB. procedure, public :: update => aabb_update public subroutine aabb_update (this, lbnd, ubnd) Updates an AABB with new bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in), optional dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), optional dimension(3) :: ubnd Upper bound procedure, public :: fatten => aabb_fatten public subroutine aabb_fatten (this, frac) Fattens an AABB by a fraction of its base extent. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in) :: frac Fraction of AABB base extent. procedure, public :: includes => aabb_includes public function aabb_includes (this, other) result(res) Returns true if this includes other , false otherwise. Inclusion\n is considered in a strict sense. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical procedure, public :: overlaps => aabb_overlaps public function aabb_overlaps (this, other) result(res) Returns true if this overlaps other , false otherwise. Touching\n does not count as an overlap. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical procedure, private :: calc_center => aabb_calc_center public subroutine aabb_calc_center (this) Calculates the center of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. procedure, private :: calc_srfarea => aabb_calc_srfarea public subroutine aabb_calc_srfarea (this) Calculates the surface area of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. Source Code type aabb_t real ( rp ), dimension ( 3 ) :: lbnd real ( rp ), dimension ( 3 ) :: ubnd real ( rp ), dimension ( 3 ) :: center real ( rp ) :: srfarea contains procedure :: init => aabb_init procedure :: print => aabb_print procedure :: clear => aabb_clear procedure :: get_extent => aabb_get_extent procedure :: update => aabb_update procedure :: fatten => aabb_fatten procedure :: includes => aabb_includes procedure :: overlaps => aabb_overlaps procedure , private :: calc_center => aabb_calc_center procedure , private :: calc_srfarea => aabb_calc_srfarea end type aabb_t","tags":"","loc":"type/aabb_t.html"},{"title":"itable_t – BROWNPAK ","text":"type, public :: itable_t Contents Variables num_rows buffer row_indx Type-Bound Procedures delete clear append set_val is_in get_val get_row shrink_to_fit print Source Code itable_t Components Type Visibility Attributes Name Initial integer, public :: num_rows = 0 type( ivector_t ), public :: buffer integer, public, dimension(:), allocatable :: row_indx Type-Bound Procedures procedure, public :: delete => itbl_delete private subroutine itbl_delete (this) Deletes an itable_t . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this procedure, public :: clear => itbl_clear private subroutine itbl_clear (this) Clears all rows. Does not deallocate memory. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this procedure, public :: append => itbl_append private subroutine itbl_append (this, irow, val) Appends an element val to row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: val procedure, public :: set_val => itbl_set_val private subroutine itbl_set_val (this, irow, j, val) Sets the value of the j th element of row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: j integer, intent(in) :: val procedure, public :: is_in => itbl_is_in private function itbl_is_in (this, irow, val) result(res) Returns .true. if val is in row irow , .false. otherwise. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: val Return Value logical procedure, public :: get_val => itbl_get_val private function itbl_get_val (this, irow, j) result(res) Returns the j th element of row irow Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: j Return Value integer procedure, public :: get_row => itbl_get_row private subroutine itbl_get_row (this, irow, res) Returns a pointer to the row data of irow . No bounds checking is performed. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in), target :: this integer, intent(in) :: irow integer, intent(out), dimension(:), pointer :: res procedure, public :: shrink_to_fit => itbl_shrink_to_fit private subroutine itbl_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(out), optional :: ierr procedure, public :: print => itbl_print private subroutine itbl_print (this) Prints an itable_t . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this Source Code type itable_t integer :: num_rows = 0 !Must be > 0 type ( ivector_t ) :: buffer integer , dimension (:), allocatable :: row_indx contains procedure :: delete => itbl_delete procedure :: clear => itbl_clear procedure :: append => itbl_append procedure :: set_val => itbl_set_val procedure :: is_in => itbl_is_in procedure :: get_val => itbl_get_val procedure :: get_row => itbl_get_row procedure :: shrink_to_fit => itbl_shrink_to_fit procedure :: print => itbl_print end type itable_t","tags":"","loc":"type/itable_t.html"},{"title":"logger_t – BROWNPAK ","text":"type, private :: logger_t Contents Variables fn fu is_open Type-Bound Procedures finish log_msg Source Code logger_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: fn Name of the log file integer, public :: fu = huge(0) Unit number of the log file logical, public :: is_open = .false. Is the log file open for writing? {T/F} Type-Bound Procedures procedure, public :: finish => logger_finish private subroutine logger_finish (this) Cleanup routine for a logger_t instance. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(inout) :: this A logger_t instance procedure, public :: log_msg => logger_log_msg private subroutine logger_log_msg (this, msg) Write a message to the log file. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(in) :: this A logger_t instance character(len=*), intent(in) :: msg Message to write to the log file Source Code type logger_t character ( len = :), allocatable :: fn !! Name of the log file integer :: fu = huge ( 0 ) !! Unit number of the log file logical :: is_open = . false . !! Is the log file open for writing? {T/F} contains procedure :: finish => logger_finish procedure :: log_msg => logger_log_msg end type logger_t","tags":"","loc":"type/logger_t.html"},{"title":"smbx_t – BROWNPAK ","text":"type, public :: smbx_t Contents Variables basis dl_basis volume is_deforming is_aligned Type-Bound Procedures set_basis freeze unfreeze get_image wrap_all to_center get_rnd_points Source Code smbx_t Components Type Visibility Attributes Name Initial real(kind=rp), public, dimension(3,3) :: basis real(kind=rp), public, dimension(3,3) :: dl_basis real(kind=rp), public :: volume logical, public :: is_deforming logical, public :: is_aligned Whether the basis vectors are aligned with the laboratory frame Type-Bound Procedures procedure, public :: set_basis => smbx_set_basis public subroutine smbx_set_basis (this, bv) Sets all three basis vectors. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(3,3) :: bv procedure, public :: freeze => smbx_freeze public subroutine smbx_freeze (this) Specifies this as non-deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this procedure, public :: unfreeze => smbx_unfreeze public subroutine smbx_unfreeze (this) Specifies this as deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this procedure, public :: get_image => smbx_get_image public subroutine smbx_get_image (this, r) Returns the image of r under PBC. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(3) :: r procedure, public :: wrap_all => smbx_wrap_all public subroutine smbx_wrap_all (this, coords) Wraps atom positions w.r.t. periodic boundary conditions. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords procedure, public :: to_center => smbx_to_center public subroutine smbx_to_center (this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the center \n of the box. Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com procedure, public :: get_rnd_points => smbx_get_rnd_points public subroutine smbx_get_rnd_points (this, coords) Returns uniformly distributed points within the box. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(out), dimension(:,:) :: coords Source Code type smbx_t real ( rp ), dimension ( 3 , 3 ) :: basis real ( rp ), dimension ( 3 , 3 ) :: dl_basis real ( rp ) :: volume logical :: is_deforming logical :: is_aligned !! Whether the basis vectors are aligned with the laboratory frame contains procedure :: set_basis => smbx_set_basis procedure :: freeze => smbx_freeze procedure :: unfreeze => smbx_unfreeze procedure :: get_image => smbx_get_image procedure :: wrap_all => smbx_wrap_all procedure :: to_center => smbx_to_center procedure :: get_rnd_points => smbx_get_rnd_points end type smbx_t","tags":"","loc":"type/smbx_t.html"},{"title":"trajectory_t – BROWNPAK ","text":"type, public :: trajectory_t Contents Variables header_size frame_size num_atoms num_mpcd_atoms num_atoms_tot frmcmp fn file_id num_frames isopen Type-Bound Procedures create open clear close read append_frame write_frame init Source Code trajectory_t Components Type Visibility Attributes Name Initial integer, public :: header_size = 0 integer, public :: frame_size = 0 integer, public :: num_atoms = 0 integer, public :: num_mpcd_atoms = 0 integer, public :: num_atoms_tot = 0 integer, public, dimension(4) :: frmcmp = 0 character(len=:), public, allocatable :: fn integer, public :: file_id = 0 integer, public :: num_frames = 0 logical, public :: isopen = .false. Type-Bound Procedures procedure, public :: create => traj_create public subroutine traj_create (this, fn, na, nam, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of non-MPCD atoms integer, intent(in) :: nam Number of MPCD atoms, pass zero to indicate no data from MPCD\n particles are present. integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges procedure, public :: open => traj_open public subroutine traj_open (this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr procedure, public :: clear => traj_clear public subroutine traj_clear (this) After a call to this subroutine, all memory within this is deallocated,\n all components of this are reset to zero, and the underlying file is\n closed (if open). Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this procedure, public :: close => traj_close public subroutine traj_close (this) Closes the underlying file of a trajectory_t . Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this procedure, public :: read => traj_read public subroutine traj_read (this, iframe, nts, ierr, mflag, coordinates, velocities, forces, charge) Read from an open trajectory. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(in) :: this integer, intent(in) :: iframe Frame number integer(kind=ip_long), intent(out) :: nts Time step counter integer, intent(out) :: ierr Error flag integer, intent(in), optional :: mflag 1: Only non-MPCD data, 2: Only MPCD data, 3: All data real(kind=rp), intent(out), optional dimension(:,:) :: coordinates real(kind=rp), intent(out), optional dimension(:,:) :: velocities real(kind=rp), intent(out), optional dimension(:,:) :: forces real(kind=rp), intent(out), optional dimension(:) :: charge procedure, public :: append_frame => traj_append_frame public subroutine traj_append_frame (this, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge procedure, public :: write_frame => traj_write_frame public subroutine traj_write_frame (this, iframe, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer, intent(in) :: iframe integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge generic, public :: init => create , open public subroutine traj_create (this, fn, na, nam, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of non-MPCD atoms integer, intent(in) :: nam Number of MPCD atoms, pass zero to indicate no data from MPCD\n particles are present. integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges public subroutine traj_open (this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr Source Code type trajectory_t integer :: header_size = 0 integer :: frame_size = 0 integer :: num_atoms = 0 integer :: num_mpcd_atoms = 0 integer :: num_atoms_tot = 0 integer , dimension ( 4 ) :: frmcmp = 0 character ( len = :), allocatable :: fn integer :: file_id = 0 integer :: num_frames = 0 logical :: isopen = . false . contains procedure :: create => traj_create procedure :: open => traj_open procedure :: clear => traj_clear procedure :: close => traj_close procedure :: read => traj_read procedure :: append_frame => traj_append_frame procedure :: write_frame => traj_write_frame generic :: init => create , open end type trajectory_t","tags":"","loc":"type/trajectory_t.html"},{"title":"node_t – BROWNPAK ","text":"type, private :: node_t Contents Variables next parent left right height atom aabb Type-Bound Procedures init isleaf asstr Source Code node_t Components Type Visibility Attributes Name Initial integer, public :: next = NULL_NODE integer, public :: parent = NULL_NODE integer, public :: left = NULL_NODE integer, public :: right = NULL_NODE integer, public :: height = -1 integer, public :: atom = 0 type( aabb_t ), public :: aabb Type-Bound Procedures procedure, public :: init => node_init interface private module subroutine node_init(this) Implementation → Initializes a node. Arguments Type Intent Optional Attributes Name class( node_t ), intent(out) :: this A node_t instance. procedure, public :: isleaf => node_isleaf interface private module function node_isleaf(this) result(res) Implementation → Is this a leaf node? Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. Return Value logical true if this is a leaf node, false otherwise. procedure, public :: asstr => node_asstr interface private module function node_asstr(this, frmt) result(buf) Implementation → Returns a string representation of a node. Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. character(len=*), intent(in), optional :: frmt Format string for real numbers, e.g. '(f15.6)'. Default: (g0.6) . Return Value character(len=:),\n  allocatable Return value Source Code type node_t integer :: next = NULL_NODE integer :: parent = NULL_NODE integer :: left = NULL_NODE integer :: right = NULL_NODE integer :: height = - 1 integer :: atom = 0 type ( aabb_t ) :: aabb contains procedure :: init => node_init procedure :: isleaf => node_isleaf procedure :: asstr => node_asstr end type node_t","tags":"","loc":"type/node_t.html"},{"title":"aabbtree_t – BROWNPAK ","text":"type, public :: aabbtree_t Contents Variables nodes atnd_tab capacity freestore size root tskin Type-Bound Procedures init print clear delete insert remove remove_all update_fatm update_fatmaabb update query_watm query_waabb query_watmaabb query get_num_atoms get_aabb get_height get_max_balance get_srfarea_ratio rebuild validate insert_leaf remove_leaf balance calc_height fs_acquire fs_return validate_structure validate_metrics Source Code aabbtree_t Components Type Visibility Attributes Name Initial type( node_t ), public, dimension(:), allocatable :: nodes integer, public, dimension(:), allocatable :: atnd_tab Atom -> node map. integer, public :: capacity Maximum number of nodes that the tree can currently handle. This may\n increase as more atoms are inserted. integer, public :: freestore Pointer to head to the free store. integer, public :: size Number of nodes in the tree. integer, public :: root Pointer to the tree root. real(kind=rp), public :: tskin Thickness of the skin for fattened AABBs, as a fraction of the AABB\n base length. Type-Bound Procedures procedure, public :: init interface private module subroutine init(this, natoms, tskin) Implementation → Initializes an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(out) :: this An aabbtree_t instance. integer, intent(in) :: natoms Estimated number of atoms to be handled by this tree. real(kind=rp), intent(in) :: tskin Thickness of the skin for fattened AABBs, as a fraction of the\n AABB base length. procedure, public :: print interface private recursive module subroutine print(this, p) Implementation → Prints a subtree of an AABB tree rooted at p in order. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default is the root of the\n whole tree. procedure, public :: clear interface private module subroutine clear(this) Implementation → Clears an AABB tree. Associated memory is not deallocated. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. procedure, public :: delete interface private module subroutine delete(this) Implementation → Deletes an AABB tree. All associated memory is deallocated. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. procedure, public :: insert interface private module subroutine insert(this, ia, pos, radius) Implementation → Inserts an atom into an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) procedure, public :: remove interface private module subroutine remove(this, ia) Implementation → Removes an atom from an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index procedure, public :: remove_all interface private module subroutine remove_all(this) Implementation → Removes all atoms from an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. procedure, public :: update_fatm interface private module subroutine update_fatm(this, ia, pos, radius, lstat) Implementation → Updates an AABB tree for the case when an atom leaves its fattened\n AABB. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. procedure, public :: update_fatmaabb interface private module subroutine update_fatmaabb(this, ia, lbnd, ubnd, lstat) Implementation → Updates an AABB tree for the case when an atom leaves its fattened\n AABB, with the bounds of the new AABB for the atom as input. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound of atom AABB real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound of atom AABB logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. generic, public :: update => update_fatm , update_fatmaabb private interface update_fatm () Arguments None private interface update_fatmaabb () Arguments None procedure, public :: query_watm interface private module subroutine query_watm(this, ia, nbrs) Implementation → Query an AABB tree for a set of potential neighbors of an atom. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. procedure, public :: query_waabb interface private module subroutine query_waabb(this, aabb, atms) Implementation → Query an AABB tree for the set of atoms whose AABBS overlap with aabb . Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. type( aabb_t ), intent(in) :: aabb An aabb_t instance. type( ivector_t ), intent(inout) :: atms List of potential neighbors. procedure, public :: query_watmaabb interface private module subroutine query_watmaabb(this, ia, aabb, nbrs) Implementation → Query an AABB tree for a set of potential neighbors of an atom & its\n bounding AABB. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. type( aabb_t ), intent(in) :: aabb Bounding AABB for atom with index ia . type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. generic, public :: query => query_watm , query_waabb , query_watmaabb private interface query_watm () Arguments None private interface query_waabb () Arguments None private interface query_watmaabb () Arguments None procedure, public :: get_num_atoms interface private module function get_num_atoms(this) result(na) Implementation → Returns the number of atoms in an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value procedure, public :: get_aabb interface private module function get_aabb(this, ia) result(aabb) Implementation → Returns a copy of the AABB associated with atom with index ia . Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. Return Value type( aabb_t ) AABB of atom ia . procedure, public :: get_height interface private module function get_height(this) result(height) Implementation → Returns the height of an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. procedure, public :: get_max_balance interface private module function get_max_balance(this) result(max_balance) Implementation → Returns the maximum difference between the height of two children\n of a node. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. procedure, public :: get_srfarea_ratio interface private module function get_srfarea_ratio(this) result(saratio) Implementation → Returns the ratio of the sum of the node surface area to the surface\n area of the root node. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value real(kind=rp) Return value. procedure, public :: rebuild interface private module subroutine rebuild(this) Implementation → Rebuilds an optimal AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. procedure, public :: validate interface private module subroutine validate(this) Implementation → Validates an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. procedure, private :: insert_leaf interface private module subroutine insert_leaf(this, leaf) Implementation → Inserts a leaf node into a tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node procedure, private :: remove_leaf interface private module subroutine remove_leaf(this, leaf) Implementation → Removes a leaf node from a tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node procedure, private :: balance interface private module function balance(this, p) result(q) Implementation → Balances an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node index Return Value integer procedure, private :: calc_height interface private recursive module function calc_height(this, p) result(height) Implementation → Calculates the height of a subtree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default: Root of the whole\n tree. Return Value integer Return value procedure, private :: fs_acquire interface private module function fs_acquire(this) result(p) Implementation → Acquires a new node from the free store and returns a pointer to it. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Return Value integer Return value procedure, private :: fs_return interface private module subroutine fs_return(this, p) Implementation → Returns a node to the free store. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node pointer. procedure, private :: validate_structure interface private recursive module subroutine validate_structure(this, p) Implementation → Asserts that an AABB subtree has a valid structure. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. procedure, private :: validate_metrics interface private recursive module subroutine validate_metrics(this, p) Implementation → Asserts that an AABB subtree has a valid metric. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. Source Code type aabbtree_t type ( node_t ), dimension (:), allocatable :: nodes integer , dimension (:), allocatable :: atnd_tab !! Atom -> node map. integer :: capacity !! Maximum number of nodes that the tree can currently handle. This may !! increase as more atoms are inserted. integer :: freestore !! Pointer to head to the free store. integer :: size !! Number of nodes in the tree. integer :: root !! Pointer to the tree root. real ( rp ) :: tskin !! Thickness of the skin for fattened AABBs, as a fraction of the AABB !! base length. contains procedure :: init procedure :: print procedure :: clear procedure :: delete procedure :: insert procedure :: remove procedure :: remove_all procedure :: update_fatm procedure :: update_fatmaabb generic :: update => update_fatm , update_fatmaabb procedure :: query_watm procedure :: query_waabb procedure :: query_watmaabb generic :: query => query_watm , query_waabb , query_watmaabb procedure :: get_num_atoms procedure :: get_aabb procedure :: get_height procedure :: get_max_balance procedure :: get_srfarea_ratio procedure :: rebuild procedure :: validate procedure , private :: insert_leaf procedure , private :: remove_leaf procedure , private :: balance procedure , private :: calc_height procedure , private :: fs_acquire procedure , private :: fs_return procedure , private :: validate_structure procedure , private :: validate_metrics end type aabbtree_t","tags":"","loc":"type/aabbtree_t.html"},{"title":"brn_init – BROWNPAK","text":"public subroutine brn_init(n, nblks, mth, f, e) Performs initial setup. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Size of the mobility matrix. integer, intent(in) :: nblks Number of B . d W vectors to generate for the same mobility matrix. 1 <= nblks < n . character(len=4), intent(in) :: mth Method for calculating the Brownian terms. mth = 'CHOL' for\n Cholesky decomposition; mth = 'LANC' for KSP-based method. integer, intent(in), optional :: f For KSP-based method, maximum number of iterations.\n Must be present if mth = 'LANC' . f must be less than n . real(kind=rp), intent(in), optional :: e For KSP-based method, error threshold for convergence. \n Must be present if mth = 'LANC' . Contents None","tags":"","loc":"proc/brn_init.html"},{"title":"brn_finish – BROWNPAK","text":"public subroutine brn_finish() Performs cleanup. Arguments None Contents None","tags":"","loc":"proc/brn_finish.html"},{"title":"brn_calc_bdw – BROWNPAK","text":"public subroutine brn_calc_bdw(mob, bdw, ierr, lconv, f) Main driver routine for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix.\n On entry , contains the mobility matrix.  On return , if meth = 'CHOL' ,\n the upper triangular part is overwritten with the result of Cholesky\n decomposition.  The strictly lower triangular part is left intact. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B .d W . integer, intent(out) :: ierr Error flag. logical, intent(out), optional :: lconv If meth = 'LANC' , returns true if converged, false otherwise. integer, intent(out), optional :: f If meth = 'LANC' , the number of iterations performed. Contents None","tags":"","loc":"proc/brn_calc_bdw.html"},{"title":"calc_bdw_lanc – BROWNPAK","text":"private subroutine calc_bdw_lanc(mob, bdw, lconv, f, ierr) Implements Lanczos algorithm for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm ,1) array.\n On entry , contains a vector drawn from standard normal \n distribution. On return , is overwritten with the result of B . d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag. Contents None","tags":"","loc":"proc/calc_bdw_lanc.html"},{"title":"calc_bdw_blanc – BROWNPAK","text":"private subroutine calc_bdw_blanc(mob, bdw, lconv, f, ierr) Implements block Lanczos algorithm for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B . d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag. Contents None","tags":"","loc":"proc/calc_bdw_blanc.html"},{"title":"calc_bdw_cholesky – BROWNPAK","text":"private subroutine calc_bdw_cholesky(mob, bdw, ierr) Calculates B . d W using Cholesky decomposition. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix.\n On entry , contains the mobility matrix.  On return ,\n the upper triangular part is overwritten with the result of Cholesky\n decomposition.  The strictly lower triangular part is left intact. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B . d W . integer, intent(out) :: ierr Error flag. Contents None","tags":"","loc":"proc/calc_bdw_cholesky.html"},{"title":"brn_calc_dw – BROWNPAK","text":"public subroutine brn_calc_dw(dw) Calculates standard normally distributed random vectors. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:), target :: dw ( n , m ) array. Contents None","tags":"","loc":"proc/brn_calc_dw.html"},{"title":"calc_bdw_lanc_sor – BROWNPAK","text":"private subroutine calc_bdw_lanc_sor(mob, bdw, lconv, f, ierr) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm ,1) array.\n On entry , contains a vector drawn from standard normal \n distribution. On return , is overwritten with the result of B .d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag. Contents None","tags":"","loc":"proc/calc_bdw_lanc_sor.html"},{"title":"ia_angle_setup – BROWNPAK","text":"public subroutine ia_angle_setup() Sets up parameters for angle potentials Arguments None Contents None","tags":"","loc":"proc/ia_angle_setup.html"},{"title":"ia_get_angle_force – BROWNPAK","text":"public subroutine ia_get_angle_force(q1, q2, typ, enrg, fim1, fi, fip1) Calculates the energy & force due to an angle. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 integer, intent(in) :: typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fim1 real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fip1 Contents None","tags":"","loc":"proc/ia_get_angle_force.html"},{"title":"ang_cos_set – BROWNPAK","text":"private subroutine ang_cos_set(params, k) Setter for angular cosine interaction. U(theta) = k*(1 - cos theta), where theta is the complementary angle between bonds i & (i+1). User-set parameters: params(1) = k Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k Contents None","tags":"","loc":"proc/ang_cos_set.html"},{"title":"ia_setup – BROWNPAK","text":"public subroutine ia_setup() Builds necessary neighbor tables and sets up parameters for potentials. Arguments None Contents None","tags":"","loc":"proc/ia_setup.html"},{"title":"ia_finish – BROWNPAK","text":"public subroutine ia_finish() Cleanup routine for interaction calculation. Arguments None Contents None","tags":"","loc":"proc/ia_finish.html"},{"title":"ia_calc_forces – BROWNPAK","text":"public subroutine ia_calc_forces(ierr) Calculates total forces and energies Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/ia_calc_forces.html"},{"title":"ia_add_vdw_forces – BROWNPAK","text":"private subroutine ia_add_vdw_forces(ierr) Calculates force and energy due to all short-ranged non-bonded pairwise\n interactions based on pair_tab and adds to energy_vdw & forces in module m_globals . Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/ia_add_vdw_forces.html"},{"title":"ia_add_bond_forces – BROWNPAK","text":"private subroutine ia_add_bond_forces(ierr) Calculates forces & energy due to all bonds. Will add to energy_bond & and 'forces in module m_globals`. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/ia_add_bond_forces.html"},{"title":"ia_add_angle_forces – BROWNPAK","text":"private subroutine ia_add_angle_forces() Calculates forces & energy due to all angles. Will add to energy_angle & 'forces in module m_globals`. Arguments None Contents None","tags":"","loc":"proc/ia_add_angle_forces.html"},{"title":"ia_add_dihedral_forces – BROWNPAK","text":"private subroutine ia_add_dihedral_forces() Calculates forces & energy due to all dihedrals. Will add to energy_dihedral & 'forces in module m_globals`. Arguments None Contents None","tags":"","loc":"proc/ia_add_dihedral_forces.html"},{"title":"ia_add_tether_forces – BROWNPAK","text":"private subroutine ia_add_tether_forces(ierr) Calculates forces & energy due to all tethers. Will add to energy_tether &\n 'forces in module m_globals`. Tether forces cannot be subject to\n periodic boundary conditions. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/ia_add_tether_forces.html"},{"title":"ivector_get_len – BROWNPAK","text":"public function ivector_get_len(this) result(res) Returns the length of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/ivector_get_len.html"},{"title":"dvector_get_len – BROWNPAK","text":"public function dvector_get_len(this) result(res) Returns the length of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/dvector_get_len.html"},{"title":"ivector_get_val – BROWNPAK","text":"public function ivector_get_val(this, i) result(res) Returns the ith element of an ivector . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/ivector_get_val.html"},{"title":"dvector_get_val – BROWNPAK","text":"public function dvector_get_val(this, i) result(res) Returns the ith element of a dvector . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rp) Contents None","tags":"","loc":"proc/dvector_get_val.html"},{"title":"ivector_pop – BROWNPAK","text":"public function ivector_pop(this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Return Value integer Contents None","tags":"","loc":"proc/ivector_pop.html"},{"title":"dvector_pop – BROWNPAK","text":"public function dvector_pop(this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Return Value real(kind=rp) Contents None","tags":"","loc":"proc/dvector_pop.html"},{"title":"ivector_init – BROWNPAK","text":"public subroutine ivector_init(this, len_init, ierr) Creates an empty ivector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/ivector_init.html"},{"title":"dvector_init – BROWNPAK","text":"public subroutine dvector_init(this, len_init, ierr) Creates an empty dvector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/dvector_init.html"},{"title":"ivector_from_array – BROWNPAK","text":"public subroutine ivector_from_array(this, x) Creates an ivector with all elements from an array Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), dimension(:) :: x Contents None","tags":"","loc":"proc/ivector_from_array.html"},{"title":"dvector_from_array – BROWNPAK","text":"public subroutine dvector_from_array(this, x) Creates a dvector with all elements from an array Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(:) :: x Contents None","tags":"","loc":"proc/dvector_from_array.html"},{"title":"ivector_delete – BROWNPAK","text":"public subroutine ivector_delete(this) Deletes an ivector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/ivector_delete.html"},{"title":"dvector_delete – BROWNPAK","text":"public subroutine dvector_delete(this) Deletes a dvector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/dvector_delete.html"},{"title":"ivector_clear – BROWNPAK","text":"public subroutine ivector_clear(this) Clears an ivector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/ivector_clear.html"},{"title":"dvector_clear – BROWNPAK","text":"public subroutine dvector_clear(this) Clears a dvector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/dvector_clear.html"},{"title":"ivector_assign – BROWNPAK","text":"public subroutine ivector_assign(this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other Contents None","tags":"","loc":"proc/ivector_assign.html"},{"title":"dvector_assign – BROWNPAK","text":"public subroutine dvector_assign(this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other Contents None","tags":"","loc":"proc/dvector_assign.html"},{"title":"i_dvector_assign – BROWNPAK","text":"public subroutine i_dvector_assign(this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other Contents None","tags":"","loc":"proc/i_dvector_assign.html"},{"title":"ivector_set_val – BROWNPAK","text":"public subroutine ivector_set_val(this, i, val) Sets the value of the ith element of an ivector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: val Contents None","tags":"","loc":"proc/ivector_set_val.html"},{"title":"dvector_set_val – BROWNPAK","text":"public subroutine dvector_set_val(this, i, val) Sets the value of the ith element of a dvector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: i real(kind=rp), intent(in) :: val Contents None","tags":"","loc":"proc/dvector_set_val.html"},{"title":"ivector_append – BROWNPAK","text":"public subroutine ivector_append(this, val) Adds an element to the end of an ivector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: val Contents None","tags":"","loc":"proc/ivector_append.html"},{"title":"dvector_append – BROWNPAK","text":"public subroutine dvector_append(this, val) Adds an element to the end of a dvector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this real(kind=rp), intent(in) :: val Contents None","tags":"","loc":"proc/dvector_append.html"},{"title":"ivector_get_data – BROWNPAK","text":"public subroutine ivector_get_data(this, res, ibeg, iend) Returns a pointer to the underlying data of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in), target :: this integer, intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend Contents None","tags":"","loc":"proc/ivector_get_data.html"},{"title":"dvector_get_data – BROWNPAK","text":"public subroutine dvector_get_data(this, res, ibeg, iend) Returns a pointer to the underlying data of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in), target :: this real(kind=rp), intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend Contents None","tags":"","loc":"proc/dvector_get_data.html"},{"title":"ivector_resize – BROWNPAK","text":"public subroutine ivector_resize(this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/ivector_resize.html"},{"title":"dvector_resize – BROWNPAK","text":"public subroutine dvector_resize(this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/dvector_resize.html"},{"title":"ivector_shrink_to_fit – BROWNPAK","text":"public subroutine ivector_shrink_to_fit(this, ierr) Releases additional memory to fit underlying data of an ivector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/ivector_shrink_to_fit.html"},{"title":"dvector_shrink_to_fit – BROWNPAK","text":"public subroutine dvector_shrink_to_fit(this, ierr) Releases additional memory to fit underlying data of a dvector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/dvector_shrink_to_fit.html"},{"title":"ivector_sort – BROWNPAK","text":"public subroutine ivector_sort(this, order) Sorts an ivector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order Contents None","tags":"","loc":"proc/ivector_sort.html"},{"title":"dvector_sort – BROWNPAK","text":"public subroutine dvector_sort(this, order) Sorts a dvector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order Contents None","tags":"","loc":"proc/dvector_sort.html"},{"title":"ivector_unique – BROWNPAK","text":"public subroutine ivector_unique(this) Sorts and removes all duplicate entries of an ivector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call ivector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/ivector_unique.html"},{"title":"dvector_unique – BROWNPAK","text":"public subroutine dvector_unique(this) Sorts and removes all duplicate entries of a dvector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call dvector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/dvector_unique.html"},{"title":"ivector_print – BROWNPAK","text":"public subroutine ivector_print(this) Prints an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Contents None","tags":"","loc":"proc/ivector_print.html"},{"title":"dvector_print – BROWNPAK","text":"public subroutine dvector_print(this) Prints a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Contents None","tags":"","loc":"proc/dvector_print.html"},{"title":"ivector_init – BROWNPAK","text":"public interface ivector_init Contents Module Procedures ivector_init ivector_from_array Module Procedures public interface ivector_init () Arguments None public subroutine ivector_from_array (this, x) Creates an ivector with all elements from an array Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), dimension(:) :: x","tags":"","loc":"interface/ivector_init.html"},{"title":"dvector_init – BROWNPAK","text":"public interface dvector_init Contents Module Procedures dvector_init dvector_from_array Module Procedures public interface dvector_init () Arguments None public subroutine dvector_from_array (this, x) Creates a dvector with all elements from an array Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(:) :: x","tags":"","loc":"interface/dvector_init.html"},{"title":"assignment(=) – BROWNPAK","text":"public interface assignment(=) Contents Module Procedures ivector_assign dvector_assign i_dvector_assign Module Procedures public subroutine ivector_assign (this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine dvector_assign (this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other public subroutine i_dvector_assign (this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other","tags":"","loc":"interface/assignment(=).html"},{"title":"pt_init – BROWNPAK","text":"public subroutine pt_init() Performs initial setup for building a pair list. Arguments None Contents None","tags":"","loc":"proc/pt_init.html"},{"title":"pt_finish – BROWNPAK","text":"public subroutine pt_finish() Cleanup for pair list calculation. Arguments None Contents None","tags":"","loc":"proc/pt_finish.html"},{"title":"pt_build – BROWNPAK","text":"public subroutine pt_build() Builds a pair table. The resulting table is stored in the module variable pair_tab . Arguments None Contents None","tags":"","loc":"proc/pt_build.html"},{"title":"build_pt_n2 – BROWNPAK","text":"private subroutine build_pt_n2() Builds a pair table using direct N&#94;2 looping over all pairs. Arguments None Contents None","tags":"","loc":"proc/build_pt_n2.html"},{"title":"build_pt_verlet – BROWNPAK","text":"private subroutine build_pt_verlet() Builds a pair table using the Verlet scheme. Arguments None Contents None","tags":"","loc":"proc/build_pt_verlet.html"},{"title":"build_pt_aabbtree – BROWNPAK","text":"private subroutine build_pt_aabbtree() Arguments None Contents None","tags":"","loc":"proc/build_pt_aabbtree.html"},{"title":"build_pt_cell_list – BROWNPAK","text":"private subroutine build_pt_cell_list() Builds a pair table using cell list. Arguments None Contents None","tags":"","loc":"proc/build_pt_cell_list.html"},{"title":"ia_dihedral_setup – BROWNPAK","text":"public subroutine ia_dihedral_setup() Sets up parameters for dihedral potentials Arguments None Contents None","tags":"","loc":"proc/ia_dihedral_setup.html"},{"title":"ia_get_dihedral_force – BROWNPAK","text":"public subroutine ia_get_dihedral_force(q1, q2, q3, typ, enrg, fi, fj, fk, fl) Calculates the force & energy due to a dihedral. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 real(kind=rp), intent(in), dimension(3) :: q3 integer, intent(in) :: typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fj real(kind=rp), intent(out), dimension(3) :: fk real(kind=rp), intent(out), dimension(3) :: fl Contents None","tags":"","loc":"proc/ia_get_dihedral_force.html"},{"title":"stats_init – BROWNPAK","text":"public subroutine stats_init() Set up for stats collection Arguments None Contents None","tags":"","loc":"proc/stats_init.html"},{"title":"stats_finish – BROWNPAK","text":"public subroutine stats_finish() Closes any files opened in stats_init . Arguments None Contents None","tags":"","loc":"proc/stats_finish.html"},{"title":"stats_write_hdr – BROWNPAK","text":"private subroutine stats_write_hdr() Driver for writing header of file fn_stats . This is called only after\n appropriate files have been opened. Arguments None Contents None","tags":"","loc":"proc/stats_write_hdr.html"},{"title":"stats_write – BROWNPAK","text":"public subroutine stats_write() Writing statistics Arguments None Contents None","tags":"","loc":"proc/stats_write.html"},{"title":"stats_compute_ic1 – BROWNPAK","text":"private subroutine stats_compute_ic1() Computes statistics for a possibly multiple chains in a periodic domain. Arguments None Contents None","tags":"","loc":"proc/stats_compute_ic1.html"},{"title":"stats_compute_ic0 – BROWNPAK","text":"private subroutine stats_compute_ic0() Computes statistics for a single chain in unbounded domain. Arguments None Contents None","tags":"","loc":"proc/stats_compute_ic0.html"},{"title":"calc_shape – BROWNPAK","text":"private subroutine calc_shape(ev1, ev2, ev3, asph, prol) Given three eigen values of the gyration tensor, calculates asphericity\n and prolateness. Note that ev1 >= ev2 >= ev3. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ev1 real(kind=rp), intent(in) :: ev2 real(kind=rp), intent(in) :: ev3 real(kind=rp), intent(out) :: asph real(kind=rp), intent(out) :: prol Contents None","tags":"","loc":"proc/calc_shape.html"},{"title":"dsyevc3 – BROWNPAK","text":"private subroutine dsyevc3(A, W) Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's\n analytical algorithm.\n Only the diagonal and upper triangular parts of A are accessed. The access\n is read-only. Copyright (C) 2006  Joachim Kopp Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), DIMENSION(3,3) :: A real(kind=RP), intent(out), DIMENSION(3) :: W (3) Contents None","tags":"","loc":"proc/dsyevc3.html"},{"title":"aabb_includes – BROWNPAK","text":"public function aabb_includes(this, other) result(res) Returns true if this includes other , false otherwise. Inclusion\n is considered in a strict sense. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical Contents None","tags":"","loc":"proc/aabb_includes.html"},{"title":"aabb_overlaps – BROWNPAK","text":"public function aabb_overlaps(this, other) result(res) Returns true if this overlaps other , false otherwise. Touching\n does not count as an overlap. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical Contents None","tags":"","loc":"proc/aabb_overlaps.html"},{"title":"aabb_union – BROWNPAK","text":"public function aabb_union(x, y) result(z) Combines AABBs x and y to return a new AABB z . Arguments Type Intent Optional Attributes Name type( aabb_t ), intent(in) :: x An aabb_t instance. type( aabb_t ), intent(in) :: y An aabb_t instance. Return Value type( aabb_t ) Contents None","tags":"","loc":"proc/aabb_union.html"},{"title":"aabb_init – BROWNPAK","text":"public subroutine aabb_init(this, lbnd, ubnd) Creates an aabb_t instance from lower and upper bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(out) :: this An aabb_t instance. real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound Contents None","tags":"","loc":"proc/aabb_init.html"},{"title":"aabb_print – BROWNPAK","text":"public subroutine aabb_print(this, frmt, str) Prints an AABB. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. character(len=*), intent(in), optional :: frmt Fortran-style format string for a real number. Default: (g0.6) . character(len=:), intent(out), optional allocatable :: str If present, the output is printed to this string instead of STDOUT. Contents None","tags":"","loc":"proc/aabb_print.html"},{"title":"aabb_clear – BROWNPAK","text":"public subroutine aabb_clear(this) Clears all attributes of an AABB and sets them to zero. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. Contents None","tags":"","loc":"proc/aabb_clear.html"},{"title":"aabb_get_extent – BROWNPAK","text":"public subroutine aabb_get_extent(this, extent) Calculates the extent of an aabb . The extent of an AABB is defined as\n the difference between its upper and lower bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. real(kind=rp), intent(out), dimension(3) :: extent Extent of an AABB. Contents None","tags":"","loc":"proc/aabb_get_extent.html"},{"title":"aabb_update – BROWNPAK","text":"public subroutine aabb_update(this, lbnd, ubnd) Updates an AABB with new bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in), optional dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), optional dimension(3) :: ubnd Upper bound Contents None","tags":"","loc":"proc/aabb_update.html"},{"title":"aabb_fatten – BROWNPAK","text":"public subroutine aabb_fatten(this, frac) Fattens an AABB by a fraction of its base extent. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in) :: frac Fraction of AABB base extent. Contents None","tags":"","loc":"proc/aabb_fatten.html"},{"title":"aabb_calc_center – BROWNPAK","text":"public subroutine aabb_calc_center(this) Calculates the center of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. Contents None","tags":"","loc":"proc/aabb_calc_center.html"},{"title":"aabb_calc_srfarea – BROWNPAK","text":"public subroutine aabb_calc_srfarea(this) Calculates the surface area of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. Contents None","tags":"","loc":"proc/aabb_calc_srfarea.html"},{"title":"operator(+) – BROWNPAK","text":"public interface operator(+) Contents Module Procedures aabb_union Module Procedures public function aabb_union (x, y) result(z) Combines AABBs x and y to return a new AABB z . Arguments Type Intent Optional Attributes Name type( aabb_t ), intent(in) :: x An aabb_t instance. type( aabb_t ), intent(in) :: y An aabb_t instance. Return Value type( aabb_t )","tags":"","loc":"interface/operator(+).html"},{"title":"itbl_is_in – BROWNPAK","text":"private function itbl_is_in(this, irow, val) result(res) Returns .true. if val is in row irow , .false. otherwise. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: val Return Value logical Contents None","tags":"","loc":"proc/itbl_is_in.html"},{"title":"itbl_get_val – BROWNPAK","text":"private function itbl_get_val(this, irow, j) result(res) Returns the j th element of row irow Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: j Return Value integer Contents None","tags":"","loc":"proc/itbl_get_val.html"},{"title":"itbl_init – BROWNPAK","text":"public subroutine itbl_init(this, num_rows, ierr) Creates an empty itable_t with num_rows rows and all rows having\n zero elements. Arguments Type Intent Optional Attributes Name type( itable_t ), intent(inout) :: this integer, intent(in) :: num_rows Must be > 0 integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/itbl_init.html"},{"title":"itbl_delete – BROWNPAK","text":"private subroutine itbl_delete(this) Deletes an itable_t . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/itbl_delete.html"},{"title":"itbl_clear – BROWNPAK","text":"private subroutine itbl_clear(this) Clears all rows. Does not deallocate memory. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/itbl_clear.html"},{"title":"itbl_append – BROWNPAK","text":"private subroutine itbl_append(this, irow, val) Appends an element val to row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: val Contents None","tags":"","loc":"proc/itbl_append.html"},{"title":"itbl_set_val – BROWNPAK","text":"private subroutine itbl_set_val(this, irow, j, val) Sets the value of the j th element of row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: j integer, intent(in) :: val Contents None","tags":"","loc":"proc/itbl_set_val.html"},{"title":"itbl_get_row – BROWNPAK","text":"private subroutine itbl_get_row(this, irow, res) Returns a pointer to the row data of irow . No bounds checking is performed. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in), target :: this integer, intent(in) :: irow integer, intent(out), dimension(:), pointer :: res Contents None","tags":"","loc":"proc/itbl_get_row.html"},{"title":"itbl_shrink_to_fit – BROWNPAK","text":"private subroutine itbl_shrink_to_fit(this, ierr) Releases additional memory to fit underlying data. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/itbl_shrink_to_fit.html"},{"title":"itbl_print – BROWNPAK","text":"private subroutine itbl_print(this) Prints an itable_t . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this Contents None","tags":"","loc":"proc/itbl_print.html"},{"title":"str_is_letter – BROWNPAK","text":"public pure function str_is_letter(str) result(res) Returns .true. if str contains only letters ( a--z or A--Z ) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical Contents None","tags":"","loc":"proc/str_is_letter.html"},{"title":"str_is_digit – BROWNPAK","text":"public pure function str_is_digit(str) result(res) Returns .true. if str contains only digits (0,1,...,9) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical Contents None","tags":"","loc":"proc/str_is_digit.html"},{"title":"str_is_space – BROWNPAK","text":"public pure function str_is_space(str) result(res) Returns .true. if str is non-empty and contains only whitespace\n characters (tab or blankspace). Otherwise .false. is returned. Note : This function will return .false. for an empty string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical Contents None","tags":"","loc":"proc/str_is_space.html"},{"title":"str_is_comment – BROWNPAK","text":"public pure function str_is_comment(line, comment_str) result(res) Returns .true. if line is a comment, .false. other wise. line is a comment if comment_str is its first non-blank character\n  sequence. If line is an empty string or contains only blankspaces, the\n  return value is .false. If comment_str is empty, the return value is .true. . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Input string character(len=*), intent(in) :: comment_str String marking the beginning of a comment. Return Value logical Contents None","tags":"","loc":"proc/str_is_comment.html"},{"title":"str_compact – BROWNPAK","text":"public pure function str_compact(str) result(ostr) Returns a copy of str with multiple spaces and tabs converted to\n single spaces, control characters deleted, and leading and trailing\n spaces removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_compact.html"},{"title":"str_remove_stcc – BROWNPAK","text":"public pure function str_remove_stcc(str) result(ostr) Returns a copy of the string str with spaces, tabs, and\n control characters removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_remove_stcc.html"},{"title":"str_to_upper – BROWNPAK","text":"public pure function str_to_upper(str) result(ucstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to uppercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) Contents None","tags":"","loc":"proc/str_to_upper.html"},{"title":"str_to_lower – BROWNPAK","text":"public pure function str_to_lower(str) result(lcstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to lowercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) Contents None","tags":"","loc":"proc/str_to_lower.html"},{"title":"str_from_inum – BROWNPAK","text":"private pure function str_from_inum(num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_from_inum.html"},{"title":"str_from_ilnum – BROWNPAK","text":"private pure function str_from_ilnum(num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_from_ilnum.html"},{"title":"str_from_dnum – BROWNPAK","text":"private pure function str_from_dnum(num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_from_dnum.html"},{"title":"str_trimzero – BROWNPAK","text":"public pure function str_trimzero(str) result(res) Deletes nonsignificant trailing zeroes from number string str. If number\n string ends in a decimal point, one trailing zero is added. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_trimzero.html"},{"title":"str_to_d – BROWNPAK","text":"public pure function str_to_d(str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value real(kind=rp) Contents None","tags":"","loc":"proc/str_to_d.html"},{"title":"str_to_i – BROWNPAK","text":"public pure function str_to_i(str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer Contents None","tags":"","loc":"proc/str_to_i.html"},{"title":"str_strip – BROWNPAK","text":"public pure function str_strip(str, chars, ends) result(ostr) Returns a copy of string str with the leading and trailing characters\n removed. The chars argument is a string specifying the set of characters to\n be removed.  The chars argument is not a prefix or suffix; rather, all\n combinations of its values are stripped. If ends = 'l' , only leading\n characters are removed, if ends = 'r' , only trailing characters are\n removed, and if ends = 'b' both leading and trailing characters are\n removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: chars character(len=1), intent(in) :: ends {'l', 'r', 'b'} Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_strip.html"},{"title":"str_startswith – BROWNPAK","text":"public pure function str_startswith(str, prefix, start, finish) result(res) Returns .true. if the string str starts with prefix , otherwise\n returns .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: prefix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical Contents None","tags":"","loc":"proc/str_startswith.html"},{"title":"str_endswith – BROWNPAK","text":"public pure function str_endswith(str, suffix, start, finish) result(res) Returns .true. if the string str ends with suffix , otherwise\n return .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical Contents None","tags":"","loc":"proc/str_endswith.html"},{"title":"str_shift – BROWNPAK","text":"public subroutine str_shift(str, n) Shifts characters in str by n positions (positive values\n denote a right shift and negative values denote a left shift). Characters\n that are shifted off the end are lost. Positions opened up by the shift \n are replaced by spaces. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str integer, intent(in) :: n Contents None","tags":"","loc":"proc/str_shift.html"},{"title":"str_insert – BROWNPAK","text":"public subroutine str_insert(str, substr, loc) Inserts the string substr into the string str at position loc . \n Characters in str starting at position loc are shifted right to\n make room for the inserted string. Trailing spaces of substr are \n removed prior to insertion. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in) :: loc Contents None","tags":"","loc":"proc/str_insert.html"},{"title":"str_del – BROWNPAK","text":"public subroutine str_del(str, substr, n) Deletes first n occurrences of substring substr from string str and\n shifts characters left to fill hole. If n < 0 , all occurances are\n deleted.  If n is not explicitly provided, it defaults to removing the\n first occurrence. Trailing spaces or blanks are not considered part of substr . Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in), optional :: n Contents None","tags":"","loc":"proc/str_del.html"},{"title":"str_strip_comment – BROWNPAK","text":"public subroutine str_strip_comment(str, comment_str) Strips trailing comment from a string. The comment is assumed to begin with the sequence of characters in comment_str . If the sequence comment_str is not found within str ,\n  no changes are made. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str Input string character(len=*), intent(in) :: comment_str String indicating beginning of a comment. Contents None","tags":"","loc":"proc/str_strip_comment.html"},{"title":"str_get_keyval – BROWNPAK","text":"public subroutine str_get_keyval(str, key, val, delimiter) Split a string str into two strings, key and val based on space\n delimiter. A non-empty non-comment string should be passed to this subroutine.\n Keys can have corresponding empty values, but keys must always be present Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=:), intent(out), allocatable :: key character(len=:), intent(out), allocatable :: val character(len=*), intent(in), optional :: delimiter Contents None","tags":"","loc":"proc/str_get_keyval.html"},{"title":"str_match – BROWNPAK","text":"public subroutine str_match(str, ipos, imatch) This routine finds the delimiter in string str that matches the delimiter\n in position ipos of str . The argument imatch contains the position of\n the matching delimiter. Allowable delimiters are (), [], {}, <>. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: ipos integer, intent(out) :: imatch Contents None","tags":"","loc":"proc/str_match.html"},{"title":"str_compact_rlstr – BROWNPAK","text":"public subroutine str_compact_rlstr(str) Compact a string representing a real number, so that the same value is\n displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str string representation of a real number. Contents None","tags":"","loc":"proc/str_compact_rlstr.html"},{"title":"str_split – BROWNPAK","text":"public subroutine str_split(str, delimiter, before) Routine finds the first instance of a character from delims in the the\n string str . The characters before the found delimiter are output in before . The characters after the found delimiter are output in str .\n Repeated applications of this routine can be used to parse a string into its\n component parts. Multiple whitespaces of str are compacted into a single\n whitespace before splitting begins. If either str or delimiter is\n empty, an empty string is retured in before and str remains\n unchanged. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: delimiter character(len=:), intent(out), allocatable :: before Contents None","tags":"","loc":"proc/str_split.html"},{"title":"str_append – BROWNPAK","text":"public subroutine str_append(dest, source, sep) Appends a copy of the source string to the dest string, with \n optional string sep in between. It is assumed that dest is long\n enough to hold the result, otherwise an error will be generated. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: dest character(len=*), intent(in) :: source character(len=*), intent(in), optional :: sep Contents None","tags":"","loc":"proc/str_append.html"},{"title":"readline – BROWNPAK","text":"public subroutine readline(nunitr, line, comment_str, ios) Reads a line from unit=nunitr, ignoring blank lines\n  and deleting comments Arguments Type Intent Optional Attributes Name integer, intent(in) :: nunitr character(len=*), intent(inout) :: line character(len=*), intent(in) :: comment_str integer, intent(out) :: ios Contents None","tags":"","loc":"proc/readline.html"},{"title":"str_from_num – BROWNPAK","text":"public interface str_from_num Generic  interface for writing a number to a string. The calling syntax is str_from_num(num, frmt) where number is a real number or an integer, format is the format desired, e.g., e15.6 , i5 , etc. Contents Module Procedures str_from_inum str_from_ilnum str_from_dnum Module Procedures private pure function str_from_inum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_ilnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_dnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/str_from_num.html"},{"title":"cl_get_num_cells – BROWNPAK","text":"public function cl_get_num_cells() result(res) Returns the total number of cells Arguments None Return Value integer Contents None","tags":"","loc":"proc/cl_get_num_cells.html"},{"title":"cl_init – BROWNPAK","text":"public subroutine cl_init(na_max, cs_min) Initializes a cell list. Arguments Type Intent Optional Attributes Name integer, intent(in) :: na_max Maximum number of atoms to be handled. real(kind=rp), intent(in) :: cs_min Minimum size (i.e. length) of a cell. Contents None","tags":"","loc":"proc/cl_init.html"},{"title":"cl_set_cell_size – BROWNPAK","text":"public subroutine cl_set_cell_size(cs) Sets the cell size. The actual cell size may be slightly larger. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: cs Contents None","tags":"","loc":"proc/cl_set_cell_size.html"},{"title":"cl_build_cell_nbrs – BROWNPAK","text":"public subroutine cl_build_cell_nbrs() Makes a table of neighboring cells. Arguments None Contents None","tags":"","loc":"proc/cl_build_cell_nbrs.html"},{"title":"cl_delete – BROWNPAK","text":"public subroutine cl_delete() Deallocates memory allocated in cl_init . Arguments None Contents None","tags":"","loc":"proc/cl_delete.html"},{"title":"cl_build – BROWNPAK","text":"public subroutine cl_build(coords) Sorts atoms into cells for calculating short-range interations Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: coords Contents None","tags":"","loc":"proc/cl_build.html"},{"title":"cl_get_contents – BROWNPAK","text":"public subroutine cl_get_contents(ic, res) Returns a pointer to the entries of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res Contents None","tags":"","loc":"proc/cl_get_contents.html"},{"title":"cl_get_nbr_cells – BROWNPAK","text":"public subroutine cl_get_nbr_cells(ic, res) Returns a pointer to the neighbor cells of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res Contents None","tags":"","loc":"proc/cl_get_nbr_cells.html"},{"title":"cl_print – BROWNPAK","text":"public subroutine cl_print() Prints a cell list Arguments None Contents None","tags":"","loc":"proc/cl_print.html"},{"title":"atbo_build – BROWNPAK","text":"public subroutine atbo_build() Arguments None Contents None","tags":"","loc":"proc/atbo_build.html"},{"title":"atan_build – BROWNPAK","text":"public subroutine atan_build() Arguments None Contents None","tags":"","loc":"proc/atan_build.html"},{"title":"atdh_build – BROWNPAK","text":"public subroutine atdh_build() Arguments None Contents None","tags":"","loc":"proc/atdh_build.html"},{"title":"atat_build – BROWNPAK","text":"private subroutine atat_build() Arguments None Contents None","tags":"","loc":"proc/atat_build.html"},{"title":"exat_build – BROWNPAK","text":"public subroutine exat_build() Arguments None Contents None","tags":"","loc":"proc/exat_build.html"},{"title":"logger_init – BROWNPAK","text":"public subroutine logger_init(this, fn, use_stdout) Initializes a logger. Arguments Type Intent Optional Attributes Name type( logger_t ), intent(inout) :: this A logger_t instance character(len=*), intent(in) :: fn Name of the log file. If use_stdout is true, fn is ignored. logical, intent(in) :: use_stdout Write all log messages to stdout rather than a file on disk? {T/F} Contents None","tags":"","loc":"proc/logger_init.html"},{"title":"logger_finish – BROWNPAK","text":"private subroutine logger_finish(this) Cleanup routine for a logger_t instance. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(inout) :: this A logger_t instance Contents None","tags":"","loc":"proc/logger_finish.html"},{"title":"logger_log_msg – BROWNPAK","text":"private subroutine logger_log_msg(this, msg) Write a message to the log file. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(in) :: this A logger_t instance character(len=*), intent(in) :: msg Message to write to the log file Contents None","tags":"","loc":"proc/logger_log_msg.html"},{"title":"timestring – BROWNPAK","text":"private subroutine timestring(string) TIMESTRING writes the current YMDHMS date into a string. Arguments Type Intent Optional Attributes Name character(len=*) :: string Contents None","tags":"","loc":"proc/timestring.html"},{"title":"logger_init – BROWNPAK","text":"private interface logger_init Contents Module Procedures logger_init Module Procedures private interface logger_init () Arguments None","tags":"","loc":"interface/logger_init.html"},{"title":"iqsort – BROWNPAK","text":"public subroutine iqsort(list, order) Sorts a sequence of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), DIMENSION (:) :: list Sequence of integers to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence Contents Source Code iqsort Source Code RECURSIVE SUBROUTINE iqsort ( list , order ) !!  Sorts a sequence of integers IMPLICIT NONE INTEGER , DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of integers to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE iqsort","tags":"","loc":"proc/iqsort.html"},{"title":"dqsort – BROWNPAK","text":"public subroutine dqsort(list, order) Sorts a sequence of reals Arguments Type Intent Optional Attributes Name real(kind=RP), intent(inout), DIMENSION (:) :: list Sequence of reals to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence Contents Source Code dqsort Source Code RECURSIVE SUBROUTINE dqsort ( list , order ) !!  Sorts a sequence of reals !\"\" IMPLICIT NONE REAL ( RP ), DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of reals to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE dqsort","tags":"","loc":"proc/dqsort.html"},{"title":"read_dump – BROWNPAK","text":"public subroutine read_dump(fn) Reads from DUMP file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Contents None","tags":"","loc":"proc/read_dump.html"},{"title":"write_dump – BROWNPAK","text":"public subroutine write_dump(fn) Writes to DUMP file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Contents None","tags":"","loc":"proc/write_dump.html"},{"title":"read_config – BROWNPAK","text":"public subroutine read_config(fn) Read from CONFIG file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Contents None","tags":"","loc":"proc/read_config.html"},{"title":"write_config – BROWNPAK","text":"public subroutine write_config(fn, title) Write to cfg file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn character(len=*), intent(in) :: title Contents None","tags":"","loc":"proc/write_config.html"},{"title":"write_ldf – BROWNPAK","text":"public subroutine write_ldf(fn_ld, title, with_mpcd_atoms) Write to a LAMMPS data file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn_ld Name of the file character(len=*), intent(in) :: title Title of the configuation logical, intent(in), optional :: with_mpcd_atoms Include MPCD atoms in the file? {T, F} Contents None","tags":"","loc":"proc/write_ldf.html"},{"title":"write_xyz – BROWNPAK","text":"public subroutine write_xyz(fn_xyz, title, with_mpcd_atoms) Write to an XYZ file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn_xyz Name of the XYZ file character(len=*), intent(in) :: title Title (for the configuration) logical, intent(in), optional :: with_mpcd_atoms Include MPCD atoms in the file? {T, F} Contents None","tags":"","loc":"proc/write_xyz.html"},{"title":"setup – BROWNPAK","text":"public subroutine setup() Arguments None Contents None","tags":"","loc":"proc/setup.html"},{"title":"run – BROWNPAK","text":"public subroutine run() Arguments None Contents None","tags":"","loc":"proc/run.html"},{"title":"config_clear – BROWNPAK","text":"public subroutine config_clear() Clears out all configuration related variables in module m_globals . Arguments None Contents None","tags":"","loc":"proc/config_clear.html"},{"title":"finish – BROWNPAK","text":"public subroutine finish() Arguments None Contents None","tags":"","loc":"proc/finish.html"},{"title":"smbx_init – BROWNPAK","text":"public subroutine smbx_init(this) Creates an instance of smbx_t . Can also be called to reset. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/smbx_init.html"},{"title":"smbx_set_basis – BROWNPAK","text":"public subroutine smbx_set_basis(this, bv) Sets all three basis vectors. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(3,3) :: bv Contents None","tags":"","loc":"proc/smbx_set_basis.html"},{"title":"smbx_freeze – BROWNPAK","text":"public subroutine smbx_freeze(this) Specifies this as non-deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/smbx_freeze.html"},{"title":"smbx_unfreeze – BROWNPAK","text":"public subroutine smbx_unfreeze(this) Specifies this as deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/smbx_unfreeze.html"},{"title":"smbx_get_image – BROWNPAK","text":"public subroutine smbx_get_image(this, r) Returns the image of r under PBC. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(3) :: r Contents None","tags":"","loc":"proc/smbx_get_image.html"},{"title":"smbx_wrap_all – BROWNPAK","text":"public subroutine smbx_wrap_all(this, coords) Wraps atom positions w.r.t. periodic boundary conditions. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords Contents None","tags":"","loc":"proc/smbx_wrap_all.html"},{"title":"smbx_to_center – BROWNPAK","text":"public subroutine smbx_to_center(this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the center \n of the box. Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com Contents None","tags":"","loc":"proc/smbx_to_center.html"},{"title":"smbx_get_rnd_points – BROWNPAK","text":"public subroutine smbx_get_rnd_points(this, coords) Returns uniformly distributed points within the box. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(out), dimension(:,:) :: coords Contents None","tags":"","loc":"proc/smbx_get_rnd_points.html"},{"title":"mpcd_init – BROWNPAK","text":"public subroutine mpcd_init(ierr) Initializes the MPCD solver. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/mpcd_init.html"},{"title":"mpcd_finish – BROWNPAK","text":"public subroutine mpcd_finish() Clean up MPCD solver. Arguments None Contents None","tags":"","loc":"proc/mpcd_finish.html"},{"title":"mpcd_run – BROWNPAK","text":"public subroutine mpcd_run() Driver for MPCD integrator. Repeatedly calls mpcd_stream and mpcd_collide to update atom\n positions. Handling of flow field is not imlemented yet. If a non-zero flow_style is specified, it will be set to zero. Arguments None Contents None","tags":"","loc":"proc/mpcd_run.html"},{"title":"mpcd_stream – BROWNPAK","text":"private subroutine mpcd_stream(ierr) Performs one step of streaming. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/mpcd_stream.html"},{"title":"mpcd_collide – BROWNPAK","text":"private subroutine mpcd_collide() Performs one step of MPCD collision. Arguments None Contents None","tags":"","loc":"proc/mpcd_collide.html"},{"title":"bds_init – BROWNPAK","text":"public subroutine bds_init(ierr) Initializes the BD solver. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/bds_init.html"},{"title":"bds_finish – BROWNPAK","text":"public subroutine bds_finish() Clears up memory allocated in bds_init . Arguments None Contents None","tags":"","loc":"proc/bds_finish.html"},{"title":"bds_run – BROWNPAK","text":"public subroutine bds_run() Driver for BD integrator. Repeatedly calls integrate_em or integrate_se or integrate_rk to update atom positions. Arguments None Contents None","tags":"","loc":"proc/bds_run.html"},{"title":"integrate_em – BROWNPAK","text":"private subroutine integrate_em(ierr) Performs one step of BD integration using explicit Euler-Maruyama scheme. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/integrate_em.html"},{"title":"integrate_se – BROWNPAK","text":"private subroutine integrate_se(ierr) Performs one step of BD integration using semi-implicit Euler scheme. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/integrate_se.html"},{"title":"se_calc_fval – BROWNPAK","text":"private subroutine se_calc_fval(ierr) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/se_calc_fval.html"},{"title":"se_linsolve – BROWNPAK","text":"private subroutine se_linsolve(lconv, itercount, ierr) Solves the linear system using fgmres. Arguments Type Intent Optional Attributes Name logical, intent(out) :: lconv integer, intent(out) :: itercount integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/se_linsolve.html"},{"title":"integrate_rk – BROWNPAK","text":"private subroutine integrate_rk(ierr) Performs one step of BD integration using explicit RK scheme. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/integrate_rk.html"},{"title":"calc_diffusion – BROWNPAK","text":"private subroutine calc_diffusion(ierr) Calculates the diffusion term of the SDE. Updates module variables diffusion and cntr_mobsam . Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/calc_diffusion.html"},{"title":"calc_drift – BROWNPAK","text":"private subroutine calc_drift(ierr) Calculates the drift term of the SDE. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/calc_drift.html"},{"title":"calc_rpy_tensor – BROWNPAK","text":"private subroutine calc_rpy_tensor(mob) Calculates the RPY approximation to the mobility tensor. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:) :: mob (3 num_atoms , 3 num_atoms ) matrix; stores the mobility tensor. Contents None","tags":"","loc":"proc/calc_rpy_tensor.html"},{"title":"read_control – BROWNPAK","text":"public subroutine read_control(fn) Reads simulation parameters from file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Name of parameters file. Contents None","tags":"","loc":"proc/read_control.html"},{"title":"write_control – BROWNPAK","text":"public subroutine write_control(fn) Write simulation parameters to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn File name Contents None","tags":"","loc":"proc/write_control.html"},{"title":"scalar_triple_product – BROWNPAK","text":"public function scalar_triple_product(a, b, c) result(res) Returns the scalar triple product a .( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c Return Value real(kind=rp) Contents None","tags":"","loc":"proc/scalar_triple_product.html"},{"title":"det – BROWNPAK","text":"public function det(A) result(res) Returns the determinant of an (N x N) matrix, where N = 2, 3, or 4. Original routine by David Simpson Note For a general NxN matrix do an LU decomp Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (N,N) array, where N = 2, 3, or 4. Return Value real(kind=rp) Contents None","tags":"","loc":"proc/det.html"},{"title":"trace – BROWNPAK","text":"public function trace(mat) result(res) Returns the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mat (:,:) (N,N) array Return Value real(kind=rp) Contents None","tags":"","loc":"proc/trace.html"},{"title":"isclose – BROWNPAK","text":"public elemental function isclose(a, b, rel_tol, abs_tol) Checks if two floating point numbers of type double are close within\n  tolerance. Based on python implementation at https://github.com/PythonCHB/close_pep/blob/master/is_close.py .\n  The method='weak' option is used here. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b real(kind=rp), intent(in), optional :: rel_tol Relative tolerance, rel_tol >= 0, default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance, abs_tol >= 0, default 0.0 Return Value logical Contents None","tags":"","loc":"proc/isclose.html"},{"title":"allclose_rank1 – BROWNPAK","text":"public function allclose_rank1(a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical Contents None","tags":"","loc":"proc/allclose_rank1.html"},{"title":"allclose_rank2 – BROWNPAK","text":"public function allclose_rank2(a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical Contents None","tags":"","loc":"proc/allclose_rank2.html"},{"title":"allclose_rank3 – BROWNPAK","text":"public function allclose_rank3(a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical Contents None","tags":"","loc":"proc/allclose_rank3.html"},{"title":"get_quad_form – BROWNPAK","text":"public function get_quad_form(A, x) result(res) Calculates the quadratic form x&#94;T A x , where A is an n x n matrix and x is a\n  vector of length n Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (n,n) array real(kind=rp), intent(in), dimension(:) :: x (n,) array Return Value real(kind=rp) Contents None","tags":"","loc":"proc/get_quad_form.html"},{"title":"rad2deg – BROWNPAK","text":"public elemental subroutine rad2deg(rad, deg) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rad real(kind=rp), intent(out) :: deg Contents None","tags":"","loc":"proc/rad2deg.html"},{"title":"deg2rad – BROWNPAK","text":"public elemental subroutine deg2rad(deg, rad) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: deg real(kind=rp), intent(out) :: rad Contents None","tags":"","loc":"proc/deg2rad.html"},{"title":"cross – BROWNPAK","text":"public subroutine cross(a, b, c) Calculates the cross product between two 3-element vectors Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(out), dimension(3) :: c Cross product of a and b ; c = a x b Contents None","tags":"","loc":"proc/cross.html"},{"title":"cross_mat – BROWNPAK","text":"public subroutine cross_mat(a, mat) Calculates the cross product matrix of a 3-element vector. The cross\n product matrix A of a is defined as a x b = A . b ,\n where b is another 3-element vector. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(out), dimension(3,3) :: mat Cross product matrix of a Contents None","tags":"","loc":"proc/cross_mat.html"},{"title":"outer – BROWNPAK","text":"public subroutine outer(a, b, c) Calculates the outer product of two vectors, . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (n,) array real(kind=rp), intent(out), dimension(:,:) :: c (m,n) array; Outer product Contents None","tags":"","loc":"proc/outer.html"},{"title":"vector_triple_product – BROWNPAK","text":"public subroutine vector_triple_product(a, b, c, d) Returns the vector triple product d = a x ( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c real(kind=rp), intent(out), dimension(3) :: d Vector triple product Contents None","tags":"","loc":"proc/vector_triple_product.html"},{"title":"swap_integer – BROWNPAK","text":"public elemental subroutine swap_integer(a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b Contents None","tags":"","loc":"proc/swap_integer.html"},{"title":"swap_real – BROWNPAK","text":"public elemental subroutine swap_real(a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b Contents None","tags":"","loc":"proc/swap_real.html"},{"title":"swap_complex – BROWNPAK","text":"public elemental subroutine swap_complex(a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b Contents None","tags":"","loc":"proc/swap_complex.html"},{"title":"unitize – BROWNPAK","text":"public subroutine unitize(a) Normalizes a vector in-place. If the magnitude of the vector is nearly\n zero, no normalization takes place and the vector is returned as is with\n a warning message. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: a (m,) array Contents None","tags":"","loc":"proc/unitize.html"},{"title":"linspace – BROWNPAK","text":"public subroutine linspace(start, finish, num, val, step) Generates evenly spaced numbers over a specified interval. Both end\n points are included. If start < finish , the returned step size (if step is present) will be negative. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point real(kind=rp), intent(in) :: finish Ending point, finish /= start integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(out), optional :: step Step size Contents None","tags":"","loc":"proc/linspace.html"},{"title":"logspace – BROWNPAK","text":"public subroutine logspace(start, finish, num, val, base) Generates numbers spaced evenly on a log scale.\n  In linear space, the sequence starts at base ** start ( base to the power of start ) and ends with base ** stop Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point, base ** start is the starting value real(kind=rp), intent(in) :: finish Ending point, finish /= start , base ** start is the ending value integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(in), optional :: base Base of the logspace, default 10 Contents None","tags":"","loc":"proc/logspace.html"},{"title":"identity – BROWNPAK","text":"public subroutine identity(mat_eye) Creates an identity matrix of size n x n. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:) :: mat_eye (n,n) array Contents None","tags":"","loc":"proc/identity.html"},{"title":"get_diagonal – BROWNPAK","text":"public subroutine get_diagonal(mat, d) Returns the diagonal elements of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mat (n,n) array real(kind=rp), intent(out), dimension(:) :: d (n,) array; contains the entries of the main diagonal Contents None","tags":"","loc":"proc/get_diagonal.html"},{"title":"add_transpose – BROWNPAK","text":"public subroutine add_transpose(mat) Adds a square matrix and its transpose in place: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat (n,n) array Contents None","tags":"","loc":"proc/add_transpose.html"},{"title":"subtract_transpose – BROWNPAK","text":"public subroutine subtract_transpose(mat) Calculates the difference of a square matrix and its transpose in place: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat Contents None","tags":"","loc":"proc/subtract_transpose.html"},{"title":"multiply_transpose – BROWNPAK","text":"public subroutine multiply_transpose(A, B) Multiplies a matrix with its transpose: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (m,n) array real(kind=rp), intent(out), dimension(:,:) :: B (m,m) array Contents None","tags":"","loc":"proc/multiply_transpose.html"},{"title":"orth – BROWNPAK","text":"public subroutine orth(a) Orthogonalizes a set of vectors in-place using Gram-Schmidt orthonormalization Reference: Golub and Van Loan, Matrix Computations, 3rd edition, Section 5.2.8,\n Algorithm 5.2.5, p. 231. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: a (m,n) array, where m <= n. The first m columns of the matrix are\n  overwritten with the orthogonal basis vectors. Contents None","tags":"","loc":"proc/orth.html"},{"title":"invert_mat33 – BROWNPAK","text":"public subroutine invert_mat33(a, inv_a) Inverts a 3x3 matrix. Reference: https://www.geometrictools.com/Documentation/LaplaceExpansionTheorem.pdf Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3,3) :: inv_a Contents None","tags":"","loc":"proc/invert_mat33.html"},{"title":"eigval_33rsym – BROWNPAK","text":"public subroutine eigval_33rsym(a, ev) Calculates the eigenvalues of a 3 x 3 real symmetric matrix. The\n eigenvalues calculated are in decreasing order. Only the diagonal and\n lower triangular part of the matrix is accessed. Reference: https://en.wikipedia.org/wiki/Eigenvalue_algorithm#cite_note-Smith-12 See also David Eberly's notes and implementation at \n https://www.geometrictools.com/Documentation/RobustEigenSymmetric3x3.pdf Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3) :: ev Contents None","tags":"","loc":"proc/eigval_33rsym.html"},{"title":"dsyevc3 – BROWNPAK","text":"public subroutine dsyevc3(A, W) Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's\n analytical algorithm.\n Only the diagonal and upper triangular parts of A are accessed. The access\n is read-only. Copyright (C) 2006  Joachim Kopp Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), DIMENSION(3,3) :: A real(kind=RP), intent(out), DIMENSION(3) :: W (3) Contents None","tags":"","loc":"proc/dsyevc3~2.html"},{"title":"allclose – BROWNPAK","text":"public interface allclose Checks if two arrays are elementwise close within tolerance Contents Module Procedures allclose_rank1 allclose_rank2 allclose_rank3 Module Procedures public function allclose_rank1 (a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank2 (a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank3 (a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical","tags":"","loc":"interface/allclose.html"},{"title":"swap – BROWNPAK","text":"public interface swap Swaps two arrays Contents Module Procedures swap_integer swap_real swap_complex Module Procedures public elemental subroutine swap_integer (a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b public elemental subroutine swap_real (a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b public elemental subroutine swap_complex (a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b","tags":"","loc":"interface/swap.html"},{"title":"ia_vdw_setup – BROWNPAK","text":"public subroutine ia_vdw_setup() Sets up parameters for vdw potentials Arguments None Contents None","tags":"","loc":"proc/ia_vdw_setup.html"},{"title":"ia_get_vdw_force – BROWNPAK","text":"public subroutine ia_get_vdw_force(rij_mag, qi, qj, typ, enrg, frc, ierr) Calculates the energy & its derivative due to a single interacting pair of atoms. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between two atoms real(kind=rp), intent(in) :: qi Charge on atom i real(kind=rp), intent(in) :: qj Charge on atom j integer, intent(in) :: typ Type of vdw interaction real(kind=rp), intent(out) :: enrg Energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of force due to\n this potential. integer, intent(out) :: ierr Error flag Contents None","tags":"","loc":"proc/ia_get_vdw_force.html"},{"title":"vdw_lj_set – BROWNPAK","text":"private subroutine vdw_lj_set(params, eps, sigma, rcut) Setter for 12-6 LJ (truncated & force-shifted) interaction. The potential U is given by: V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] U = V - V(rcut) - (r - rcut)*dV/dr, r < rcut, 0, r >= rcut where dV/dr is evaluated at r = rcut . User-set parameters: params(1) = eps params(2) = sigma params(3) = rcut Internally stored parameters: params(4) = V(rcut) params(5) = dV/dr(rcut) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut Contents None","tags":"","loc":"proc/vdw_lj_set.html"},{"title":"vdw_lj – BROWNPAK","text":"private pure subroutine vdw_lj(r, params, enrg, frc) Evaluates the potential and its derivative for LJ interaction. See vdw_lj_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/vdw_lj.html"},{"title":"vdw_gaussian_set – BROWNPAK","text":"private subroutine vdw_gaussian_set(params, A, B, rcut) Setter for gaussian interaction. The potential is truncated and\n force-shifted. The potential U is given by: V = A*exp(-B*r&#94;2) U = V - V(rcut) - (r - rcut)*dV/dr, r < rcut 0, r >= rcut, where dV/dr is evaluated at r = rcut . User-set parameters: params(1) = A params(2) = B params(3) = rcut Internally stored parameters: params(4) = V(rcut) params(5) = dV/dr(rcut) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: B real(kind=rp), intent(in), optional :: rcut Contents None","tags":"","loc":"proc/vdw_gaussian_set.html"},{"title":"vdw_gaussian – BROWNPAK","text":"private pure subroutine vdw_gaussian(r, params, enrg, frc) Calculates energy & its derivative for gaussian interaction. See vdw_gaussian_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/vdw_gaussian.html"},{"title":"vdw_cosine_set – BROWNPAK","text":"private subroutine vdw_cosine_set(params, A, rcut) Setter for cosine interaction. The potential U is given by: U = A*[1 + cos(pi*r/rcut)], r < rcut 0, r >= rcut The potential as well as its derivative is zero at r = rcut . User-set parameters: params(1) = A params(2) = rcut Internally stored parameters: None Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: rcut Contents None","tags":"","loc":"proc/vdw_cosine_set.html"},{"title":"vdw_cosine – BROWNPAK","text":"private pure subroutine vdw_cosine(r, params, enrg, frc) Evaluates the potential and its derivative for  cosine interaction.\n See vdw_cosine_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/vdw_cosine.html"},{"title":"vdw_lj_coul_debye_set – BROWNPAK","text":"private subroutine vdw_lj_coul_debye_set(params, eps, sigma, rcut, rcut_coul, C, kappa) Setter for 12-6 LJ with screened Coulombic interaction. The potential U is given by: V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] W = C*qi*qj*exp(-kappa*r)/r if rcut_coul > 0: U = V - V(rcut) + W - W(rcut_coul), r < rcut W - W(rcut_coul), rcut <= r < rcut_coul 0, r >= rcut_coul if rcut_coul <= 0: U = V - V(rcut) + W, r < rcut W, r >= rcut The LJ potential V is cut & shifted at r = rcut . If rcut_coul > 0 , the screened Coulombic potential W is cut & shifted\n at r = rcut_coul . If rcut_coul <= 0 , no cutoff is applied on W . rcut_coul must be >= rcut . User-set parameters: params(1) = eps params(2) = sigma params(3) = rcut params(4) = rcut_coul params(5) = C params(6) = kappa Internally stored parameters: params(7) = V(rcut) params(8) = C*exp(-kappa*rcut_coul)/rcut_coul Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C real(kind=rp), intent(in), optional :: kappa Contents None","tags":"","loc":"proc/vdw_lj_coul_debye_set.html"},{"title":"vdw_lj_coul_debye – BROWNPAK","text":"private pure subroutine vdw_lj_coul_debye(r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for screened Coulombic interaction\ncombined with 12-6 LJ (cut & shifted). See vdw_lj_coul_debye_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/vdw_lj_coul_debye.html"},{"title":"vdw_lj_coul_set – BROWNPAK","text":"private subroutine vdw_lj_coul_set(params, eps, sigma, rcut, rcut_coul, C) Setter for 12-6 LJ with Coulombic interaction. The potential U is given by: V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] W = C*qi*qj/r if rcut_coul > 0: U = V - V(rcut) + W - W(rcut_coul), r < rcut W - W(rcut_coul), rcut <= r < rcut_coul 0, r >= rcut_coul if rcut_coul <= 0: U = V - V(rcut) + W, r < rcut W, r >= rcut The LJ potential V is cut & shifted at r = rcut . If rcut_coul > 0 , the Coulombic potential W is cut & shifted at r = rcut_coul . If rcut_coul <= 0 , no cutoff is applied on W . rcut_coul must be >= rcut . User-set parameters: params(1) = eps params(2) = sigma params(3) = rcut params(4) = rcut_coul params(5) = C Internally stored parameters: params(6) = V(rcut) params(7) = C/rcut_coul Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C Contents None","tags":"","loc":"proc/vdw_lj_coul_set.html"},{"title":"vdw_lj_coul – BROWNPAK","text":"private pure subroutine vdw_lj_coul(r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for Coulombic interaction\n combined with 12-6 LJ (cut & shifted). See vdw_lj_coul_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/vdw_lj_coul.html"},{"title":"vdw_dpd_set – BROWNPAK","text":"private subroutine vdw_dpd_set(params, A, rcut) Setter for standard DPD interaction. The potential U is given by: U = (A/2)*rcut*(1 - (r/rcut))&#94;2, r < rcut User-set parameters: params(1) = A params(2) = rcut Internally stored parameters: None Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: rcut Contents None","tags":"","loc":"proc/vdw_dpd_set.html"},{"title":"vdw_dpd – BROWNPAK","text":"private pure subroutine vdw_dpd(r, params, enrg, frc) Evaluates the potential and its derivative for standard DPD interaction.\n See vdw_dpd_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/vdw_dpd.html"},{"title":"traj_create – BROWNPAK","text":"public subroutine traj_create(this, fn, na, nam, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of non-MPCD atoms integer, intent(in) :: nam Number of MPCD atoms, pass zero to indicate no data from MPCD\n particles are present. integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges Contents None","tags":"","loc":"proc/traj_create.html"},{"title":"traj_open – BROWNPAK","text":"public subroutine traj_open(this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/traj_open.html"},{"title":"traj_clear – BROWNPAK","text":"public subroutine traj_clear(this) After a call to this subroutine, all memory within this is deallocated,\n all components of this are reset to zero, and the underlying file is\n closed (if open). Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/traj_clear.html"},{"title":"traj_close – BROWNPAK","text":"public subroutine traj_close(this) Closes the underlying file of a trajectory_t . Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/traj_close.html"},{"title":"traj_read – BROWNPAK","text":"public subroutine traj_read(this, iframe, nts, ierr, mflag, coordinates, velocities, forces, charge) Read from an open trajectory. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(in) :: this integer, intent(in) :: iframe Frame number integer(kind=ip_long), intent(out) :: nts Time step counter integer, intent(out) :: ierr Error flag integer, intent(in), optional :: mflag 1: Only non-MPCD data, 2: Only MPCD data, 3: All data real(kind=rp), intent(out), optional dimension(:,:) :: coordinates real(kind=rp), intent(out), optional dimension(:,:) :: velocities real(kind=rp), intent(out), optional dimension(:,:) :: forces real(kind=rp), intent(out), optional dimension(:) :: charge Contents None","tags":"","loc":"proc/traj_read.html"},{"title":"traj_append_frame – BROWNPAK","text":"public subroutine traj_append_frame(this, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge Contents None","tags":"","loc":"proc/traj_append_frame.html"},{"title":"traj_write_frame – BROWNPAK","text":"public subroutine traj_write_frame(this, iframe, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer, intent(in) :: iframe integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge Contents None","tags":"","loc":"proc/traj_write_frame.html"},{"title":"node_isleaf – BROWNPAK","text":"interface private module function node_isleaf(this) result(res) Implementation → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. Return Value logical true if this is a leaf node, false otherwise. Description Is this a leaf node?","tags":"","loc":"interface/node_isleaf.html"},{"title":"node_asstr – BROWNPAK","text":"interface private module function node_asstr(this, frmt) result(buf) Implementation → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. character(len=*), intent(in), optional :: frmt Format string for real numbers, e.g. '(f15.6)'. Default: (g0.6) . Return Value character(len=:),\n  allocatable Return value Description Returns a string representation of a node.","tags":"","loc":"interface/node_asstr.html"},{"title":"get_num_atoms – BROWNPAK","text":"interface private module function get_num_atoms(this) result(na) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value Description Returns the number of atoms in an AABB tree.","tags":"","loc":"interface/get_num_atoms.html"},{"title":"get_aabb – BROWNPAK","text":"interface private module function get_aabb(this, ia) result(aabb) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. Return Value type( aabb_t ) AABB of atom ia . Description Returns a copy of the AABB associated with atom with index ia .","tags":"","loc":"interface/get_aabb.html"},{"title":"get_height – BROWNPAK","text":"interface private module function get_height(this) result(height) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. Description Returns the height of an AABB tree.","tags":"","loc":"interface/get_height.html"},{"title":"get_max_balance – BROWNPAK","text":"interface private module function get_max_balance(this) result(max_balance) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. Description Returns the maximum difference between the height of two children\n of a node.","tags":"","loc":"interface/get_max_balance.html"},{"title":"get_srfarea_ratio – BROWNPAK","text":"interface private module function get_srfarea_ratio(this) result(saratio) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value real(kind=rp) Return value. Description Returns the ratio of the sum of the node surface area to the surface\n area of the root node.","tags":"","loc":"interface/get_srfarea_ratio.html"},{"title":"balance – BROWNPAK","text":"interface private module function balance(this, p) result(q) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node index Return Value integer Description Balances an AABB tree.","tags":"","loc":"interface/balance.html"},{"title":"calc_height – BROWNPAK","text":"interface private recursive module function calc_height(this, p) result(height) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default: Root of the whole\n tree. Return Value integer Return value Description Calculates the height of a subtree.","tags":"","loc":"interface/calc_height.html"},{"title":"fs_acquire – BROWNPAK","text":"interface private module function fs_acquire(this) result(p) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Return Value integer Return value Description Acquires a new node from the free store and returns a pointer to it.","tags":"","loc":"interface/fs_acquire.html"},{"title":"node_init – BROWNPAK","text":"interface private module subroutine node_init(this) Implementation → Arguments Type Intent Optional Attributes Name class( node_t ), intent(out) :: this A node_t instance. Description Initializes a node.","tags":"","loc":"interface/node_init.html"},{"title":"init – BROWNPAK","text":"interface private module subroutine init(this, natoms, tskin) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(out) :: this An aabbtree_t instance. integer, intent(in) :: natoms Estimated number of atoms to be handled by this tree. real(kind=rp), intent(in) :: tskin Thickness of the skin for fattened AABBs, as a fraction of the\n AABB base length. Description Initializes an AABB tree.","tags":"","loc":"interface/init.html"},{"title":"print – BROWNPAK","text":"interface private recursive module subroutine print(this, p) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default is the root of the\n whole tree. Description Prints a subtree of an AABB tree rooted at p in order.","tags":"","loc":"interface/print.html"},{"title":"clear – BROWNPAK","text":"interface private module subroutine clear(this) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Description Clears an AABB tree. Associated memory is not deallocated.","tags":"","loc":"interface/clear.html"},{"title":"delete – BROWNPAK","text":"interface private module subroutine delete(this) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Description Deletes an AABB tree. All associated memory is deallocated.","tags":"","loc":"interface/delete.html"},{"title":"insert – BROWNPAK","text":"interface private module subroutine insert(this, ia, pos, radius) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) Description Inserts an atom into an AABB tree.","tags":"","loc":"interface/insert.html"},{"title":"remove – BROWNPAK","text":"interface private module subroutine remove(this, ia) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index Description Removes an atom from an AABB tree.","tags":"","loc":"interface/remove.html"},{"title":"remove_all – BROWNPAK","text":"interface private module subroutine remove_all(this) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Description Removes all atoms from an AABB tree.","tags":"","loc":"interface/remove_all.html"},{"title":"update_fatm – BROWNPAK","text":"interface private module subroutine update_fatm(this, ia, pos, radius, lstat) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. Description Updates an AABB tree for the case when an atom leaves its fattened\n AABB.","tags":"","loc":"interface/update_fatm.html"},{"title":"update_fatmaabb – BROWNPAK","text":"interface private module subroutine update_fatmaabb(this, ia, lbnd, ubnd, lstat) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound of atom AABB real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound of atom AABB logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. Description Updates an AABB tree for the case when an atom leaves its fattened\n AABB, with the bounds of the new AABB for the atom as input.","tags":"","loc":"interface/update_fatmaabb.html"},{"title":"query_watm – BROWNPAK","text":"interface private module subroutine query_watm(this, ia, nbrs) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. Description Query an AABB tree for a set of potential neighbors of an atom.","tags":"","loc":"interface/query_watm.html"},{"title":"query_watmaabb – BROWNPAK","text":"interface private module subroutine query_watmaabb(this, ia, aabb, nbrs) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. type( aabb_t ), intent(in) :: aabb Bounding AABB for atom with index ia . type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. Description Query an AABB tree for a set of potential neighbors of an atom & its\n bounding AABB.","tags":"","loc":"interface/query_watmaabb.html"},{"title":"query_waabb – BROWNPAK","text":"interface private module subroutine query_waabb(this, aabb, atms) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. type( aabb_t ), intent(in) :: aabb An aabb_t instance. type( ivector_t ), intent(inout) :: atms List of potential neighbors. Description Query an AABB tree for the set of atoms whose AABBS overlap with aabb .","tags":"","loc":"interface/query_waabb.html"},{"title":"rebuild – BROWNPAK","text":"interface private module subroutine rebuild(this) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Description Rebuilds an optimal AABB tree.","tags":"","loc":"interface/rebuild.html"},{"title":"validate – BROWNPAK","text":"interface private module subroutine validate(this) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Description Validates an AABB tree.","tags":"","loc":"interface/validate.html"},{"title":"insert_leaf – BROWNPAK","text":"interface private module subroutine insert_leaf(this, leaf) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node Description Inserts a leaf node into a tree.","tags":"","loc":"interface/insert_leaf.html"},{"title":"remove_leaf – BROWNPAK","text":"interface private module subroutine remove_leaf(this, leaf) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node Description Removes a leaf node from a tree.","tags":"","loc":"interface/remove_leaf.html"},{"title":"fs_return – BROWNPAK","text":"interface private module subroutine fs_return(this, p) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node pointer. Description Returns a node to the free store.","tags":"","loc":"interface/fs_return.html"},{"title":"validate_structure – BROWNPAK","text":"interface private recursive module subroutine validate_structure(this, p) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. Description Asserts that an AABB subtree has a valid structure.","tags":"","loc":"interface/validate_structure.html"},{"title":"validate_metrics – BROWNPAK","text":"interface private recursive module subroutine validate_metrics(this, p) Implementation → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. Description Asserts that an AABB subtree has a valid metric.","tags":"","loc":"interface/validate_metrics.html"},{"title":"ia_tether_setup – BROWNPAK","text":"public subroutine ia_tether_setup() Sets up parameters for tether potentials Arguments None Contents None","tags":"","loc":"proc/ia_tether_setup.html"},{"title":"ia_get_tether_force – BROWNPAK","text":"public subroutine ia_get_tether_force(qmag, teth_typ, enrg, frc, ierr) Calculates the energy and its derivative due to a tether. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: qmag Distance between the tethered atom & the tether point integer, intent(in) :: teth_typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/ia_get_tether_force.html"},{"title":"teth_rigid_set – BROWNPAK","text":"private subroutine teth_rigid_set(params, r0, eps) Setter for rigid tether interaction. User-set parameters: params(1) = r0 (fixed separation distance) params(2) = eps (allowed tolerance) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: r0 real(kind=rp), intent(in), optional :: eps Contents None","tags":"","loc":"proc/teth_rigid_set.html"},{"title":"teth_rigid – BROWNPAK","text":"private subroutine teth_rigid(r, params, enrg, frc, ierr) Not implemented, needs constraint formalism. See teth_rigid_set . Calculates energy for rigid tether interaction. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/teth_rigid.html"},{"title":"teth_harm_set – BROWNPAK","text":"private subroutine teth_harm_set(params, k, r0) Setter for harmonic tether interaction. U = (1/2)*k*(r - r0)&#94;2 User-set parameters: params(1) = k (spring constant) params(2) = r0 (equilibrium distance) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 Contents None","tags":"","loc":"proc/teth_harm_set.html"},{"title":"teth_harm – BROWNPAK","text":"private subroutine teth_harm(r, params, enrg, frc) Calculates energy and its derivative for harmonic tether interaction. See teth_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/teth_harm.html"},{"title":"verlet_init – BROWNPAK","text":"public subroutine verlet_init(rskin, tskin) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rskin real(kind=rp), intent(in) :: tskin Contents None","tags":"","loc":"proc/verlet_init.html"},{"title":"verlet_delete – BROWNPAK","text":"public subroutine verlet_delete() Arguments None Contents None","tags":"","loc":"proc/verlet_delete.html"},{"title":"verlet_build – BROWNPAK","text":"public subroutine verlet_build() Arguments None Contents None","tags":"","loc":"proc/verlet_build.html"},{"title":"get_uniform – BROWNPAK","text":"public function get_uniform(lb, ub) result(res) Returns a random number from a uniform distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound Return Value real(kind=rp) Contents None","tags":"","loc":"proc/get_uniform.html"},{"title":"get_iuniform – BROWNPAK","text":"public function get_iuniform(lb, ub) result(res) Returns a random integer from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub Return Value integer(kind=ip) Contents None","tags":"","loc":"proc/get_iuniform.html"},{"title":"init_stream – BROWNPAK","text":"public subroutine init_stream(fn) Initializes a BRNG stream. The stream is initialized with a seed from the file fn . If fn is an empty string, the seed is obtained from /dev/urandom . Arguments Type Intent Optional Attributes Name character(len=*) :: fn Name of the file containing the RNG seed. Contents None","tags":"","loc":"proc/init_stream.html"},{"title":"delete_stream – BROWNPAK","text":"public subroutine delete_stream() Deletes a BRNG stream. Arguments None Contents None","tags":"","loc":"proc/delete_stream.html"},{"title":"load_stream – BROWNPAK","text":"public subroutine load_stream(fn) Loads a BRNG stream from file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Contents None","tags":"","loc":"proc/load_stream.html"},{"title":"save_seed – BROWNPAK","text":"public subroutine save_seed(fn) Saves the RNG seed to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Contents None","tags":"","loc":"proc/save_seed.html"},{"title":"save_stream – BROWNPAK","text":"public subroutine save_stream(fn) Saves a BRNG stream to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Contents None","tags":"","loc":"proc/save_stream.html"},{"title":"get_rv_uniform – BROWNPAK","text":"public subroutine get_rv_uniform(lb, ub, rv, block_size) Returns a random vector from a uniform distribution. If a block_size > 0 is provided, it fills rv in blocks of\n size block_size . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size Contents None","tags":"","loc":"proc/get_rv_uniform.html"},{"title":"get_rv_iuniform – BROWNPAK","text":"public subroutine get_rv_iuniform(lb, ub, rv, block_size) Returns a random vector of integers from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub integer(kind=ip), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size Contents None","tags":"","loc":"proc/get_rv_iuniform.html"},{"title":"get_rv_gaussian – BROWNPAK","text":"public subroutine get_rv_gaussian(mean, std_dev, rv, block_size) Generates a random vector of integers from a gaussian distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: std_dev real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size Contents None","tags":"","loc":"proc/get_rv_gaussian.html"},{"title":"ransphere – BROWNPAK","text":"public subroutine ransphere(r) Generates a random vector from the surface of a unit sphere. Algorithm from Allen & Tildesley (ed 1) p. 349. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(3) :: r (3) Contents None","tags":"","loc":"proc/ransphere.html"},{"title":"ia_external_setup – BROWNPAK","text":"public subroutine ia_external_setup() Sets up parameters for external potentials. Usually there is nothing to\n set for externals, but this acts as a placeholder for special cases. Arguments None Contents None","tags":"","loc":"proc/ia_external_setup.html"},{"title":"ia_add_external_forces – BROWNPAK","text":"public subroutine ia_add_external_forces(ierr) Calculates the force and energy due to an external field and adds to energy_external , 'forces , & stress in module m_globals`. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/ia_add_external_forces.html"},{"title":"rlx_run – BROWNPAK","text":"public subroutine rlx_run() Driver for relaxation Arguments None Contents None","tags":"","loc":"proc/rlx_run.html"},{"title":"rlx_integrate – BROWNPAK","text":"private subroutine rlx_integrate(ierr, zf) Performs one step of relaxation Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr logical, intent(out) :: zf Contents None","tags":"","loc":"proc/rlx_integrate.html"},{"title":"ia_bond_setup – BROWNPAK","text":"public subroutine ia_bond_setup() Sets up parameters for bond potentials Arguments None Contents None","tags":"","loc":"proc/ia_bond_setup.html"},{"title":"ia_get_bond_force – BROWNPAK","text":"public subroutine ia_get_bond_force(rij_mag, bnd_typ, enrg, frc, ierr) Calculates the energy & its derivative due to a bond. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between bonded atoms integer, intent(in) :: bnd_typ Type of the bond real(kind=rp), intent(out) :: enrg Bond energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of the force due\n to this potential. integer, intent(out) :: ierr Error flag Contents None","tags":"","loc":"proc/ia_get_bond_force.html"},{"title":"bond_harm_set – BROWNPAK","text":"private subroutine bond_harm_set(params, k, r0) Setter for harmonic bond interaction. U = (1/2)*k*(r - r0)&#94;2 User-set parameters: params(1) = k (spring constant) params(2) = r0 (equilibrium distance) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 Contents None","tags":"","loc":"proc/bond_harm_set.html"},{"title":"bond_harm – BROWNPAK","text":"private subroutine bond_harm(r, params, enrg, frc) Calculates energy & its derivative for harmonic bond. See bond_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/bond_harm.html"},{"title":"bond_fene_set – BROWNPAK","text":"private subroutine bond_fene_set(params, k, rmax, r0) Setter for FENE bond. U = -0.5 k rmax&#94;2 log [1 - ((r - r0)/rmax)&#94;2] User-set parameters: params(1) = k params(2) = rmax params(3) = r0 Note The bond cannot extend beyond (rmax+r0), where r0 is the\n equilibrium bond length. If r0 = 0, this reduces to the standard definition\n of FENE bonds. Internally stored parameters: params(4) = rmax&#94;2 Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: r0 Contents None","tags":"","loc":"proc/bond_fene_set.html"},{"title":"bond_fene – BROWNPAK","text":"private subroutine bond_fene(r, params, enrg, frc, ierr) Calculates energy & its derivative for FENE bond. See bond_fene_set . If bond length exceeds maximum extensible spring length, an error will be\n reported by ierr = 1 . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/bond_fene.html"},{"title":"bond_kg_set – BROWNPAK","text":"private subroutine bond_kg_set(params, k, rmax, eps, sigma) Setter for FENE bond interaction. V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] + eps W = -0.5 k rmax&#94;2 log [1 - (r/rmax)&#94;2] U = W + V, r < 2&#94;(1/6)*sigma W, r >= 2&#94;(1/6)*sigma User-set parameters: params(1) = k params(2) = rmax params(3) = eps params(4) = sigma Internally stored parameters: params(5) = rmax&#94;2 params(6) = 2&#94;(1/6)*sigma Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma Contents None","tags":"","loc":"proc/bond_kg_set.html"},{"title":"bond_kg – BROWNPAK","text":"private subroutine bond_kg(r, params, enrg, frc, ierr) Calculates energy & its derivative for Kremer-Grest bond. See bond_kg_set . If bond length exceeds maximum extensible spring length, an error will be\n reported as ierr = 1 . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/bond_kg.html"},{"title":"bond_ms_set – BROWNPAK","text":"private subroutine bond_ms_set(params, lp, rmax) Setter for Marko-Siggia bond. U = [-(1/2)*rtilde&#94;2 + 0.25/(1-rtilde)&#94;2 + 0.25*rtilde]*(rmax/lp), r < rmax where rtilde = r/rmax. User-set parameters: params(1) = lp (persistence length) params(2) = rmax Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: lp real(kind=rp), intent(in), optional :: rmax Contents None","tags":"","loc":"proc/bond_ms_set.html"},{"title":"bond_ms – BROWNPAK","text":"private subroutine bond_ms(r, params, enrg, frc, ierr) Evaluates the potential & its derivative for Marko-Siggia bond.\n See bond_ms_set . If bond length exceeds maximum extensible spring length, an error will be\n reported as ierr = 1 . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/bond_ms.html"},{"title":"node_isleaf – BROWNPAK","text":"module function node_isleaf(this) result(res) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/node_isleaf.html"},{"title":"node_asstr – BROWNPAK","text":"module function node_asstr(this, frmt) result(buf) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/node_asstr.html"},{"title":"get_num_atoms – BROWNPAK","text":"module function get_num_atoms(this) result(na) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_num_atoms.html"},{"title":"get_aabb – BROWNPAK","text":"module function get_aabb(this, ia) result(aabb) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia Return Value type( aabb_t ) Contents None","tags":"","loc":"proc/get_aabb.html"},{"title":"get_height – BROWNPAK","text":"module function get_height(this) result(height) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_height.html"},{"title":"get_max_balance – BROWNPAK","text":"module function get_max_balance(this) result(max_balance) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/get_max_balance.html"},{"title":"get_srfarea_ratio – BROWNPAK","text":"module function get_srfarea_ratio(this) result(saratio) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value real(kind=rp) Contents None","tags":"","loc":"proc/get_srfarea_ratio.html"},{"title":"balance – BROWNPAK","text":"module function balance(this, p) result(q) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: p Return Value integer Contents None","tags":"","loc":"proc/balance.html"},{"title":"calc_height – BROWNPAK","text":"recursive module function calc_height(this, p) result(height) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in), optional :: p Return Value integer Contents None","tags":"","loc":"proc/calc_height.html"},{"title":"fs_acquire – BROWNPAK","text":"module function fs_acquire(this) result(p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Return Value integer Contents None","tags":"","loc":"proc/fs_acquire.html"},{"title":"node_init – BROWNPAK","text":"module subroutine node_init(this) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(out) :: this Contents None","tags":"","loc":"proc/node_init.html"},{"title":"init – BROWNPAK","text":"module subroutine init(this, natoms, tskin) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(out) :: this integer, intent(in) :: natoms real(kind=rp), intent(in) :: tskin Contents None","tags":"","loc":"proc/init.html"},{"title":"print – BROWNPAK","text":"recursive module subroutine print(this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in), optional :: p Contents None","tags":"","loc":"proc/print.html"},{"title":"clear – BROWNPAK","text":"module subroutine clear(this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/clear.html"},{"title":"delete – BROWNPAK","text":"module subroutine delete(this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/delete.html"},{"title":"insert – BROWNPAK","text":"module subroutine insert(this, ia, pos, radius) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: pos real(kind=rp), intent(in) :: radius Contents None","tags":"","loc":"proc/insert.html"},{"title":"remove – BROWNPAK","text":"module subroutine remove(this, ia) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia Contents None","tags":"","loc":"proc/remove.html"},{"title":"remove_all – BROWNPAK","text":"module subroutine remove_all(this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/remove_all.html"},{"title":"update_fatm – BROWNPAK","text":"module subroutine update_fatm(this, ia, pos, radius, lstat) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: pos real(kind=rp), intent(in) :: radius logical, intent(out) :: lstat Contents None","tags":"","loc":"proc/update_fatm.html"},{"title":"update_fatmaabb – BROWNPAK","text":"module subroutine update_fatmaabb(this, ia, lbnd, ubnd, lstat) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: lbnd real(kind=rp), intent(in), dimension(3) :: ubnd logical, intent(out) :: lstat Contents None","tags":"","loc":"proc/update_fatmaabb.html"},{"title":"query_watm – BROWNPAK","text":"module subroutine query_watm(this, ia, nbrs) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia type( ivector_t ), intent(inout) :: nbrs Contents None","tags":"","loc":"proc/query_watm.html"},{"title":"query_watmaabb – BROWNPAK","text":"module subroutine query_watmaabb(this, ia, aabb, nbrs) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia type( aabb_t ), intent(in) :: aabb type( ivector_t ), intent(inout) :: nbrs Contents None","tags":"","loc":"proc/query_watmaabb.html"},{"title":"query_waabb – BROWNPAK","text":"module subroutine query_waabb(this, aabb, atms) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this type( aabb_t ), intent(in) :: aabb type( ivector_t ), intent(inout) :: atms Contents None","tags":"","loc":"proc/query_waabb.html"},{"title":"rebuild – BROWNPAK","text":"module subroutine rebuild(this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/rebuild.html"},{"title":"validate – BROWNPAK","text":"module subroutine validate(this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Contents None","tags":"","loc":"proc/validate.html"},{"title":"insert_leaf – BROWNPAK","text":"module subroutine insert_leaf(this, leaf) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: leaf Contents None","tags":"","loc":"proc/insert_leaf.html"},{"title":"remove_leaf – BROWNPAK","text":"module subroutine remove_leaf(this, leaf) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: leaf Contents None","tags":"","loc":"proc/remove_leaf.html"},{"title":"fs_return – BROWNPAK","text":"module subroutine fs_return(this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: p Contents None","tags":"","loc":"proc/fs_return.html"},{"title":"validate_structure – BROWNPAK","text":"recursive module subroutine validate_structure(this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: p Contents None","tags":"","loc":"proc/validate_structure.html"},{"title":"validate_metrics – BROWNPAK","text":"recursive module subroutine validate_metrics(this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: p Contents None","tags":"","loc":"proc/validate_metrics.html"},{"title":"m_brown – BROWNPAK","text":"Contains routines for evaluating B . d W in the SDE for Brownian Dynamics\n simulation. Uses iso_c_binding mkl_blas mkl_lapack m_precision m_ran_num m_strings m_logger Contents Variables meth sizm s dimk_min dimk_max ethres bdw_old lncv eigvlh eigvch w h_d h_sd tau matr h_bd h_bsd h_bnd tmp work iwork Subroutines brn_init brn_finish brn_calc_bdw calc_bdw_lanc calc_bdw_blanc calc_bdw_cholesky brn_calc_dw calc_bdw_lanc_sor Variables Type Visibility Attributes Name Initial character(len=4), private :: meth Method to use for generating Brownian terms. Possible values are\n'CHOL' or 'LANC'. integer, private :: sizm Size of the mobility matrix integer, private :: s Number of Brownian vectors to be generated; equivalent to block size in the\nblock Lanczos algorithm. integer, private :: dimk_min = 2 Minimum dimension of KSP integer, private :: dimk_max Maximum dimension of KSP real(kind=rp), private :: ethres = 1.0e-3_rp Error threshold for KSP-based method. real(kind=rp), private, dimension(:,:), allocatable :: bdw_old ( sizm , s ) array. Stores B.dw at previous iteration. real(kind=rp), private, dimension(:,:), allocatable :: lncv ( sizm , s*dimk_max ) array. Stores the Lanczos vectors. real(kind=rp), private, dimension(:), allocatable :: eigvlh ( s*dimk_max ,) array. Eigenvalues of the tridiagonal/block triadiagonal\n matrix H generated by the Lanczos algorithm. real(kind=rp), private, dimension(:,:), allocatable :: eigvch ( s*dimk_max , s*dimk_max ) array. Eigenvectors of the matrix H. real(kind=rp), private, dimension(:,:), allocatable :: w ( sizm , s ) array. Used for generating the Lanczos vectors. real(kind=rp), private, dimension(:), allocatable :: h_d ( dimk_max ,) array. Diagonal of the symmetric tridiagonal matrix H\n generated in case of s = 1 . real(kind=rp), private, dimension(:), allocatable :: h_sd ( dimk_max ,) array. Subdiagonal of the symmetric tridiagonal matrix H\n generated in case of s = 1 . real(kind=rp), private, dimension(:), allocatable :: tau ( s ,) array. Used in the QR decomposition of w . real(kind=rp), private, dimension(:,:), allocatable :: matr ( s , s ) array. Used in the QR decomposition of w . real(kind=rp), private, dimension(:,:), allocatable :: h_bd ( s , s*dimk_max ) array. Diagonal blocks of the matrix H.\nUsed for KSP with s > 1 . real(kind=rp), private, dimension(:,:), allocatable :: h_bsd ( s , s*dimk_max ) array. Subdiagonal blocks of the matrix H.\nUsed for KSP with s > 1 . real(kind=rp), private, dimension(:,:), allocatable :: h_bnd ( 2*s , s*dimk_max ) array. Matrix H in banded storage.\nUsed for KSP with s > 1 . real(kind=rp), private, dimension(:,:), allocatable :: tmp ( s*dimk_max , 2*s ) array used as temporary storage space. real(kind=rp), private, dimension(:), allocatable :: work Workspace array for LAPACK routines. integer, private, dimension(:), allocatable :: iwork Workspace array for LAPACK routines. Subroutines public subroutine brn_init (n, nblks, mth, f, e) Performs initial setup. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Size of the mobility matrix. integer, intent(in) :: nblks Number of B . d W vectors to generate for the same mobility matrix. 1 <= nblks < n . character(len=4), intent(in) :: mth Method for calculating the Brownian terms. mth = 'CHOL' for\n Cholesky decomposition; mth = 'LANC' for KSP-based method. integer, intent(in), optional :: f For KSP-based method, maximum number of iterations.\n Must be present if mth = 'LANC' . f must be less than n . real(kind=rp), intent(in), optional :: e For KSP-based method, error threshold for convergence. \n Must be present if mth = 'LANC' . public subroutine brn_finish () Performs cleanup. Arguments None public subroutine brn_calc_bdw (mob, bdw, ierr, lconv, f) Main driver routine for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix.\n On entry , contains the mobility matrix.  On return , if meth = 'CHOL' ,\n the upper triangular part is overwritten with the result of Cholesky\n decomposition.  The strictly lower triangular part is left intact. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B .d W . integer, intent(out) :: ierr Error flag. logical, intent(out), optional :: lconv If meth = 'LANC' , returns true if converged, false otherwise. integer, intent(out), optional :: f If meth = 'LANC' , the number of iterations performed. private subroutine calc_bdw_lanc (mob, bdw, lconv, f, ierr) Implements Lanczos algorithm for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm ,1) array.\n On entry , contains a vector drawn from standard normal \n distribution. On return , is overwritten with the result of B . d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag. private subroutine calc_bdw_blanc (mob, bdw, lconv, f, ierr) Implements block Lanczos algorithm for calculating B . d W . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B . d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag. private subroutine calc_bdw_cholesky (mob, bdw, ierr) Calculates B . d W using Cholesky decomposition. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix.\n On entry , contains the mobility matrix.  On return ,\n the upper triangular part is overwritten with the result of Cholesky\n decomposition.  The strictly lower triangular part is left intact. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm , s ) matrix.\n On entry , contains s column vectors drawn from standard normal \n distribution. On return , the s columns are overwritten with the \n result of B . d W . integer, intent(out) :: ierr Error flag. public subroutine brn_calc_dw (dw) Calculates standard normally distributed random vectors. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:), target :: dw ( n , m ) array. private subroutine calc_bdw_lanc_sor (mob, bdw, lconv, f, ierr) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mob ( sizm , sizm ) symmetric positive definite matrix. real(kind=rp), intent(inout), dimension(:,:) :: bdw ( sizm ,1) array.\n On entry , contains a vector drawn from standard normal \n distribution. On return , is overwritten with the result of B .d W . logical, intent(out) :: lconv Returns true if converged, false otherwise. integer, intent(out) :: f The number of iterations performed. integer, intent(out) :: ierr Error flag.","tags":"","loc":"module/m_brown.html"},{"title":"m_ia_angle – BROWNPAK","text":"Angle potentials Style 0: None (Only topology) Style 1: Cosine. See ang_cos_set . Uses m_precision m_constants_math m_globals Contents Subroutines ia_angle_setup ia_get_angle_force ang_cos_set Subroutines public subroutine ia_angle_setup () Sets up parameters for angle potentials Arguments None public subroutine ia_get_angle_force (q1, q2, typ, enrg, fim1, fi, fip1) Calculates the energy & force due to an angle. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 integer, intent(in) :: typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fim1 real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fip1 private subroutine ang_cos_set (params, k) Setter for angular cosine interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k","tags":"","loc":"module/m_ia_angle.html"},{"title":"m_interaction – BROWNPAK","text":"Driver routines for force & energy calculation. Uses m_precision m_constants_math m_globals m_pairtab m_ia_bond m_ia_angle m_ia_dihedral m_ia_vdw m_ia_tether m_ia_external Contents Subroutines ia_setup ia_finish ia_calc_forces ia_add_vdw_forces ia_add_bond_forces ia_add_angle_forces ia_add_dihedral_forces ia_add_tether_forces Subroutines public subroutine ia_setup () Builds necessary neighbor tables and sets up parameters for potentials. Arguments None public subroutine ia_finish () Cleanup routine for interaction calculation. Arguments None public subroutine ia_calc_forces (ierr) Calculates total forces and energies Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine ia_add_vdw_forces (ierr) Calculates force and energy due to all short-ranged non-bonded pairwise\n interactions based on pair_tab and adds to energy_vdw & forces in module m_globals . Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine ia_add_bond_forces (ierr) Calculates forces & energy due to all bonds. Will add to energy_bond & and 'forces in module m_globals`. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine ia_add_angle_forces () Calculates forces & energy due to all angles. Will add to energy_angle & 'forces in module m_globals`. Arguments None private subroutine ia_add_dihedral_forces () Calculates forces & energy due to all dihedrals. Will add to energy_dihedral & 'forces in module m_globals`. Arguments None private subroutine ia_add_tether_forces (ierr) Calculates forces & energy due to all tethers. Will add to energy_tether &\n 'forces in module m_globals`. Tether forces cannot be subject to\n periodic boundary conditions. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr","tags":"","loc":"module/m_interaction.html"},{"title":"m_vector – BROWNPAK","text":"Implements a vector as an extendable array. Uses m_precision m_qsort Contents Interfaces ivector_init dvector_init assignment(=) Derived Types ivector_t dvector_t Functions ivector_get_len dvector_get_len ivector_get_val dvector_get_val ivector_pop dvector_pop Subroutines ivector_init dvector_init ivector_from_array dvector_from_array ivector_delete dvector_delete ivector_clear dvector_clear ivector_assign dvector_assign i_dvector_assign ivector_set_val dvector_set_val ivector_append dvector_append ivector_get_data dvector_get_data ivector_resize dvector_resize ivector_shrink_to_fit dvector_shrink_to_fit ivector_sort dvector_sort ivector_unique dvector_unique ivector_print dvector_print Interfaces public interface ivector_init public interface ivector_init () Arguments None public subroutine ivector_from_array (this, x) Creates an ivector with all elements from an array Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), dimension(:) :: x public interface dvector_init public interface dvector_init () Arguments None public subroutine dvector_from_array (this, x) Creates a dvector with all elements from an array Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(:) :: x public interface assignment(=) public subroutine ivector_assign (this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine dvector_assign (this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other public subroutine i_dvector_assign (this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other Derived Types type, public :: ivector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 integer, public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => ivector_delete procedure, public :: clear => ivector_clear procedure, public :: get_val => ivector_get_val procedure, public :: set_val => ivector_set_val procedure, public :: get_data => ivector_get_data procedure, public :: append => ivector_append procedure, public :: pop => ivector_pop procedure, public :: resize => ivector_resize procedure, public :: shrink_to_fit => ivector_shrink_to_fit procedure, public :: sort => ivector_sort procedure, public :: unique => ivector_unique procedure, public :: print => ivector_print type, public :: dvector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 real(kind=rp), public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => dvector_delete procedure, public :: clear => dvector_clear procedure, public :: get_val => dvector_get_val procedure, public :: set_val => dvector_set_val procedure, public :: get_data => dvector_get_data procedure, public :: append => dvector_append procedure, public :: pop => dvector_pop procedure, public :: resize => dvector_resize procedure, public :: shrink_to_fit => dvector_shrink_to_fit procedure, public :: sort => dvector_sort procedure, public :: unique => dvector_unique procedure, public :: print => dvector_print Functions public function ivector_get_len (this) result(res) Returns the length of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Return Value integer public function dvector_get_len (this) result(res) Returns the length of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Return Value integer public function ivector_get_val (this, i) result(res) Returns the ith element of an ivector . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this integer, intent(in) :: i Return Value integer public function dvector_get_val (this, i) result(res) Returns the ith element of a dvector . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rp) public function ivector_pop (this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Return Value integer public function dvector_pop (this) result(val) Removes the last element and returns it. Calling this method on an empty list Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Return Value real(kind=rp) Subroutines public subroutine ivector_init (this, len_init, ierr) Creates an empty ivector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr public subroutine dvector_init (this, len_init, ierr) Creates an empty dvector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr public subroutine ivector_from_array (this, x) Creates an ivector with all elements from an array Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), dimension(:) :: x public subroutine dvector_from_array (this, x) Creates a dvector with all elements from an array Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(:) :: x public subroutine ivector_delete (this) Deletes an ivector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this public subroutine dvector_delete (this) Deletes a dvector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this public subroutine ivector_clear (this) Clears an ivector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this public subroutine dvector_clear (this) Clears a dvector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this public subroutine ivector_assign (this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine dvector_assign (this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other public subroutine i_dvector_assign (this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine ivector_set_val (this, i, val) Sets the value of the ith element of an ivector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: val public subroutine dvector_set_val (this, i, val) Sets the value of the ith element of a dvector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: i real(kind=rp), intent(in) :: val public subroutine ivector_append (this, val) Adds an element to the end of an ivector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: val public subroutine dvector_append (this, val) Adds an element to the end of a dvector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this real(kind=rp), intent(in) :: val public subroutine ivector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in), target :: this integer, intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend public subroutine dvector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in), target :: this real(kind=rp), intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend public subroutine ivector_resize (this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr public subroutine dvector_resize (this, new_size, ierr) Resizes a vector to a given size. Existing data is truncated if desired size\n is smaller than current size. Otherwise, the empty spaces are filled with\n zero. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: new_size integer, intent(out), optional :: ierr public subroutine ivector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of an ivector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional :: ierr public subroutine dvector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of a dvector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional :: ierr public subroutine ivector_sort (this, order) Sorts an ivector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order public subroutine dvector_sort (this, order) Sorts a dvector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order public subroutine ivector_unique (this) Sorts and removes all duplicate entries of an ivector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call ivector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this public subroutine dvector_unique (this) Sorts and removes all duplicate entries of a dvector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call dvector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this public subroutine ivector_print (this) Prints an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this public subroutine dvector_print (this) Prints a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this","tags":"","loc":"module/m_vector.html"},{"title":"m_pairtab – BROWNPAK","text":"Uses m_precision m_vector m_table m_aabbtree m_globals m_cell_list m_connectivity Contents Variables pair_tab tree rskin_sq tskin_sq coordinates_save coordinates_dr Subroutines pt_init pt_finish pt_build build_pt_n2 build_pt_verlet build_pt_aabbtree build_pt_cell_list Variables Type Visibility Attributes Name Initial type( itable_t ), public :: pair_tab type( aabbtree_t ), private :: tree real(kind=rp), private :: rskin_sq = 0.0_rp real(kind=rp), private :: tskin_sq = 0.0_rp real(kind=rp), private, dimension(:,:), allocatable :: coordinates_save (3, num_atoms ) array real(kind=rp), private, dimension(:,:), allocatable :: coordinates_dr (3, num_atoms ) array Subroutines public subroutine pt_init () Performs initial setup for building a pair list. Arguments None public subroutine pt_finish () Cleanup for pair list calculation. Arguments None public subroutine pt_build () Builds a pair table. The resulting table is stored in the module variable pair_tab . Arguments None private subroutine build_pt_n2 () Builds a pair table using direct N&#94;2 looping over all pairs. Arguments None private subroutine build_pt_verlet () Builds a pair table using the Verlet scheme. Arguments None private subroutine build_pt_aabbtree () Arguments None private subroutine build_pt_cell_list () Builds a pair table using cell list. Arguments None","tags":"","loc":"module/m_pairtab.html"},{"title":"m_ia_dihedral – BROWNPAK","text":"Dihedral potentials (none implemented) Uses m_precision m_constants_math m_globals Contents Subroutines ia_dihedral_setup ia_get_dihedral_force Subroutines public subroutine ia_dihedral_setup () Sets up parameters for dihedral potentials Arguments None public subroutine ia_get_dihedral_force (q1, q2, q3, typ, enrg, fi, fj, fk, fl) Calculates the force & energy due to a dihedral. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 real(kind=rp), intent(in), dimension(3) :: q3 integer, intent(in) :: typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fj real(kind=rp), intent(out), dimension(3) :: fk real(kind=rp), intent(out), dimension(3) :: fl","tags":"","loc":"module/m_ia_dihedral.html"},{"title":"m_stats_io – BROWNPAK","text":"Computes and writes properties calculated during simulation. Uses m_precision m_constants_math m_strings m_globals Contents Variables fu_stats span reedsq rgsq reev asph prol rgsq_bbone rgsq_sc reedsq_sc asph_sc prol_sc molbuf Subroutines stats_init stats_finish stats_write_hdr stats_write stats_compute_ic1 stats_compute_ic0 calc_shape dsyevc3 Variables Type Visibility Attributes Name Initial integer, private :: fu_stats Unit number of file fn_stats . real(kind=rp), private, dimension(3) :: span Span of a chain molecule. For multiple molecules this is averaged. real(kind=rp), private :: reedsq Mean squared end-to-end distance of a linear chain molecule.\n For multiple molecules this is averaged. Not defined for rings. real(kind=rp), private :: rgsq Mean squared gyration radius of a chain/ring molecule.\n For multiple molecules this is averaged. real(kind=rp), private, dimension(3) :: reev End-to-end vector. Not defined for rings. real(kind=rp), private :: asph Asphericity of the entire molecule real(kind=rp), private :: prol Prolateness of the entire molecule real(kind=rp), private :: rgsq_bbone Mean squared gyration radius of the backbone of a branched\n chain/ring molecule. real(kind=rp), private :: rgsq_sc Mean squared gyration radius of the side chains of a branched\n chain/ring molecule. real(kind=rp), private :: reedsq_sc Mean squared end-to-end distance of the side chains of a branched\n chain/ring molecule. real(kind=rp), private :: asph_sc Mean asphericity of the side chains of a branched chain/ring molecule. real(kind=rp), private :: prol_sc Mean prolateness of the side chains of a branched chain/ring molecule. real(kind=rp), private, dimension(:,:), allocatable :: molbuf Buffer for the largest molecule in the system Subroutines public subroutine stats_init () Set up for stats collection Arguments None public subroutine stats_finish () Closes any files opened in stats_init . Arguments None private subroutine stats_write_hdr () Driver for writing header of file fn_stats . This is called only after\n appropriate files have been opened. Arguments None public subroutine stats_write () Writing statistics Arguments None private subroutine stats_compute_ic1 () Computes statistics for a possibly multiple chains in a periodic domain. Arguments None private subroutine stats_compute_ic0 () Computes statistics for a single chain in unbounded domain. Arguments None private subroutine calc_shape (ev1, ev2, ev3, asph, prol) Given three eigen values of the gyration tensor, calculates asphericity\n and prolateness. Note that ev1 >= ev2 >= ev3. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ev1 real(kind=rp), intent(in) :: ev2 real(kind=rp), intent(in) :: ev3 real(kind=rp), intent(out) :: asph real(kind=rp), intent(out) :: prol private subroutine dsyevc3 (A, W) Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's\n analytical algorithm.\n Only the diagonal and upper triangular parts of A are accessed. The access\n is read-only. Read more… Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), DIMENSION(3,3) :: A real(kind=RP), intent(out), DIMENSION(3) :: W (3)","tags":"","loc":"module/m_stats_io.html"},{"title":"m_aabb – BROWNPAK","text":"Uses m_precision m_strings Contents Interfaces operator(+) Derived Types aabb_t Functions aabb_includes aabb_overlaps aabb_union Subroutines aabb_init aabb_print aabb_clear aabb_get_extent aabb_update aabb_fatten aabb_calc_center aabb_calc_srfarea Interfaces public interface operator(+) public function aabb_union (x, y) result(z) Combines AABBs x and y to return a new AABB z . Arguments Type Intent Optional Attributes Name type( aabb_t ), intent(in) :: x An aabb_t instance. type( aabb_t ), intent(in) :: y An aabb_t instance. Return Value type( aabb_t ) Derived Types type, public :: aabb_t Components Type Visibility Attributes Name Initial real(kind=rp), public, dimension(3) :: lbnd real(kind=rp), public, dimension(3) :: ubnd real(kind=rp), public, dimension(3) :: center real(kind=rp), public :: srfarea Type-Bound Procedures procedure, public :: init => aabb_init procedure, public :: print => aabb_print procedure, public :: clear => aabb_clear procedure, public :: get_extent => aabb_get_extent procedure, public :: update => aabb_update procedure, public :: fatten => aabb_fatten procedure, public :: includes => aabb_includes procedure, public :: overlaps => aabb_overlaps procedure, private :: calc_center => aabb_calc_center procedure, private :: calc_srfarea => aabb_calc_srfarea Functions public function aabb_includes (this, other) result(res) Returns true if this includes other , false otherwise. Inclusion\n is considered in a strict sense. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical public function aabb_overlaps (this, other) result(res) Returns true if this overlaps other , false otherwise. Touching\n does not count as an overlap. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. type( aabb_t ), intent(in) :: other An aabb_t instance. Return Value logical public function aabb_union (x, y) result(z) Combines AABBs x and y to return a new AABB z . Arguments Type Intent Optional Attributes Name type( aabb_t ), intent(in) :: x An aabb_t instance. type( aabb_t ), intent(in) :: y An aabb_t instance. Return Value type( aabb_t ) Subroutines public subroutine aabb_init (this, lbnd, ubnd) Creates an aabb_t instance from lower and upper bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(out) :: this An aabb_t instance. real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound public subroutine aabb_print (this, frmt, str) Prints an AABB. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. character(len=*), intent(in), optional :: frmt Fortran-style format string for a real number. Default: (g0.6) . character(len=:), intent(out), optional allocatable :: str If present, the output is printed to this string instead of STDOUT. public subroutine aabb_clear (this) Clears all attributes of an AABB and sets them to zero. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. public subroutine aabb_get_extent (this, extent) Calculates the extent of an aabb . The extent of an AABB is defined as\n the difference between its upper and lower bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(in) :: this An aabb_t instance. real(kind=rp), intent(out), dimension(3) :: extent Extent of an AABB. public subroutine aabb_update (this, lbnd, ubnd) Updates an AABB with new bounds. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in), optional dimension(3) :: lbnd Lower bound real(kind=rp), intent(in), optional dimension(3) :: ubnd Upper bound public subroutine aabb_fatten (this, frac) Fattens an AABB by a fraction of its base extent. Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. real(kind=rp), intent(in) :: frac Fraction of AABB base extent. public subroutine aabb_calc_center (this) Calculates the center of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance. public subroutine aabb_calc_srfarea (this) Calculates the surface area of an aabb . Arguments Type Intent Optional Attributes Name class( aabb_t ), intent(inout) :: this An aabb_t instance.","tags":"","loc":"module/m_aabb.html"},{"title":"m_table – BROWNPAK","text":"Implements a table with contiguously stored rows. Uses m_precision m_vector Contents Derived Types itable_t Functions itbl_is_in itbl_get_val Subroutines itbl_init itbl_delete itbl_clear itbl_append itbl_set_val itbl_get_row itbl_shrink_to_fit itbl_print Derived Types type, public :: itable_t Components Type Visibility Attributes Name Initial integer, public :: num_rows = 0 type( ivector_t ), public :: buffer integer, public, dimension(:), allocatable :: row_indx Type-Bound Procedures procedure, public :: delete => itbl_delete procedure, public :: clear => itbl_clear procedure, public :: append => itbl_append procedure, public :: set_val => itbl_set_val procedure, public :: is_in => itbl_is_in procedure, public :: get_val => itbl_get_val procedure, public :: get_row => itbl_get_row procedure, public :: shrink_to_fit => itbl_shrink_to_fit procedure, public :: print => itbl_print Functions private function itbl_is_in (this, irow, val) result(res) Returns .true. if val is in row irow , .false. otherwise. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: val Return Value logical private function itbl_get_val (this, irow, j) result(res) Returns the j th element of row irow Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: j Return Value integer Subroutines public subroutine itbl_init (this, num_rows, ierr) Creates an empty itable_t with num_rows rows and all rows having\n zero elements. Arguments Type Intent Optional Attributes Name type( itable_t ), intent(inout) :: this integer, intent(in) :: num_rows Must be > 0 integer, intent(out), optional :: ierr private subroutine itbl_delete (this) Deletes an itable_t . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this private subroutine itbl_clear (this) Clears all rows. Does not deallocate memory. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this private subroutine itbl_append (this, irow, val) Appends an element val to row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: val private subroutine itbl_set_val (this, irow, j, val) Sets the value of the j th element of row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: j integer, intent(in) :: val private subroutine itbl_get_row (this, irow, res) Returns a pointer to the row data of irow . No bounds checking is performed. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in), target :: this integer, intent(in) :: irow integer, intent(out), dimension(:), pointer :: res private subroutine itbl_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(out), optional :: ierr private subroutine itbl_print (this) Prints an itable_t . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this","tags":"","loc":"module/m_table.html"},{"title":"m_strings – BROWNPAK","text":"Many of these routines were originally written by George Benthien , some have\n been written by Sarit Dutta or gathered/modified from other authors (appropriately credited). These routines were developed primarily to aid in the reading and manipulation\n of input data from an ASCII text file. Accordingly, it is assumed that all\n characters to be processed are ASCII characters. Uses m_precision Contents Interfaces str_from_num Functions str_is_letter str_is_digit str_is_space str_is_comment str_compact str_remove_stcc str_to_upper str_to_lower str_from_inum str_from_ilnum str_from_dnum str_trimzero str_to_d str_to_i str_strip str_startswith str_endswith Subroutines str_shift str_insert str_del str_strip_comment str_get_keyval str_match str_compact_rlstr str_split str_append readline Interfaces public interface str_from_num Generic  interface for writing a number to a string. The calling syntax is str_from_num(num, frmt) where number is a real number or an integer, format is the format desired, e.g., e15.6 , i5 , etc. private pure function str_from_inum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_ilnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_dnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Functions public pure function str_is_letter (str) result(res) Returns .true. if str contains only letters ( a--z or A--Z ) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical public pure function str_is_digit (str) result(res) Returns .true. if str contains only digits (0,1,...,9) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical public pure function str_is_space (str) result(res) Returns .true. if str is non-empty and contains only whitespace\n characters (tab or blankspace). Otherwise .false. is returned. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical public pure function str_is_comment (line, comment_str) result(res) Returns .true. if line is a comment, .false. other wise. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Input string character(len=*), intent(in) :: comment_str String marking the beginning of a comment. Return Value logical public pure function str_compact (str) result(ostr) Returns a copy of str with multiple spaces and tabs converted to\n single spaces, control characters deleted, and leading and trailing\n spaces removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable public pure function str_remove_stcc (str) result(ostr) Returns a copy of the string str with spaces, tabs, and\n control characters removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable public pure function str_to_upper (str) result(ucstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to uppercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) public pure function str_to_lower (str) result(lcstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to lowercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) private pure function str_from_inum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_ilnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_dnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable public pure function str_trimzero (str) result(res) Deletes nonsignificant trailing zeroes from number string str. If number\n string ends in a decimal point, one trailing zero is added. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable public pure function str_to_d (str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value real(kind=rp) public pure function str_to_i (str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer public pure function str_strip (str, chars, ends) result(ostr) Returns a copy of string str with the leading and trailing characters\n removed. The chars argument is a string specifying the set of characters to\n be removed.  The chars argument is not a prefix or suffix; rather, all\n combinations of its values are stripped. If ends = 'l' , only leading\n characters are removed, if ends = 'r' , only trailing characters are\n removed, and if ends = 'b' both leading and trailing characters are\n removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: chars character(len=1), intent(in) :: ends {'l', 'r', 'b'} Return Value character(len=:),\n  allocatable public pure function str_startswith (str, prefix, start, finish) result(res) Returns .true. if the string str starts with prefix , otherwise\n returns .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: prefix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical public pure function str_endswith (str, suffix, start, finish) result(res) Returns .true. if the string str ends with suffix , otherwise\n return .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical Subroutines public subroutine str_shift (str, n) Shifts characters in str by n positions (positive values\n denote a right shift and negative values denote a left shift). Characters\n that are shifted off the end are lost. Positions opened up by the shift \n are replaced by spaces. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str integer, intent(in) :: n public subroutine str_insert (str, substr, loc) Inserts the string substr into the string str at position loc . \n Characters in str starting at position loc are shifted right to\n make room for the inserted string. Trailing spaces of substr are \n removed prior to insertion. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in) :: loc public subroutine str_del (str, substr, n) Deletes first n occurrences of substring substr from string str and\n shifts characters left to fill hole. If n < 0 , all occurances are\n deleted.  If n is not explicitly provided, it defaults to removing the\n first occurrence. Trailing spaces or blanks are not considered part of substr . Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in), optional :: n public subroutine str_strip_comment (str, comment_str) Strips trailing comment from a string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str Input string character(len=*), intent(in) :: comment_str String indicating beginning of a comment. public subroutine str_get_keyval (str, key, val, delimiter) Split a string str into two strings, key and val based on space\n delimiter. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=:), intent(out), allocatable :: key character(len=:), intent(out), allocatable :: val character(len=*), intent(in), optional :: delimiter public subroutine str_match (str, ipos, imatch) This routine finds the delimiter in string str that matches the delimiter\n in position ipos of str . The argument imatch contains the position of\n the matching delimiter. Allowable delimiters are (), [], {}, <>. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: ipos integer, intent(out) :: imatch public subroutine str_compact_rlstr (str) Author Izaak Beekman Date 02/24/2015 Compact a string representing a real number, so that the same value is\n displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str string representation of a real number. public subroutine str_split (str, delimiter, before) Routine finds the first instance of a character from delims in the the\n string str . The characters before the found delimiter are output in before . The characters after the found delimiter are output in str .\n Repeated applications of this routine can be used to parse a string into its\n component parts. Multiple whitespaces of str are compacted into a single\n whitespace before splitting begins. If either str or delimiter is\n empty, an empty string is retured in before and str remains\n unchanged. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: delimiter character(len=:), intent(out), allocatable :: before public subroutine str_append (dest, source, sep) Appends a copy of the source string to the dest string, with \n optional string sep in between. It is assumed that dest is long\n enough to hold the result, otherwise an error will be generated. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: dest character(len=*), intent(in) :: source character(len=*), intent(in), optional :: sep public subroutine readline (nunitr, line, comment_str, ios) Reads a line from unit=nunitr, ignoring blank lines\n  and deleting comments Arguments Type Intent Optional Attributes Name integer, intent(in) :: nunitr character(len=*), intent(inout) :: line character(len=*), intent(in) :: comment_str integer, intent(out) :: ios","tags":"","loc":"module/m_strings.html"},{"title":"m_constants_math – BROWNPAK","text":"Various math constants. Uses m_precision Contents Variables math_third math_pi math_pi_2 math_pi_4 math_1_pi math_2_pi math_2_sqrtpi math_sqrt2 math_cbrt2 math_sxrt2 math_sqrt1_2 math_sqrt3 math_sqrt_e math_sqrt_pi math_e math_log2e math_log10e math_ln2 math_ln10 Variables Type Visibility Attributes Name Initial real(kind=rp), public, parameter :: math_third = 0.333333333333333_rp real(kind=rp), public, parameter :: math_pi = 3.1415926535897931_rp pi real(kind=rp), public, parameter :: math_pi_2 = 1.5707963267948966_rp pi divided by two real(kind=rp), public, parameter :: math_pi_4 = 0.78539816339744828_rp pi divided by four real(kind=rp), public, parameter :: math_1_pi = 0.31830988618379069_rp reciprocal of pi real(kind=rp), public, parameter :: math_2_pi = 0.63661977236758138_rp two times reciprocal of pi real(kind=rp), public, parameter :: math_2_sqrtpi = 1.1283791670955126_rp two times the reciprocal of the square root of pi. real(kind=rp), public, parameter :: math_sqrt2 = 1.4142135623730951_rp square root of two real(kind=rp), public, parameter :: math_cbrt2 = 1.2599210498948732_rp cube root of two real(kind=rp), public, parameter :: math_sxrt2 = 1.122462048309373_rp sixth root of two real(kind=rp), public, parameter :: math_sqrt1_2 = 0.70710678118654746_rp reciprocal of the square root of two real(kind=rp), public, parameter :: math_sqrt3 = 1.7320508075688772_rp square root of three real(kind=rp), public, parameter :: math_sqrt_e = 1.6487212707001282_rp square root of M_E real(kind=rp), public, parameter :: math_sqrt_pi = 1.7724538509055159_rp square root of pi real(kind=rp), public, parameter :: math_e = 2.7182818284590451_rp The base of natural logarithms real(kind=rp), public, parameter :: math_log2e = 1.4426950408889634_rp The logarithm of M_E to base two real(kind=rp), public, parameter :: math_log10e = 0.43429448190325182_rp The logarithm of M_E to base 10 real(kind=rp), public, parameter :: math_ln2 = 0.69314718055994529_rp The natural logarithm of two real(kind=rp), public, parameter :: math_ln10 = 2.3025850929940459_rp The natural logarithm of 10","tags":"","loc":"module/m_constants_math.html"},{"title":"m_cell_list – BROWNPAK","text":"Sorts atoms using a cell list. The algorithm to build the cell list partially follows the techniques in Watanabe et\n al, 2011, “Efficient Implementations of Molecular Dynamics Simulations for\n Lennard-Jones Systems,” Prog. Theor. Phys. 126, 203–235. The pairlist is not explicitly built, rather the cells are directly\n looped over during force calculation. Uses m_precision m_vector m_globals Contents Variables cell_size nc_max nc nct_max nct cells cells_pos cell_nbrs cell_nbrs_pos host_cells cell_pop d Functions cl_get_num_cells Subroutines cl_init cl_set_cell_size cl_build_cell_nbrs cl_delete cl_build cl_get_contents cl_get_nbr_cells cl_print Variables Type Visibility Attributes Name Initial real(kind=rp), private, dimension(3) :: cell_size = 0.0_rp Cell size along x , y , & z . integer, private, dimension(3) :: nc_max = 0 Maximum number of cells along x , y , & z . integer, private, dimension(3) :: nc = 0 Number of cells along x , y , & z . integer, private :: nct_max = 0 Maximum total number of cells. integer, private :: nct = 0 Total of cells. integer, private, dimension(:), allocatable, target :: cells (na_max,) array. Listing atoms in each cell. integer, private, dimension(:), allocatable :: cells_pos (0:nct_max,) index array. Note: 0-based indexing. type( ivector_t ), private :: cell_nbrs Lists neighbor cells for each cell. integer, private, dimension(:), allocatable :: cell_nbrs_pos (0:nct_max,) index array. Note: 0-based indexing. integer, private, dimension(:), allocatable :: host_cells (na_max,) array. host_cells(i) stores the linear index of the cell\n containing atom i . na_max is the total number of atoms under consideration. integer, private, dimension(:), allocatable :: cell_pop (0:nct_max-1,) array storing population of each cell. Note: 0-based indexing. integer, private, parameter, dimension(3,13) :: d = reshape([1, 0, 0, 1, 1, 0, -1, 1, 0, 0, 1, 0, 0, 0, 1, -1, 0, 1, 1, 0, 1, -1, -1, 1, 0, -1, 1, 1, -1, 1, -1, 1, 1, 0, 1, 1, 1, 1, 1], [3, 13]) Functions public function cl_get_num_cells () result(res) Returns the total number of cells Arguments None Return Value integer Subroutines public subroutine cl_init (na_max, cs_min) Initializes a cell list. Arguments Type Intent Optional Attributes Name integer, intent(in) :: na_max Maximum number of atoms to be handled. real(kind=rp), intent(in) :: cs_min Minimum size (i.e. length) of a cell. public subroutine cl_set_cell_size (cs) Sets the cell size. The actual cell size may be slightly larger. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: cs public subroutine cl_build_cell_nbrs () Makes a table of neighboring cells. Arguments None public subroutine cl_delete () Deallocates memory allocated in cl_init . Arguments None public subroutine cl_build (coords) Sorts atoms into cells for calculating short-range interations Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: coords public subroutine cl_get_contents (ic, res) Returns a pointer to the entries of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res public subroutine cl_get_nbr_cells (ic, res) Returns a pointer to the neighbor cells of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res public subroutine cl_print () Prints a cell list Arguments None","tags":"","loc":"module/m_cell_list.html"},{"title":"m_connectivity – BROWNPAK","text":"Routines for building atom->bond, atom->angle, etc. tables and excluded\n atoms table. Uses m_precision m_vector m_table m_globals Contents Variables atbo_tab atan_tab atdh_tab atat_tab exat_tab Subroutines atbo_build atan_build atdh_build atat_build exat_build Variables Type Visibility Attributes Name Initial type( itable_t ), public :: atbo_tab Atoms -> bonds table type( itable_t ), public :: atan_tab Atoms -> angles table type( itable_t ), public :: atdh_tab Atoms -> dihedrals table type( itable_t ), private :: atat_tab Atoms -> bonded atoms table (1-ring) type( itable_t ), public :: exat_tab Atoms -> excluded atoms (from vdw calculation) table Subroutines public subroutine atbo_build () Arguments None public subroutine atan_build () Arguments None public subroutine atdh_build () Arguments None private subroutine atat_build () Arguments None public subroutine exat_build () Arguments None","tags":"","loc":"module/m_connectivity.html"},{"title":"m_logger – BROWNPAK","text":"Implements a basic logger. Uses iso_fortran_env Contents Variables logger Interfaces logger_init Derived Types logger_t Subroutines logger_init logger_finish logger_log_msg timestring Variables Type Visibility Attributes Name Initial type( logger_t ), public :: logger Interfaces private interface logger_init private interface logger_init () Arguments None Derived Types type, private :: logger_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: fn Name of the log file integer, public :: fu = huge(0) Unit number of the log file logical, public :: is_open = .false. Is the log file open for writing? {T/F} Type-Bound Procedures procedure, public :: finish => logger_finish procedure, public :: log_msg => logger_log_msg Subroutines public subroutine logger_init (this, fn, use_stdout) Initializes a logger. Arguments Type Intent Optional Attributes Name type( logger_t ), intent(inout) :: this A logger_t instance character(len=*), intent(in) :: fn Name of the log file. If use_stdout is true, fn is ignored. logical, intent(in) :: use_stdout Write all log messages to stdout rather than a file on disk? {T/F} private subroutine logger_finish (this) Cleanup routine for a logger_t instance. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(inout) :: this A logger_t instance private subroutine logger_log_msg (this, msg) Write a message to the log file. Arguments Type Intent Optional Attributes Name class( logger_t ), intent(in) :: this A logger_t instance character(len=*), intent(in) :: msg Message to write to the log file private subroutine timestring (string) TIMESTRING writes the current YMDHMS date into a string. Arguments Type Intent Optional Attributes Name character(len=*) :: string","tags":"","loc":"module/m_logger.html"},{"title":"m_qsort – BROWNPAK","text":"Implements quicksort for a sequence of integers and reals, in combination with\n  insertion sort for very short sequences. Quick sort routine from Brainerd, W.S., Goldberg, C.H. & Adams, J.C. (1990)\n \"Programmer's Guide to Fortran 90\", McGraw-Hill  ISBN 0-07-000248-7, pages 149-150. Modified by Alan Miller to include an associated integer array which gives\n   the positions of the elements in the original order. Modified for integer array by Sarit Dutta Uses m_precision Contents Subroutines iqsort dqsort Subroutines public subroutine iqsort (list, order) Sorts a sequence of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), DIMENSION (:) :: list Sequence of integers to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence public subroutine dqsort (list, order) Sorts a sequence of reals Arguments Type Intent Optional Attributes Name real(kind=RP), intent(inout), DIMENSION (:) :: list Sequence of reals to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence","tags":"","loc":"module/m_qsort.html"},{"title":"m_config_io – BROWNPAK","text":"Routines for IO of config and dump files. Uses m_precision m_strings m_simbox m_globals Contents Subroutines read_dump write_dump read_config write_config write_ldf write_xyz Subroutines public subroutine read_dump (fn) Reads from DUMP file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine write_dump (fn) Writes to DUMP file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine read_config (fn) Read from CONFIG file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine write_config (fn, title) Write to cfg file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn character(len=*), intent(in) :: title public subroutine write_ldf (fn_ld, title, with_mpcd_atoms) Write to a LAMMPS data file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn_ld Name of the file character(len=*), intent(in) :: title Title of the configuation logical, intent(in), optional :: with_mpcd_atoms Include MPCD atoms in the file? {T, F} public subroutine write_xyz (fn_xyz, title, with_mpcd_atoms) Write to an XYZ file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn_xyz Name of the XYZ file character(len=*), intent(in) :: title Title (for the configuration) logical, intent(in), optional :: with_mpcd_atoms Include MPCD atoms in the file? {T, F}","tags":"","loc":"module/m_config_io.html"},{"title":"m_setup – BROWNPAK","text":"Routines for doing allocation, etc. in preparation for simulation run. Uses m_precision m_ran_num m_simbox m_globals m_config_io m_interaction m_bd_solver m_mpcd m_relax m_stats_io Contents Subroutines setup run config_clear finish Subroutines public subroutine setup () Arguments None public subroutine run () Arguments None public subroutine config_clear () Clears out all configuration related variables in module m_globals . Arguments None public subroutine finish () Arguments None","tags":"","loc":"module/m_setup.html"},{"title":"m_simbox – BROWNPAK","text":"Implements a simulation box with appropriate boundary conditions. Uses m_precision m_constants_math m_ran_num Contents Derived Types smbx_t Subroutines smbx_init smbx_set_basis smbx_freeze smbx_unfreeze smbx_get_image smbx_wrap_all smbx_to_center smbx_get_rnd_points Derived Types type, public :: smbx_t Components Type Visibility Attributes Name Initial real(kind=rp), public, dimension(3,3) :: basis real(kind=rp), public, dimension(3,3) :: dl_basis real(kind=rp), public :: volume logical, public :: is_deforming logical, public :: is_aligned Whether the basis vectors are aligned with the laboratory frame Type-Bound Procedures procedure, public :: set_basis => smbx_set_basis procedure, public :: freeze => smbx_freeze procedure, public :: unfreeze => smbx_unfreeze procedure, public :: get_image => smbx_get_image procedure, public :: wrap_all => smbx_wrap_all procedure, public :: to_center => smbx_to_center procedure, public :: get_rnd_points => smbx_get_rnd_points Subroutines public subroutine smbx_init (this) Creates an instance of smbx_t . Can also be called to reset. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(inout) :: this public subroutine smbx_set_basis (this, bv) Sets all three basis vectors. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(3,3) :: bv public subroutine smbx_freeze (this) Specifies this as non-deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this public subroutine smbx_unfreeze (this) Specifies this as deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this public subroutine smbx_get_image (this, r) Returns the image of r under PBC. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(3) :: r public subroutine smbx_wrap_all (this, coords) Wraps atom positions w.r.t. periodic boundary conditions. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords public subroutine smbx_to_center (this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the center \n of the box. Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com public subroutine smbx_get_rnd_points (this, coords) Returns uniformly distributed points within the box. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(out), dimension(:,:) :: coords","tags":"","loc":"module/m_simbox.html"},{"title":"m_mpcd – BROWNPAK","text":"Routines implementing the MPCD solver. Uses m_precision m_constants_math m_utils_math m_strings m_logger m_ran_num m_globals m_cell_list m_interaction m_stats_io m_config_io f95_precision lapack95 Contents Variables mass buf_aic Subroutines mpcd_init mpcd_finish mpcd_run mpcd_stream mpcd_collide Variables Type Visibility Attributes Name Initial real(kind=rp), private, dimension(:), allocatable :: mass (num_atoms_tot,) array. Stores mass of each atom (including MPCD\n atoms). The mass of each MPCD atom is taken as unity. real(kind=rp), private, dimension(:), allocatable :: buf_aic Buffer for atoms in cell storing mass, coordinates, & velocities.\n For nc atoms, the first nc elements stores the mass, the next 3*nc elements stores the coordinates, and the next 3*nc elements\n store the velocities. The velocities part of this buffer may be overwritten\n for relative velocity calculations. Subroutines public subroutine mpcd_init (ierr) Initializes the MPCD solver. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr public subroutine mpcd_finish () Clean up MPCD solver. Arguments None public subroutine mpcd_run () Driver for MPCD integrator. Read more… Arguments None private subroutine mpcd_stream (ierr) Performs one step of streaming. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine mpcd_collide () Performs one step of MPCD collision. Arguments None","tags":"","loc":"module/m_mpcd.html"},{"title":"m_bd_solver – BROWNPAK","text":"Routines implementing Brownian Dynamics (BD) solver. Uses iso_c_binding mkl_blas mkl_rci m_precision m_constants_math m_logger m_globals m_interaction m_brown m_stats_io m_config_io Contents Variables cntr_mobsam sqrt_two_dt nlmxitr lmxitr tol_res tol_upd atol rtol drift diffusion mob crd0 crdk fvalk fval rhs sol fgmres_tmp crdn h2 h3 pvcrd pvfrc Subroutines bds_init bds_finish bds_run integrate_em integrate_se se_calc_fval se_linsolve integrate_rk calc_diffusion calc_drift calc_rpy_tensor Variables Type Visibility Attributes Name Initial integer, private :: cntr_mobsam real(kind=rp), private :: sqrt_two_dt integer, private :: nlmxitr = 150 integer, private :: lmxitr = 150 real(kind=rp), private :: tol_res = 1.0e-6_rp real(kind=rp), private :: tol_upd = 1.0e-8_rp real(kind=rp), private :: atol = 0.0_rp real(kind=rp), private :: rtol = 1.0e-6_rp real(kind=rp), private, dimension(:  ), allocatable :: drift real(kind=rp), private, dimension(:,:), allocatable :: diffusion real(kind=rp), private, dimension(:,:), allocatable :: mob real(kind=rp), private, dimension(:), allocatable :: crd0 real(kind=rp), private, dimension(:), allocatable :: crdk real(kind=rp), private, dimension(:), allocatable :: fvalk real(kind=rp), private, dimension(:), allocatable :: fval real(kind=rp), private, dimension(:), allocatable :: rhs real(kind=rp), private, dimension(:), allocatable :: sol real(kind=rp), private, dimension(:), allocatable :: fgmres_tmp real(kind=rp), private, dimension(:), allocatable :: crdn real(kind=rp), private, dimension(:), allocatable :: h2 real(kind=rp), private, dimension(:), allocatable :: h3 real(kind=rp), private, dimension(:), pointer :: pvcrd real(kind=rp), private, dimension(:), pointer :: pvfrc Subroutines public subroutine bds_init (ierr) Initializes the BD solver. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr public subroutine bds_finish () Clears up memory allocated in bds_init . Arguments None public subroutine bds_run () Driver for BD integrator. Read more… Arguments None private subroutine integrate_em (ierr) Performs one step of BD integration using explicit Euler-Maruyama scheme. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine integrate_se (ierr) Performs one step of BD integration using semi-implicit Euler scheme. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine se_calc_fval (ierr) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine se_linsolve (lconv, itercount, ierr) Solves the linear system using fgmres. Arguments Type Intent Optional Attributes Name logical, intent(out) :: lconv integer, intent(out) :: itercount integer, intent(out) :: ierr private subroutine integrate_rk (ierr) Performs one step of BD integration using explicit RK scheme. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine calc_diffusion (ierr) Calculates the diffusion term of the SDE. Updates module variables diffusion and cntr_mobsam . Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine calc_drift (ierr) Calculates the drift term of the SDE. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine calc_rpy_tensor (mob) Calculates the RPY approximation to the mobility tensor. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:) :: mob (3 num_atoms , 3 num_atoms ) matrix; stores the mobility tensor.","tags":"","loc":"module/m_bd_solver.html"},{"title":"m_globals – BROWNPAK","text":"Global variables, primarily dealing with system configuration\n and simulation execution. Uses m_precision m_trajectory m_simbox m_logger Contents Variables mxrdln mxparam simbox imcon num_atom_types atom_names atom_styles atom_mass mpcd_avnc num_mpcd_atoms num_atoms num_atoms_tot atoms charge coordinates orientation velocities forces num_bond_types bond_styles bond_params num_bonds bonds num_angle_types angle_styles angle_params num_angles angles num_dihedral_types dihedral_styles dihedral_params num_dihedrals dihedrals num_branches branches num_molecule_types molecule_names molecule_pop num_molecules molecules molecule_com num_tether_types tether_styles tether_params num_tethers tethers tether_points num_vdw_types vdw_styles vdw_params vdw_pairs num_externals external_styles external_params flow_style flow_params sim_style leql lrevive tim_stp nts nts_md nts_log nts_dump nts_samp nts_eql nts_eql_samp nts_sim nts_mobsam use_verlet_tab use_aabbtree rcutoff tskin use_cell_list fn_cfg fn_revive fn_traj fn_stats traj job_tag read_seed write_seed write_traj traj_frmcmp traj_wmpcd stress stress_accu stress_slvnt energy_kin energy_bond energy_angle energy_dihedral energy_vdw energy_tether energy_external energy_tot bndlen bndlen_min bndlen_max excluded_atoms lvdw bdintg mob_fctr lanc_mxitr lanc_tol lhdia lelectrostatics Variables Type Visibility Attributes Name Initial integer, public, parameter :: mxrdln = 1024 Maximum length of character string for input line buffer. integer, public, parameter :: mxparam = 12 Maximum number of parameters for bonds, angles, etc. type( smbx_t ), public :: simbox Simulation box. integer, public :: imcon = 0 Flag specifying boundary conditions on the simulation box. imcon = 0 : Unbounded domain. While not explicitly enforced this \n    is useful only for a single molecule. The dynamics is performed in the \n    c.o.m. frame of reference. imcon = 1 : PBC along x , y , & z . There are no restrictions on\n    the number of molecules. integer, public :: num_atom_types = 0 Number of atom_type s character(len=8), public, dimension(:), allocatable :: atom_names ( num_atom_types ,) array. Name of atoms of each type. integer, public, dimension(:), allocatable :: atom_styles ( num_atom_types ,) array. Style of atoms of each type. real(kind=rp), public, dimension(:), allocatable :: atom_mass ( num_atom_types ,) array. Mass of atoms of each type. integer, public :: mpcd_avnc = 0 Average number of MPCD atoms per collision cell integer, public :: num_mpcd_atoms = 0 Number of MPCD atoms integer, public :: num_atoms = 0 Number of atoms (excluding MPCD atoms) integer, public :: num_atoms_tot = 0 Total number of atoms (includes MPCD atoms) integer, public, dimension(:), allocatable :: atoms ( num_atoms ,) array. For atom i , its type at = atoms(i) , with style atom_styles(at) , name atom_names(at) , mass atom_mass(at) , charge charge(i) , position coordinates(:,i) , velocity velocities(:,i) ,\n orientation (if the style requires) orientations(:,i) . The force acting on atom i is forces(:,i) . real(kind=rp), public, dimension(:), allocatable :: charge ( num_atoms ,) array. real(kind=rp), public, dimension(:,:), allocatable, target :: coordinates (3, num_atoms_tot ) array real(kind=rp), public, dimension(:,:), allocatable :: orientation (4, num_atoms ) array real(kind=rp), public, dimension(:,:), allocatable, target :: velocities (3, num_atoms_tot ) array. The first num_atoms columns stores\n velocities of non-MPCD atoms, the rest, i.e num_atoms+1 to num_atoms_tot , store velocities of MPCD atoms. real(kind=rp), public, dimension(:,:), allocatable, target :: forces (3, num_atoms_tot ) array integer, public :: num_bond_types = 0 Number of bond_type s integer, public, dimension(:), allocatable :: bond_styles ( num_bond_types ,) array. real(kind=rp), public, dimension(:,:), allocatable :: bond_params ( mxparam , num_bond_types ) array. integer, public :: num_bonds = 0 Total number of bonds. integer, public, dimension(:,:), allocatable :: bonds (3, num_bonds ) array. Bond i is of type bt = bonds(1,i) ,  directed from\n atom bonds(2,i) to bonds(3,i) . Its style is bond_styles(bt) with\n parameters bond_params(:,bt) . integer, public :: num_angle_types = 0 Number of angle_type s integer, public, dimension(:), allocatable :: angle_styles ( num_angle_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: angle_params ( mxparam , num_angle_types ) array integer, public :: num_angles = 0 Number of angles integer, public, dimension(:,:), allocatable :: angles (4, num_angles ) array. Angle i is of type ant = angles(1,i) , incident\n to atoms angles(2,i) , angles(3,i) , and angles(4,i) . Its style is angle_styles(ant) with parameters angle_params(:,ant) . integer, public :: num_dihedral_types = 0 Number of dihedral_type s integer, public, dimension(:), allocatable :: dihedral_styles ( num_dihedral_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: dihedral_params ( mxparam , num_dihedral_types ) array integer, public :: num_dihedrals = 0 Number of dihedrals integer, public, dimension(:,:), allocatable :: dihedrals (5, num_dihedrals ) array. Dihedral i is of type dt = dihedrals(1,i) , incident\n to atoms dihedrals(2,i) , dihedrals(3,i) , dihedrals(4,i) , and dihedrals(5,i) .\n Its style is dihedral_styles(dt) with parameters dihedral_params(:,dt) . integer, public :: num_branches = 0 Total number of branches (including the backbone) integer, public, dimension(:,:), allocatable :: branches (3, num_branches ) array. Branch i is tethered to atom branches(1,i) ,\n contains branches(2,i) atoms, with the beginning atom index branches(3,i) . integer, public :: num_molecule_types = 0 Number of molecule_type s character(len=8), public, dimension(:), allocatable :: molecule_names ( num_molecule_types ,) array integer, public, dimension(:), allocatable :: molecule_pop ( num_molecule_types ,) array integer, public :: num_molecules = 0 Number of molecules integer, public, dimension(:,:), allocatable :: molecules (9, num_molecules ) array. For molecule i , its type mt = molecules(1,i) , \n containing molecules(2,i) atoms with beginning index molecules(3,i) , molecules(4,i) bonds with beginning index molecules(5,i) , molecules(6,i) angles with beginning index molecules(7,i) , and molecules(8,i) dihedrals with beginning index molecules(9,i) . real(kind=rp), public, dimension(3) :: molecule_com = 0.0_rp Center of mass of the molecule. This is used only when imcon == 0, i.e.\n for a single molecule without periodic boundaries. integer, public :: num_tether_types = 0 Number of tether_type s integer, public, dimension(:), allocatable :: tether_styles ( num_tether_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: tether_params ( mxparam , num_tether_types ) array integer, public :: num_tethers = 0 Number of tethers integer, public, dimension(:,:), allocatable :: tethers (2, num_tethers ) array. Tether i is of type tt = tethers(1,i) , tethering\n atom tethers(2,i) to a point tether_points(:,i) .\n Its style is tether_styles(tt) with parameters tether_params(:,tt) . real(kind=rp), public, dimension(:,:), allocatable :: tether_points (3, num_tethers ) array integer, public :: num_vdw_types = 0 Number of vdw_type s integer, public, dimension(:), allocatable :: vdw_styles ( num_vdw_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: vdw_params ( mxparam , num_vdw_types ) array integer, public, dimension(:,:), allocatable :: vdw_pairs (2, num_vdw_types ) array. Stores atom type of interacting pairs, such\n that at_i >= at_j. integer, public :: num_externals = 0 Number of external fields integer, public, dimension(:), allocatable :: external_styles ( num_external ,) array real(kind=rp), public, dimension(:,:), allocatable :: external_params ( mxparam , num_external ) array integer, public :: flow_style = 0 real(kind=rp), public, dimension(:), allocatable :: flow_params ( mxparam ,) array integer, public :: sim_style = 1 '0': Structure relaxation, '1' : Brownian dynamics, '2' : MPCD logical, public :: leql = .true. Is the system equilibrating? {T, F} logical, public :: lrevive = .false. Is this a restart run? {T, F}. real(kind=rp), public :: tim_stp BD/MPCD time step size integer(kind=ip_long), public :: nts Counter for BD/MPCD time steps integer(kind=ip), public :: nts_md = 1 Number of MD steps per MPCD step integer(kind=ip_long), public :: nts_log = 1 Interval for logging (in BD time steps) integer(kind=ip_long), public :: nts_dump = 1 Interval for dumping to revive file (in BD time steps) integer(kind=ip_long), public :: nts_samp = 1 Interval for sampling statistics (in BD time steps) integer(kind=ip_long), public :: nts_eql = 0 Number of BD time steps for equilibration integer(kind=ip_long), public :: nts_eql_samp = 1 Sampling interval during equilibration (in BD time steps) integer(kind=ip_long), public :: nts_sim = 0 Total number of BD time steps in production run integer(kind=ip), public :: nts_mobsam = 1 Number of time steps for which the same mobility tensor is used for BD\n with HI. If nts_mobsam == 1 , mobility is updated every step. logical, public :: use_verlet_tab = .false. Use Verlet neighbor table? {T, F} logical, public :: use_aabbtree = .false. Use AABB tree for pairwise interactions? {T, F} real(kind=rp), public :: rcutoff = 0.0_rp Cut off for short-ranged interaction. Also used as the radius of the\n skin sphere for short-ranged forces real(kind=rp), public :: tskin = 0.0_rp Thickness of the skin sphere (same for all) logical, public :: use_cell_list = .false. Use cell list for short-range interactions? {T, F} character(len=:), public, allocatable :: fn_cfg Name of the file containing the initial configuration character(len=:), public, allocatable :: fn_revive Name of the revive file character(len=:), public, allocatable :: fn_traj Name of the trajectory file character(len=:), public, allocatable :: fn_stats Name of the statistics file type( trajectory_t ), public :: traj Trajectory object character(len=8), public :: job_tag = '' A tag useful for array jobs, available only as a command line argument logical, public :: read_seed = .false. {T, F} Whether to initialize the random number generator by reading a seed from\n a file. If read_seed == T, the seed will be read from a file\n 'random_seed.txt' logical, public :: write_seed = .false. {T, F} Whether to write the random number generator seed. If write_seed == T the seed will be written to a file named\n  'random_seed.txt' logical, public :: write_traj = .false. Should the trajectory be written to file? {T, F} integer, public, dimension(4) :: traj_frmcmp = 0 Control for what gets written to a trajectory frame.\n 1: coordinates; 2: velocities; 3: forces; 4: charge logical, public :: traj_wmpcd = .false. Depending on the values in traj_frmcmp , whether the corresponding\n quantities for the MPCD atoms are written as well. real(kind=rp), public, dimension(3,3) :: stress = 0.0_rp Stress tensor due to non-MPCD atoms real(kind=rp), public, dimension(3,3) :: stress_accu = 0.0_rp Stress tensor accumulator due to non-MPCD atoms real(kind=rp), public, dimension(3,3) :: stress_slvnt = 0.0_rp Stress tensor due to MPCD atoms (solvent) real(kind=rp), public :: energy_kin = 0.0_rp Kinetic energy real(kind=rp), public :: energy_bond = 0.0_rp Bond energy real(kind=rp), public :: energy_angle = 0.0_rp Angle energy real(kind=rp), public :: energy_dihedral = 0.0_rp Dihedral energy real(kind=rp), public :: energy_vdw = 0.0_rp vdw interaction energy real(kind=rp), public :: energy_tether = 0.0_rp Energetic contribution from tethers real(kind=rp), public :: energy_external = 0.0_rp Energetic contribution from external fields real(kind=rp), public :: energy_tot = 0.0_rp Total energy real(kind=rp), public :: bndlen = 0.0_rp Average bond length real(kind=rp), public :: bndlen_min = 0.0_rp Minimum bond length real(kind=rp), public :: bndlen_max = 0.0_rp Maximum bond length integer, public :: excluded_atoms = 0 Control for excluded atoms in vdw calculation.\n 0: No exclusion, 1: exclude 1-ring bonded neighbors,\n 2: exclude 2-ring bonded neighbors, 3: exclude 3-ring bonded neighbors. logical, public :: lvdw = .true. Whether to calculate VDW interactions character(len=4), public :: bdintg Integration method {'EM', 'SE', 'RK'} character(len=4), public :: mob_fctr Factorization method for mobility matrix {'CHOL', 'LANC'} integer, public :: lanc_mxitr Maximum number of iterations for Lanczos algorithm real(kind=rp), public :: lanc_tol = 1.0e-3_rp Error tolerance for Lanczos algorithm logical, public :: lhdia = .true. Whether to include hydrodynamic interactions in BD logical, public :: lelectrostatics = .false. Whether to calculate electrostatic interactions","tags":"","loc":"module/m_globals.html"},{"title":"m_control_io – BROWNPAK","text":"Routines for reading and witing control file. Uses m_precision m_strings m_globals Contents Subroutines read_control write_control Subroutines public subroutine read_control (fn) Reads simulation parameters from file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Name of parameters file. public subroutine write_control (fn) Write simulation parameters to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn File name","tags":"","loc":"module/m_control_io.html"},{"title":"m_utils_math – BROWNPAK","text":"Various (mostly linear algebra) functions, particularly for use with small\nmatrices. Uses ieee_arithmetic m_constants_math m_precision Contents Interfaces allclose swap Functions scalar_triple_product det trace isclose allclose_rank1 allclose_rank2 allclose_rank3 get_quad_form Subroutines rad2deg deg2rad cross cross_mat outer vector_triple_product swap_integer swap_real swap_complex unitize linspace logspace identity get_diagonal add_transpose subtract_transpose multiply_transpose orth invert_mat33 eigval_33rsym dsyevc3 Interfaces public interface allclose Checks if two arrays are elementwise close within tolerance public function allclose_rank1 (a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank2 (a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank3 (a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public interface swap Swaps two arrays public elemental subroutine swap_integer (a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b public elemental subroutine swap_real (a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b public elemental subroutine swap_complex (a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b Functions public function scalar_triple_product (a, b, c) result(res) Returns the scalar triple product a .( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c Return Value real(kind=rp) public function det (A) result(res) Returns the determinant of an (N x N) matrix, where N = 2, 3, or 4. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (N,N) array, where N = 2, 3, or 4. Return Value real(kind=rp) public function trace (mat) result(res) Returns the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mat (:,:) (N,N) array Return Value real(kind=rp) public elemental function isclose (a, b, rel_tol, abs_tol) Checks if two floating point numbers of type double are close within\n  tolerance. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b real(kind=rp), intent(in), optional :: rel_tol Relative tolerance, rel_tol >= 0, default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance, abs_tol >= 0, default 0.0 Return Value logical public function allclose_rank1 (a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank2 (a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank3 (a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function get_quad_form (A, x) result(res) Calculates the quadratic form x&#94;T A x , where A is an n x n matrix and x is a\n  vector of length n Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (n,n) array real(kind=rp), intent(in), dimension(:) :: x (n,) array Return Value real(kind=rp) Subroutines public elemental subroutine rad2deg (rad, deg) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rad real(kind=rp), intent(out) :: deg public elemental subroutine deg2rad (deg, rad) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: deg real(kind=rp), intent(out) :: rad public subroutine cross (a, b, c) Calculates the cross product between two 3-element vectors Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(out), dimension(3) :: c Cross product of a and b ; c = a x b public subroutine cross_mat (a, mat) Calculates the cross product matrix of a 3-element vector. The cross\n product matrix A of a is defined as a x b = A . b ,\n where b is another 3-element vector. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(out), dimension(3,3) :: mat Cross product matrix of a public subroutine outer (a, b, c) Calculates the outer product of two vectors, . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (n,) array real(kind=rp), intent(out), dimension(:,:) :: c (m,n) array; Outer product public subroutine vector_triple_product (a, b, c, d) Returns the vector triple product d = a x ( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c real(kind=rp), intent(out), dimension(3) :: d Vector triple product public elemental subroutine swap_integer (a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b public elemental subroutine swap_real (a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b public elemental subroutine swap_complex (a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b public subroutine unitize (a) Normalizes a vector in-place. If the magnitude of the vector is nearly\n zero, no normalization takes place and the vector is returned as is with\n a warning message. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: a (m,) array public subroutine linspace (start, finish, num, val, step) Generates evenly spaced numbers over a specified interval. Both end\n points are included. If start < finish , the returned step size (if step is present) will be negative. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point real(kind=rp), intent(in) :: finish Ending point, finish /= start integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(out), optional :: step Step size public subroutine logspace (start, finish, num, val, base) Generates numbers spaced evenly on a log scale.\n  In linear space, the sequence starts at base ** start ( base to the power of start ) and ends with base ** stop Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point, base ** start is the starting value real(kind=rp), intent(in) :: finish Ending point, finish /= start , base ** start is the ending value integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(in), optional :: base Base of the logspace, default 10 public subroutine identity (mat_eye) Creates an identity matrix of size n x n. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:) :: mat_eye (n,n) array public subroutine get_diagonal (mat, d) Returns the diagonal elements of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mat (n,n) array real(kind=rp), intent(out), dimension(:) :: d (n,) array; contains the entries of the main diagonal public subroutine add_transpose (mat) Adds a square matrix and its transpose in place: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat (n,n) array public subroutine subtract_transpose (mat) Calculates the difference of a square matrix and its transpose in place: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat public subroutine multiply_transpose (A, B) Multiplies a matrix with its transpose: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (m,n) array real(kind=rp), intent(out), dimension(:,:) :: B (m,m) array public subroutine orth (a) Orthogonalizes a set of vectors in-place using Gram-Schmidt orthonormalization Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: a (m,n) array, where m <= n. The first m columns of the matrix are\n  overwritten with the orthogonal basis vectors. public subroutine invert_mat33 (a, inv_a) Inverts a 3x3 matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3,3) :: inv_a public subroutine eigval_33rsym (a, ev) Calculates the eigenvalues of a 3 x 3 real symmetric matrix. The\n eigenvalues calculated are in decreasing order. Only the diagonal and\n lower triangular part of the matrix is accessed. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3) :: ev public subroutine dsyevc3 (A, W) Author Joachim Kopp Date 2006 Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's\n analytical algorithm.\n Only the diagonal and upper triangular parts of A are accessed. The access\n is read-only. Read more… Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), DIMENSION(3,3) :: A real(kind=RP), intent(out), DIMENSION(3) :: W (3)","tags":"","loc":"module/m_utils_math.html"},{"title":"m_ia_vdw – BROWNPAK","text":"Routines to evaulate pairwise potentials and their derivative. The following styles are available: Style 1. 12-6 LJ. See vdw_lj_set . Style 2. Gaussian. See vdw_gaussian_set . Style 3. Cosine. See vdw_cosine_set . Style 4. Screened Coulomb + LJ. See vdw_lj_coul_debye_set . Style 5. Coulomb + LJ. See vdw_lj_coul_set . Style 6. Standard DPD. See vdw_dpd_set . Uses m_precision m_constants_math m_globals Contents Subroutines ia_vdw_setup ia_get_vdw_force vdw_lj_set vdw_lj vdw_gaussian_set vdw_gaussian vdw_cosine_set vdw_cosine vdw_lj_coul_debye_set vdw_lj_coul_debye vdw_lj_coul_set vdw_lj_coul vdw_dpd_set vdw_dpd Subroutines public subroutine ia_vdw_setup () Sets up parameters for vdw potentials Arguments None public subroutine ia_get_vdw_force (rij_mag, qi, qj, typ, enrg, frc, ierr) Calculates the energy & its derivative due to a single interacting pair of atoms. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between two atoms real(kind=rp), intent(in) :: qi Charge on atom i real(kind=rp), intent(in) :: qj Charge on atom j integer, intent(in) :: typ Type of vdw interaction real(kind=rp), intent(out) :: enrg Energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of force due to\n this potential. integer, intent(out) :: ierr Error flag private subroutine vdw_lj_set (params, eps, sigma, rcut) Setter for 12-6 LJ (truncated & force-shifted) interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut private pure subroutine vdw_lj (r, params, enrg, frc) Evaluates the potential and its derivative for LJ interaction. See vdw_lj_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_gaussian_set (params, A, B, rcut) Setter for gaussian interaction. The potential is truncated and\n force-shifted. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: B real(kind=rp), intent(in), optional :: rcut private pure subroutine vdw_gaussian (r, params, enrg, frc) Calculates energy & its derivative for gaussian interaction. See vdw_gaussian_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_cosine_set (params, A, rcut) Setter for cosine interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: rcut private pure subroutine vdw_cosine (r, params, enrg, frc) Evaluates the potential and its derivative for  cosine interaction.\n See vdw_cosine_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_lj_coul_debye_set (params, eps, sigma, rcut, rcut_coul, C, kappa) Setter for 12-6 LJ with screened Coulombic interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C real(kind=rp), intent(in), optional :: kappa private pure subroutine vdw_lj_coul_debye (r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for screened Coulombic interaction\ncombined with 12-6 LJ (cut & shifted). See vdw_lj_coul_debye_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_lj_coul_set (params, eps, sigma, rcut, rcut_coul, C) Setter for 12-6 LJ with Coulombic interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C private pure subroutine vdw_lj_coul (r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for Coulombic interaction\n combined with 12-6 LJ (cut & shifted). See vdw_lj_coul_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_dpd_set (params, A, rcut) Setter for standard DPD interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: rcut private pure subroutine vdw_dpd (r, params, enrg, frc) Evaluates the potential and its derivative for standard DPD interaction.\n See vdw_dpd_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc","tags":"","loc":"module/m_ia_vdw.html"},{"title":"m_precision – BROWNPAK","text":"Uses iso_fortran_env Contents Variables ip ip_long rp sizeof_char sizeof_int sizeof_long_int sizeof_real Variables Type Visibility Attributes Name Initial integer, public, parameter :: ip = int32 Default integer precision integer, public, parameter :: ip_long = int64 Default long integer precision integer, public, parameter :: rp = real64 Default real precision integer, public, parameter :: sizeof_char = 1 Size of a char in bytes integer, public, parameter :: sizeof_int = 4 Size of a default int in bytes integer, public, parameter :: sizeof_long_int = 8 Size of a default long int in bytes integer, public, parameter :: sizeof_real = 8 Size of a default real in bytes","tags":"","loc":"module/m_precision.html"},{"title":"m_trajectory – BROWNPAK","text":"Routines for reading and writing frames from a trajectory file. Uses m_precision Contents Derived Types trajectory_t Subroutines traj_create traj_open traj_clear traj_close traj_read traj_append_frame traj_write_frame Derived Types type, public :: trajectory_t Components Type Visibility Attributes Name Initial integer, public :: header_size = 0 integer, public :: frame_size = 0 integer, public :: num_atoms = 0 integer, public :: num_mpcd_atoms = 0 integer, public :: num_atoms_tot = 0 integer, public, dimension(4) :: frmcmp = 0 character(len=:), public, allocatable :: fn integer, public :: file_id = 0 integer, public :: num_frames = 0 logical, public :: isopen = .false. Type-Bound Procedures procedure, public :: create => traj_create procedure, public :: open => traj_open procedure, public :: clear => traj_clear procedure, public :: close => traj_close procedure, public :: read => traj_read procedure, public :: append_frame => traj_append_frame procedure, public :: write_frame => traj_write_frame generic, public :: init => create, open Subroutines public subroutine traj_create (this, fn, na, nam, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of non-MPCD atoms integer, intent(in) :: nam Number of MPCD atoms, pass zero to indicate no data from MPCD\n particles are present. integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges public subroutine traj_open (this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr public subroutine traj_clear (this) After a call to this subroutine, all memory within this is deallocated,\n all components of this are reset to zero, and the underlying file is\n closed (if open). Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this public subroutine traj_close (this) Closes the underlying file of a trajectory_t . Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this public subroutine traj_read (this, iframe, nts, ierr, mflag, coordinates, velocities, forces, charge) Read from an open trajectory. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(in) :: this integer, intent(in) :: iframe Frame number integer(kind=ip_long), intent(out) :: nts Time step counter integer, intent(out) :: ierr Error flag integer, intent(in), optional :: mflag 1: Only non-MPCD data, 2: Only MPCD data, 3: All data real(kind=rp), intent(out), optional dimension(:,:) :: coordinates real(kind=rp), intent(out), optional dimension(:,:) :: velocities real(kind=rp), intent(out), optional dimension(:,:) :: forces real(kind=rp), intent(out), optional dimension(:) :: charge public subroutine traj_append_frame (this, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge public subroutine traj_write_frame (this, iframe, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer, intent(in) :: iframe integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge","tags":"","loc":"module/m_trajectory.html"},{"title":"m_aabbtree – BROWNPAK","text":"Uses m_precision m_strings m_vector m_aabb Used by Descendants: sm_aabbtree Contents Variables NULL_NODE stack Interfaces node_isleaf node_asstr get_num_atoms get_aabb get_height get_max_balance get_srfarea_ratio balance calc_height fs_acquire node_init init print clear delete insert remove remove_all update_fatm update_fatmaabb query_watm query_watmaabb query_waabb rebuild validate insert_leaf remove_leaf fs_return validate_structure validate_metrics Derived Types node_t aabbtree_t Variables Type Visibility Attributes Name Initial integer, private, parameter :: NULL_NODE = 0 type( ivector_t ), private :: stack Interfaces interface private module function node_isleaf(this) result(res) Implementation → Is this a leaf node? Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. Return Value logical true if this is a leaf node, false otherwise. interface private module function node_asstr(this, frmt) result(buf) Implementation → Returns a string representation of a node. Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this A node_t instance. character(len=*), intent(in), optional :: frmt Format string for real numbers, e.g. '(f15.6)'. Default: (g0.6) . Return Value character(len=:),\n  allocatable Return value interface private module function get_num_atoms(this) result(na) Implementation → Returns the number of atoms in an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value interface private module function get_aabb(this, ia) result(aabb) Implementation → Returns a copy of the AABB associated with atom with index ia . Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. Return Value type( aabb_t ) AABB of atom ia . interface private module function get_height(this) result(height) Implementation → Returns the height of an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. interface private module function get_max_balance(this) result(max_balance) Implementation → Returns the maximum difference between the height of two children\n of a node. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value integer Return value. interface private module function get_srfarea_ratio(this) result(saratio) Implementation → Returns the ratio of the sum of the node surface area to the surface\n area of the root node. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. Return Value real(kind=rp) Return value. interface private module function balance(this, p) result(q) Implementation → Balances an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node index Return Value integer interface private recursive module function calc_height(this, p) result(height) Implementation → Calculates the height of a subtree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default: Root of the whole\n tree. Return Value integer Return value interface private module function fs_acquire(this) result(p) Implementation → Acquires a new node from the free store and returns a pointer to it. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. Return Value integer Return value interface private module subroutine node_init(this) Implementation → Initializes a node. Arguments Type Intent Optional Attributes Name class( node_t ), intent(out) :: this A node_t instance. interface private module subroutine init(this, natoms, tskin) Implementation → Initializes an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(out) :: this An aabbtree_t instance. integer, intent(in) :: natoms Estimated number of atoms to be handled by this tree. real(kind=rp), intent(in) :: tskin Thickness of the skin for fattened AABBs, as a fraction of the\n AABB base length. interface private recursive module subroutine print(this, p) Implementation → Prints a subtree of an AABB tree rooted at p in order. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in), optional :: p Pointer to the root of the subtree. Default is the root of the\n whole tree. interface private module subroutine clear(this) Implementation → Clears an AABB tree. Associated memory is not deallocated. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. interface private module subroutine delete(this) Implementation → Deletes an AABB tree. All associated memory is deallocated. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. interface private module subroutine insert(this, ia, pos, radius) Implementation → Inserts an atom into an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) interface private module subroutine remove(this, ia) Implementation → Removes an atom from an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index interface private module subroutine remove_all(this) Implementation → Removes all atoms from an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. interface private module subroutine update_fatm(this, ia, pos, radius, lstat) Implementation → Updates an AABB tree for the case when an atom leaves its fattened\n AABB. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: pos Atom position real(kind=rp), intent(in) :: radius Atom radius (or cutoff distance for point particles) logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. interface private module subroutine update_fatmaabb(this, ia, lbnd, ubnd, lstat) Implementation → Updates an AABB tree for the case when an atom leaves its fattened\n AABB, with the bounds of the new AABB for the atom as input. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index real(kind=rp), intent(in), dimension(3) :: lbnd Lower bound of atom AABB real(kind=rp), intent(in), dimension(3) :: ubnd Upper bound of atom AABB logical, intent(out) :: lstat true if the atom was reinserted, false otherwise. interface private module subroutine query_watm(this, ia, nbrs) Implementation → Query an AABB tree for a set of potential neighbors of an atom. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. interface private module subroutine query_watmaabb(this, ia, aabb, nbrs) Implementation → Query an AABB tree for a set of potential neighbors of an atom & its\n bounding AABB. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: ia Atom index. type( aabb_t ), intent(in) :: aabb Bounding AABB for atom with index ia . type( ivector_t ), intent(inout) :: nbrs List of potential neighbors. interface private module subroutine query_waabb(this, aabb, atms) Implementation → Query an AABB tree for the set of atoms whose AABBS overlap with aabb . Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. type( aabb_t ), intent(in) :: aabb An aabb_t instance. type( ivector_t ), intent(inout) :: atms List of potential neighbors. interface private module subroutine rebuild(this) Implementation → Rebuilds an optimal AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. interface private module subroutine validate(this) Implementation → Validates an AABB tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. interface private module subroutine insert_leaf(this, leaf) Implementation → Inserts a leaf node into a tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node interface private module subroutine remove_leaf(this, leaf) Implementation → Removes a leaf node from a tree. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: leaf Pointer to a leaf node interface private module subroutine fs_return(this, p) Implementation → Returns a node to the free store. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this An aabbtree_t instance. integer, intent(in) :: p Node pointer. interface private recursive module subroutine validate_structure(this, p) Implementation → Asserts that an AABB subtree has a valid structure. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. interface private recursive module subroutine validate_metrics(this, p) Implementation → Asserts that an AABB subtree has a valid metric. Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this An aabbtree_t instance. integer, intent(in) :: p Pointer to the root of the subtree. Derived Types type, private :: node_t Components Type Visibility Attributes Name Initial integer, public :: next = NULL_NODE integer, public :: parent = NULL_NODE integer, public :: left = NULL_NODE integer, public :: right = NULL_NODE integer, public :: height = -1 integer, public :: atom = 0 type( aabb_t ), public :: aabb Type-Bound Procedures procedure, public :: init => node_init procedure, public :: isleaf => node_isleaf procedure, public :: asstr => node_asstr type, public :: aabbtree_t Components Type Visibility Attributes Name Initial type( node_t ), public, dimension(:), allocatable :: nodes integer, public, dimension(:), allocatable :: atnd_tab Atom -> node map. integer, public :: capacity Maximum number of nodes that the tree can currently handle. This may\n increase as more atoms are inserted. integer, public :: freestore Pointer to head to the free store. integer, public :: size Number of nodes in the tree. integer, public :: root Pointer to the tree root. real(kind=rp), public :: tskin Thickness of the skin for fattened AABBs, as a fraction of the AABB\n base length. Type-Bound Procedures procedure, public :: init procedure, public :: print procedure, public :: clear procedure, public :: delete procedure, public :: insert procedure, public :: remove procedure, public :: remove_all procedure, public :: update_fatm procedure, public :: update_fatmaabb generic, public :: update => update_fatm, update_fatmaabb procedure, public :: query_watm procedure, public :: query_waabb procedure, public :: query_watmaabb generic, public :: query => query_watm, query_waabb, query_watmaabb procedure, public :: get_num_atoms procedure, public :: get_aabb procedure, public :: get_height procedure, public :: get_max_balance procedure, public :: get_srfarea_ratio procedure, public :: rebuild procedure, public :: validate procedure, private :: insert_leaf procedure, private :: remove_leaf procedure, private :: balance procedure, private :: calc_height procedure, private :: fs_acquire procedure, private :: fs_return procedure, private :: validate_structure procedure, private :: validate_metrics","tags":"","loc":"module/m_aabbtree.html"},{"title":"m_ia_tether – BROWNPAK","text":"Tether potentials Style 0: None Style 1: Rigid connector (not implemented)\n *Style 2: Harmonic spring. See teth_harm_set . Uses m_precision m_constants_math m_globals Contents Subroutines ia_tether_setup ia_get_tether_force teth_rigid_set teth_rigid teth_harm_set teth_harm Subroutines public subroutine ia_tether_setup () Sets up parameters for tether potentials Arguments None public subroutine ia_get_tether_force (qmag, teth_typ, enrg, frc, ierr) Calculates the energy and its derivative due to a tether. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: qmag Distance between the tethered atom & the tether point integer, intent(in) :: teth_typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr private subroutine teth_rigid_set (params, r0, eps) Setter for rigid tether interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: r0 real(kind=rp), intent(in), optional :: eps private subroutine teth_rigid (r, params, enrg, frc, ierr) Not implemented, needs constraint formalism. See teth_rigid_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr private subroutine teth_harm_set (params, k, r0) Setter for harmonic tether interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 private subroutine teth_harm (r, params, enrg, frc) Calculates energy and its derivative for harmonic tether interaction. See teth_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc","tags":"","loc":"module/m_ia_tether.html"},{"title":"m_verlet – BROWNPAK","text":"Routines for building Verlet neighbor table. Uses m_precision m_vector m_table m_globals Contents Variables verlet_tab coordinates_save coordinates_dr rskin_sq tskin_sq Subroutines verlet_init verlet_delete verlet_build Variables Type Visibility Attributes Name Initial type( itable_t ), public :: verlet_tab Verlet table real(kind=rp), private, dimension(:,:), allocatable :: coordinates_save (3, num_atoms ) array real(kind=rp), private, dimension(:,:), allocatable :: coordinates_dr (3, num_atoms ) array real(kind=rp), private :: rskin_sq = 0.0_rp real(kind=rp), private :: tskin_sq = 0.0_rp Subroutines public subroutine verlet_init (rskin, tskin) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rskin real(kind=rp), intent(in) :: tskin public subroutine verlet_delete () Arguments None public subroutine verlet_build () Arguments None","tags":"","loc":"module/m_verlet.html"},{"title":"m_ran_num – BROWNPAK","text":"Provides random number generation procedures, mostly calling\n routine from Intel MKL VSL. Uses m_precision mkl_vsl_type mkl_vsl Contents Variables seed stream Functions get_uniform get_iuniform Subroutines init_stream delete_stream load_stream save_seed save_stream get_rv_uniform get_rv_iuniform get_rv_gaussian ransphere Variables Type Visibility Attributes Name Initial integer(kind=ip), private, save :: seed type(VSL_STREAM_STATE), private, save :: stream Functions public function get_uniform (lb, ub) result(res) Returns a random number from a uniform distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound Return Value real(kind=rp) public function get_iuniform (lb, ub) result(res) Returns a random integer from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub Return Value integer(kind=ip) Subroutines public subroutine init_stream (fn) Initializes a BRNG stream. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: fn Name of the file containing the RNG seed. public subroutine delete_stream () Deletes a BRNG stream. Arguments None public subroutine load_stream (fn) Loads a BRNG stream from file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine save_seed (fn) Saves the RNG seed to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine save_stream (fn) Saves a BRNG stream to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine get_rv_uniform (lb, ub, rv, block_size) Returns a random vector from a uniform distribution. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size public subroutine get_rv_iuniform (lb, ub, rv, block_size) Returns a random vector of integers from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub integer(kind=ip), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size public subroutine get_rv_gaussian (mean, std_dev, rv, block_size) Generates a random vector of integers from a gaussian distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: std_dev real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size public subroutine ransphere (r) Generates a random vector from the surface of a unit sphere. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(3) :: r (3)","tags":"","loc":"module/m_ran_num.html"},{"title":"m_ia_external – BROWNPAK","text":"External potentials This module is meant to be a placeholder to any external fields that the user\n wants to add. Accordingly replace/add to the existing routines. The\n subroutines ia_external_setup and ia_add_external_forces must remain\n for interfacing to the force calculation driver routine ia_calc_forces . Style 0: None Style 1: Pulling force along +ve x-axis Style 2: Hard planar wall Uses m_precision m_constants_math m_globals Contents Subroutines ia_external_setup ia_add_external_forces Subroutines public subroutine ia_external_setup () Sets up parameters for external potentials. Usually there is nothing to\n set for externals, but this acts as a placeholder for special cases. Arguments None public subroutine ia_add_external_forces (ierr) Calculates the force and energy due to an external field and adds to energy_external , 'forces , & stress in module m_globals`. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr","tags":"","loc":"module/m_ia_external.html"},{"title":"m_relax – BROWNPAK","text":"Performs structure relaxation (energy minimization) using steepest descent. Atom positions evolve following the gradient direction, in steps of size tim_stp . If tim_stp is too large, bond constraints are likely to be\n violated. If MPCD atoms are present, they do not take part in structure relaxation. Uses m_precision m_ran_num m_strings m_globals m_interaction m_stats_io m_config_io Contents Subroutines rlx_run rlx_integrate Subroutines public subroutine rlx_run () Driver for relaxation Arguments None private subroutine rlx_integrate (ierr, zf) Performs one step of relaxation Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr logical, intent(out) :: zf","tags":"","loc":"module/m_relax.html"},{"title":"m_ia_bond – BROWNPAK","text":"This module contains routines to evaluate bond potentials and their\n derivative. The following styles are available: Style 0. None (only topology) Style 1. Harmonic. See bond_harm_set . Style 2. FENE. See bond_fene_set . Style 3. Kremer-Grest. See bond_kg_set . Style 4. Marko-Siggia. See bond_ms_set . Uses m_precision m_constants_math m_strings m_globals m_logger Contents Subroutines ia_bond_setup ia_get_bond_force bond_harm_set bond_harm bond_fene_set bond_fene bond_kg_set bond_kg bond_ms_set bond_ms Subroutines public subroutine ia_bond_setup () Sets up parameters for bond potentials Arguments None public subroutine ia_get_bond_force (rij_mag, bnd_typ, enrg, frc, ierr) Calculates the energy & its derivative due to a bond. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between bonded atoms integer, intent(in) :: bnd_typ Type of the bond real(kind=rp), intent(out) :: enrg Bond energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of the force due\n to this potential. integer, intent(out) :: ierr Error flag private subroutine bond_harm_set (params, k, r0) Setter for harmonic bond interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 private subroutine bond_harm (r, params, enrg, frc) Calculates energy & its derivative for harmonic bond. See bond_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine bond_fene_set (params, k, rmax, r0) Setter for FENE bond. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: r0 private subroutine bond_fene (r, params, enrg, frc, ierr) Calculates energy & its derivative for FENE bond. See bond_fene_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr private subroutine bond_kg_set (params, k, rmax, eps, sigma) Setter for FENE bond interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma private subroutine bond_kg (r, params, enrg, frc, ierr) Calculates energy & its derivative for Kremer-Grest bond. See bond_kg_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr private subroutine bond_ms_set (params, lp, rmax) Setter for Marko-Siggia bond. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: lp real(kind=rp), intent(in), optional :: rmax private subroutine bond_ms (r, params, enrg, frc, ierr) Evaluates the potential & its derivative for Marko-Siggia bond.\n See bond_ms_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr","tags":"","loc":"module/m_ia_bond.html"},{"title":"sm_aabbtree – BROWNPAK","text":"Uses Ancestors: m_aabbtree Contents Module Functions node_isleaf node_asstr get_num_atoms get_aabb get_height get_max_balance get_srfarea_ratio balance calc_height fs_acquire Module Subroutines node_init init print clear delete insert remove remove_all update_fatm update_fatmaabb query_watm query_watmaabb query_waabb rebuild validate insert_leaf remove_leaf fs_return validate_structure validate_metrics Module Functions module function node_isleaf (this) result(res) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this Return Value logical module function node_asstr (this, frmt) result(buf) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: this character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable module function get_num_atoms (this) result(na) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer module function get_aabb (this, ia) result(aabb) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia Return Value type( aabb_t ) module function get_height (this) result(height) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer module function get_max_balance (this) result(max_balance) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value integer module function get_srfarea_ratio (this) result(saratio) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this Return Value real(kind=rp) module function balance (this, p) result(q) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: p Return Value integer recursive module function calc_height (this, p) result(height) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in), optional :: p Return Value integer module function fs_acquire (this) result(p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this Return Value integer Module Subroutines module subroutine node_init (this) Interface → Arguments Type Intent Optional Attributes Name class( node_t ), intent(out) :: this module subroutine init (this, natoms, tskin) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(out) :: this integer, intent(in) :: natoms real(kind=rp), intent(in) :: tskin recursive module subroutine print (this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in), optional :: p module subroutine clear (this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this module subroutine delete (this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this module subroutine insert (this, ia, pos, radius) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: pos real(kind=rp), intent(in) :: radius module subroutine remove (this, ia) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia module subroutine remove_all (this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this module subroutine update_fatm (this, ia, pos, radius, lstat) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: pos real(kind=rp), intent(in) :: radius logical, intent(out) :: lstat module subroutine update_fatmaabb (this, ia, lbnd, ubnd, lstat) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: ia real(kind=rp), intent(in), dimension(3) :: lbnd real(kind=rp), intent(in), dimension(3) :: ubnd logical, intent(out) :: lstat module subroutine query_watm (this, ia, nbrs) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia type( ivector_t ), intent(inout) :: nbrs module subroutine query_watmaabb (this, ia, aabb, nbrs) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: ia type( aabb_t ), intent(in) :: aabb type( ivector_t ), intent(inout) :: nbrs module subroutine query_waabb (this, aabb, atms) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this type( aabb_t ), intent(in) :: aabb type( ivector_t ), intent(inout) :: atms module subroutine rebuild (this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this module subroutine validate (this) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this module subroutine insert_leaf (this, leaf) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: leaf module subroutine remove_leaf (this, leaf) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: leaf module subroutine fs_return (this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(inout) :: this integer, intent(in) :: p recursive module subroutine validate_structure (this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: p recursive module subroutine validate_metrics (this, p) Interface → Arguments Type Intent Optional Attributes Name class( aabbtree_t ), intent(in) :: this integer, intent(in) :: p","tags":"","loc":"module/sm_aabbtree.html"},{"title":"main – BROWNPAK","text":"Uses m_precision m_strings m_logger m_globals m_control_io m_setup Contents Variables cla key val fn_control msg ierr icla ncla ccbeg ccend crate Variables Type Attributes Name Initial character(len=64) :: cla character(len=:), allocatable :: key character(len=:), allocatable :: val character(len=:), allocatable :: fn_control character(len=128) :: msg integer :: ierr integer :: icla integer :: ncla integer(kind=int64) :: ccbeg integer(kind=int64) :: ccend integer(kind=int64) :: crate","tags":"","loc":"program/main.html"},{"title":"User Guide – BROWNPAK","text":"This is BROWNPAK. It can perform the following kinds of simulations: Energy minimization (also called structure relaxation) via steepest\n  descent. Brownian dynamics (BD) Multiparticle collision dynamics (MPCD) The source code is written in F2008 compliant fortran. There is a dependency on\nthe Intel Math Kernel Library (MKL). I have compiled the code with gfortran-8.3\ncompiler and MKL 2019 Update 4. Getting the source files The simplest way is to clone using git . Of course, this requires git to be\ninstalled on your system. If you do not want to clone, it is possible to\ndownload a zip file containing the source. Let's say you want to clone. Create a directory where you want the files to live. Say this directory is foo . mkdir foo cd foo Then clone the repo from GitHub thus: git clone https://github.com/saridut/BROWNPAK.git . That's it. Directory structure The directory structure is as follows: src contains the Fortran source files. There are some unused (not required/buggy?)\n source files in src/extra . bin contains the compiled executable, named brownpak . The executable can\n  be run directly from here, or from some other location with appropriately\n  specified path to the executable. It is best not to move around the\nexecutable, rather invoke the executable from the directory where you want to\nrun it. build is the build directory. It contains a makefile. It is necessary to\n  update the paths in the makefile to suit the local system. utils contains several utilities. There are python scripts the generate\n  initial configuration, fortran routines to extract configurations, etc. tests contains testing routines for development purposes. This need not be\n  necessarily present. docs contain files for generating autogenerated Fortran documentation (using FORD . To read the\n documentation, see here . Input and output files BROWNPAK reads several input files and produces several output files. The input\nfiles are: fn_control : This file contains various directives on what simulation to run,\n  time steps, etc. The directives are provided as a list of key-value pairs. The default name\n for this file is control.txt . fn_config : This file specifies the configuration of the system of be\n  simulated, i.e. atom positions, interactions, etc. The extension for this file\n  is .cfg , though it is not mandatory. The output files are: fn_traj : This is a binary file containing the trajectory data. These have\n  extension of .bin , though not mandatory. fn_stats : This is a text file containing a minimal set of statistics.\n  Further statistics may be obtained by post processing fn_traj . During\n  equilibration, the statistics will be written to a file called fn_stats.eq . brownpak.log : Log file. Check this for progress and error messsages For energy-minimization, two other files with -rlx in their names will be\n  produced. The file fn_config-rlx.cfg contains the minimized configuration,\nand the file fn_config-rlx.txt contains the same configuration in LAMMPS data\nformat for visualization in Ovito. Compilation and running There is a makefile in build . In the makefile, the DEBUG flag should be set\nto false for production builds. For testing purposes, set DEBUG = true . The compiler name is specified via the variable FC . e.g. for intel it will be\nappropriate to use FC = ifort . I use fortran95 wrappers to MKL as well. If one\nis using a non-Intel compiler, these wrappers need to be built (see the MKL\ndocumentation on how to do this). Anyways, since I am using gfortran, I specify the location of the\nwrappers through the variable MKL_INTRFC . Furthermore, MKLROOT is the root\ndirectory of the MKL installation. For an Intel compiler, MKL_INTRFC is not\nnecessary, but MKLROOT must be specified. It may be helpful to use the Intel\nLink Line Advisor for looking up appropriate flags. Appropriate compilation flags must be\nspecified via FCFLAGS . The current flags pertain to gfortran. For debug\nbuilds, the flags should turn off optimization, raise all warnings, check\nbounds, etc.; for production builds do turn on necessary optimization (without\nbeing too aggressive), loop unrolling, interprocedural optimizations, inlining,\netc. make To clean all .o and .mod files, do make clean To remove all .o , .mod , and the executable, do make clobber To run, the simplest way is to go to bin and ./brownpak fn_control = controlfile.txt job_tag = some_number Both the arguments fn_control and job_tag are optional.\nIf you do not specify the name of the control file, it will be assumed to be control.txt . The job_tag argument is there to help running array jobs on a\ncluster. For example, with SGE job scheduler I can request array jobs numbered\nfrom 1-16 and specify job_tag=$SGE_TASK_ID . Then all output files will have\nthe numbers 1-16 appended to their file names, like traj.bin.1, traj.bin.2, etc. Instead to running the executable from bin , you can run it from some other\ndirectory as path_to_bin/brownpak fn_control = controlfile.txt job_tag = some_number The above is more convenient with running multiple jobs on a cluster. Note that once compiled, if you change the source files a recompilation is\nnecessary. Unlike some codes that you may be familiar with, changing input files\ndo not require recompilation. Structure of the control file Here is a sample control file. It is called `control.txt. sim_style 2 use_verlet_tab F rcutoff 5 . 25 D0 tskin 2 . 1 D0 use_cell_list T excluded_atoms 1 lvdw T lhdia F mob_fctr KRYL lelectrostatics F tim_stp 1 . 0 D - 2 nts_md 100 nts_eql 0 . 0 D0 nts_eql_samp 10 nts_sim 2 . 0 D3 nts_samp 10 nts_dump 10 nts_log 10 fn_cfg sample . cfg fn_revive revive . bin fn_stats stats . txt fn_traj traj . bin lrevive F read_seed F write_seed T write_eql_stats T write_traj T traj_frmcmp 1 0 0 1 traj_wmpcd F As you can see, it lists a number of keywords and their corresponding values\nseparated by whitespace. The maximum length of a line is as specified in mxrdln . Note Each of the keywords in the control file is a variable listed in m_globals . Please look up the detailed description and possible set\nof allowed values there. Warning There are no checks performed on the consistency of the values provided\nin the control file. If you use unphysical values, your results may be incorrect\nor the program may crash. There can be blank lines between the keywords. Comments begin with # . If the # character is found on any line the rest of the line after # will be\ndiscarded. The keywords and the values must be separated by one or more whitespaces. I will elaborate on some specific aspects of the value format: Strings need not be quoted Booleans may be simply given as T or F instead of .true. or .false. Floats are always double precision, so please use *.D* fortran format. For\n  example, a value of 2.1 is single precision; instead specify it at 2.1D0 .\n  Other exponents are similar, e.g., 1.0D-2 for 0.01 . Values requiring uppercase letters must be given in that form, e.g. KRYL is\n  not the same a kryl . All the keywords starting with nts except nts_md are long ints. For\n  convenience these values may be given in *.D* format. Internally they will\n  be cast as long ints. mts_md is not a long int because it does not make\n  sense for it to be a large number, else the simulation will never complete. traj_frmcmp : See traj_frmcmp for details. Each element of the\n  sequence can be either 0 or 1 (separated by whitespaces), e.g. 1 1 1 1 or 1 0 0 1.\n  All four being zero is allowed, but makes no sense. Choosing nts_dump <= nts_samp is a good idea, but do not dump too frequently\n  either. Structure of the trajectory file The trajectory file is a binary file, i.e. it is a stream of bytes. The byte\norder is native. It can be read back in python (using struct to unpack), in\nfortran (opening the file with form='unformatted, access='stream' ), or in any\nother language. Warning If traj_wmpcd = T in the control file, the trajectory file can be\nextremely large. Explicit data for the position and velocities of MPCD atoms are\nrarely needed. MPCD atoms do not have forces or charge on them. I will call the trajectory file as traj.bin . It contains a header, followed by\na sequence of frames. The structure of the header is: header_size : 1 int (32 bits) frame_size : 1 int (32 bits) num_atoms : 1 int (32 bits). Number of non-MPCD atoms in the trajectory. num_mpcd_atoms : 1 int (32 bits). Number of MPCD atoms in the trajectory. frmcmp : 4 ints (32 bits each). Components of each frame, as specified by traj_frmcmp in the control file. During creation of a trajectory, num_atoms and num_mpcd_atoms are given\nto traj_create . Depending on traj_wmpcd , it is\npossible for an MPCD simulation to not write any MPCD data to traj.bin . This\nshould be the commonly used case. For BD/energy-minimization the value of traj_wmpcd does not matter. Following the header, there is a sequence of frame data, written according to traj_wmpcd and traj_frmcmp . Structure of the revive file The revive file is a binary dump. It contains enough information to restart the\nsimulation if lrevive = T in the control file. To see what gets dumped, please\nexamine the source for write_dump . Interactions The following kinds of interactions are available (or can be made available with\nminimal effort): Bonds All bonds have a type called bond_type . bond_type s are assigned\nby the user. For example, in a A-B diblock polymer, the user may choose A-A bonds\nas type 1, B-B bonds as type 2, and the A-B bond as type 3. Each bond_type is completely determined by a style , called bond_style ,\nand a set of parameters, called bond_params . bond_style s are chosen from the\nlist of available styles, as specified in m_ia_bond . The number of required\nparameters depend on the chosen style. The maximum number of parameters is mxparam .  For example, in our A-B diblock, the A-A bonds can be\nof type 1, with style 3 (corresponding to Kremer-Grest bond), and a set of four\nparameters; the B-B bonds can be of type 2, and also of style 3, with a set\nof four parameters, same as or different from the parameters of A-A bonds. Angles Similar to bonds, angles have types and styles as well. See m_ia_angle .\nOnly one non-trivial style is available, as this is the most commonly used\nstyle for polymers. However, more styles can be added if necessary. Dihedrals Dihedrals are not typically used in the kind of polymer models I deal with.\nSo, only the trivial style is present. In case you need a dihedral, add the\nappropriate routines to m_ia_dihedral . Tethers Tethers are pointwise restraints on one or more atoms. There can be multiple\ntethers, see m_ia_tether . Pairwise : See m_ia_vdw for a list. External : There is no working implementation of external interactions. The\n  idea is this: I do not know what kind of external interactions you need, but I\ndo not want to restrict you into a set of predefined interactions. So, please\nmodify the module m_ia_external to your choice, while keeping the interface\nintact. I assume you are a competent Fortran programmer, so that you will\nimmediately get it when you look at m_ia_external . A guiding principle is\nthat external interactions are generally fields that act on all the atoms in the\nsytem, but in some sense this covers everything. Remember to update the\nstress as you add external interactions. Structure of the config file Here is an extremely basic config file for a bunch of MPCD atoms. Sample SIMBOX 20 0 . 0 0 . 0 0 . 0 20 0 . 0 0 . 0 0 . 0 20 IMCON 1 ATOM_TYPES 0 MPCD_ATOMS 40000 5 ATOMS 0 MOLECULE_TYPES 0 MOLECULES 0 Please see the other examples in utils/models . It is best to use the python\nscripts to generate your config files. These scripts are self-explanatory. Restarting a simulation To restart a simulation, set nts_sim to a higher value in the control file\nand start the simulations. Note that an unusual situation may happen if you are\nrestarting after your job got killed/you deliberately killed it. In this case,\nit is possible that the data written in fn_stats and fn_traj are a few time\nsteps ahead of what is in fn_dump . This is most annoying; to get rid of such\nunwanted annoyances, I have written a small python script called sync.py that\nlives at utils/sync . This script basically compares both fn_traj and fn_stats with fn_dump and shaves off the extra records. You can run it\nbefore resubmitting a killed job. Use it with care, you may lose data. Workflow: Energy minimization Create an intial configuration. Say it is in file sample.cfg . Run the programme with sim_style = 0 . Monitor fn_stats , here the output energies will be written. The minimized\n   configuration will be written to sample-rlx.cfg . Moreover sample-rlx.txt (in LAMMPS data format) will be created, which you can visualize in Ovito. If\nnecessary, rerun by setting nts_sim to a higher value. Workflow: BD/MPCD Create an initial configuration. Minimize energy if you think this will be useful. It is usually useful. Use\n   the minimized configuration as the stating configuration for BD/MPCD\nsimulation. Set sim_style = 1 (for BD) or sim_style = 2 (for MPCD) and run. Rerun if necessary. Updating documentation (for developers) API documentation (Fortran files) is generated using FORD . As required by FORD,\nthe documentation is written in Markdown. All versions of Markdown may not be\nsupported, please experiment to see what works. Whole of GFM definitely doesn't. FORD also processes a User's Guide page, also written in Markdown. The source\nfor this is index.md in docs/pages . This may change in future, as I would\nprefer this to be in reStructuredText. The html pages generated by FORD is hosted on GitHub Pages for this\n  repository. For a number of reasons, pushing newly generated html pages is\nnot straightforward. These pages are pushed to the gh-pages branch, not to master . Assume that you have cloned the repo as usual, worked on it, and now you wish to update \nthe documentation. This will be done via git worktree, as discussed by Sangsoo Nam . Commit your current work and push. From the root of the repo, first create a\nlinked worktree as follows: cd docs\ngit worktree add html gh-pages cd html This will create a linked worktree in the directory docs/html and enter it. If\nyou do git branch now, you will see the current branch to be gh-pages . docs/html is where the html pages will finally live. Now, clean it. git rm -rf . Next, create an empty file .nojekyll . This prevents Jekyll from fiddling\n  with stuff inside html . touch .nojekyll Change directory to docs . cd ../docs Create a temporary directory called docs/tmp . FORD will generate the html files here, which will be copied to docs/html . This is necessary because\nFORD deletes everything inside its output directory, including .git . mkdir tmp Run FORD. Move the html pages to html . Delete tmp . ford -o tmp brownpak.md\nmv tmp/* html/\nrm -r tmp Go in html , add, commit, and push to gh-pages . cd html\ngit add --all\ngit commit -a --allow-empty-message -m '' git push origin gh-pages Get back to docs . Then get rid of the worktree. cd ../docs\ngit worktree remove html","tags":"","loc":"page//index.html"}]}