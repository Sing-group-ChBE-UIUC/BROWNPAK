var tipuesearch = {"pages":[{"title":" BROWNPAK ","text":"BROWNPAK Developer Info Sarit Dutta","tags":"home","loc":"index.html"},{"title":"m_bd_solver.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_bd_solver.f90~~EfferentGraph sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_bd_solver.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_bd_solver.f90->sourcefile~m_precision.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_bd_solver.f90->sourcefile~m_constants_math.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_bd_solver.f90->sourcefile~m_strings.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_bd_solver.f90->sourcefile~m_ran_num.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_bd_solver.f90->sourcefile~m_logger.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_precision.f90 sourcefile~m_interaction.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_stats_io.f90->sourcefile~m_precision.f90 sourcefile~m_stats_io.f90->sourcefile~m_constants_math.f90 sourcefile~m_stats_io.f90->sourcefile~m_strings.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90->sourcefile~m_precision.f90 sourcefile~m_config_io.f90->sourcefile~m_strings.f90 sourcefile~m_config_io.f90->sourcefile~m_simbox.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_ia_external.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90->sourcefile~m_constants_math.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_precision.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_cell_list.f90->sourcefile~m_vector.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_connectivity.f90->sourcefile~m_precision.f90 sourcefile~m_connectivity.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_vector.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_precision.f90 sourcefile~m_ia_angle.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_precision.f90 sourcefile~m_ia_bond.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_strings.f90 sourcefile~m_ia_bond.f90->sourcefile~m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_precision.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_logger.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_precision.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_precision.f90 sourcefile~m_ia_tether.f90->sourcefile~m_constants_math.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_table.f90->sourcefile~m_precision.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 var pansourcefilem_bd_solverf90EfferentGraph = svgPanZoom('#sourcefilem_bd_solverf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_bd_solver.f90~~AfferentGraph sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_setup.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_bd_solver Source Code m_bd_solver.f90 Source Code module m_bd_solver !! Routines implementing Brownian Dynamics (BD) solver. use iso_c_binding , only : c_loc , c_ptr , c_f_pointer use blas95 use lapack95 use f95_precision use m_precision use m_constants_math use m_strings use m_ran_num use m_globals use m_interaction , only : ia_calc_forces use m_stats_io use m_config_io use m_logger , only : logger => master_logger implicit none private public :: bds_init , bds_run , bds_finish real ( rp ), dimension (:), allocatable :: drift real ( rp ), dimension (:), allocatable :: diffusion real ( rp ), dimension (:,:), allocatable :: mobility contains !******************************************************************************* subroutine bds_init ( ierr ) !! Initializes the BD solver. integer , intent ( out ) :: ierr logical :: lexists ierr = 0 !Allocate memory for BD integration allocate ( drift ( 3 * num_atoms )) drift = 0.0_rp allocate ( diffusion ( 3 * num_atoms )) diffusion = 0.0_rp if ( lhdia ) then allocate ( mobility ( 3 * num_atoms , 3 * num_atoms )) mobility = 0.0_rp end if !Opening trajectory file if ( write_traj ) then if ( lrevive ) then !Append (write) to existing (new) trajectory file !Check if trajectory file exists inquire ( file = fn_traj // trim ( adjustl ( job_tag )), exist = lexists ) if ( lexists ) then !Open existing file for appending call traj % open ( fn_traj // trim ( adjustl ( job_tag )), 'rw' , ierr ) if ( ierr /= 0 ) return else !Create new trajectory file call traj % create ( fn_traj // trim ( adjustl ( job_tag )), num_atoms , 0 , traj_frmcmp ) end if else !Create new trajectory file call traj % create ( fn_traj // trim ( adjustl ( job_tag )), num_atoms , 0 , traj_frmcmp ) end if end if end subroutine !****************************************************************************** subroutine bds_finish () !! Clears up memory allocated in [[bds_init]]. call traj % close () if ( allocated ( drift )) deallocate ( drift ) if ( allocated ( diffusion )) deallocate ( diffusion ) if ( allocated ( mobility )) deallocate ( mobility ) end subroutine !****************************************************************************** subroutine bds_run () !! Driver for BD integrator. !! !! Repeatedly calls [[bds_integrate_fd]] or [[bds_integrate_hi]] to update !! atom positions. real ( rp ), dimension ( 3 ) :: com integer :: flow_style_ integer :: ierr ierr = 0 !For isolated untethered molecule, ensure c.o.m. is at the center of the !box. if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) then call simbox % to_center ( coordinates ) end if !Log & dump starting configuration call logger % info ( 'bds_run' , ' nts: ' // str_from_num ( nts )) call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) !Equilibration run. This is done under free-draining condition. if ( leql ) then !Turn off flow during equilibration flow_style_ = flow_style flow_style = 0 do while ( nts < nts_eql ) call bds_integrate_fd ( ierr ) if ( ierr /= 0 ) return nts = nts + 1 !Apply boundary conditions: For isolated untethered molecule, !bring c.o.m. to the origin. No need to update molecule_com during !equilibration. if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) then call simbox % to_center ( coordinates ) end if !For PBC, wrap atom positions if ( imcon /= 0 ) call simbox % wrap_all ( coordinates ) !Logging if ( mod ( nts , nts_log ) == 0 ) then call logger % info ( 'bds_run' , ' nts: ' // str_from_num ( nts )) end if !Dump revive file if ( mod ( nts , nts_dump ) == 0 ) then call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end if !Equilibration stats if ( write_eql_stats ) then if ( mod ( nts , nts_eql_samp ) == 0 ) call stats_write () end if end do call logger % info ( 'finish_equil_run' , 'Equilibration completed' ) call stats_finish () call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) leql = . false . nts = 0 !Turn flow back on flow_style = flow_style_ !If continue on to production run, create new stats file. if ( nts_sim > 0 ) call stats_init () end if !Production run. do while ( nts < nts_sim ) if ( lhdia ) then call bds_integrate_hi ( ierr ) else call bds_integrate_fd ( ierr ) end if if ( ierr /= 0 ) return nts = nts + 1 !Apply boundary conditions: For isolated untethered molecule, !update molecule_com & bring c.o.m. to the center of the box. if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) then call simbox % to_center ( coordinates , com ) molecule_com = molecule_com + com end if !For PBC, wrap atom positions if ( imcon /= 0 ) call simbox % wrap_all ( coordinates ) !Logging if ( mod ( nts , nts_log ) == 0 ) then call logger % info ( 'bds_run' , ' nts: ' // str_from_num ( nts )) end if !Dump revive file if ( mod ( nts , nts_dump ) == 0 ) then call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end if if ( mod ( nts , nts_samp ) == 0 ) then !Write stats call stats_write () !Write traj if ( write_traj ) call traj % append_frame ( nts , coordinates , & velocities , forces , charge ) end if end do !Dump the final configuration call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end subroutine !****************************************************************************** subroutine bds_integrate_fd ( ierr ) !! Performs one step of free-draining BD integeration. integer , intent ( out ) :: ierr real ( rp ), dimension (:), pointer :: fptr_forces type ( c_ptr ) :: cptr_forces real ( rp ) :: sqrt_two_dt integer :: nb integer :: i ierr = 0 drift = 0.0_rp ; diffusion = 0.0_rp sqrt_two_dt = sqrt ( 2 * tim_stp ) nb = size ( coordinates , 2 ) !Update forces call ia_calc_forces ( ierr ) if ( ierr /= 0 ) return !Calculate ambient flow velocity at the atom locations and store it in !module variable `drift`. call calc_ambient_velocity () !Calculate mobility matrix, take its dot product with force, & add to drift. !Using MKL routine 'symv' here. cptr_forces = c_loc ( forces ) call c_f_pointer ( cptr_forces , fptr_forces , [ 3 * nb ]) !No hydrodynamic interaction drift = drift + fptr_forces !Calculate random force & store it in module variable diffusion. call get_rv_gaussian ( 0.0_rp , 1.0_rp , diffusion , 1000000 ) !Update positions do i = 1 , nb coordinates (:, i ) = coordinates (:, i ) + tim_stp * drift ( 3 * i - 2 : 3 * i ) & + sqrt_two_dt * diffusion ( 3 * i - 2 : 3 * i ) end do end subroutine !****************************************************************************** subroutine bds_integrate_hi ( ierr ) !! Performs one step of BD integeration including HI. integer , intent ( out ) :: ierr real ( rp ), dimension (:), pointer :: fptr_forces type ( c_ptr ) :: cptr_forces real ( rp ) :: sqrt_two_dt integer :: nb , info integer :: i ierr = 0 drift = 0.0_rp ; diffusion = 0.0_rp sqrt_two_dt = sqrt ( 2 * tim_stp ) nb = size ( coordinates , 2 ) !Update forces call ia_calc_forces ( ierr ) if ( ierr /= 0 ) return !Calculate ambient flow velocity at the atom locations and store it in !module variable `drift`. call calc_ambient_velocity () !Calculate mobility matrix, take its dot product with force, & add to drift. !Using MKL routine 'symv' here. cptr_forces = c_loc ( forces ) call c_f_pointer ( cptr_forces , fptr_forces , [ 3 * nb ]) !With hydrodynamic interaction call calc_rpy_tensor () if ( flow_style == 0 ) then call symv ( mobility , fptr_forces , drift , 'U' ) else call symv ( mobility , fptr_forces , drift , 'U' , 1.0_rp , 1.0_rp ) end if !Calculate random force & store it in module variable diffusion. call get_rv_gaussian ( 0.0_rp , 1.0_rp , diffusion , 1000000 ) !Performs the operation: x = A.x, where A is the square root of mobility. !Only the upper triangular part of the square root matrix is !considered. For hi_method='cholesky', the square root matrix is calculated !before trmv. !Trmv operation on the sqrt of mobility matrix. if ( mob_fctr == 'CHOL' ) then call potrf ( mobility , 'U' , info ) if ( info /= 0 ) then ierr = 1 call logger % fatal ( 'potrf:' , 'err code ' // str_from_num ( info ) ) return end if ! Default for trmv: access the upper triangular part only call trmv ( mobility , diffusion , 'U' , 'N' , 'U' ) else if ( mob_fctr == 'KRYL' ) then call calc_Bdw_kryl ( mobility , diffusion , ierr ) if ( ierr /= 0 ) return end if !Update positions do i = 1 , nb coordinates (:, i ) = coordinates (:, i ) + tim_stp * drift ( 3 * i - 2 : 3 * i ) & + sqrt_two_dt * diffusion ( 3 * i - 2 : 3 * i ) end do end subroutine !****************************************************************************** subroutine calc_ambient_velocity () !! Calculates ambient velocity at the atom positions and store it in module !! variable `drift`. integer :: i , nb nb = size ( coordinates , 2 ) select case ( flow_style ) case ( 1 ) !Steady simple shear: Flow along x, gradient along y do i = 1 , nb drift ( 3 * i - 2 ) = flow_params ( 1 ) * coordinates ( 2 , i ) end do case ( 2 ) !Steady planar extension in x-y plane do i = 1 , nb drift ( 3 * i - 2 ) = flow_params ( 1 ) * coordinates ( 1 , i ) drift ( 3 * i - 1 ) = - flow_params ( 1 ) * coordinates ( 2 , i ) end do case ( 3 ) !Steady uniaxial extension along x do i = 1 , nb drift ( 3 * i - 2 ) = flow_params ( 1 ) * coordinates ( 1 , i ) drift ( 3 * i - 1 ) = - 0.5_rp * flow_params ( 1 ) * coordinates ( 2 , i ) drift ( 3 * i ) = - 0.5_rp * flow_params ( 1 ) * coordinates ( 3 , i ) end do case default continue end select end subroutine !****************************************************************************** subroutine calc_rpy_tensor () !! Calculates the RPY approximation to the mobility tensor. Overwrites !! the upper triangular part of `mobility`. real ( rp ), dimension ( 3 ) :: ri , rj , rij real ( rp ), dimension ( 3 , 3 ) :: matrpy real ( rp ) :: rijm , irijm , irijm2 real ( rp ) :: c1 , c2 , consij integer :: nb integer :: i , j nb = size ( coordinates , 2 ) !Reset mobility matrix to zero. mobility = 0.0_rp !Calculate the RPY tensor (in strictly upper triangular form) do j = 2 , nb rj = coordinates (:, j ) do i = 1 , ( j - 1 ) ri = coordinates (:, i ) rij = rj - ri rijm = norm2 ( rij ) irijm = 1.0_rp / rijm irijm2 = irijm * irijm if ( rijm >= 2.0_rp ) then C1 = 1.0_rp + ( 2.0_rp / 3.0_rp ) * irijm2 C2 = 1.0_rp - 2.0_rp * irijm2 consij = 0.75_rp * irijm else C1 = 1.0_rp - 9.0_rp * rijm / ( 3 2.0_rp ) C2 = 3.0_rp * rijm / ( 3 2.0_rp ) consij = 1.0_rp end if matrpy ( 1 , 1 ) = consij * ( C1 + C2 * rij ( 1 ) * rij ( 1 ) * irijm2 ) matrpy ( 2 , 1 ) = consij * ( C2 * rij ( 2 ) * rij ( 1 ) * irijm2 ) matrpy ( 3 , 1 ) = consij * ( C2 * rij ( 3 ) * rij ( 1 ) * irijm2 ) matrpy ( 1 , 2 ) = consij * ( C2 * rij ( 1 ) * rij ( 2 ) * irijm2 ) matrpy ( 2 , 2 ) = consij * ( C1 + C2 * rij ( 2 ) * rij ( 2 ) * irijm2 ) matrpy ( 3 , 2 ) = consij * ( C2 * rij ( 3 ) * rij ( 2 ) * irijm2 ) matrpy ( 1 , 3 ) = consij * ( C2 * rij ( 1 ) * rij ( 3 ) * irijm2 ) matrpy ( 2 , 3 ) = consij * ( C2 * rij ( 2 ) * rij ( 3 ) * irijm2 ) matrpy ( 3 , 3 ) = consij * ( C1 + C2 * rij ( 3 ) * rij ( 3 ) * irijm2 ) mobility ( 3 * i - 2 : 3 * i , 3 * j - 2 : 3 * j ) = matrpy end do end do !Copy upper triangular part to lower triangular part. This is not necessary !if the lower triangular part is not accessed in subsequent calculations. !do j = 2, (3*nb-1) !    do i = 1, j-1 !        rpy_tensor(j,i) = rpy_tensor(i,j) !    end do !end do !Put one on the diagonal. do j = 1 , 3 * nb mobility ( j , j ) = 1.0_rp end do end subroutine !****************************************************************************** subroutine calc_Bdw_kryl ( D , Bdw , ierr ) !! Calculates *B.dW* using Krylov subspace method. real ( rp ), dimension (:,:), intent ( in ) :: D !! (3N,3N) symmetric positive definite matrix. !! !! Diffusivity matrix. Only the upper triangular part of the matrix is used. real ( rp ), dimension (:), intent ( in out ) :: Bdw !! (3N,) vector. On entry contains vector **dW**. On return, contains !! **B.dW**, where **B** is the square root matrix of **D**. integer , intent ( out ) :: ierr !! Error flag integer , parameter :: dimk = 12 ! Dimension of Krylov subspace real ( rp ), parameter :: Ek_thres = 0.01_rp real ( rp ), dimension ( size ( D , 2 )) :: Bdwold real ( rp ), dimension ( size ( D , 2 )) :: w real ( rp ), dimension ( size ( D , 2 ), dimk ) :: V real ( rp ), dimension ( dimk , dimk ) :: P real ( rp ), dimension ( dimk ) :: diagH real ( rp ), dimension ( dimk ) :: diagHsav real ( rp ), dimension ( dimk ) :: subH real ( rp ), dimension ( dimk ) :: subHsav real ( rp ), dimension ( dimk ) :: sqrtHcol1 real ( rp ), dimension ( dimk ) :: Ptranscol1 real ( rp ) :: normz real ( rp ) :: Ek integer :: ncol integer :: j integer :: info ierr = 0 ncol = size ( D , 2 ) diagH = 0.0_rp subH = 0.0_rp Bdwold = 0.0_rp normz = norm2 ( Bdw ) V (:, 1 ) = Bdw / normz do j = 1 , dimk call symv ( D , V (:, j ), w ) !Default using upper triangular part if ( j > 1 ) then w = w - subH ( j - 1 ) * V (:, j - 1 ) end if diagH ( j ) = dot_product ( w , V (:, j )) if ( j < dimk ) then w = w - diagH ( j ) * V (:, j ) subH ( j ) = norm2 ( w ) V (:, j + 1 ) = w / subH ( j ) end if !Update Bdw if ( j >= 5 ) then diagHsav ( 1 : j ) = diagH ( 1 : j ) subHsav ( 1 : j ) = subH ( 1 : j ) call stevd ( diagHsav ( 1 : j ), subHsav ( 1 : j ), P ( 1 : j , 1 : j ), info ) if ( info /= 0 ) then write ( * , * ) 'calc_Bdw_kryl: info = ' , info ierr = 1 return end if diagHsav ( 1 : j ) = sqrt ( diagHsav ( 1 : j ) ) Ptranscol1 ( 1 : j ) = P ( 1 , 1 : j ) Ptranscol1 ( 1 : j ) = diagHsav ( 1 : j ) * Ptranscol1 ( 1 : j ) call gemv ( P ( 1 : j , 1 : j ), Ptranscol1 ( 1 : j ), sqrtHcol1 ( 1 : j ) ) call gemv ( V (:, 1 : j ), sqrtHcol1 ( 1 : j ), Bdw , normz , 0.0_rp , 'N' ) !Error calculation if ( j <= 5 ) then !Check only after several iterations, say 5 Ek = 1.0_rp else Ek = norm2 ( Bdw - Bdwold ) / norm2 ( Bdwold ) end if if ( Ek <= Ek_thres ) then exit end if Bdwold = Bdw end if end do end subroutine !****************************************************************************** end module m_bd_solver","tags":"","loc":"sourcefile/m_bd_solver.f90.html"},{"title":"m_cell_list.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_cell_list.f90~~EfferentGraph sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_cell_list.f90->sourcefile~m_precision.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_cell_list.f90->sourcefile~m_vector.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_cell_list.f90~~AfferentGraph sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_cell_list Source Code m_cell_list.f90 Source Code module m_cell_list !! Sorts atoms using a cell list. !! !! The algorithm to build the cell list partially follows the techniques in Watanabe et !! al, 2011, “Efficient Implementations of Molecular Dynamics Simulations for !! Lennard-Jones Systems,” Prog. Theor. Phys. 126, 203–235. !! !! The pairlist is not explicitly built, rather the cells are directly !! looped over during force calculation. use m_precision use m_vector use m_globals , only : simbox implicit none private public :: cl_init , cl_delete , cl_print , & cl_set_cell_size , cl_build , cl_build_cell_nbrs , & cl_get_num_cells , cl_get_contents , cl_get_nbr_cells real ( rp ), dimension ( 3 ) :: cell_size = 0.0_rp !! Cell size along *x*, *y*, & *z*. integer , dimension ( 3 ) :: nc_max = 0 !! Maximum number of cells along *x*, *y*, & *z*. integer , dimension ( 3 ) :: nc = 0 !! Number of cells along *x*, *y*, & *z*. integer :: nct_max = 0 !! Maximum total number of cells. integer :: nct = 0 !! Total of cells. integer , dimension (:), allocatable , target :: cells !! *(na_max,)* array. Listing atoms in each cell. integer , dimension (:), allocatable :: cells_pos !! *(0:nct_max,)* index array. Note: 0-based indexing. type ( ivector_t ) :: cell_nbrs !! Lists neighbor cells for each cell. integer , dimension (:), allocatable :: cell_nbrs_pos !! *(0:nct_max,)* index array. Note: 0-based indexing. integer , dimension (:), allocatable :: host_cells !! *(na_max,)* array. *host_cells(i)* stores the linear index of the cell !! containing atom *i*. *na_max* is the total number of atoms under consideration. integer , dimension (:), allocatable :: cell_pop !! *(0:nct_max-1,)* array storing population of each cell. Note: 0-based indexing. integer , dimension ( 3 , 13 ), parameter :: d = reshape ( [ & & 1 , 0 , 0 , & & 1 , 1 , 0 , - 1 , 1 , 0 , 0 , 1 , 0 , & & 0 , 0 , 1 , - 1 , 0 , 1 , 1 , 0 , 1 , & & - 1 , - 1 , 1 , 0 , - 1 , 1 , 1 , - 1 , 1 , & & - 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 ], [ 3 , 13 ] ) contains !****************************************************************************** subroutine cl_init ( na_max , cs_min ) !! Initializes a cell list. integer , intent ( in ) :: na_max !! Maximum number of atoms to be handled. real ( rp ), intent ( in ) :: cs_min !! Minimum size (i.e. length) of a cell. integer :: nelem !The following defines an upper bound on the number of cells nc_max ( 1 ) = ceiling ( simbox % basis ( 1 , 1 ) / cs_min ) nc_max ( 2 ) = ceiling ( simbox % basis ( 2 , 2 ) / cs_min ) nc_max ( 3 ) = ceiling ( simbox % basis ( 3 , 3 ) / cs_min ) nct_max = product ( nc_max ) allocate ( cells ( na_max )) allocate ( cells_pos ( 0 : nct_max )) allocate ( host_cells ( na_max )) allocate ( cell_pop ( 0 : nct_max - 1 )) !Provisional allocation with nelem (arbitrary) elements, !will expand/contract later. nelem = 8 call ivector_init ( cell_nbrs , nelem ) allocate ( cell_nbrs_pos ( 0 : nelem )) end subroutine !****************************************************************************** subroutine cl_set_cell_size ( cs ) !! Sets the cell size. The actual cell size may be slightly larger. real ( rp ), intent ( in ) :: cs nc ( 1 ) = floor ( simbox % basis ( 1 , 1 ) / cs ) nc ( 2 ) = floor ( simbox % basis ( 2 , 2 ) / cs ) nc ( 3 ) = floor ( simbox % basis ( 3 , 3 ) / cs ) nct = product ( nc ) cell_size ( 1 ) = simbox % basis ( 1 , 1 ) / nc ( 1 ) cell_size ( 2 ) = simbox % basis ( 2 , 2 ) / nc ( 2 ) cell_size ( 3 ) = simbox % basis ( 3 , 3 ) / nc ( 3 ) end subroutine !****************************************************************************** subroutine cl_build_cell_nbrs () !! Makes a table of neighboring cells. integer :: j integer :: ncx , ncy , ncz integer :: icx , icy , icz , ic integer :: jcx , jcy , jcz , jc if ( size ( cell_nbrs_pos ) < ( nct + 1 ) ) then deallocate ( cell_nbrs_pos ) allocate ( cell_nbrs_pos ( 0 : nct )) end if ncx = nc ( 1 ); ncy = nc ( 2 ); ncz = nc ( 3 ) cell_nbrs_pos ( 0 ) = 1 do icz = 0 , ncz - 1 do icy = 0 , ncy - 1 do icx = 0 , ncx - 1 ic = icz * ncx * ncy + icy * ncx + icx cell_nbrs_pos ( ic + 1 ) = cell_nbrs_pos ( ic ) do j = 1 , 13 jcx = modulo ( icx + d ( 1 , j ), ncx ) jcy = modulo ( icy + d ( 2 , j ), ncy ) jcz = modulo ( icz + d ( 3 , j ), ncz ) jc = jcz * ncx * ncy + jcy * ncx + jcx call cell_nbrs % append ( jc ) cell_nbrs_pos ( ic + 1 ) = cell_nbrs_pos ( ic + 1 ) + 1 end do end do end do end do call cell_nbrs % shrink_to_fit () end subroutine !****************************************************************************** subroutine cl_delete () !! Deallocates memory allocated in `cl_init`. if ( allocated ( cells )) deallocate ( cells ) if ( allocated ( cells_pos )) deallocate ( cells_pos ) call cell_nbrs % delete () if ( allocated ( cell_nbrs_pos )) deallocate ( cell_nbrs_pos ) if ( allocated ( host_cells )) deallocate ( host_cells ) if ( allocated ( cell_pop )) deallocate ( cell_pop ) cell_size = 0.0_rp nc_max = 0 ; nc = 0 nct_max = 0 ; nct = 0 end subroutine !****************************************************************************** subroutine cl_build ( coords ) !! Sorts atoms into cells for calculating short-range interations real ( rp ), dimension (:,:), intent ( in ) :: coords real ( rp ), dimension ( 3 ) :: ri integer :: na , iatm , j integer :: ncx , ncy , ncz integer :: icx , icy , icz , ic cells = 0 host_cells = 0 cell_pop = 0 ncx = nc ( 1 ); ncy = nc ( 2 ); ncz = nc ( 3 ) na = size ( coords , 2 ) !Loop over particles and put into cells do iatm = 1 , na ri = coords (:, iatm ) icx = int ( ri ( 1 ) / cell_size ( 1 ) ) icy = int ( ri ( 2 ) / cell_size ( 2 ) ) icz = int ( ri ( 3 ) / cell_size ( 3 ) ) if (( icx < 0 ) . or . ( icy < 0 ) . or . ( icz < 0 )) then print * , ri stop end if !If atoms are exactly on the box edge if ( icx > ( ncx - 1 ) ) icx = ncx - 1 if ( icy > ( ncy - 1 ) ) icy = ncy - 1 if ( icz > ( ncz - 1 ) ) icz = ncz - 1 ic = icz * ncx * ncy + icy * ncx + icx host_cells ( iatm ) = ic cell_pop ( ic ) = cell_pop ( ic ) + 1 end do !Loop over all cells to set up pointers cells_pos ( 0 ) = 1 do ic = 0 , ( nct - 1 ) cells_pos ( ic + 1 ) = cells_pos ( ic ) + cell_pop ( ic ) end do !Loop over all atoms do iatm = 1 , na ic = host_cells ( iatm ) j = cells_pos ( ic ) cells ( j ) = iatm cells_pos ( ic ) = cells_pos ( ic ) + 1 end do !Loop over all cells to set up pointers cells_pos ( 0 ) = 1 do ic = 0 , ( nct - 1 ) cells_pos ( ic + 1 ) = cells_pos ( ic ) + cell_pop ( ic ) end do end subroutine !****************************************************************************** function cl_get_num_cells () result ( res ) !! Returns the total number of cells integer :: res res = nct end function !****************************************************************************** subroutine cl_get_contents ( ic , res ) !! Returns a pointer to the entries of cell with linear index *ic*. integer , intent ( in ) :: ic integer , dimension (:), pointer , intent ( out ) :: res integer :: ibeg , iend res => null () ibeg = cells_pos ( ic ); iend = cells_pos ( ic + 1 ) - 1 res => cells ( ibeg : iend ) end subroutine !****************************************************************************** subroutine cl_get_nbr_cells ( ic , res ) !! Returns a pointer to the neighbor cells of cell with linear index *ic*. integer , intent ( in ) :: ic integer , dimension (:), pointer , intent ( out ) :: res integer :: ibeg , iend res => null () ibeg = cell_nbrs_pos ( ic ); iend = cell_nbrs_pos ( ic + 1 ) - 1 call cell_nbrs % get_data ( res , ibeg , iend ) end subroutine !******************************************************************************** subroutine cl_print () !! Prints a cell list integer , dimension (:), pointer :: aic => null () integer , dimension (:), pointer :: nbrc => null () integer :: ncx , ncy , ncz integer :: icx , icy , icz , ic ncx = nc ( 1 ); ncy = nc ( 2 ); ncz = nc ( 3 ) write ( * , '(\"ncx: \", i0, \" ncy: \", i0, \" ncz: \", i0)' ) ncx , ncy , ncz write ( * , '(\"lcx: \", g0.6, \" lcy: \", g0.6, \" lcz: \", g0.6)' ) cell_size write ( * , * ) 'CELL CONTENTS' do icz = 0 , ncz - 1 do icy = 0 , ncy - 1 do icx = 0 , ncx - 1 ic = icz * ncx * ncy + icy * ncx + icx call cl_get_contents ( ic , aic ) if ( size ( aic ) > 0 ) then write ( * , '(\"(\",i0,\",\",i0,\",\",i0,\")[\",i0,\"] \")' , advance = 'no' ) icx , icy , icz , ic write ( * , * ) size ( aic ), aic end if end do end do end do write ( * , * ) write ( * , * ) 'NBR CELLS' do icz = 0 , ncz - 1 do icy = 0 , ncy - 1 do icx = 0 , ncx - 1 ic = icz * ncx * ncy + icy * ncx + icx call cl_get_nbr_cells ( ic , nbrc ) write ( * , '(\"(\",i0,\",\",i0,\",\",i0,\")[\",i0,\"] \")' , advance = 'no' ) icx , icy , icz , ic write ( * , * ) size ( nbrc ), nbrc end do end do end do end subroutine !******************************************************************************** end module m_cell_list","tags":"","loc":"sourcefile/m_cell_list.f90.html"},{"title":"m_config_io.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_config_io.f90~~EfferentGraph sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_config_io.f90->sourcefile~m_precision.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_config_io.f90->sourcefile~m_strings.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_config_io.f90->sourcefile~m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_config_io.f90~~AfferentGraph sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_config_io.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_config_io.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_config_io Source Code m_config_io.f90 Source Code module m_config_io !! Routines for IO of config and dump files. use m_precision use m_strings use m_simbox use m_globals implicit none contains !****************************************************************************** subroutine read_dump ( fn ) !! Reads from DUMP file character ( len =* ), intent ( in ) :: fn real ( rp ), dimension ( 3 , 3 ) :: mat integer :: fu logical :: lvel open ( newunit = fu , file = fn , access = 'stream' , form = 'unformatted' , & action = 'read' , status = 'old' ) read ( fu ) leql , nts read ( fu ) mat call simbox % set_basis ( mat ) read ( fu ) imcon read ( fu ) num_atom_types allocate ( atom_names ( num_atom_types )) allocate ( atom_styles ( num_atom_types )) allocate ( atom_mass ( num_atom_types )) read ( fu ) atom_names , atom_styles , atom_mass read ( fu ) mpcd_avnc , num_mpcd_atoms read ( fu ) num_atoms , num_atoms_tot allocate ( atoms ( num_atoms )) read ( fu ) atoms allocate ( coordinates ( 3 , num_atoms_tot )) read ( fu ) coordinates read ( fu ) lvel if ( lvel ) then allocate ( velocities ( 3 , num_atoms_tot )) read ( fu ) velocities end if allocate ( charge ( num_atoms )) read ( fu ) charge read ( fu ) num_bond_types if ( num_bond_types > 0 ) then allocate ( bond_styles ( num_bond_types )) allocate ( bond_params ( mxparam , num_bond_types )) read ( fu ) bond_styles , bond_params end if read ( fu ) num_bonds if ( num_bonds > 0 ) then allocate ( bonds ( 3 , num_bonds )) read ( fu ) bonds end if read ( fu ) num_angle_types if ( num_angle_types > 0 ) then allocate ( angle_styles ( num_angle_types )) allocate ( angle_params ( mxparam , num_angle_types )) read ( fu ) angle_styles , angle_params end if read ( fu ) num_angles if ( num_angles > 0 ) then allocate ( angles ( 4 , num_angles )) read ( fu ) angles end if read ( fu ) num_dihedral_types if ( num_dihedral_types > 0 ) then allocate ( dihedral_styles ( num_dihedral_types )) allocate ( dihedral_params ( mxparam , num_dihedral_types )) read ( fu ) dihedral_styles , dihedral_params end if read ( fu ) num_dihedrals if ( num_dihedrals > 0 ) then allocate ( dihedrals ( 5 , num_dihedrals )) read ( fu ) dihedrals end if read ( fu ) num_branches if ( num_branches > 0 ) then allocate ( branches ( 3 , num_branches )) read ( fu ) branches end if read ( fu ) num_molecule_types allocate ( molecule_names ( num_molecule_types )) allocate ( molecule_pop ( num_molecule_types )) read ( fu ) molecule_names , molecule_pop read ( fu ) num_molecules allocate ( molecules ( 9 , num_molecules )) read ( fu ) molecules read ( fu ) num_tether_types if ( num_tether_types > 0 ) then allocate ( tether_styles ( num_tether_types )) allocate ( tether_params ( mxparam , num_tether_types )) read ( fu ) tether_styles , tether_params end if read ( fu ) num_tethers if ( num_tethers > 0 ) then allocate ( tethers ( 2 , num_tethers )) allocate ( tether_points ( 3 , num_tethers )) read ( fu ) tethers , tether_points end if read ( fu ) num_vdw_types if ( num_vdw_types > 0 ) then allocate ( vdw_styles ( num_vdw_types )) allocate ( vdw_pairs ( 2 , num_vdw_types )) allocate ( vdw_params ( mxparam , num_vdw_types )) read ( fu ) vdw_pairs , vdw_styles , vdw_params end if read ( fu ) num_externals if ( num_externals > 0 ) then allocate ( external_styles ( num_externals )) allocate ( external_params ( mxparam , num_externals )) read ( fu ) external_styles , external_params end if read ( fu ) flow_style if ( flow_style /= 0 ) then allocate ( flow_params ( mxparam )) read ( fu ) flow_params end if if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) read ( fu ) molecule_com close ( fu ) end subroutine !****************************************************************************** subroutine write_dump ( fn ) !! Writes to DUMP file. character ( len =* ), intent ( in ) :: fn integer :: fu logical :: lvel open ( newunit = fu , file = fn , access = 'stream' , form = 'unformatted' , & action = 'write' , status = 'replace' ) write ( fu ) leql , nts write ( fu ) simbox % basis write ( fu ) imcon write ( fu ) num_atom_types , atom_names , atom_styles , atom_mass write ( fu ) mpcd_avnc , num_mpcd_atoms write ( fu ) num_atoms , num_atoms_tot write ( fu ) atoms write ( fu ) coordinates if ( allocated ( velocities )) then !A logical indicating whether velocities are written lvel = . true . write ( fu ) lvel , velocities else lvel = . false . write ( fu ) lvel end if write ( fu ) charge write ( fu ) num_bond_types if ( num_bond_types > 0 ) write ( fu ) bond_styles , bond_params write ( fu ) num_bonds if ( num_bonds > 0 ) write ( fu ) bonds write ( fu ) num_angle_types if ( num_angle_types > 0 ) write ( fu ) angle_styles , angle_params write ( fu ) num_angles if ( num_angles > 0 ) write ( fu ) angles write ( fu ) num_dihedral_types if ( num_dihedral_types > 0 ) write ( fu ) dihedral_styles , dihedral_params write ( fu ) num_dihedrals if ( num_dihedrals > 0 ) write ( fu ) dihedrals write ( fu ) num_branches if ( num_branches > 0 ) write ( fu ) branches write ( fu ) num_molecule_types , molecule_names , molecule_pop write ( fu ) num_molecules , molecules write ( fu ) num_tether_types if ( num_tether_types > 0 ) write ( fu ) tether_styles , tether_params write ( fu ) num_tethers if ( num_tethers > 0 ) write ( fu ) tethers , tether_points write ( fu ) num_vdw_types if ( num_vdw_types > 0 ) write ( fu ) vdw_pairs , vdw_styles , vdw_params write ( fu ) num_externals if ( num_externals > 0 ) write ( fu ) external_styles , external_params write ( fu ) flow_style if ( flow_style /= 0 ) write ( fu ) flow_params if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) write ( fu ) molecule_com close ( fu ) end subroutine !****************************************************************************** subroutine read_config ( fn ) !! Read from CONFIG file character ( len =* ), intent ( in ) :: fn character ( len = mxrdln ) :: line character ( len = :), allocatable :: word real ( rp ), dimension ( 3 , 3 ) :: mat integer :: i , it , npar , ibr integer :: fu , ios open ( newunit = fu , file = fn , action = 'read' , status = 'old' ) do call readline ( fu , line , '#' , ios ) if ( ios /= 0 ) exit line = adjustl ( line ) if ( str_startswith ( line , 'SIMBOX' )) then !Read simulation box size into lattice vectors defining the box read ( fu , * ) mat (:, 1 ) read ( fu , * ) mat (:, 2 ) read ( fu , * ) mat (:, 3 ) call simbox % set_basis ( mat ) end if if ( str_startswith ( line , 'IMCON' )) then !Read box boundary condition call str_split ( line , ' ' , word ) imcon = str_to_i ( line ) end if if ( str_startswith ( line , 'ATOM_TYPES' )) then call str_split ( line , ' ' , word ) num_atom_types = str_to_i ( line ) allocate ( atom_names ( num_atom_types )) allocate ( atom_styles ( num_atom_types )) allocate ( atom_mass ( num_atom_types )) do it = 1 , num_atom_types read ( fu , * ) atom_names ( it ), atom_styles ( it ), atom_mass ( it ) end do end if if ( str_startswith ( line , 'MPCD_ATOMS' )) then call str_split ( line , ' ' , word ) call str_split ( line , ' ' , word ) num_mpcd_atoms = str_to_i ( word ) mpcd_avnc = str_to_i ( line ) end if if ( str_startswith ( line , 'ATOMS' )) then call str_split ( line , ' ' , word ) num_atoms = str_to_i ( line ) num_atoms_tot = num_mpcd_atoms + num_atoms allocate ( atoms ( num_atoms )) allocate ( charge ( num_atoms )) allocate ( coordinates ( 3 , num_atoms_tot )) do i = 1 , num_atoms read ( fu , * ) atoms ( i ), charge ( i ), coordinates (:, i ) end do end if if ( str_startswith ( line , 'BOND_TYPES' )) then call str_split ( line , ' ' , word ) num_bond_types = str_to_i ( line ) allocate ( bond_styles ( num_bond_types )) allocate ( bond_params ( mxparam , num_bond_types )) bond_params = 0.0_rp do it = 1 , num_bond_types call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) bond_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) bond_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'BONDS' )) then call str_split ( line , ' ' , word ) num_bonds = str_to_i ( line ) allocate ( bonds ( 3 , num_bonds )) do i = 1 , num_bonds read ( fu , * ) bonds (:, i ) end do end if if ( str_startswith ( line , 'ANGLE_TYPES' )) then call str_split ( line , ' ' , word ) num_angle_types = str_to_i ( line ) allocate ( angle_styles ( num_angle_types )) allocate ( angle_params ( mxparam , num_angle_types )) angle_params = 0.0_rp do it = 1 , num_angle_types call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) angle_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) angle_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'ANGLES' )) then call str_split ( line , ' ' , word ) num_angles = str_to_i ( line ) allocate ( angles ( 4 , num_angles )) do i = 1 , num_angles read ( fu , * ) angles (:, i ) end do end if if ( str_startswith ( line , 'DIHEDRAL_TYPES' )) then call str_split ( line , ' ' , word ) num_dihedral_types = str_to_i ( line ) allocate ( dihedral_styles ( num_dihedral_types )) allocate ( dihedral_params ( mxparam , num_dihedral_types )) dihedral_params = 0.0_rp do it = 1 , num_dihedral_types call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) dihedral_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) dihedral_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'DIHEDRALS' )) then call str_split ( line , ' ' , word ) num_dihedrals = str_to_i ( line ) allocate ( dihedrals ( 5 , num_dihedrals )) do i = 1 , num_dihedrals read ( fu , * ) dihedrals (:, i ) end do end if if ( str_startswith ( line , 'BRANCHES' )) then call str_split ( line , ' ' , word ) num_branches = str_to_i ( line ) allocate ( branches ( 3 , num_branches )) do ibr = 1 , num_branches read ( fu , * ) branches (:, ibr ) end do end if if ( str_startswith ( line , 'MOLECULE_TYPES' )) then call str_split ( line , ' ' , word ) num_molecule_types = str_to_i ( line ) allocate ( molecule_names ( num_molecule_types )) allocate ( molecule_pop ( num_molecule_types )) do it = 1 , num_molecule_types read ( fu , * ) molecule_names ( it ), molecule_pop ( it ) end do end if if ( str_startswith ( line , 'MOLECULES' )) then call str_split ( line , ' ' , word ) num_molecules = str_to_i ( line ) allocate ( molecules ( 9 , num_molecules )) do i = 1 , num_molecules read ( fu , * ) molecules (:, i ) end do end if if ( str_startswith ( line , 'TETHER_TYPES' )) then call str_split ( line , ' ' , word ) num_tether_types = str_to_i ( line ) allocate ( tether_styles ( num_tether_types )) allocate ( tether_params ( mxparam , num_tether_types )) tether_params = 0.0_rp do it = 1 , num_tether_types call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) tether_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) tether_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'TETHERS' )) then call str_split ( line , ' ' , word ) num_tethers = str_to_i ( line ) allocate ( tethers ( 2 , num_tethers )) allocate ( tether_points ( 3 , num_tethers )) do i = 1 , num_tethers read ( fu , * ) tethers (:, i ), tether_points (:, i ) end do end if if ( str_startswith ( line , 'VDW' )) then call str_split ( line , ' ' , word ) num_vdw_types = str_to_i ( line ) allocate ( vdw_styles ( num_vdw_types )) allocate ( vdw_pairs ( 2 , num_vdw_types )) allocate ( vdw_params ( mxparam , num_vdw_types )) vdw_params = 0.0_rp do it = 1 , num_vdw_types call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) vdw_pairs ( 1 , it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) vdw_pairs ( 2 , it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) vdw_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) vdw_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'EXTERNAL' )) then call str_split ( line , ' ' , word ) num_externals = str_to_i ( line ) allocate ( external_styles ( num_externals )) allocate ( external_params ( mxparam , num_externals )) external_params = 0.0_rp do it = 1 , num_externals call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) external_styles ( it ) = str_to_i ( word ) call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) external_params ( 1 : npar , it ) end if end do end if if ( str_startswith ( line , 'FLOW_FIELD' )) then allocate ( flow_params ( mxparam )) flow_params = 0.0_rp call readline ( fu , line , '#' , ios ) call str_split ( line , ' ' , word ) flow_style = str_to_i ( word ) if ( flow_style > 0 ) then call str_split ( line , ' ' , word ) npar = str_to_i ( word ) if ( npar > 0 ) then read ( line , * ) flow_params ( 1 : npar ) end if end if end if end do close ( fu ) end subroutine !******************************************************************************* subroutine write_config ( fn , title ) !! Write to cfg file character ( len =* ), intent ( in ) :: fn character ( len =* ), intent ( in ) :: title integer :: fu integer :: i , it open ( newunit = fu , file = fn , action = 'write' , status = 'replace' ) write ( fu , '(a)' ) '#' // trim ( adjustl ( title )) write ( fu , '(a)' ) 'version 1.0' write ( fu , * ) write ( fu , '(a)' ) 'SIMBOX' write ( fu , '(3(g0.8,2x))' ) simbox % basis (:, 1 ) write ( fu , '(3(g0.8,2x))' ) simbox % basis (:, 2 ) write ( fu , '(3(g0.8,2x))' ) simbox % basis (:, 3 ) write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'IMCON' , imcon write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ATOM_TYPES' , num_atom_types do it = 1 , num_atom_types write ( fu , '(a,2x,i0,2x,g0.6)' ) trim ( adjustl ( atom_names ( it ))), & atom_styles ( it ), atom_mass ( it ) end do if ( num_mpcd_atoms > 0 ) then write ( fu , * ) write ( fu , '(a,2x, i0,2x,i0)' ) 'MPCD_ATOMS' , num_mpcd_atoms , mpcd_avnc end if write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ATOMS' , num_atoms do i = 1 , num_atoms write ( fu , '(i0,2x,*(g0.14,2x))' ) atoms ( i ), charge ( i ), coordinates (:, i ) end do if ( num_bonds > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'BOND_TYPES' , num_bond_types do it = 1 , num_bond_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) bond_styles ( it ), & size ( bond_params , 1 ), bond_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'BONDS' , num_bonds do i = 1 , num_bonds write ( fu , '(*(i0,2x))' ) bonds (:, i ) end do end if if ( num_angles > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ANGLE_TYPES' , num_angle_types do it = 1 , num_angle_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) angle_styles ( it ), & size ( angle_params , 1 ), angle_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'ANGLES' , num_angles do i = 1 , num_angles write ( fu , '(*(i0,2x))' ) angles (:, i ) end do end if if ( num_dihedrals > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'DIHEDRAL_TYPES' , num_dihedral_types do it = 1 , num_dihedral_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) dihedral_styles ( it ), & size ( dihedral_params , 1 ), dihedral_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'DIHEDRALS' , num_dihedrals do i = 1 , num_dihedrals write ( fu , '(*(i0,2x))' ) dihedrals (:, i ) end do end if if ( num_branches > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'BRANCHES' , num_branches do i = 1 , num_branches write ( fu , '(*(i0,2x))' ) branches (:, i ) end do end if write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'MOLECULE_TYPES' , num_molecule_types do it = 1 , num_molecule_types write ( fu , '(a,2x,i0)' ) trim ( adjustl ( molecule_names ( it ))), molecule_pop ( it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'MOLECULES' , num_molecules do i = 1 , num_molecules write ( fu , '(*(i0,2x))' ) molecules (:, i ) end do if ( num_tethers > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'TETHER_TYPES' , num_tether_types do it = 1 , num_tether_types write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) tether_styles ( it ), & size ( tether_params , 1 ), tether_params (:, it ) end do write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'TETHERS' , num_tethers do i = 1 , num_tethers write ( fu , '(2(i0,2x),3(g0.6,2x))' ) tethers (:, i ), tether_points (:, i ) end do end if if ( num_vdw_types > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'VDW' , num_vdw_types do it = 1 , num_vdw_types write ( fu , '(2(i0,2x),i0,2x,i0,2x,*(g0.6,2x))' ) vdw_pairs (:, it ), & vdw_styles ( it ), size ( vdw_params , 1 ), vdw_params (:, it ) end do end if if ( num_externals > 0 ) then write ( fu , * ) write ( fu , '(a,2x,i0)' ) 'EXTERNAL' , num_externals do it = 1 , num_externals write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' ) external_styles ( it ), & size ( external_params , 1 ), external_params (:, it ) end do end if write ( fu , * ) write ( fu , '(a)' ) 'FLOW_FIELD' write ( fu , '(i0,2x,i0,2x,*(g0.6,2x))' , advance = 'no' ) flow_style if ( flow_style > 0 ) then write ( fu , '(i0,2x,*(g0.6,2x))' ) size ( flow_params ), flow_params else write ( fu , * ) end if close ( fu ) end subroutine !****************************************************************************** subroutine write_ldf ( fn_ld , title , with_mpcd_atoms ) !! Write to a LAMMPS data file. character ( len =* ), intent ( in ) :: fn_ld !! Name of the file character ( len =* ), intent ( in ) :: title !! Title of the configuation logical , intent ( in ), optional :: with_mpcd_atoms !! Include MPCD atoms in the file? {T, F} real ( rp ), dimension ( 3 ) :: tilt_factors real ( rp ) :: chge logical :: with_mpcd_atoms_ integer :: fu_ld integer :: cntr_atm , iatm_beg , natm integer :: i , iatm , imol if ( present ( with_mpcd_atoms )) then with_mpcd_atoms_ = with_mpcd_atoms else with_mpcd_atoms_ = . false . end if open ( newunit = fu_ld , file = fn_ld , action = 'write' ) !Header write ( fu_ld , '(a)' ) '#' // trim ( adjustl ( title )) if ( with_mpcd_atoms_ ) then write ( fu_ld , '(i0,2x,a)' ) num_atoms_tot , 'atoms' write ( fu_ld , '(i0,2x,a)' ) num_atom_types + 1 , 'atom types' else write ( fu_ld , '(i0,2x,a)' ) num_atoms , 'atoms' write ( fu_ld , '(i0,2x,a)' ) num_atom_types , 'atom types' end if if ( num_bonds > 0 ) then write ( fu_ld , '(i0,2x,a)' ) num_bonds , 'bonds' write ( fu_ld , '(i0,2x,a)' ) num_bond_types , 'bond types' end if if ( num_angles > 0 ) then write ( fu_ld , '(i0,2x,a)' ) num_angles , 'angles' write ( fu_ld , '(i0,2x,a)' ) num_angle_types , 'angle types' end if if ( num_dihedrals > 0 ) then write ( fu_ld , '(i0,2x,a)' ) num_dihedrals , 'dihedrals' write ( fu_ld , '(i0,2x,a)' ) num_dihedral_types , 'dihedral types' end if !Simulation box & tilt factors write ( fu_ld , '(a,2x,g0.6,2x,a)' ) '0.0' , simbox % basis ( 1 , 1 ), 'xlo xhi' write ( fu_ld , '(a,2x,g0.6,2x,a)' ) '0.0' , simbox % basis ( 2 , 2 ), 'ylo yhi' write ( fu_ld , '(a,2x,g0.6,2x,a)' ) '0.0' , simbox % basis ( 3 , 3 ), 'zlo zhi' write ( fu_ld , '(a)' ) '0.0 0.0 0.0 xy xz yz' !TODO: Triclinic box !   tilt_factors(1) = dot_product(simbox%basis(:,1)/norm2(simbox%basis(:,1)), & !       simbox%basis(:,2)/norm2(simbox%basis(:,2))) !   tilt_factors(2) = dot_product(simbox%basis(:,1)/norm2(simbox%basis(:,1)), & !       simbox%basis(:,3)/norm2(simbox%basis(:,3))) !   tilt_factors(3) = dot_product(simbox%basis(:,2)/norm2(simbox%basis(:,2)), & !       simbox%basis(:,3)/norm2(simbox%basis(:,3))) !   tilt_factors = acos(tilt_factors) !   write(fu_ld,'(3(g0.6,2x),a)') tilt_factors, 'xy xz yz' !Body: Atoms write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Atoms # full' write ( fu_ld , * ) cntr_atm = 1 do imol = 1 , num_molecules natm = molecules ( 2 , imol ) iatm_beg = molecules ( 3 , imol ) do i = 1 , natm iatm = iatm_beg + i - 1 write ( fu_ld , '(i0,2x,i0,2x,i0,2x,4(g0.8,2x))' ) cntr_atm , imol , & atoms ( iatm ), charge ( iatm ), coordinates (:, iatm ) cntr_atm = cntr_atm + 1 end do end do if ( with_mpcd_atoms_ ) then imol = 0 ; chge = 0.0_rp !No charge on MPCD atoms do i = num_atoms + 1 , num_atoms_tot write ( fu_ld , '(i0,2x,i0,2x,i0,2x,4(g0.8,2x))' ) cntr_atm , imol , & ( num_atom_types + 1 ), chge , coordinates (:, i ) cntr_atm = cntr_atm + 1 end do end if !Body: Bonds if ( num_bonds > 0 ) then write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Bonds' write ( fu_ld , * ) do i = 1 , num_bonds write ( fu_ld , '(i0,2x,3(i0,2x))' ) i , bonds (:, i ) end do end if !Body: Angles if ( num_angles > 0 ) then write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Angles' write ( fu_ld , * ) do i = 1 , num_angles write ( fu_ld , '(i0,2x,4(i0,2x))' ) i , angles (:, i ) end do end if !Body: Dihedrals if ( num_dihedrals > 0 ) then write ( fu_ld , * ) write ( fu_ld , '(a)' ) 'Dihedrals' write ( fu_ld , * ) do i = 1 , num_dihedrals write ( fu_ld , '(i0,2x,5(i0,2x))' ) i , dihedrals (:, i ) end do end if close ( fu_ld ) end subroutine !******************************************************************************* subroutine write_xyz ( fn_xyz , title , with_mpcd_atoms ) !! Write to an XYZ file. character ( len =* ), intent ( in ) :: fn_xyz !! Name of the XYZ file character ( len =* ), intent ( in ) :: title !! Title (for the configuration) logical , intent ( in ), optional :: with_mpcd_atoms !! Include MPCD atoms in the file? {T, F} integer :: iatm integer :: na integer :: fu_xyz if ( present ( with_mpcd_atoms )) then if ( with_mpcd_atoms ) then na = num_atoms_tot else na = num_atoms end if else na = num_atoms end if open ( newunit = fu_xyz , file = fn_xyz , action = 'write' ) write ( fu_xyz , '(i0)' ) na write ( fu_xyz , '(a)' ) title do iatm = 1 , na write ( fu_xyz , '(3(g0.7,2x))' ) coordinates (:, iatm ) end do close ( fu_xyz ) end subroutine !******************************************************************************* end module m_config_io","tags":"","loc":"sourcefile/m_config_io.f90.html"},{"title":"m_connectivity.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_connectivity.f90~~EfferentGraph sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_connectivity.f90->sourcefile~m_precision.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_connectivity.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_table.f90->sourcefile~m_precision.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_connectivity.f90~~AfferentGraph sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_connectivity Source Code m_connectivity.f90 Source Code module m_connectivity !! Routines for building atom->bond, atom->angle, etc. tables and excluded !! atoms table. use m_precision use m_vector use m_table use m_globals implicit none private public :: atbo_build , atan_build , atdh_build , exat_build public :: atbo_tab , atan_tab , atdh_tab , exat_tab type ( itable_t ) :: atbo_tab !! Atoms -> bonds table type ( itable_t ) :: atan_tab !! Atoms -> angles table type ( itable_t ) :: atdh_tab !! Atoms -> dihedrals table type ( itable_t ) :: atat_tab !! Atoms -> bonded atoms table (1-ring) type ( itable_t ) :: exat_tab !! Atoms -> excluded atoms (from vdw calculation) table contains !******************************************************************************** subroutine atbo_build () type ( ivector_t ), dimension (:), allocatable :: buf_map integer :: iatm , jatm , ibnd integer :: j !Build table as list of lists allocate ( buf_map ( num_atoms )) do iatm = 1 , num_atoms call ivector_init ( buf_map ( iatm )) end do do ibnd = 1 , num_bonds iatm = bonds ( 2 , ibnd ) jatm = bonds ( 3 , ibnd ) call buf_map ( iatm )% append ( ibnd ) call buf_map ( jatm )% append ( ibnd ) end do !Sort in ascending order do iatm = 1 , num_atoms if ( buf_map ( iatm )% len > 1 ) call buf_map ( iatm )% sort () end do !Copy over to table call itbl_init ( atbo_tab , num_atoms ) do iatm = 1 , num_atoms do j = 1 , buf_map ( iatm )% len jatm = buf_map ( iatm )% get_val ( j ) call atbo_tab % append ( iatm , jatm ) end do end do !Delete list of lists table do iatm = 1 , num_atoms call buf_map ( iatm )% delete () end do deallocate ( buf_map ) !Release additional memory call atbo_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine atan_build () type ( ivector_t ), dimension (:), allocatable :: buf_map integer :: iatm , jatm , katm , iang integer :: j !Build table as list of lists allocate ( buf_map ( num_atoms )) do iatm = 1 , num_atoms call ivector_init ( buf_map ( iatm )) end do do iang = 1 , num_angles iatm = angles ( 2 , iang ) jatm = angles ( 3 , iang ) katm = angles ( 4 , iang ) call buf_map ( iatm )% append ( iang ) call buf_map ( jatm )% append ( iang ) call buf_map ( katm )% append ( iang ) end do !Sort in ascending order do iatm = 1 , num_atoms if ( buf_map ( iatm )% len > 1 ) call buf_map ( iatm )% sort () end do !Copy over to table call itbl_init ( atan_tab , num_atoms ) do iatm = 1 , num_atoms do j = 1 , buf_map ( iatm )% len jatm = buf_map ( iatm )% get_val ( j ) call atan_tab % append ( iatm , jatm ) end do end do !Delete list of lists table do iatm = 1 , num_atoms call buf_map ( iatm )% delete () end do deallocate ( buf_map ) !Release additional memory call atan_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine atdh_build () type ( ivector_t ), dimension (:), allocatable :: buf_map integer :: iatm , jatm , katm , latm , idhd integer :: j !Build table as list of lists allocate ( buf_map ( num_atoms )) do iatm = 1 , num_atoms call ivector_init ( buf_map ( iatm )) end do do idhd = 1 , num_dihedrals iatm = dihedrals ( 2 , idhd ) jatm = dihedrals ( 3 , idhd ) katm = dihedrals ( 4 , idhd ) latm = dihedrals ( 5 , idhd ) call buf_map ( iatm )% append ( idhd ) call buf_map ( jatm )% append ( idhd ) call buf_map ( katm )% append ( idhd ) call buf_map ( latm )% append ( idhd ) end do !Sort in ascending order do iatm = 1 , num_atoms if ( buf_map ( iatm )% len > 1 ) call buf_map ( iatm )% sort () end do !Copy over to table call itbl_init ( atdh_tab , num_atoms ) do iatm = 1 , num_atoms do j = 1 , buf_map ( iatm )% len jatm = buf_map ( iatm )% get_val ( j ) call atdh_tab % append ( iatm , jatm ) end do end do !Delete list of lists table do iatm = 1 , num_atoms call buf_map ( iatm )% delete () end do deallocate ( buf_map ) !Release additional memory call atdh_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine atat_build () integer , dimension (:), pointer :: inc_bonds => null () type ( ivector_t ) :: excl_atms integer :: iatm , jatm , jbnd , jbnd_atm1 , jbnd_atm2 integer :: j !Initialize table call itbl_init ( atat_tab , num_atoms ) !List of excluded atoms call ivector_init ( excl_atms ) do iatm = 1 , num_atoms call excl_atms % clear () !Get incident bonds call atbo_tab % get_row ( iatm , inc_bonds ) !Add atoms from each of the incident bonds, excluding iatom do j = 1 , size ( inc_bonds ) jbnd = inc_bonds ( j ) jbnd_atm1 = bonds ( 2 , jbnd ) jbnd_atm2 = bonds ( 3 , jbnd ) if ( jbnd_atm1 /= iatm ) call excl_atms % append ( jbnd_atm1 ) if ( jbnd_atm2 /= iatm ) call excl_atms % append ( jbnd_atm2 ) end do !Sort and remove duplicates. These are the atoms in the 1-ring. call excl_atms % unique () !Add to atat_tab. Note that iatm does not appear in the atat table !for iatm. do j = 1 , excl_atms % len jatm = excl_atms % get_val ( j ) call atat_tab % append ( iatm , jatm ) end do end do !Release additional memory call atat_tab % shrink_to_fit () end subroutine !******************************************************************************** subroutine exat_build () integer , dimension (:), pointer :: nbr_atms => null () integer , dimension (:), pointer :: nbr2_atms => null () integer , dimension (:), pointer :: nbr3_atms => null () type ( ivector_t ) :: excl_atms integer :: iatm , jatm , j2atm , j3atm integer :: j , j2 , j3 !Build atat_tab. This is the 1-ring neighborhood of each atom. call atat_build () call atat_tab % shrink_to_fit () !Debug statements !print*, 'ATAT_TAB' !call atat_tab%print() !Initialize table call itbl_init ( exat_tab , num_atoms ) !List of excluded atoms call ivector_init ( excl_atms ) do iatm = 1 , num_atoms call excl_atms % clear () if ( excluded_atoms > 0 ) then !Get atoms in 1-ring neighborhood call atat_tab % get_row ( iatm , nbr_atms ) !Add atoms to excluded atoms list. First adding iatm itself. call excl_atms % append ( iatm ) do j = 1 , size ( nbr_atms ) jatm = nbr_atms ( j ) call excl_atms % append ( jatm ) !Atoms for second ring neighbors if ( excluded_atoms > 1 ) then call atat_tab % get_row ( jatm , nbr2_atms ) do j2 = 1 , size ( nbr2_atms ) j2atm = nbr2_atms ( j2 ) call excl_atms % append ( j2atm ) !Atoms for third ring neighbors if ( excluded_atoms > 2 ) then call atat_tab % get_row ( j2atm , nbr3_atms ) do j3 = 1 , size ( nbr3_atms ) j3atm = nbr3_atms ( j3 ) call excl_atms % append ( j3atm ) end do !Finished adding all third ring neighbors end if end do !Finished adding all second ring neighbors end if !Finished adding all first ring neighbors end do end if !Sort and remove duplicates call excl_atms % unique () !Add to exat_tab. Note that iatom appears in the excluded atoms list for !iatom. do j = 1 , excl_atms % len jatm = excl_atms % get_val ( j ) call exat_tab % append ( iatm , jatm ) end do end do !Release additional memory call exat_tab % shrink_to_fit () !atat_tab no longer required call atat_tab % delete () end subroutine !******************************************************************************** end module m_connectivity","tags":"","loc":"sourcefile/m_connectivity.f90.html"},{"title":"m_constants_math.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_constants_math.f90~~EfferentGraph sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_constants_math.f90~~AfferentGraph sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_ia_external.f90->sourcefile~m_constants_math.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_constants_math.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_kmc.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_constants_math.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_stats_io.f90->sourcefile~m_constants_math.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_bd_solver.f90->sourcefile~m_constants_math.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~m_ia_angle.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_utils_math.f90 m_utils_math.f90 sourcefile~m_utils_math.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_mpcd.f90->sourcefile~m_constants_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_utils_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90->sourcefile~m_simbox.f90 sourcefile~m_setup.f90->sourcefile~m_stats_io.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_globals.f90 sourcefile~m_setup.f90->sourcefile~m_config_io.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_globals.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~m_control_io.f90 m_control_io.f90 sourcefile~main.f90->sourcefile~m_control_io.f90 sourcefile~m_config_io.f90->sourcefile~m_simbox.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90->sourcefile~m_stats_io.f90 sourcefile~m_relax.f90->sourcefile~m_globals.f90 sourcefile~m_relax.f90->sourcefile~m_config_io.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_control_io.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 var pansourcefilem_constants_mathf90AfferentGraph = svgPanZoom('#sourcefilem_constants_mathf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_constants_math Source Code m_constants_math.f90 Source Code module m_constants_math !! Various math constants. use m_precision implicit none real ( rp ), parameter :: math_third = 0.333333333333333_rp !>pi real ( rp ), parameter :: math_pi = 3.1415926535897931_rp !>pi divided by two real ( rp ), parameter :: math_pi_2 = 1.5707963267948966_rp !>pi divided by four real ( rp ), parameter :: math_pi_4 = 0.78539816339744828_rp !>reciprocal of pi real ( rp ), parameter :: math_1_pi = 0.31830988618379069_rp !>two times reciprocal of pi real ( rp ), parameter :: math_2_pi = 0.63661977236758138_rp !>two times the reciprocal of the square root of pi. real ( rp ), parameter :: math_2_sqrtpi = 1.1283791670955126_rp !>square root of two real ( rp ), parameter :: math_sqrt2 = 1.4142135623730951_rp !>cube root of two real ( rp ), parameter :: math_cbrt2 = 1.2599210498948732_rp !>sixth root of two real ( rp ), parameter :: math_sxrt2 = 1.122462048309373_rp !>reciprocal of the square root of two real ( rp ), parameter :: math_sqrt1_2 = 0.70710678118654746_rp !>square root of three real ( rp ), parameter :: math_sqrt3 = 1.7320508075688772_rp !>square root of M_E real ( rp ), parameter :: math_sqrt_e = 1.6487212707001282_rp !>square root of pi real ( rp ), parameter :: math_sqrt_pi = 1.7724538509055159_rp !>The base of natural logarithms real ( rp ), parameter :: math_e = 2.7182818284590451_rp !>The logarithm of M_E to base two real ( rp ), parameter :: math_log2e = 1.4426950408889634_rp !>The logarithm of M_E to base 10 real ( rp ), parameter :: math_log10e = 0.43429448190325182_rp !>The natural logarithm of two real ( rp ), parameter :: math_ln2 = 0.69314718055994529_rp !>The natural logarithm of 10 real ( rp ), parameter :: math_ln10 = 2.3025850929940459_rp end module m_constants_math","tags":"","loc":"sourcefile/m_constants_math.f90.html"},{"title":"m_control_io.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_control_io.f90~~EfferentGraph sourcefile~m_control_io.f90 m_control_io.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_control_io.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_control_io.f90->sourcefile~m_precision.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_control_io.f90->sourcefile~m_strings.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_control_io.f90~~AfferentGraph sourcefile~m_control_io.f90 m_control_io.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_control_io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_control_io Source Code m_control_io.f90 Source Code module m_control_io !! Routines for reading and witing control file. use m_precision use m_strings use m_globals implicit none contains !****************************************************************************** subroutine read_control ( fn ) !! Reads simulation parameters from file character ( len =* ), intent ( in ) :: fn !! Name of parameters file. character ( len = :), allocatable :: key character ( len = :), allocatable :: val character ( len = mxrdln ) :: line character ( len = 1 ) :: cstr = '#' !Comment string integer :: fu integer :: ios open ( newunit = fu , file = fn , action = 'read' , status = 'old' ) do call readline ( fu , line , cstr , ios ) if ( ios /= 0 ) return call str_get_keyval ( line , key , val ) if ( key == 'sim_style' ) read ( val , * ) sim_style if ( key == 'use_verlet_tab' ) read ( val , * ) use_verlet_tab if ( key == 'rcutoff' ) rcutoff = str_to_d ( val ) if ( key == 'tskin' ) tskin = str_to_d ( val ) if ( key == 'use_cell_list' ) read ( val , * ) use_cell_list if ( key == 'excluded_atoms' ) excluded_atoms = str_to_i ( val ) if ( key == 'lvdw' ) read ( val , * ) lvdw if ( key == 'lhdia' ) read ( val , * ) lhdia if ( key == 'mob_fctr' ) read ( val , * ) mob_fctr if ( key == 'lelectrostatics' ) read ( val , * ) lelectrostatics if ( key == 'tim_stp' ) tim_stp = str_to_d ( val ) if ( key == 'nts_md' ) nts_md = int ( str_to_d ( val )) if ( key == 'nts_log' ) nts_log = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_dump' ) nts_dump = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_samp' ) nts_samp = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_eql' ) nts_eql = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_eql_samp' ) nts_eql_samp = int ( str_to_d ( val ), ip_long ) if ( key == 'nts_sim' ) nts_sim = int ( str_to_d ( val ), ip_long ) if ( key == 'fn_cfg' ) fn_cfg = val if ( key == 'fn_revive' ) fn_revive = val if ( key == 'fn_stats' ) fn_stats = val if ( key == 'fn_traj' ) fn_traj = val if ( key == 'lrevive' ) read ( val , * ) lrevive if ( key == 'read_seed' ) read ( val , * ) read_seed if ( key == 'write_seed' ) read ( val , * ) write_seed if ( key == 'write_eql_stats' ) read ( val , * ) write_eql_stats if ( key == 'write_traj' ) read ( val , * ) write_traj if ( key == 'traj_frmcmp' ) read ( val , * ) traj_frmcmp if ( key == 'traj_wmpcd' ) read ( val , * ) traj_wmpcd end do close ( fu ) end subroutine !****************************************************************************** subroutine write_control ( fn ) !! Write simulation parameters to file character ( len =* ), intent ( in ) :: fn !! File name integer :: fu open ( newunit = fu , file = fn , action = 'write' , status = 'unknown' ) write ( fu , '(a,t20,a)' ) 'sim_style' , sim_style write ( fu , '(a,t20,l1)' ) 'use_verlet_tab' , use_verlet_tab write ( fu , '(a,t20,g0.6)' ) 'rcutoff' , rcutoff write ( fu , '(a,t20,g0.6)' ) 'tskin' , tskin write ( fu , '(a,t20,l1)' ) 'use_cell_list' , use_cell_list write ( fu , '(a,t20,i0)' ) 'excluded_atoms' , excluded_atoms write ( fu , '(a,t20,l1)' ) 'lvdw' , lvdw write ( fu , '(a,t20,l1)' ) 'lhdia' , lhdia write ( fu , '(a,t20,a)' ) 'mob_fctr' , mob_fctr write ( fu , '(a,t20,l1)' ) 'lelectrostatics' , lelectrostatics write ( fu , * ) write ( fu , '(a,t20,g0.6)' ) 'tim_stp' , tim_stp write ( fu , '(a,t20,i0)' ) 'nts_md' , nts_md write ( fu , '(a,t20,i0)' ) 'nts_log' , nts_log write ( fu , '(a,t20,i0)' ) 'nts_dump' , nts_dump write ( fu , '(a,t20,i0)' ) 'nts_samp' , nts_samp write ( fu , '(a,t20,i0)' ) 'nts_eql' , nts_eql write ( fu , '(a,t20,i0)' ) 'nts_eql_samp' , nts_eql_samp write ( fu , '(a,t20,i0)' ) 'nts_sim' , nts_sim write ( fu , * ) write ( fu , '(a,t20,a)' ) 'fn_cfg' , fn_cfg write ( fu , '(a,t20,a)' ) 'fn_revive' , fn_revive write ( fu , '(a,t20,a)' ) 'fn_stats' , fn_stats write ( fu , '(a,t20,a)' ) 'fn_traj' , fn_traj write ( fu , * ) write ( fu , '(a,t20,l1)' ) 'lrevive' , lrevive write ( fu , '(a,t20,l1)' ) 'read_seed' , read_seed write ( fu , '(a,t20,l1)' ) 'write_seed' , write_seed write ( fu , '(a,t20,l1)' ) 'write_eql_stats' , write_eql_stats write ( fu , '(a,t20,l1)' ) 'write_traj' , write_traj write ( fu , '(a,t20,*(i0,2x))' ) 'traj_frmcmp' , traj_frmcmp write ( fu , '(a,t20,l1)' ) 'traj_wmpcd' , traj_wmpcd close ( fu ) end subroutine !****************************************************************************** end module m_control_io","tags":"","loc":"sourcefile/m_control_io.f90.html"},{"title":"m_globals.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_globals.f90~~EfferentGraph sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_globals.f90~~AfferentGraph sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_bd_solver.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_globals.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90->sourcefile~m_stats_io.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_config_io.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_control_io.f90 m_control_io.f90 sourcefile~m_control_io.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_globals.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_control_io.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_relax.f90->sourcefile~m_globals.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90->sourcefile~m_stats_io.f90 sourcefile~m_relax.f90->sourcefile~m_config_io.f90 var pansourcefilem_globalsf90AfferentGraph = svgPanZoom('#sourcefilem_globalsf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_globals Source Code m_globals.f90 Source Code module m_globals !! Global variables, primarily dealing with system configuration !! and simulation execution. use m_precision use m_trajectory use m_simbox implicit none !General integer , parameter :: mxrdln = 1024 !! Maximum length of character string for input line buffer. integer , parameter :: mxparam = 12 !! Maximum number of parameters for bonds, angles, etc. !Simulation box type ( smbx_t ) :: simbox !! Simulation box. integer :: imcon = 0 !! Flag specifying boundary conditions on the simulation box. !! !! * *imcon = 0*: Unbounded domain. While not explicitly enforced this !!    is useful only for a single molecule. The dynamics is performed in the !!    c.o.m. frame of reference. !! !! * *imcon = 1*: PBC along *x*, *y*, & *z*. There are no restrictions on !!    the number of molecules. !Particle configuration: Atoms integer :: num_atom_types = 0 !! Number of *atom_type*s character ( len = 8 ), dimension (:), allocatable :: atom_names !! (*num_atom_types*,) array. Name of atoms of each type. integer , dimension (:), allocatable :: atom_styles !! (*num_atom_types*,) array. Style of atoms of each type. real ( rp ), dimension (:), allocatable :: atom_mass !! (*num_atom_types*,) array. Mass of atoms of each type. integer :: mpcd_avnc = 0 !! Average number of MPCD atoms per collision cell integer :: num_mpcd_atoms = 0 !!  Number of MPCD atoms integer :: num_atoms = 0 !!  Number of atoms (excluding MPCD atoms) integer :: num_atoms_tot = 0 !!  Total number of atoms (includes MPCD atoms) integer , dimension (:), allocatable :: atoms !! (*num_atoms*,) array. !! !! For atom *i*, its type *at = atoms(i)*, with style !! *atom_styles(at)*, name *atom_names(at)*, mass *atom_mass(at)*, charge !! *charge(i)*, position *coordinates(:,i)*, velocity *velocities(:,i)*, !! orientation (if the style requires) *orientations(:,i)*. The force acting on atom *i* !! is *forces(:,i)*. real ( rp ), dimension (:), allocatable :: charge !! (*num_atoms*,) array. real ( rp ), dimension (:,:), allocatable :: coordinates !!  (3, *num_atoms_tot*) array real ( rp ), dimension (:,:), allocatable :: orientation !!  (4, *num_atoms*) array real ( rp ), dimension (:,:), allocatable , target :: velocities !! (3, *num_atoms_tot*) array. The first *num_atoms* columns stores !! velocities of non-MPCD atoms, the rest, i.e *num_atoms+1* to !! *num_atoms_tot*, store velocities of MPCD atoms. real ( rp ), dimension (:,:), allocatable , target :: forces !!  (3, *num_atoms_tot*) array !Particle configuration: Bonds integer :: num_bond_types = 0 !!  Number of *bond_type*s integer , dimension (:), allocatable :: bond_styles !!  (*num_bond_types*,) array. real ( rp ), dimension (:,:), allocatable :: bond_params !!  (*mxparam*,*num_bond_types*) array. integer :: num_bonds = 0 !!  Total number of bonds. integer , dimension (:,:), allocatable :: bonds !! (3, *num_bonds*) array. Bond *i* is of type *bt = bonds(1,i)*,  directed from !! atom *bonds(2,i)* to *bonds(3,i)*. Its style is *bond_styles(bt)* with !! parameters *bond_params(:,bt)*. !Particle configuration: Angles integer :: num_angle_types = 0 !!  Number of *angle_type*s integer , dimension (:), allocatable :: angle_styles !!  (*num_angle_types*,) array real ( rp ), dimension (:,:), allocatable :: angle_params !!  (*mxparam*, *num_angle_types*) array integer :: num_angles = 0 !!  Number of angles integer , dimension (:,:), allocatable :: angles !! (4, *num_angles*) array. Angle *i* is of type *ant = angles(1,i)*, incident !! to atoms *angles(2,i)*, *angles(3,i)*, and *angles(4,i)*. Its style is !! *angle_styles(ant)* with parameters *angle_params(:,ant)*. !Particle configuration: Dihedrals integer :: num_dihedral_types = 0 !!  Number of *dihedral_type*s integer , dimension (:), allocatable :: dihedral_styles !!  (*num_dihedral_types*,) array real ( rp ), dimension (:,:), allocatable :: dihedral_params !!  (*mxparam*, *num_dihedral_types*) array integer :: num_dihedrals = 0 !!  Number of dihedrals integer , dimension (:,:), allocatable :: dihedrals !! (5, *num_dihedrals*) array. Dihedral *i* is of type *dt = dihedrals(1,i)*, incident !! to atoms *dihedrals(2,i)*, *dihedrals(3,i)*, *dihedrals(4,i)*, and *dihedrals(5,i)*. !! Its style is *dihedral_styles(dt)* with parameters *dihedral_params(:,dt)*. !Particle configuration: Branches integer :: num_branches = 0 !! Total number of branches (including the backbone) integer , dimension (:,:), allocatable :: branches !! (3,*num_branches*) array. Branch *i* is tethered to atom *branches(1,i)*, !! contains *branches(2,i)* atoms, with the beginning atom index *branches(3,i)*. !Particle configuration: Molecules integer :: num_molecule_types = 0 !!  Number of *molecule_type*s character ( len = 8 ), dimension (:), allocatable :: molecule_names !! (*num_molecule_types*,) array integer , dimension (:), allocatable :: molecule_pop !! (*num_molecule_types*,) array integer :: num_molecules = 0 !!  Number of molecules integer , dimension (:,:), allocatable :: molecules !! (9,*num_molecules*) array. For molecule *i*, its type *mt = molecules(1,i)*, !! containing *molecules(2,i)* atoms with beginning index *molecules(3,i)*, !! *molecules(4,i)* bonds with beginning index *molecules(5,i)*, !! *molecules(6,i)* angles with beginning index *molecules(7,i)*, and !! *molecules(8,i)* dihedrals with beginning index *molecules(9,i)*. real ( rp ), dimension ( 3 ) :: molecule_com = 0.0_rp !! Center of mass of the molecule. This is used only when imcon == 0, i.e. !! for a single molecule without periodic boundaries. !Particle configuration: Tethers integer :: num_tether_types = 0 !!  Number of *tether_type*s integer , dimension (:), allocatable :: tether_styles !!  (*num_tether_types*,) array real ( rp ), dimension (:,:), allocatable :: tether_params !!  (*mxparam*, *num_tether_types*) array integer :: num_tethers = 0 !!  Number of tethers integer , dimension (:,:), allocatable :: tethers !! (2, *num_tethers*) array. Tether *i* is of type *tt = tethers(1,i)*, tethering !! atom *tethers(2,i)* to a point *tether_points(:,i)*. !! Its style is *tether_styles(tt)* with parameters *tether_params(:,tt)*. real ( rp ), dimension (:,:), allocatable :: tether_points !!  (3, *num_tethers*) array !Particle configuration: VDW (pair) interactions integer :: num_vdw_types = 0 !!  Number of *vdw_type*s integer , dimension (:), allocatable :: vdw_styles !!  (*num_vdw_types*,) array real ( rp ), dimension (:,:), allocatable :: vdw_params !!  (*mxparam*, *num_vdw_types*) array integer , dimension (:,:), allocatable :: vdw_pairs !!  (2, *num_vdw_types*) array. Stores atom type of interacting pairs, such !! that at_i >= at_j. !Particle configuration: External force field integer :: num_externals = 0 !!  Number of external fields integer , dimension (:), allocatable :: external_styles !!  (*num_external*,) array real ( rp ), dimension (:,:), allocatable :: external_params !!  (*mxparam*, *num_external*) array !Particle configuration: Flow field integer :: flow_style = 0 real ( rp ), dimension (:), allocatable :: flow_params !!  (*mxparam*,) array !End of configuration related globals !Variables controlling runtime behavior integer :: sim_style = 1 !! '0': Structure relaxation, '1' : Brownian dynamics, '2' : MPCD logical :: leql = . true . !! Is the system equilibrating? {T, F} logical :: lrevive = . false . !! Is this a restart run? {T, F}. real ( rp ) :: tim_stp !! BD/MPCD time step size integer ( ip_long ) :: nts !! Counter for BD/MPCD time steps integer ( ip ) :: nts_md = 1 !! Number of MD steps per MPCD step integer ( ip_long ) :: nts_log = 1 !! Interval for logging (in BD time steps) integer ( ip_long ) :: nts_dump = 1 !! Interval for dumping to revive file (in BD time steps) integer ( ip_long ) :: nts_samp = 1 !! Interval for sampling statistics (in BD time steps) integer ( ip_long ) :: nts_eql = 0 !! Number of BD time steps for equilibration integer ( ip_long ) :: nts_eql_samp = 1 !! Sampling interval during equilibration (in BD time steps) integer ( ip_long ) :: nts_sim = 0 !! Total number of BD time steps in production run logical :: use_verlet_tab = . false . !! Use Verlet neighbor table? {T, F} real ( rp ) :: rcutoff = 0.0_rp !! Cut off for short-ranged interaction. Also used as the radius of the !! skin sphere for short-ranged forces real ( rp ) :: tskin = 0.0_rp !!  Thickness of the skin sphere (same for all) logical :: use_cell_list = . false . !! Use cell list for short-range interactions? {T, F} !End of Variables controlling runtime behavior !Variables for I/O character ( len = :), allocatable :: fn_cfg !! Name of the file containing the initial configuration character ( len = :), allocatable :: fn_revive !! Name of the revive file character ( len = :), allocatable :: fn_traj !! Name of the trajectory file character ( len = :), allocatable :: fn_stats !! Name of the statistics file type ( trajectory_t ) :: traj !! Trajectory object character ( len = 8 ) :: job_tag = '' !! A tag useful for array jobs, available only as a command line argument logical :: read_seed = . false . !! {T, F} !! !! Whether to initialize the random number generator by reading a seed from !! a file. If `read_seed` == T, the seed will be read from a file !! 'random_seed.txt' logical :: write_seed = . false . !! {T, F} !! !!  Whether to write the random number generator seed. If !!  `write_seed` == T the seed will be written to a file named !!  'random_seed.txt' logical :: write_eql_stats = . false . !! During equilibration, should the statistics file be written? {T, F} logical :: write_traj = . false . !! Should the trajectory be written to file? {T, F} integer , dimension ( 4 ) :: traj_frmcmp = 0 !! Control for what gets written to a trajectory frame. !! 1: coordinates; 2: velocities; 3: forces; 4: charge logical :: traj_wmpcd = . false . !! Depending on the values in *traj_frmcmp*, whether the corresponding !! quantities for the MPCD atoms are written as well. !End of variables for I/O !Miscellaneous variables real ( rp ), dimension ( 3 , 3 ) :: stress = 0.0_rp !! Stress tensor due to non-MPCD atoms real ( rp ), dimension ( 3 , 3 ) :: stress_slvnt = 0.0_rp !! Stress tensor due to MPCD atoms (solvent) real ( rp ) :: energy_kin = 0.0_rp !! Kinetic energy real ( rp ) :: energy_bond = 0.0_rp !! Bond energy real ( rp ) :: energy_angle = 0.0_rp !! Angle energy real ( rp ) :: energy_dihedral = 0.0_rp !! Dihedral energy real ( rp ) :: energy_vdw = 0.0_rp !! vdw interaction energy real ( rp ) :: energy_tether = 0.0_rp !! Energetic contribution from tethers real ( rp ) :: energy_external = 0.0_rp !! Energetic contribution from external fields real ( rp ) :: energy_tot = 0.0_rp !! Total energy real ( rp ) :: bndlen = 0.0_rp !! Average bond length real ( rp ) :: bndlen_min = 0.0_rp !! Minimum bond length real ( rp ) :: bndlen_max = 0.0_rp !! Maximum bond length integer :: excluded_atoms = 0 !! Control for excluded atoms in vdw calculation. !! 0: No exclusion, 1: exclude 1-ring bonded neighbors, !! 2: exclude 2-ring bonded neighbors, 3: exclude 3-ring bonded neighbors. logical :: lvdw = . true . !! Whether to calculate VDW interactions character ( len = 4 ) :: mob_fctr !! Factorization method for mobility matrix {'CHOL', 'KRYL'} logical :: lhdia = . true . !! Whether to include hydrodynamic interactions in BD logical :: lelectrostatics = . false . !! Whether to calculate electrostatic interactions !End of miscellaneous variables end module m_globals","tags":"","loc":"sourcefile/m_globals.f90.html"},{"title":"m_ia_angle.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_ia_angle.f90~~EfferentGraph sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_ia_angle.f90->sourcefile~m_constants_math.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_ia_angle.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_ia_angle.f90~~AfferentGraph sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_ia_angle Source Code m_ia_angle.f90 Source Code module m_ia_angle !! Angle potentials !! !! * Style 0: None (Only topology) !! * Style 1: Cosine. See [[ang_cos_set]]. use m_precision use m_constants_math use m_globals implicit none private public :: ia_angle_setup , ia_get_angle_force contains !****************************************************************************** subroutine ia_angle_setup () !! Sets up parameters for angle potentials integer :: i integer :: sty !Set angular interactions do i = 1 , num_angle_types sty = angle_styles ( i ) select case ( sty ) case ( 1 ) call ang_cos_set ( angle_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_angle_force ( q1 , q2 , typ , enrg , fim1 , fi , fip1 ) !! Calculates the energy & force due to an angle. real ( rp ), dimension ( 3 ), intent ( in ) :: q1 real ( rp ), dimension ( 3 ), intent ( in ) :: q2 integer , intent ( in ) :: typ real ( rp ), intent ( out ) :: enrg real ( rp ), dimension ( 3 ), intent ( out ) :: fim1 real ( rp ), dimension ( 3 ), intent ( out ) :: fi real ( rp ), dimension ( 3 ), intent ( out ) :: fip1 real ( rp ), dimension ( 3 ) :: q1hat , q2hat real ( rp ) :: kang real ( rp ) :: q1mag , q2mag , ctheta integer :: styl q1mag = norm2 ( q1 ); q2mag = norm2 ( q2 ) q1hat = q1 / q1mag ; q2hat = q2 / q2mag ctheta = dot_product ( q1hat , q2hat ) !Floating point correction if ( ctheta > 1.0_rp ) ctheta = 1.0_rp if ( ctheta < - 1.0_rp ) ctheta = - 1.0_rp styl = angle_styles ( typ ) select case ( styl ) case ( 1 ) kang = angle_params ( 1 , typ ) enrg = kang * ( 1.0_rp - ctheta ) fim1 = kang * ( - q2hat + ctheta * q1hat ) / q1mag fip1 = kang * ( q1hat - ctheta * q2hat ) / q2mag fi = - ( fim1 + fip1 ) case default continue end select end subroutine !******************************************************************************** subroutine ang_cos_set ( params , k ) !! Setter for angular cosine interaction. !! !!``` !!   U(theta) = k*(1 - cos theta), !!   where theta is the complementary angle between bonds i & (i+1). !!``` !! User-set parameters: !! !! params(1) = `k` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k if ( present ( k )) params ( 1 ) = k end subroutine !****************************************************************************** end module m_ia_angle","tags":"","loc":"sourcefile/m_ia_angle.f90.html"},{"title":"m_ia_bond.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_ia_bond.f90~~EfferentGraph sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_ia_bond.f90->sourcefile~m_precision.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_constants_math.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_ia_bond.f90->sourcefile~m_strings.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_ia_bond.f90->sourcefile~m_logger.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_ia_bond.f90~~AfferentGraph sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_ia_bond Source Code m_ia_bond.f90 Source Code module m_ia_bond !! This module contains routines to evaluate bond potentials and their !! derivative. !! !! The following styles are available: !! !! * Style 0. None (only topology) !! * Style 1. Harmonic. See [[bond_harm_set]]. !! * Style 2. FENE. See [[bond_fene_set]]. !! * Style 3. Kremer-Grest. See [[bond_kg_set]]. !! * Style 4. Marko-Siggia. See [[bond_ms_set]]. use m_precision use m_constants_math use m_strings use m_globals use m_logger , only : logger_init , logger => master_logger implicit none private public :: ia_bond_setup , ia_get_bond_force contains !****************************************************************************** subroutine ia_bond_setup () !! Sets up parameters for bond potentials integer :: i integer :: sty !Set bond interactions do i = 1 , num_bond_types sty = bond_styles ( i ) select case ( sty ) case ( 1 ) call bond_harm_set ( bond_params (:, i )) case ( 2 ) call bond_fene_set ( bond_params (:, i )) case ( 3 ) call bond_kg_set ( bond_params (:, i )) case ( 4 ) call bond_ms_set ( bond_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_bond_force ( rij_mag , bnd_typ , enrg , frc , ierr ) !! Calculates the energy & its derivative due to a bond. real ( rp ), intent ( in ) :: rij_mag !! Distance between bonded atoms integer , intent ( in ) :: bnd_typ !! Type of the bond real ( rp ), intent ( out ) :: enrg !! Bond energy real ( rp ), intent ( out ) :: frc !! Derivative of the potential. This is the magnitude of the force due !! to this potential. integer , intent ( out ) :: ierr !! Error flag integer :: bnd_styl ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp bnd_styl = bond_styles ( bnd_typ ) select case ( bnd_styl ) case ( 1 ) call bond_harm ( rij_mag , bond_params (:, bnd_typ ), enrg , frc ) case ( 2 ) call bond_fene ( rij_mag , bond_params (:, bnd_typ ), enrg , frc , ierr ) case ( 3 ) call bond_kg ( rij_mag , bond_params (:, bnd_typ ), enrg , frc , ierr ) case ( 4 ) call bond_ms ( rij_mag , bond_params (:, bnd_typ ), enrg , frc , ierr ) case default continue end select end subroutine !******************************************************************************** subroutine bond_harm_set ( params , k , r0 ) !! Setter for harmonic bond interaction. !! !!``` !!  U = (1/2)*k*(r - r0)&#94;2 !!``` !! User-set parameters: !! !! * params(1) = `k` (spring constant) !! * params(2) = `r0` (equilibrium distance) real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: r0 if ( present ( k )) params ( 1 ) = k if ( present ( r0 )) params ( 2 ) = r0 end subroutine !******************************************************************************** subroutine bond_harm ( r , params , enrg , frc ) !! Calculates energy & its derivative for harmonic bond. See [[bond_harm_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc enrg = 0.5_rp * params ( 1 ) * ( r - params ( 2 )) * ( r - params ( 2 )) frc = params ( 1 ) * ( r - params ( 2 )) end subroutine !******************************************************************************** subroutine bond_fene_set ( params , k , rmax , r0 ) !! Setter for FENE bond. !! !!``` !!  U = -0.5 k rmax&#94;2 log [1 - ((r - r0)/rmax)&#94;2] !!``` !! !! User-set parameters: !! !! * params(1) = `k` !! * params(2) = `rmax` !! * params(3) = `r0` !! !! @Note The bond cannot extend beyond (rmax+r0), where r0 is the !! equilibrium bond length. If r0 = 0, this reduces to the standard definition !! of FENE bonds. !! !! Internally stored parameters: !! !! * params(4) = `rmax&#94;2` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: rmax real ( rp ), intent ( in ), optional :: r0 if ( present ( k )) params ( 1 ) = k if ( present ( rmax )) params ( 2 ) = rmax if ( present ( r0 )) params ( 3 ) = r0 params ( 4 ) = params ( 2 ) * params ( 2 ) end subroutine !******************************************************************************** subroutine bond_fene ( r , params , enrg , frc , ierr ) !! Calculates energy & its derivative for FENE bond. See [[bond_fene_set]]. !! !! If bond length exceeds maximum extensible spring length, an error will be !! reported by `ierr = 1`. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr real ( rp ) :: k , rmax , r0 real ( rp ) :: extn , extnsq , rmaxsq ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp k = params ( 1 ); rmax = params ( 2 ); r0 = params ( 3 ); rmaxsq = params ( 4 ) extn = r - r0 ; extnsq = extn * extn if ( r >= ( rmax + r0 ) ) then ierr = 1 call logger % fatal ( 'bond_fene' , 'bondlength too large' ) call logger % info ( 'bond_fene' , 'r = ' // str_from_num ( r )) return else enrg = - 0.5_rp * k * rmaxsq * log ( 1.0_rp - extnsq / rmaxsq ) frc = k * extn / ( 1.0_rp - extnsq / rmaxsq ) end if end subroutine !****************************************************************************** subroutine bond_kg_set ( params , k , rmax , eps , sigma ) !! Setter for FENE bond interaction. !! !!``` !!   V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] + eps !!   W = -0.5 k rmax&#94;2 log [1 - (r/rmax)&#94;2] !!   U = W + V, r < 2&#94;(1/6)*sigma !!       W, r >= 2&#94;(1/6)*sigma !!``` !! User-set parameters: !! !! * params(1) = `k` !! * params(2) = `rmax` !! * params(3) = `eps` !! * params(4) = `sigma` !! !! Internally stored parameters: !! !! * params(5) = `rmax&#94;2` !! * params(6) = `2&#94;(1/6)*sigma` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: rmax real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ) :: k_ , rmax_ , eps_ , sigma_ if ( present ( k )) params ( 1 ) = k if ( present ( rmax )) params ( 2 ) = rmax if ( present ( eps )) params ( 3 ) = eps if ( present ( sigma )) params ( 4 ) = sigma k_ = params ( 1 ); rmax_ = params ( 2 ); eps_ = params ( 3 ); sigma_ = params ( 4 ) params ( 5 ) = rmax_ ** 2 params ( 6 ) = math_sxrt2 * sigma_ end subroutine !******************************************************************************** subroutine bond_kg ( r , params , enrg , frc , ierr ) !! Calculates energy & its derivative for Kremer-Grest bond. See [[bond_kg_set]]. !! !! If bond length exceeds maximum extensible spring length, an error will be !! reported as `ierr = 1`. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr real ( rp ) :: k , rmax , eps , sigma real ( rp ) :: rmaxsq , rcut real ( rp ) :: rsq , sir , sir2 , sir12 , sir6 ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp k = params ( 1 ); rmax = params ( 2 ); eps = params ( 3 ); sigma = params ( 4 ) rmaxsq = params ( 5 ); rcut = params ( 6 ) rsq = r * r if ( r >= rmax ) then ierr = 1 call logger % fatal ( 'bond_kg' , 'r > rmax' ) call logger % info ( 'bond_kg' , 'r = ' // str_from_num ( r )) return else if ( ( r >= rcut ) . and . ( r < rmax ) ) then enrg = - 0.5_rp * k * rmaxsq * log ( 1.0_rp - rsq / rmaxsq ) frc = k * r / ( 1.0_rp - rsq / rmaxsq ) else sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = - 0.5_rp * k * rmaxsq * log ( 1.0_rp - rsq / rmaxsq ) & + 4 * eps * ( sir12 - sir6 ) + eps frc = k * r / ( 1.0_rp - rsq / rmaxsq ) - 24 * eps * ( 2 * sir12 - sir6 ) / r end if end subroutine !****************************************************************************** subroutine bond_ms_set ( params , lp , rmax ) !! Setter for Marko-Siggia bond. !! !!``` !!   U = [-(1/2)*rtilde&#94;2 + 0.25/(1-rtilde)&#94;2 + 0.25*rtilde]*(rmax/lp), r < rmax !!   where rtilde = r/rmax. !!``` !! !! User-set parameters: !! !! * params(1) = `lp` (persistence length) !! * params(2) = `rmax` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: lp real ( rp ), intent ( in ), optional :: rmax if ( present ( lp )) params ( 1 ) = lp if ( present ( rmax )) params ( 2 ) = rmax end subroutine !******************************************************************************** subroutine bond_ms ( r , params , enrg , frc , ierr ) !! Evaluates the potential & its derivative for Marko-Siggia bond. !! See [[bond_ms_set]]. !! !! If bond length exceeds maximum extensible spring length, an error will be !! reported as `ierr = 1`. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr real ( rp ) :: lp , rmax , rtilde , rrtilde ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp lp = params ( 1 ); rmax = params ( 2 ) if ( r >= rmax ) then ierr = 1 call logger % fatal ( 'bond_kg' , 'r > rmax' ) call logger % info ( 'bond_kg' , 'r = ' // str_from_num ( r )) return else rtilde = r / rmax ; rrtilde = 1.0_rp / ( 1.0_rp - rtilde ) enrg = ( - 0.5 * rtilde * rtilde + 0.25_rp * rrtilde * rrtilde + 0.25 * rtilde ) * ( rmax / lp ) frc = ( - rtilde - 0.25_rp * rrtilde * rrtilde + 0.25_rp ) / lp end if end subroutine !****************************************************************************** end module m_ia_bond","tags":"","loc":"sourcefile/m_ia_bond.f90.html"},{"title":"m_ia_dihedral.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_ia_dihedral.f90~~EfferentGraph sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_constants_math.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_ia_dihedral.f90~~AfferentGraph sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_ia_dihedral Source Code m_ia_dihedral.f90 Source Code module m_ia_dihedral !! Dihedral potentials (none implemented) use m_precision use m_constants_math use m_globals implicit none private public :: ia_dihedral_setup , ia_get_dihedral_force contains !****************************************************************************** subroutine ia_dihedral_setup () !! Sets up parameters for dihedral potentials integer :: i integer :: sty !Set dihedral interactions do i = 1 , num_dihedral_types sty = dihedral_styles ( i ) select case ( sty ) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_dihedral_force ( q1 , q2 , q3 , typ , enrg , fi , fj , fk , fl ) !! Calculates the force & energy due to a dihedral. real ( rp ), dimension ( 3 ), intent ( in ) :: q1 real ( rp ), dimension ( 3 ), intent ( in ) :: q2 real ( rp ), dimension ( 3 ), intent ( in ) :: q3 real ( rp ), dimension ( 3 ), intent ( out ) :: fi real ( rp ), dimension ( 3 ), intent ( out ) :: fj real ( rp ), dimension ( 3 ), intent ( out ) :: fk real ( rp ), dimension ( 3 ), intent ( out ) :: fl integer , intent ( in ) :: typ real ( rp ), intent ( out ) :: enrg integer :: dhd_styl enrg = 0.0_rp fi = 0.0_rp ; fj = 0.0_rp ; fk = 0.0_rp ; fl = 0.0_rp dhd_styl = dihedral_styles ( typ ) select case ( dhd_styl ) case default continue end select end subroutine !****************************************************************************** end module m_ia_dihedral","tags":"","loc":"sourcefile/m_ia_dihedral.f90.html"},{"title":"m_ia_external.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_ia_external.f90~~EfferentGraph sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_ia_external.f90->sourcefile~m_constants_math.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_ia_external.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_ia_external.f90~~AfferentGraph sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_ia_external Source Code m_ia_external.f90 Source Code module m_ia_external !! External potentials !! !! This module is meant to be a placeholder to any external fields that the user !! wants to add. Accordingly replace/add to the existing routines. The !! subroutines [[ia_external_setup]] and [[ia_add_external_forces]] must remain !! for interfacing to the force calculation driver routine [[ia_calc_forces]]. !! !! * Style 0: None !! * Style 1: Pulling force along +ve x-axis !! * Style 2: Hard planar wall use m_precision use m_constants_math use m_globals implicit none private public :: ia_external_setup , ia_add_external_forces contains !****************************************************************************** subroutine ia_external_setup () !! Sets up parameters for external potentials. Usually there is nothing to !! set for externals, but this acts as a placeholder for special cases. integer :: i integer :: sty !Set external interactions do i = 1 , num_externals sty = external_styles ( i ) select case ( sty ) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_add_external_forces ( ierr ) !! Calculates the force and energy due to an external field and adds to !! `energy_external`, 'forces`, & `stress` in module `m_globals`. integer , intent ( out ) :: ierr real ( rp ) :: enrg real ( rp ) :: frcx , v , sn integer :: iext integer :: styl , iatm , m ierr = 0 do iext = 1 , num_externals styl = external_styles ( iext ) select case ( styl ) case ( 1 ) ! Pulling force along +ve x-axis. iatm = int ( external_params ( 1 , iext )) frcx = external_params ( 2 , iext ) enrg = - frcx * ( coordinates ( 1 , iatm ) - coordinates ( 1 , 1 )) energy_external = energy_external + enrg forces ( 1 , iatm ) = forces ( 1 , iatm ) + frcx case ( 2 ) ! Rigid walls. Need to modify this (or another case) for repulsive walls. enrg = 0.0_rp m = int ( external_params ( 1 , iext )) v = external_params ( 2 , iext ) sn = external_params ( 3 , iext ) if ( sn > 0.0_rp ) then if ( any ( coordinates ( m ,:) < v ) ) ierr = 1 else if ( any ( coordinates ( m ,:) > v ) ) ierr = 1 end if case default continue end select end do !Need to update stress end subroutine !****************************************************************************** end module m_ia_external","tags":"","loc":"sourcefile/m_ia_external.f90.html"},{"title":"m_ia_tether.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_ia_tether.f90~~EfferentGraph sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_ia_tether.f90->sourcefile~m_constants_math.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_ia_tether.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_ia_tether.f90~~AfferentGraph sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_ia_tether Source Code m_ia_tether.f90 Source Code module m_ia_tether !! Tether potentials !! !! *Style 0: None !! *Style 1: Rigid connector (not implemented) !! *Style 2: Harmonic spring. See [[teth_harm_set]]. use m_precision use m_constants_math use m_globals implicit none private public :: ia_tether_setup , ia_get_tether_force contains !****************************************************************************** subroutine ia_tether_setup () !! Sets up parameters for tether potentials integer :: i integer :: sty !Set tether interactions do i = 1 , num_tether_types sty = tether_styles ( i ) select case ( sty ) case ( 1 ) call teth_rigid_set ( tether_params (:, i )) case ( 2 ) call teth_harm_set ( tether_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_tether_force ( qmag , teth_typ , enrg , frc , ierr ) !! Calculates the energy and its derivative due to a tether. real ( rp ), intent ( in ) :: qmag !! Distance between the tethered atom & the tether point integer , intent ( in ) :: teth_typ real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr integer :: teth_styl ierr = 0 enrg = 0.0_rp ; frc = 0.0_rp teth_styl = tether_styles ( teth_typ ) select case ( teth_styl ) case ( 1 ) call teth_rigid ( qmag , tether_params (:, teth_typ ), enrg , frc , ierr ) case ( 2 ) call teth_harm ( qmag , tether_params (:, teth_typ ), enrg , frc ) case default continue end select end subroutine !******************************************************************************** subroutine teth_rigid_set ( params , r0 , eps ) !! Setter for rigid tether interaction. !! !! User-set parameters: !! !! * params(1) = `r0` (fixed separation distance) !! * params(2) = `eps` (allowed tolerance) real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: r0 real ( rp ), intent ( in ), optional :: eps if ( present ( r0 )) params ( 1 ) = r0 if ( present ( eps )) params ( 2 ) = eps end subroutine !******************************************************************************** subroutine teth_rigid ( r , params , enrg , frc , ierr ) !! Not implemented, needs constraint formalism. See [[teth_rigid_set]]. !! !! Calculates energy for rigid tether interaction. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc integer , intent ( out ) :: ierr ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp if ( abs ( r - params ( 1 )) < params ( 2 ) ) then enrg = 0.0_rp ; frc = 0.0_rp else ierr = 1 return end if end subroutine !******************************************************************************** !params(1) = k, params(2) = r0 (equilibrium distance) subroutine teth_harm_set ( params , k , r0 ) !! Setter for harmonic tether interaction. !! !!``` !!  U = (1/2)*k*(r - r0)&#94;2 !!``` !! User-set parameters: !! !! * params(1) = `k` (spring constant) !! * params(2) = `r0` (equilibrium distance) real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: k real ( rp ), intent ( in ), optional :: r0 if ( present ( k )) params ( 1 ) = k if ( present ( r0 )) params ( 2 ) = r0 end subroutine !******************************************************************************** subroutine teth_harm ( r , params , enrg , frc ) !! Calculates energy and its derivative for harmonic tether interaction. See !! [[teth_harm_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc enrg = 0.5_rp * params ( 1 ) * ( r - params ( 2 )) * ( r - params ( 2 )) frc = params ( 1 ) * ( r - params ( 2 )) end subroutine !****************************************************************************** end module m_ia_tether","tags":"","loc":"sourcefile/m_ia_tether.f90.html"},{"title":"m_ia_vdw.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_ia_vdw.f90~~EfferentGraph sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_constants_math.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_logger.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_ia_vdw.f90~~AfferentGraph sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_ia_vdw Source Code m_ia_vdw.f90 Source Code module m_ia_vdw !! Routines to evaulate pairwise potentials and their derivative. !! !! The following styles are available: !! !! * Style 1. 12-6 LJ (cut & shifted). See [[vdw_lj_set]]. !! * Style 2. Gaussian (cut & shifted). See [[vdw_gaussian_set]]. !! * Style 3. Cosine. See [[vdw_cosine_set]]. !! * Style 4. Screened Coulomb + LJ (cut & shifted). See [[vdw_lj_coul_debye_set]]. !! * Style 5. Coulomb + LJ (cut & shifted) See [[vdw_lj_coul_set]]. use m_precision use m_constants_math use m_globals use m_logger , only : logger_init , logger => master_logger implicit none private public :: ia_vdw_setup , ia_get_vdw_force contains !****************************************************************************** subroutine ia_vdw_setup () !! Sets up parameters for vdw potentials integer :: i integer :: sty !Set vdw interactions do i = 1 , num_vdw_types sty = vdw_styles ( i ) select case ( sty ) case ( 1 ) call vdw_lj_set ( vdw_params (:, i )) case ( 2 ) call vdw_gaussian_set ( vdw_params (:, i )) case ( 3 ) call vdw_cosine_set ( vdw_params (:, i )) case ( 4 ) call vdw_lj_coul_debye_set ( vdw_params (:, i )) case ( 5 ) call vdw_lj_coul_set ( vdw_params (:, i )) case default continue end select end do end subroutine !****************************************************************************** subroutine ia_get_vdw_force ( rij_mag , qi , qj , typ , enrg , frc , ierr ) !! Calculates the energy & its derivative due to a single interacting pair of atoms. real ( rp ), intent ( in ) :: rij_mag !! Distance between two atoms real ( rp ), intent ( in ) :: qi !! Charge on atom i real ( rp ), intent ( in ) :: qj !! Charge on atom j integer , intent ( in ) :: typ !! Type of vdw interaction real ( rp ), intent ( out ) :: enrg !! Energy real ( rp ), intent ( out ) :: frc !! Derivative of the potential. This is the magnitude of force due to !! this potential. integer , intent ( out ) :: ierr !! Error flag integer :: styl ierr = 0 ; enrg = 0.0_rp ; frc = 0.0_rp styl = vdw_styles ( typ ) select case ( styl ) case ( 1 ) call vdw_lj ( rij_mag , vdw_params (:, typ ), enrg , frc ) case ( 2 ) call vdw_gaussian ( rij_mag , vdw_params (:, typ ), enrg , frc ) case ( 3 ) call vdw_cosine ( rij_mag , vdw_params (:, typ ), enrg , frc ) case ( 4 ) call vdw_lj_coul_debye ( rij_mag , qi * qj , vdw_params (:, typ ), enrg , frc ) case ( 5 ) call vdw_lj_coul ( rij_mag , qi * qj , vdw_params (:, typ ), enrg , frc ) case default continue end select end subroutine !****************************************************************************** subroutine vdw_lj_set ( params , eps , sigma , rcut ) !! Setter for 12-6 LJ (cut & shifted) interaction. !! !!``` !!   V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] !!   U = V - V(rcut), r < rcut !!       0, r >= rcut !!``` !! User-set parameters: !! !! * params(1) = `eps` !! * params(2) = `sigma` !! * params(3) = `rcut` !! !! Internally stored parameters: !! !! * params(4) = `V(rcut)` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ), intent ( in ), optional :: rcut real ( rp ) :: eps_ , sigma_ , rcut_ real ( rp ) :: pot_rcut real ( rp ) :: sir , sir2 , sir6 , sir12 if ( present ( eps )) params ( 1 ) = eps if ( present ( sigma )) params ( 2 ) = sigma if ( present ( rcut )) params ( 3 ) = rcut eps_ = params ( 1 ); sigma_ = params ( 2 ); rcut_ = params ( 3 ) sir = sigma_ / rcut_ sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 pot_rcut = 4 * eps_ * ( sir12 - sir6 ) params ( 4 ) = pot_rcut end subroutine !****************************************************************************** pure subroutine vdw_lj ( r , params , enrg , frc ) !! Evaluates the potential and its derivative for LJ interaction. See !! [[vdw_lj_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: eps , sigma , rcut real ( rp ) :: pot_rcut real ( rp ) :: sir , sir2 , sir6 , sir12 enrg = 0.0_rp ; frc = 0.0_rp eps = params ( 1 ); sigma = params ( 2 ); rcut = params ( 3 ) pot_rcut = params ( 4 ) if ( r < rcut ) then sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = 4 * eps * ( sir12 - sir6 ) - pot_rcut frc = - 24 * eps * ( 2 * sir12 - sir6 ) / r end if end subroutine !****************************************************************************** subroutine vdw_gaussian_set ( params , A , B , rcut ) !! Setter for gaussian interaction. !! !!``` !!   V = A*exp(-B*r&#94;2) !!   U = V - V(rcut), r < rcut !!   0, r >= rcut !!``` !! User-set parameters: !! !! * params(1) = `A` !! * params(2) = `B` !! * params(3) = `rcut` !! !! Internally stored parameters: !! !! * params(4) = `V(rcut)` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: A real ( rp ), intent ( in ), optional :: B real ( rp ), intent ( in ), optional :: rcut real ( rp ) :: pot_rcut if ( present ( A )) params ( 1 ) = A if ( present ( B )) params ( 2 ) = B if ( present ( rcut )) params ( 3 ) = rcut pot_rcut = params ( 1 ) * exp ( - params ( 2 ) * params ( 3 ) ** 2 ) params ( 4 ) = pot_rcut end subroutine !****************************************************************************** pure subroutine vdw_gaussian ( r , params , enrg , frc ) !! Calculates energy & its derivative for gaussian interaction. See !! [[vdw_gaussian_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: A , B , rcut , pot_rcut enrg = 0.0_rp ; frc = 0.0_rp A = params ( 1 ); B = params ( 2 ); rcut = params ( 3 ); pot_rcut = params ( 4 ) if ( r < rcut ) then enrg = A * exp ( - B * r * r ) - pot_rcut frc = - 2 * A * B * r * exp ( - B * r * r ) end if end subroutine !****************************************************************************** subroutine vdw_cosine_set ( params , A , rcut ) !! Setter for cosine interaction. !! !!``` !!   U = A*cos(pi*r/rcut) !!``` !! !! User-set parameters: !! !! * params(1) = `A` !! * params(2) = `rcut` !! !! Internally stored parameters: !! !! * params(3) = `pi/rcut` !! * params(4) = `pi*A/rcut` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: A real ( rp ), intent ( in ), optional :: rcut if ( present ( A )) params ( 1 ) = A if ( present ( rcut )) params ( 2 ) = rcut params ( 3 ) = math_pi / params ( 2 ) params ( 4 ) = params ( 3 ) * params ( 1 ) end subroutine !****************************************************************************** pure subroutine vdw_cosine ( r , params , enrg , frc ) !! Evaluates the potential and its derivative for  cosine interaction. !! See [[vdw_cosine_set]]. real ( rp ), intent ( in ) :: r real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: A , rcut enrg = 0.0_rp ; frc = 0.0_rp A = params ( 1 ); rcut = params ( 2 ) if ( r < rcut ) then enrg = params ( 1 ) * ( 1.0_rp + cos ( params ( 3 ) * r ) ) frc = - params ( 4 ) * sin ( params ( 3 ) * r ) end if end subroutine !****************************************************************************** subroutine vdw_lj_coul_debye_set ( params , eps , sigma , rcut , rcut_coul , C , kappa ) !! Setter for 12-6 LJ with screened Coulombic interaction. !! !!``` !! V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] !! W = C*qi*qj*exp(-kappa*r)/r !! if rcut_coul > 0: !!     U = V - V(rcut) + W - W(rcut_coul), r < rcut !!         W - W(rcut_coul), rcut <= r < rcut_coul !!         0, r >= rcut_coul !! if rcut_coul <= 0: !!     U = V - V(rcut) + W, r < rcut !!         W, r >= rcut !!``` !! !!- The LJ potential `V` is cut & shifted at `r = rcut`. !!- If `rcut_coul > 0`, the screened Coulombic potential `W` is cut & shifted !! at `r = rcut_coul`. !!- If `rcut_coul <= 0`, no cutoff is applied on `W`. !!- `rcut_coul` must be >= `rcut`. !! !! User-set parameters: !! !! * params(1) = `eps` !! * params(2) = `sigma` !! * params(3) = `rcut` !! * params(4) = `rcut_coul` !! * params(5) = `C` !! * params(6) = `kappa` !! !! Internally stored parameters: !! !! * params(7) = `V(rcut)` !! * params(8) = `C*exp(-kappa*rcut_coul)/rcut_coul` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ), intent ( in ), optional :: rcut real ( rp ), intent ( in ), optional :: rcut_coul real ( rp ), intent ( in ), optional :: C real ( rp ), intent ( in ), optional :: kappa real ( rp ) :: eps_ , sigma_ , rcut_ , rcut_coul_ , C_ , kappa_ real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 if ( present ( eps )) params ( 1 ) = eps if ( present ( sigma )) params ( 2 ) = sigma if ( present ( rcut )) params ( 3 ) = rcut if ( present ( rcut_coul )) params ( 4 ) = rcut_coul if ( present ( C )) params ( 5 ) = C if ( present ( kappa )) params ( 6 ) = kappa eps_ = params ( 1 ); sigma_ = params ( 2 ); rcut_ = params ( 3 ) rcut_coul_ = params ( 4 ); C_ = params ( 5 ); kappa_ = params ( 6 ) sir = sigma_ / rcut_ sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 pot_rcut = 4 * eps_ * ( sir12 - sir6 ) if ( rcut_coul_ > 0.0_rp ) then pot_rcut_coul = C_ * exp ( - kappa_ * rcut_coul_ ) / rcut_coul_ else pot_rcut_coul = 0.0_rp end if params ( 7 ) = pot_rcut params ( 8 ) = pot_rcut_coul end subroutine !****************************************************************************** pure subroutine vdw_lj_coul_debye ( r , qiqj , params , enrg , frc ) !!Evaluates the potential and its derivative for screened Coulombic interaction !!combined with 12-6 LJ (cut & shifted). See [[vdw_lj_coul_debye_set]]. real ( rp ), intent ( in ) :: r real ( rp ), intent ( in ) :: qiqj real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: eps , sigma , rcut , rcut_coul , C , kappa real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 , ekr enrg = 0.0_rp ; frc = 0.0_rp eps = params ( 1 ); sigma = params ( 2 ); rcut = params ( 3 ) rcut_coul = params ( 4 ); C = params ( 5 ); kappa = params ( 6 ) pot_rcut = params ( 7 ); pot_rcut_coul = params ( 8 ) ekr = C * qiqj * exp ( - kappa * r ) / r if ( rcut_coul > 0.0_rp ) then !Coulombic cutoff at rcut_coul if ( r < rcut_coul ) then enrg = ekr - qiqj * pot_rcut_coul frc = - ekr * ( 1 + kappa * r ) / r end if else !No Coulombic cutoff enrg = ekr frc = - ekr * ( 1 + kappa * r ) / r end if if ( r < rcut ) then sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = enrg + 4 * eps * ( sir12 - sir6 ) - pot_rcut frc = frc - 24 * eps * ( 2 * sir12 - sir6 ) / r end if end subroutine !****************************************************************************** subroutine vdw_lj_coul_set ( params , eps , sigma , rcut , rcut_coul , C ) !! Setter for 12-6 LJ with Coulombic interaction. !! !!``` !! V = 4*eps*[(r/sigma)&#94;12 - (r/sigma)&#94;6] !! W = C*qi*qj/r !! if rcut_coul > 0: !!     U = V - V(rcut) + W - W(rcut_coul), r < rcut !!         W - W(rcut_coul), rcut <= r < rcut_coul !!         0, r >= rcut_coul !! if rcut_coul <= 0: !!     U = V - V(rcut) + W, r < rcut !!         W, r >= rcut !!``` !! - The LJ potential `V` is cut & shifted at `r = rcut`. !! - If `rcut_coul > 0`, the Coulombic potential `W` is cut & shifted at `r = rcut_coul`. !! - If `rcut_coul <= 0`, no cutoff is applied on `W`. !! - `rcut_coul` must be >= `rcut`. !! !! User-set parameters: !! !! * params(1) = `eps` !! * params(2) = `sigma` !! * params(3) = `rcut` !! * params(4) = `rcut_coul` !! * params(5) = `C` !! !! Internally stored parameters: !! !! * params(6) = `V(rcut)` !! * params(7) = `V(rcut)` !! * params(8) = `C/rcut_coul` real ( rp ), dimension (:), intent ( in out ) :: params real ( rp ), intent ( in ), optional :: eps real ( rp ), intent ( in ), optional :: sigma real ( rp ), intent ( in ), optional :: rcut real ( rp ), intent ( in ), optional :: rcut_coul real ( rp ), intent ( in ), optional :: C real ( rp ) :: eps_ , sigma_ , rcut_ , rcut_coul_ , C_ real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 if ( present ( eps )) params ( 1 ) = eps if ( present ( sigma )) params ( 2 ) = sigma if ( present ( rcut )) params ( 3 ) = rcut if ( present ( rcut_coul )) params ( 4 ) = rcut_coul if ( present ( C )) params ( 5 ) = C eps_ = params ( 1 ); sigma_ = params ( 2 ); rcut_ = params ( 3 ) rcut_coul_ = params ( 4 ); C_ = params ( 5 ) sir = sigma_ / rcut_ sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 pot_rcut = 4 * eps_ * ( sir12 - sir6 ) if ( rcut_coul_ > 0.0_rp ) then pot_rcut_coul = C_ / rcut_coul_ else pot_rcut_coul = 0.0_rp end if params ( 7 ) = pot_rcut params ( 8 ) = pot_rcut_coul end subroutine !****************************************************************************** pure subroutine vdw_lj_coul ( r , qiqj , params , enrg , frc ) !! Evaluates the potential and its derivative for Coulombic interaction !! combined with 12-6 LJ (cut & shifted). See [[vdw_lj_coul_set]]. real ( rp ), intent ( in ) :: r real ( rp ), intent ( in ) :: qiqj real ( rp ), dimension (:), intent ( in ) :: params real ( rp ), intent ( out ) :: enrg real ( rp ), intent ( out ) :: frc real ( rp ) :: eps , sigma , rcut , rcut_coul , C real ( rp ) :: pot_rcut , pot_rcut_coul real ( rp ) :: sir , sir2 , sir6 , sir12 , ekr enrg = 0.0_rp ; frc = 0.0_rp eps = params ( 1 ); sigma = params ( 2 ); rcut = params ( 3 ) rcut_coul = params ( 4 ); C = params ( 5 ) pot_rcut = params ( 6 ); pot_rcut_coul = params ( 7 ) ekr = C * qiqj / r if ( rcut_coul > 0.0_rp ) then !Coulombic cutoff at rcut_coul if ( r < rcut_coul ) then enrg = ekr - qiqj * pot_rcut_coul frc = - ekr / r end if else !No Coulombic cutoff enrg = ekr frc = - ekr / r end if if ( r < rcut ) then sir = sigma / r sir2 = sir * sir ; sir6 = sir2 * sir2 * sir2 ; sir12 = sir6 * sir6 enrg = enrg + 4 * eps * ( sir12 - sir6 ) - pot_rcut frc = frc - 24 * eps * ( 2 * sir12 - sir6 ) / r end if end subroutine !****************************************************************************** end module m_ia_vdw","tags":"","loc":"sourcefile/m_ia_vdw.f90.html"},{"title":"m_interaction.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_interaction.f90~~EfferentGraph sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_interaction.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_interaction.f90->sourcefile~m_constants_math.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_connectivity.f90->sourcefile~m_precision.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_connectivity.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_ia_external.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90->sourcefile~m_constants_math.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_precision.f90 sourcefile~m_cell_list.f90->sourcefile~m_vector.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_vector.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_precision.f90 sourcefile~m_ia_angle.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_precision.f90 sourcefile~m_ia_bond.f90->sourcefile~m_constants_math.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_ia_bond.f90->sourcefile~m_strings.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_ia_bond.f90->sourcefile~m_logger.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_precision.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_logger.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_precision.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_precision.f90 sourcefile~m_ia_tether.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_table.f90->sourcefile~m_precision.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 var pansourcefilem_interactionf90EfferentGraph = svgPanZoom('#sourcefilem_interactionf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_interaction.f90~~AfferentGraph sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_interaction Source Code m_interaction.f90 Source Code module m_interaction !! Driver routines for force & energy calculation. use m_precision use m_constants_math use m_globals use m_connectivity use m_verlet use m_cell_list use m_ia_bond use m_ia_angle use m_ia_dihedral use m_ia_vdw use m_ia_tether use m_ia_external implicit none private public :: ia_setup , ia_finish , ia_calc_forces contains !****************************************************************************** subroutine ia_setup () !! Sets up parameters for potentials !Initialize and build atom -> bond, atom -> atom and next nearest bonded !neighbor tables call atbo_build () !Debug statements !write(*,*) 'ATBO_TAB' !call atbo_tab%print() !Build excluded atoms table call exat_build () !Debug statements !write(*,*) 'EXAT_TAB' !call exat_tab%print() !Delete atom -> bond table, it is no longer needed. call atbo_tab % delete () !Check if ( num_vdw_types == 0 ) lvdw = . false . if (( imcon == 0 ) . and . use_cell_list ) use_cell_list = . false . if ( use_verlet_tab . and . use_cell_list ) use_verlet_tab = . false . !Initialize verlet list if ( use_verlet_tab ) call verlet_init ( rcutoff + tskin , tskin ) !Initialize cell list if ( ( sim_style == 0 ) . or . ( sim_style == 1 ) ) then ! For relaxation/BD simulation the cell list is used for short range ! force calculation. if ( use_cell_list ) then call cl_init ( num_atoms , rcutoff ) call cl_set_cell_size ( rcutoff ) call cl_build_cell_nbrs () end if else if ( sim_style == 2 ) then ! For MPCD simulation the cell list is always used for sorting. If ! use_cell_list == .true., the cell list will also be used for force ! calculation. call cl_init ( num_atoms_tot , 1.0_rp ) !Collision cell size is 1.0. if ( use_cell_list ) then call cl_set_cell_size ( rcutoff ) !Set cell size to global cutoff call cl_build_cell_nbrs () end if end if if ( num_bonds > 0 ) call ia_bond_setup () if ( num_angles > 0 ) call ia_angle_setup () if ( num_dihedrals > 0 ) call ia_dihedral_setup () if ( num_tethers > 0 ) call ia_tether_setup () if ( lvdw ) call ia_vdw_setup () if ( num_externals > 0 ) call ia_external_setup () end subroutine !****************************************************************************** subroutine ia_finish () !! Releases memory allocated in `ia_setup`. call exat_tab % delete () if ( use_verlet_tab ) call verlet_delete () if ( use_cell_list ) call cl_delete () end subroutine !****************************************************************************** subroutine ia_calc_forces ( ierr ) !! Calculates total forces and energies integer , intent ( out ) :: ierr ierr = 0 !Zeroing out force, energies, & bond length forces = 0.0_rp energy_bond = 0.0_rp energy_angle = 0.0_rp energy_dihedral = 0.0_rp energy_tether = 0.0_rp energy_vdw = 0.0_rp energy_external = 0.0_rp energy_tot = 0.0_rp stress = 0.0_rp if ( num_bonds > 0 ) then bndlen = 0.0_rp bndlen_min = huge ( 0.0_rp ) bndlen_max = 0.0_rp end if !Calculation of bonded interactions if ( num_bonds > 0 ) then call ia_add_bond_forces ( ierr ) if ( ierr /= 0 ) return end if !Calculation of angular interactions if ( num_angles > 0 ) call ia_add_angle_forces () !Calculation of dihedral interactions if ( num_dihedrals > 0 ) call ia_add_dihedral_forces () !Calculation of tether interactions if ( num_tethers > 0 ) then call ia_add_tether_forces ( ierr ) if ( ierr /= 0 ) return end if !Calculation for pairwise interactions if ( lvdw ) then if ( use_verlet_tab ) then call ia_add_vdw_forces_vl ( ierr ) else if ( use_cell_list ) then call ia_add_vdw_forces_cl ( ierr ) else call ia_add_vdw_forces ( ierr ) end if if ( ierr /= 0 ) return end if !Calculation of external interactions if ( num_externals > 0 ) then call ia_add_external_forces ( ierr ) if ( ierr /= 0 ) return end if !Calculate total energy energy_tot = energy_bond + energy_angle + energy_dihedral + energy_vdw & + energy_tether + energy_external !Update stress considering volume for finite concentration if ( imcon /= 0 ) stress = stress / simbox % volume end subroutine !******************************************************************************** subroutine ia_add_vdw_forces ( ierr ) !! Calculates force and energy due to all short-ranged non-bonded pairwise !! interactions and adds to `energy_vdw` & 'forces` in module `m_globals`. !! Uses direct N&#94;2 calculation. integer , intent ( out ) :: ierr real ( rp ), dimension ( 3 ) :: ri , rj , rij , fi real ( rp ) :: rij_mag real ( rp ) :: qi , qj real ( rp ) :: enrg , frc integer :: i , j , at_i , at_j , typ ierr = 0 do i = 1 , ( num_atoms - 1 ) ri = coordinates (:, i ) qi = charge ( i ) at_i = atoms ( i ) do j = i + 1 , num_atoms !Check if atom j is an excluded atom for atom i if ( exat_tab % is_in ( i , j ) ) cycle rj = coordinates (:, j ) qj = charge ( j ) at_j = atoms ( j ) if ( at_i < at_j ) then typ = at_j + ( 2 * num_atom_types - at_i ) * ( at_i - 1 ) / 2 else typ = at_i + ( 2 * num_atom_types - at_j ) * ( at_j - 1 ) / 2 end if rij = rj - ri if ( imcon /= 0 ) call simbox % get_image ( rij ) rij_mag = norm2 ( rij ) call ia_get_vdw_force ( rij_mag , qi , qj , typ , enrg , frc , ierr ) if ( ierr /= 0 ) return energy_vdw = energy_vdw + enrg fi = frc * rij / rij_mag !Update forces forces (:, i ) = forces (:, i ) + fi forces (:, j ) = forces (:, j ) - fi !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - rij ( 1 ) * fi ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - rij ( 2 ) * fi ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - rij ( 3 ) * fi ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - rij ( 1 ) * fi ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - rij ( 2 ) * fi ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - rij ( 3 ) * fi ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - rij ( 1 ) * fi ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - rij ( 2 ) * fi ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - rij ( 3 ) * fi ( 3 ) end do end do end subroutine !******************************************************************************** subroutine ia_add_vdw_forces_vl ( ierr ) !! Calculates force and energy due to all short-ranged non-bonded pairwise !! interactions and adds to `energy_vdw` & 'forces` in module `m_globals`. !! Uses Verlet table. integer , intent ( out ) :: ierr integer , dimension (:), pointer :: nbrs => null () real ( rp ), dimension ( 3 ) :: ri , rj , rij , fi real ( rp ) :: rij_mag real ( rp ) :: qi , qj real ( rp ) :: enrg , frc integer :: i , j , k , at_i , at_j , typ ierr = 0 call verlet_build () !call verlet_tab%print() do i = 1 , ( num_atoms - 1 ) ri = coordinates (:, i ) qi = charge ( i ) at_i = atoms ( i ) !Getting list of neighbors of particle i using pointer nbrs call verlet_tab % get_row ( i , nbrs ) do k = 1 , size ( nbrs ) j = nbrs ( k ) !Check if atom j is an excluded atom for atom i if ( exat_tab % is_in ( i , j ) ) cycle rj = coordinates (:, j ) qj = charge ( j ) at_j = atoms ( j ) if ( at_i < at_j ) then typ = at_j + ( 2 * num_atom_types - at_i ) * ( at_i - 1 ) / 2 else typ = at_i + ( 2 * num_atom_types - at_j ) * ( at_j - 1 ) / 2 end if rij = rj - ri if ( imcon /= 0 ) call simbox % get_image ( rij ) rij_mag = norm2 ( rij ) call ia_get_vdw_force ( rij_mag , qi , qj , typ , enrg , frc , ierr ) if ( ierr /= 0 ) return energy_vdw = energy_vdw + enrg fi = frc * rij / rij_mag !Update forces forces (:, i ) = forces (:, i ) + fi forces (:, j ) = forces (:, j ) - fi !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - rij ( 1 ) * fi ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - rij ( 2 ) * fi ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - rij ( 3 ) * fi ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - rij ( 1 ) * fi ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - rij ( 2 ) * fi ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - rij ( 3 ) * fi ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - rij ( 1 ) * fi ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - rij ( 2 ) * fi ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - rij ( 3 ) * fi ( 3 ) end do end do end subroutine !******************************************************************************** subroutine ia_add_vdw_forces_cl ( ierr ) !! Calculates force and energy due to all short-ranged non-bonded pairwise !! interactions and adds to `energy_vdw` & 'forces` in module `m_globals`. !! Uses cell list. integer , intent ( out ) :: ierr integer , dimension (:), pointer :: aic => null () integer , dimension (:), pointer :: ainc => null () integer , dimension (:), pointer :: nbr_cells => null () real ( rp ), dimension ( 3 ) :: ri , rj , rij , fi real ( rp ) :: rij_mag real ( rp ) :: qi , qj real ( rp ) :: enrg , frc integer :: num_cells integer :: icell , jcell , iatm , jatm integer :: i , j , k , at_i , at_j , typ ierr = 0 call cl_build ( coordinates (:, 1 : num_atoms )) num_cells = cl_get_num_cells () do icell = 0 , ( num_cells - 1 ) call cl_get_contents ( icell , aic ) call cl_get_nbr_cells ( icell , nbr_cells ) !Interaction with particles within the cell do i = 1 , size ( aic ) - 1 iatm = aic ( i ) ri = coordinates (:, iatm ) qi = charge ( iatm ) at_i = atoms ( iatm ) do j = i + 1 , size ( aic ) jatm = aic ( j ) !Check if atom jatm is an excluded atom for atom iatm if ( exat_tab % is_in ( iatm , jatm ) ) cycle rj = coordinates (:, jatm ) qj = charge ( jatm ) at_j = atoms ( jatm ) if ( at_i < at_j ) then typ = at_j + ( 2 * num_atom_types - at_i ) * ( at_i - 1 ) / 2 else typ = at_i + ( 2 * num_atom_types - at_j ) * ( at_j - 1 ) / 2 end if rij = rj - ri if ( imcon /= 0 ) call simbox % get_image ( rij ) rij_mag = norm2 ( rij ) call ia_get_vdw_force ( rij_mag , qi , qj , typ , enrg , frc , ierr ) if ( ierr /= 0 ) return energy_vdw = energy_vdw + enrg fi = frc * rij / rij_mag !Update forces forces (:, iatm ) = forces (:, iatm ) + fi forces (:, jatm ) = forces (:, jatm ) - fi !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - rij ( 1 ) * fi ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - rij ( 2 ) * fi ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - rij ( 3 ) * fi ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - rij ( 1 ) * fi ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - rij ( 2 ) * fi ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - rij ( 3 ) * fi ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - rij ( 1 ) * fi ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - rij ( 2 ) * fi ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - rij ( 3 ) * fi ( 3 ) end do end do !Interaction with particles belonging to neighboring cells do i = 1 , size ( aic ) iatm = aic ( i ) ri = coordinates (:, iatm ) qi = charge ( iatm ) at_i = atoms ( iatm ) do j = 1 , size ( nbr_cells ) jcell = nbr_cells ( j ) call cl_get_contents ( jcell , ainc ) do k = 1 , size ( ainc ) jatm = ainc ( k ) !Check if atom jatm is an excluded atom for atom iatm if ( exat_tab % is_in ( iatm , jatm ) ) cycle rj = coordinates (:, jatm ) qj = charge ( jatm ) at_j = atoms ( jatm ) if ( at_i < at_j ) then typ = at_j + ( 2 * num_atom_types - at_i ) * ( at_i - 1 ) / 2 else typ = at_i + ( 2 * num_atom_types - at_j ) * ( at_j - 1 ) / 2 end if rij = rj - ri if ( imcon /= 0 ) call simbox % get_image ( rij ) rij_mag = norm2 ( rij ) call ia_get_vdw_force ( rij_mag , qi , qj , typ , enrg , frc , ierr ) if ( ierr /= 0 ) return energy_vdw = energy_vdw + enrg fi = frc * rij / rij_mag !Update forces forces (:, iatm ) = forces (:, iatm ) + fi forces (:, jatm ) = forces (:, jatm ) - fi !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - rij ( 1 ) * fi ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - rij ( 2 ) * fi ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - rij ( 3 ) * fi ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - rij ( 1 ) * fi ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - rij ( 2 ) * fi ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - rij ( 3 ) * fi ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - rij ( 1 ) * fi ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - rij ( 2 ) * fi ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - rij ( 3 ) * fi ( 3 ) end do end do end do end do end subroutine !******************************************************************************* subroutine ia_add_bond_forces ( ierr ) !! Calculates forces & energy due to all bonds. Will add to !! `energy_bond` & and 'forces` in module `m_globals`. integer , intent ( out ) :: ierr real ( rp ), dimension ( 3 ) :: ri , rj , rij , fi real ( rp ) :: rij_mag real ( rp ) :: enrg , frc integer :: ibnd , typ integer :: i , j ierr = 0 do ibnd = 1 , num_bonds typ = bonds ( 1 , ibnd ) i = bonds ( 2 , ibnd ) j = bonds ( 3 , ibnd ) ri = coordinates (:, i ) rj = coordinates (:, j ) rij = rj - ri if ( imcon /= 0 ) call simbox % get_image ( rij ) rij_mag = norm2 ( rij ) bndlen = bndlen + rij_mag bndlen_min = min ( bndlen_min , rij_mag ) bndlen_max = max ( bndlen_max , rij_mag ) call ia_get_bond_force ( rij_mag , typ , enrg , frc , ierr ) if ( ierr /= 0 ) return energy_bond = energy_bond + enrg fi = frc * rij / rij_mag forces (:, i ) = forces (:, i ) + fi forces (:, j ) = forces (:, j ) - fi !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - rij ( 1 ) * fi ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - rij ( 2 ) * fi ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - rij ( 3 ) * fi ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - rij ( 1 ) * fi ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - rij ( 2 ) * fi ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - rij ( 3 ) * fi ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - rij ( 1 ) * fi ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - rij ( 2 ) * fi ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - rij ( 3 ) * fi ( 3 ) end do bndlen = bndlen / num_bonds end subroutine !******************************************************************************** subroutine ia_add_angle_forces () !! Calculates forces & energy due to all angles. Will add to !! `energy_angle` & 'forces` in module `m_globals`. real ( rp ), dimension ( 3 ) :: rim1 , ri , rip1 , q1 , q2 real ( rp ), dimension ( 3 ) :: fim1 , fi , fip1 real ( rp ) :: enrg integer :: iang integer :: typ integer :: i , im1 , ip1 do iang = 1 , num_angles typ = angles ( 1 , iang ) im1 = angles ( 2 , iang ) i = angles ( 3 , iang ) ip1 = angles ( 4 , iang ) rim1 = coordinates (:, im1 ) ri = coordinates (:, i ) rip1 = coordinates (:, ip1 ) q1 = ri - rim1 ; q2 = rip1 - ri if ( imcon /= 0 ) call simbox % get_image ( q1 ) if ( imcon /= 0 ) call simbox % get_image ( q2 ) call ia_get_angle_force ( q1 , q2 , typ , enrg , fim1 , fi , fip1 ) energy_angle = energy_angle + enrg !Update forces forces (:, im1 ) = forces (:, im1 ) + fim1 forces (:, i ) = forces (:, i ) + fi forces (:, ip1 ) = forces (:, ip1 ) + fip1 !Update stress stress ( 1 , 1 ) = stress ( 1 , 1 ) - q1 ( 1 ) * fim1 ( 1 ) + q2 ( 1 ) * fip1 ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) - q1 ( 2 ) * fim1 ( 1 ) + q2 ( 2 ) * fip1 ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) - q1 ( 3 ) * fim1 ( 1 ) + q2 ( 3 ) * fip1 ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) - q1 ( 1 ) * fim1 ( 2 ) + q2 ( 1 ) * fip1 ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) - q1 ( 2 ) * fim1 ( 2 ) + q2 ( 2 ) * fip1 ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) - q1 ( 3 ) * fim1 ( 2 ) + q2 ( 3 ) * fip1 ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) - q1 ( 1 ) * fim1 ( 3 ) + q2 ( 1 ) * fip1 ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) - q1 ( 2 ) * fim1 ( 3 ) + q2 ( 2 ) * fip1 ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) - q1 ( 3 ) * fim1 ( 3 ) + q2 ( 3 ) * fip1 ( 3 ) end do end subroutine !******************************************************************************** subroutine ia_add_dihedral_forces () !! Calculates forces & energy due to all dihedrals. Will add to !! `energy_dihedral` & 'forces` in module `m_globals`. real ( rp ), dimension ( 3 ) :: ri , rj , rk , rl real ( rp ), dimension ( 3 ) :: q1 , q2 , q3 real ( rp ), dimension ( 3 ) :: fi , fj , fk , fl real ( rp ) :: enrg integer :: idhd integer :: typ integer :: i , j , k , l do idhd = 1 , num_dihedrals typ = dihedrals ( 1 , idhd ) i = dihedrals ( 2 , idhd ) j = dihedrals ( 3 , idhd ) k = dihedrals ( 4 , idhd ) l = dihedrals ( 5 , idhd ) ri = coordinates (:, i ) rj = coordinates (:, j ) rk = coordinates (:, k ) rl = coordinates (:, l ) q1 = rj - ri ; q2 = rk - rj ; q3 = rl - rk if ( imcon /= 0 ) call simbox % get_image ( q1 ) if ( imcon /= 0 ) call simbox % get_image ( q2 ) if ( imcon /= 0 ) call simbox % get_image ( q3 ) call ia_get_dihedral_force ( q1 , q2 , q3 , typ , enrg , fi , fj , fk , fl ) energy_dihedral = energy_dihedral + enrg forces (:, i ) = forces (:, i ) + fi forces (:, j ) = forces (:, j ) + fj forces (:, k ) = forces (:, k ) + fk forces (:, l ) = forces (:, l ) + fl !TODO: Add the contribution to stress here. end do end subroutine !******************************************************************************** subroutine ia_add_tether_forces ( ierr ) !! Calculates forces & energy due to all tethers. Will add to `energy_tether` & !! 'forces` in module `m_globals`. Tether forces cannot be subject to !! periodic boundary conditions. integer , intent ( out ) :: ierr real ( rp ), dimension ( 3 ) :: r , tp , q , fj real ( rp ) :: qmag real ( rp ) :: enrg , frc integer :: iteth , typ , teth_iatm ierr = 0 do iteth = 1 , num_tethers typ = tethers ( 1 , iteth ) teth_iatm = tethers ( 2 , iteth ) !Index of the tethered atom tp = tether_points (:, iteth ) r = coordinates (:, teth_iatm ) q = r - tp qmag = norm2 ( q ) call ia_get_tether_force ( qmag , typ , enrg , frc , ierr ) if ( ierr /= 0 ) return fj = - frc * q / qmag energy_tether = energy_tether + enrg forces (:, teth_iatm ) = forces (:, teth_iatm ) + fj !Update stress !Sign flipped since fj, not fi is involved stress ( 1 , 1 ) = stress ( 1 , 1 ) + q ( 1 ) * fj ( 1 ) stress ( 2 , 1 ) = stress ( 2 , 1 ) + q ( 2 ) * fj ( 1 ) stress ( 3 , 1 ) = stress ( 3 , 1 ) + q ( 3 ) * fj ( 1 ) stress ( 1 , 2 ) = stress ( 1 , 2 ) + q ( 1 ) * fj ( 2 ) stress ( 2 , 2 ) = stress ( 2 , 2 ) + q ( 2 ) * fj ( 2 ) stress ( 3 , 2 ) = stress ( 3 , 2 ) + q ( 3 ) * fj ( 2 ) stress ( 1 , 3 ) = stress ( 1 , 3 ) + q ( 1 ) * fj ( 3 ) stress ( 2 , 3 ) = stress ( 2 , 3 ) + q ( 2 ) * fj ( 3 ) stress ( 3 , 3 ) = stress ( 3 , 3 ) + q ( 3 ) * fj ( 3 ) end do end subroutine !****************************************************************************** end module m_interaction","tags":"","loc":"sourcefile/m_interaction.f90.html"},{"title":"m_kmc.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_kmc.f90~~EfferentGraph sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_kmc.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_kmc.f90->sourcefile~m_precision.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_kmc.f90->sourcefile~m_constants_math.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_kmc.f90->sourcefile~m_strings.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_kmc.f90->sourcefile~m_ran_num.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_kmc.f90->sourcefile~m_logger.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_precision.f90 sourcefile~m_interaction.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_ia_external.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90->sourcefile~m_constants_math.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_precision.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_cell_list.f90->sourcefile~m_vector.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_connectivity.f90->sourcefile~m_precision.f90 sourcefile~m_connectivity.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_vector.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_precision.f90 sourcefile~m_ia_angle.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_precision.f90 sourcefile~m_ia_bond.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_strings.f90 sourcefile~m_ia_bond.f90->sourcefile~m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_precision.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_logger.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_precision.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_precision.f90 sourcefile~m_ia_tether.f90->sourcefile~m_constants_math.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_table.f90->sourcefile~m_precision.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 var pansourcefilem_kmcf90EfferentGraph = svgPanZoom('#sourcefilem_kmcf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_kmc Source Code m_kmc.f90 Source Code module m_kmc !! Implements charge hopping via Kinetic Monte Carlo. use m_precision use m_constants_math use m_strings use m_ran_num use m_globals use m_interaction , only : ia_calc_forces use m_logger , only : logger => master_logger implicit none private public :: kmc_init , kmc_hop , kmc_finish contains !******************************************************************************* subroutine kmc_init () end subroutine !******************************************************************************* subroutine kmc_finish () end subroutine !******************************************************************************* subroutine kmc_hop () end subroutine !****************************************************************************** end module m_kmc","tags":"","loc":"sourcefile/m_kmc.f90.html"},{"title":"m_logger.f90 – BROWNPAK","text":"Files dependent on this one sourcefile~~m_logger.f90~~AfferentGraph sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_logger.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_kmc.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_logger.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_globals.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_setup.f90->sourcefile~m_stats_io.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_setup.f90->sourcefile~m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_logger.f90 sourcefile~m_bd_solver.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_logger.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~main.f90->sourcefile~m_globals.f90 sourcefile~m_control_io.f90 m_control_io.f90 sourcefile~main.f90->sourcefile~m_control_io.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_ia_bond.f90->sourcefile~m_logger.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_logger.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_logger.f90 sourcefile~m_mpcd.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_relax.f90->sourcefile~m_logger.f90 sourcefile~m_relax.f90->sourcefile~m_globals.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90->sourcefile~m_stats_io.f90 sourcefile~m_relax.f90->sourcefile~m_config_io.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_control_io.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 var pansourcefilem_loggerf90AfferentGraph = svgPanZoom('#sourcefilem_loggerf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_logger Source Code m_logger.f90 Source Code ! !  logging.f90 !  This file is part of flogging. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or !  modify it under the terms of the GNU Lesser General Public License !  as published by the Free Software Foundation; either version 3 of !  the License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, but !  WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU !  Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA !  02110-1301, USA. ! ! Removed dependence on module `face`. -- Sarit Dutta !Example driver program !---------------------- ! !program logging_example !  use logger_mod, only: logger_init, logger => master_logger ! !  ! Initialise the logger prior to use !  call logger_init('outputfile.log') ! !  ! Write some debugging information !  call logger%debug('logger_example','Starting program logger_example') ! !  ! Perform some calculation !  ! ... !  call logger%info('logger_example','Found result of calculation') ! !  ! Perform another calculation !  ! ... !  ! Oh no, an error has occurred !  call logger%error('logger_example','Calculation failed due to error') ! !  call logger%debug('logger_example','Ending program logger_example') !end program logging_example module m_logger !! Author: Christopher MacMackin !! Date: December 2016 !! License: LGPLv3 !! !! Provides routines for printing different types of messages to !! standard out, standard error, and/or a log file. !! use iso_fortran_env , only : i8 => int64 , error_unit , output_unit implicit none private integer , parameter , public :: debug = 10 !! Priority level for output only useful for debugging integer , parameter , public :: trivia = 20 !! Priority level for output which may be useful but is very !! detailed or not especially important. integer , parameter , public :: info = 30 !! Priority level for output generated by the normal execution of !! the program. integer , parameter , public :: warning = 40 !! Priority level for output which indicates some part of the !! program is not behaving as it ideally should. integer , parameter , public :: error = 50 !! Priority level for output which indicates an error has !! occurred which will affect the continued execution of the !! program. integer , parameter , public :: fatal = 60 !! Priority level for output which notifies the user than a !! serious error has occured which will result in the immediate !! termination of the program. integer , parameter :: default_stderr_threshold = error !! Default priority level needed for a message to be printed to !! standard-error. integer , parameter :: default_stdout_threshold = info !! Default priority level needed for a message to be printed to !! standard out. integer , parameter :: default_logfile_threshold = trivia !! Default priority level needed for a message to be printed to !! the log file. integer , parameter :: closed_unit = - 9999 integer , parameter :: infinity = huge ( 1 ) character ( len = 29 ), parameter :: default_format = \"('[',a,']','[',a,']',\" // & \"*(1x,a))\" type , public :: logger !* Author: Chris MacMackinc !  Date: December 2016 ! ! An object to handle output of information about the executing ! program to the terminal and to a log-file. ! private integer :: stdout = output_unit !! Unit corresponding to STDOUT integer :: stderr = error_unit !! Unit corresponding to STDERR integer :: fileunit = closed_unit !! Unit corresponding to log-file character ( len = :), allocatable :: logfile !! Name of the log-file integer :: stderr_threshold = infinity !! Cutoff for which messages with greater or equal priority will !! be written to STDERR. integer :: stdout_threshold = infinity !! Cutoff for which messages with greater or equal priority will !! be written to STDOUT. integer :: logfile_threshold = infinity !! Cutoff for which messages with greater or equal priority will !! be written to the log-file. contains procedure :: message => logger_message !! Write a message of a given priority to the appropriate !! location(s) procedure :: debug => logger_debug !! Write debug information procedure :: trivia => logger_trivia !! Write trivial run-time information procedure :: info => logger_info !! Write run-time information procedure :: warning => logger_warning !! Write warning message procedure :: error => logger_error !! Write error message procedure :: fatal => logger_fatal !! Write notification of fatal error procedure :: destroy => logger_destroy !! Closes the log-file procedure :: is_open => logger_is_open !! Return `.true.` if the log-file is open for writing final :: logger_finalize end type logger interface logger module procedure :: constructor end interface type ( logger ), public :: master_logger !! The main logger object for a program to use. Must be !! initialised in the main program with a call to [[logger_init]]. public :: logger_init contains function constructor ( logfile , stderr_threshold , stdout_threshold , & logfile_threshold ) result ( this ) type ( logger ) :: this character ( len =* ), intent ( in ) :: logfile !! Name of the log-file to which output will be written integer , intent ( in ), optional :: stderr_threshold !! Threshold priority, at and above which messages will be !! written to standard error. Defaults to `error`. integer , intent ( in ), optional :: stdout_threshold !! Threshold priority, at and above which messages will be !! written to standard out. Defaults to `info`. integer , intent ( in ), optional :: logfile_threshold !! Threshold priority, at and above which messages will be !! written to the log file. Defaults to `trivia`. integer :: flag this % logfile = logfile open ( newunit = this % fileunit , file = this % logfile , action = 'write' , & iostat = flag , status = 'replace' ) if ( flag /= 0 ) error stop 'Error opening log file.' if ( present ( stderr_threshold )) then this % stderr_threshold = stderr_threshold else this % stderr_threshold = default_stderr_threshold end if if ( present ( stdout_threshold )) then this % stdout_threshold = stdout_threshold else this % stdout_threshold = default_stdout_threshold end if if ( present ( logfile_threshold )) then this % logfile_threshold = logfile_threshold else this % logfile_threshold = default_logfile_threshold end if end function constructor subroutine logger_finalize ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Closes the log-file of this logger object. ! type ( logger ), intent ( inout ) :: this call this % destroy () end subroutine logger_finalize subroutine logger_init ( logfile , stderr_threshold , stdout_threshold , & logfile_threshold ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Initalises the master logging object. This subroutine must be ! called before the master logger is used. It should only be ! called once. ! character ( len =* ), intent ( in ) :: logfile !! Name of the log-file to which output will be written integer , intent ( in ), optional :: stderr_threshold !! Threshold priority, at and above which messages will be !! written to standard error. Defaults to `error`. integer , intent ( in ), optional :: stdout_threshold !! Threshold priority, at and above which messages will be !! written to standard out. Defaults to `info`. integer , intent ( in ), optional :: logfile_threshold !! Threshold priority, at and above which messages will be !! written to the log file. Defaults to `trivia`. master_logger = logger ( logfile , stderr_threshold , stdout_threshold , & logfile_threshold ) end subroutine logger_init function get_designator ( priority ) result ( des ) !* Author: Chris MacMackin !  Date: December 2016 ! !  Removed dependence on the **face** module by removing optional input !  `ansi_colours` ! For a given priority, returns the appropriate, optionally ! colourised, designator. ! integer , intent ( in ) :: priority !! The priority level for which to get the designator character ( len = :), allocatable :: des integer :: descriminator descriminator = priority / 10 if ( descriminator < 1 ) then des = '' else if ( descriminator < 2 ) then des = '<debug> ' else if ( descriminator < 3 ) then des = '<trivia> ' else if ( descriminator < 4 ) then des = '<info> ' else if ( descriminator < 5 ) then des = '<warning> ' else if ( descriminator < 6 ) then des = '<error> ' else des = '<fatal> ' end if end function get_designator function current_time () !* Author: Chris MacMackin !  Date: November 2016 ! ! Returns the formatted current date and time. ! character ( len = 20 ) :: current_time integer ( i8 ), dimension ( 8 ) :: time_vals character ( len = 3 ), dimension ( 12 ), parameter :: months = [ 'Jan' , & 'Feb' , & 'Mar' , & 'Apr' , & 'May' , & 'Jun' , & 'Jul' , & 'Aug' , & 'Sep' , & 'Oct' , & 'Nov' , & 'Dec' ] character ( len = 42 ), parameter :: time_format = '(a3,1x,i2,1x,i4,1x,' // & 'i2.2,\":\",i2.2,\":\",i2.2)' call date_and_time ( values = time_vals ) write ( current_time , time_format ) months ( time_vals ( 2 )), time_vals ( 3 ), & time_vals ( 1 ), time_vals ( 5 ), time_vals ( 6 ), & time_vals ( 7 ) end function current_time subroutine logger_message ( this , source , priority , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Write the provided message to STDERR, STDOUT, and/or a log-file, ! based on its priority level. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error integer , intent ( in ) :: priority !! The importance of the message, determining where it will be !! written. character ( len =* ), intent ( in ) :: message !! The information to be written. character ( len = :), allocatable :: output if ( priority >= this % stderr_threshold ) then output = get_designator ( priority ) // message write ( this % stderr , default_format ) current_time (), source , output else if ( priority >= this % stdout_threshold ) then output = get_designator ( priority ) // message write ( this % stdout , default_format ) current_time (), source , output end if if ( priority >= this % logfile_threshold ) then output = get_designator ( priority ) // message write ( this % fileunit , default_format ) current_time (), source , output end if end subroutine logger_message subroutine logger_debug ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes debug information to STDERR, STDOUT, and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , debug , message ) end subroutine logger_debug subroutine logger_trivia ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes unimportant run-time information to STDERR, STDOUT, ! and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , trivia , message ) end subroutine logger_trivia subroutine logger_info ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes run-time information to STDERR, STDOUT, and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , info , message ) end subroutine logger_info subroutine logger_warning ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes warning information to STDERR, STDOUT, and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , warning , message ) end subroutine logger_warning subroutine logger_error ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes error information to STDERR, STDOUT, and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , error , message ) end subroutine logger_error subroutine logger_fatal ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes fatal information to STDERR, STDOUT, and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , fatal , message ) end subroutine logger_fatal subroutine logger_destroy ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Closes the log-file of this logger object. Destroys only the ! logger object, *not* the output. ! class ( logger ), intent ( inout ) :: this if ( this % fileunit == closed_unit ) return close ( this % fileunit ) this % fileunit = closed_unit this % stderr_threshold = infinity this % stdout_threshold = infinity this % logfile_threshold = infinity end subroutine logger_destroy pure function logger_is_open ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Returns `.true.` if the log-file is open for writing. ! class ( logger ), intent ( in ) :: this logical :: logger_is_open logger_is_open = ( this % fileunit /= closed_unit ) end function logger_is_open end module m_logger","tags":"","loc":"sourcefile/m_logger.f90.html"},{"title":"m_mpcd.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_mpcd.f90~~EfferentGraph sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_mpcd.f90->sourcefile~m_precision.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_constants_math.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_mpcd.f90->sourcefile~m_strings.f90 sourcefile~m_utils_math.f90 m_utils_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_utils_math.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_mpcd.f90->sourcefile~m_ran_num.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_mpcd.f90->sourcefile~m_logger.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_precision.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_cell_list.f90->sourcefile~m_vector.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_precision.f90 sourcefile~m_interaction.f90->sourcefile~m_constants_math.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_stats_io.f90->sourcefile~m_precision.f90 sourcefile~m_stats_io.f90->sourcefile~m_constants_math.f90 sourcefile~m_stats_io.f90->sourcefile~m_strings.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_utils_math.f90->sourcefile~m_precision.f90 sourcefile~m_utils_math.f90->sourcefile~m_constants_math.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90->sourcefile~m_precision.f90 sourcefile~m_config_io.f90->sourcefile~m_strings.f90 sourcefile~m_config_io.f90->sourcefile~m_simbox.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_connectivity.f90->sourcefile~m_precision.f90 sourcefile~m_connectivity.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_ia_external.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_vector.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_precision.f90 sourcefile~m_ia_angle.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_precision.f90 sourcefile~m_ia_bond.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_strings.f90 sourcefile~m_ia_bond.f90->sourcefile~m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_precision.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_logger.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_precision.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_precision.f90 sourcefile~m_ia_tether.f90->sourcefile~m_constants_math.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_table.f90->sourcefile~m_precision.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 var pansourcefilem_mpcdf90EfferentGraph = svgPanZoom('#sourcefilem_mpcdf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_mpcd.f90~~AfferentGraph sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_setup.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_mpcd Source Code m_mpcd.f90 Source Code module m_mpcd !! Routines implementing the MPCD solver. use f95_precision use lapack95 use m_precision use m_constants_math use m_utils_math use m_strings use m_ran_num use m_globals use m_cell_list use m_interaction , only : ia_calc_forces use m_stats_io use m_config_io use m_logger , only : logger => master_logger implicit none private public :: mpcd_init , mpcd_run , mpcd_finish real ( rp ), dimension (:), allocatable :: mass !! *(num_atoms_tot,)* array. Stores mass of each atom (including MPCD !! atoms). The mass of each MPCD atom is taken as unity. real ( rp ), dimension (:), allocatable :: buf_aic !! Buffer for atoms in cell storing mass, coordinates, & velocities. !! For *nc* atoms, the first *nc* elements stores the mass, the next !! *3\\*nc* elements stores the coordinates, and the next *3\\*nc* elements !! store the velocities. The velocities part of this buffer may be overwritten !! for relative velocity calculations. contains !******************************************************************************* subroutine mpcd_init ( ierr ) !! Initializes the MPCD solver. integer , intent ( out ) :: ierr integer :: i , at_i logical :: lexists ierr = 0 !Allocate memory for velocities if ( . not . allocated ( velocities ) ) then allocate ( velocities ( 3 , num_atoms_tot ) ) velocities = 0.0_rp end if !Mass of each atom if ( . not . allocated ( mass ) ) then allocate ( mass ( num_atoms_tot ) ) mass = 1.0_rp do i = 1 , num_atoms at_i = atoms ( i ) mass ( i ) = atom_mass ( at_i ) end do end if !In case of new simulation, need to assign MPCD atom positions. if (. not . lrevive ) then call simbox % get_rnd_points ( coordinates (:, num_atoms + 1 : num_atoms_tot ) ) end if !Allocate buffer for atoms in a cell. Setting it to thrice the average !number of MPCD atoms per cell. Each atom has 7 quantities (mass, !coordinates, & velocities) associated with it. The buffer will be expanded !if necessary. allocate ( buf_aic ( 7 * ( 3 * mpcd_avnc )) ) buf_aic = 0.0_rp !Opening trajectory file if ( write_traj ) then if ( lrevive ) then !Append (write) to existing (new) trajectory file !Check if trajectory file exists inquire ( file = fn_traj // trim ( adjustl ( job_tag )), exist = lexists ) if ( lexists ) then !Open existing file for appending call traj % open ( fn_traj // trim ( adjustl ( job_tag )), 'rw' , ierr ) if ( ierr /= 0 ) return else !Create new trajectory file if ( traj_wmpcd ) then !With MPCD data call traj % create ( fn_traj // trim ( adjustl ( job_tag )), & num_atoms , num_mpcd_atoms , traj_frmcmp ) else !Without MPCD data call traj % create ( fn_traj // trim ( adjustl ( job_tag )), & num_atoms , 0 , traj_frmcmp ) end if end if else !Create new trajectory file if ( traj_wmpcd ) then !With MPCD data call traj % create ( fn_traj // trim ( adjustl ( job_tag )), & num_atoms , num_mpcd_atoms , traj_frmcmp ) else !Without MPCD data call traj % create ( fn_traj // trim ( adjustl ( job_tag )), & num_atoms , 0 , traj_frmcmp ) end if end if end if end subroutine !****************************************************************************** subroutine mpcd_finish () !! Clean up MPCD solver. if ( allocated ( mass )) deallocate ( mass ) if ( allocated ( buf_aic )) deallocate ( buf_aic ) call traj % close () end subroutine !****************************************************************************** subroutine mpcd_run () !! Driver for MPCD integrator. !! !! Repeatedly calls [[mpcd_stream]] and [[mpcd_collide]] to update atom !! positions. !! !! Handling of flow field is not imlemented yet. If a non-zero `flow_style` !! is specified, it will be set to zero. integer :: ierr ierr = 0 if ( flow_style /= 0 ) flow_style = 0 !Log & dump starting configuration call logger % info ( 'mpcd_run' , ' nts: ' // str_from_num ( nts )) call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) !Equilibration run if ( leql ) then do while ( nts < nts_eql ) !Streaming call mpcd_stream ( ierr ) if ( ierr /= 0 ) return !Collision call mpcd_collide () nts = nts + 1 !Logging if ( mod ( nts , nts_log ) == 0 ) then call logger % info ( 'mpcd_run' , ' nts: ' // str_from_num ( nts )) end if !Dump revive file if ( mod ( nts , nts_dump ) == 0 ) then call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end if !Equilibration stats if ( write_eql_stats ) then if ( mod ( nts , nts_eql_samp ) == 0 ) call stats_write () end if end do call logger % info ( 'finish_equil_run' , 'Equilibration completed' ) call stats_finish () call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) leql = . false . nts = 0 !If continue on to production run, create new stats file. if ( nts_sim > 0 ) call stats_init () end if !Production run do while ( nts < nts_sim ) call mpcd_stream ( ierr ) if ( ierr /= 0 ) return call mpcd_collide () nts = nts + 1 !Logging if ( mod ( nts , nts_log ) == 0 ) then call logger % info ( 'mpcd_run' , ' nts: ' // str_from_num ( nts )) end if !Dump revive file if ( mod ( nts , nts_dump ) == 0 ) then call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end if if ( mod ( nts , nts_samp ) == 0 ) then !Write stats call stats_write () !Write traj if ( write_traj ) call traj % append_frame ( nts , coordinates , & velocities , forces , charge ) end if end do !Dump the final configuration call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end subroutine !****************************************************************************** subroutine mpcd_stream ( ierr ) !! Performs one step of streaming. integer , intent ( out ) :: ierr real ( rp ) :: dt_md real ( rp ) :: half_dt integer :: i , istp dt_md = tim_stp / nts_md half_dt = 0.5_rp * dt_md istp = 0 !Set cell size to collision cells if ( use_cell_list ) call cl_set_cell_size ( rcutoff ) !Setting these to zero for the case num_atoms = 0. energy_tot = 0.0_rp stress = 0.0_rp !Update non-MPCD atoms via MD steps if ( num_atoms > 0 ) then do while ( istp < nts_md ) !Update velocities over a half-step do i = 1 , num_atoms velocities (:, i ) = velocities (:, i ) + half_dt * forces (:, i ) / mass ( i ) end do !Update position over full step do i = 1 , num_atoms coordinates (:, i ) = coordinates (:, i ) + dt_md * velocities (:, i ) end do !Wrap around periodic boundaries call simbox % wrap_all ( coordinates (:, 1 : num_atoms )) !Update forces over full step call ia_calc_forces ( ierr ) if ( ierr /= 0 ) return !Update velocities over full step do i = 1 , num_atoms velocities (:, i ) = velocities (:, i ) + half_dt * forces (:, i ) / mass ( i ) end do istp = istp + 1 end do end if !Update MPCD particles over a streaming step do i = num_atoms + 1 , num_atoms_tot coordinates (:, i ) = coordinates (:, i ) + tim_stp * velocities (:, i ) end do !Wrap MPCD particles around periodic boundaries call simbox % wrap_all ( coordinates (:, num_atoms + 1 :)) end subroutine !****************************************************************************** subroutine mpcd_collide () !! Performs one step of MPCD collision. real ( rp ), dimension ( 3 ) :: gsv real ( rp ), dimension ( 3 ) :: ri , vi , com , vcom , vrcom real ( rp ), dimension ( 3 ) :: angmom , angvel real ( rp ), dimension ( 3 , 3 ) :: mat_mi , inv_mat_mi real ( rp ), dimension ( 3 , 3 ) :: stress_kin integer , dimension (:), pointer :: aic => null () real ( rp ) :: mass_tot , massi , var integer :: num_cells , na_cell integer :: ofstc , ofstv integer :: i , iatm , icell , ibeg , iend !Grid shift vector call get_rv_uniform ( - 0.5_rp , 0.5_rp , gsv ) !Forward shift do i = 1 , num_atoms_tot coordinates (:, i ) = coordinates (:, i ) + gsv end do !Wrap around periodic boundaries call simbox % wrap_all ( coordinates ) !Set cell size to collision cells call cl_set_cell_size ( 1.0_rp ) call cl_build ( coordinates ) num_cells = cl_get_num_cells () !Momentum exchange via collision, velocity update (MPC-AT+a version) !Loop over all collision cells do icell = 0 , ( num_cells - 1 ) !Get cell contents call cl_get_contents ( icell , aic ) !Number of atoms in cell na_cell = size ( aic ) !For fewer than 2 atoms, no need for relative velocities. if ( na_cell < 2 ) cycle !Check if cell velocity buffer needs to be expanded if ( size ( buf_aic ) < 7 * na_cell ) then deallocate ( buf_aic ) allocate ( buf_aic ( 7 * na_cell ) ) end if !Populate buf_aic ofstc = na_cell ; ofstv = na_cell + 3 * na_cell do i = 1 , size ( aic ) iatm = aic ( i ) buf_aic ( i ) = mass ( iatm ) ibeg = ofstc + 3 * i - 2 ; iend = ofstc + 3 * i buf_aic ( ibeg : iend ) = coordinates (:, iatm ) ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i buf_aic ( ibeg : iend ) = velocities (:, iatm ) end do !Total mass, center-of-mass, & c.o.m. velocity com = 0.0_rp ; vcom = 0.0_rp ; mass_tot = 0.0_rp do i = 1 , na_cell mass_tot = mass_tot + buf_aic ( i ) ibeg = ofstc + 3 * i - 2 ; iend = ofstc + 3 * i com = com + buf_aic ( i ) * buf_aic ( ibeg : iend ) ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i vcom = vcom + buf_aic ( i ) * buf_aic ( ibeg : iend ) end do com = com / mass_tot vcom = vcom / mass_tot !Draw relative velocities & store in the buf_aic. This overwrites the !existing velocities. ibeg = ofstv + 1 ; iend = ofstv + 3 * na_cell call get_rv_gaussian ( 0.0_rp , 1.0_rp , buf_aic ( ibeg : iend ) ) !Multiply by the variance, i.e. kT/m do i = 1 , na_cell var = 1.0_rp / buf_aic ( i ) ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i buf_aic ( ibeg : iend ) = var * buf_aic ( ibeg : iend ) end do !Calcuate the mean of the relative velocities. vrcom = 0.0_rp do i = 1 , na_cell ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i vrcom = vrcom + buf_aic ( i ) * buf_aic ( ibeg : iend ) end do vrcom = vrcom / mass_tot !Subtract off the c.o.m. position & vrcom do i = 1 , na_cell ibeg = ofstc + 3 * i - 2 ; iend = ofstc + 3 * i buf_aic ( ibeg : iend ) = buf_aic ( ibeg : iend ) - com ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i buf_aic ( ibeg : iend ) = buf_aic ( ibeg : iend ) - vrcom end do !Add the relative velocities to the c.o.m. velocity. This produces new !velocities that do not conserve angular momentum, i.e. this is !MPC-AT-a. do i = 1 , na_cell ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i buf_aic ( ibeg : iend ) = buf_aic ( ibeg : iend ) + vcom end do !For only two atoms in the cell, the above is equivalent to MPC-AT+a. !Just copy the velocities back and move on to the next cell. if ( na_cell == 2 ) then !Explicitly unrolling the loop over i as i = 1 & i = 2. i = 1 ; iatm = aic ( i ); ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i velocities (:, iatm ) = buf_aic ( ibeg : iend ) i = 2 ; iatm = aic ( i ); ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i velocities (:, iatm ) = buf_aic ( ibeg : iend ) cycle end if !Calculate moment of intertia matrix (symmetric) about the c.o.m. and angular !momentum. mat_mi = 0.0_rp ; angmom = 0.0_rp do i = 1 , na_cell massi = buf_aic ( i ) ri = buf_aic ( ofstc + 3 * i - 2 : ofstc + 3 * i ) mat_mi ( 1 , 1 ) = mat_mi ( 1 , 1 ) + massi * ( ri ( 2 ) ** 2 + ri ( 3 ) ** 2 ) mat_mi ( 2 , 1 ) = mat_mi ( 2 , 1 ) - massi * ( ri ( 2 ) * ri ( 1 ) ) mat_mi ( 3 , 1 ) = mat_mi ( 3 , 1 ) - massi * ( ri ( 3 ) * ri ( 1 ) ) mat_mi ( 2 , 2 ) = mat_mi ( 2 , 2 ) + massi * ( ri ( 1 ) ** 2 + ri ( 3 ) ** 2 ) mat_mi ( 3 , 2 ) = mat_mi ( 3 , 2 ) - massi * ( ri ( 3 ) * ri ( 2 ) ) mat_mi ( 3 , 3 ) = mat_mi ( 3 , 3 ) + massi * ( ri ( 1 ) ** 2 + ri ( 2 ) ** 2 ) vi = buf_aic ( ofstv + 3 * i - 2 : ofstv + 3 * i ) call cross ( ri , vi , vrcom ) !Using vrcom as a buffer here angmom = angmom + massi * vrcom end do !Update the symmetric elements mat_mi ( 1 , 2 ) = mat_mi ( 2 , 1 ) mat_mi ( 1 , 3 ) = mat_mi ( 3 , 1 ) mat_mi ( 2 , 3 ) = mat_mi ( 3 , 2 ) !Solve for angular velocity. If the mat_mi is singular, do a least !squares solutions. Else, get the explicit inverse and multiply. !Checking determinant against a small value 1E-8. if ( det ( mat_mi ) > 1.0E-10_rp ) then !Invert the moment of inertia matrix call invert_mat33 ( mat_mi , inv_mat_mi ) !Solve for angular velocity angvel = matmul ( inv_mat_mi , - angmom ) else !TODO: The following must be replaced with a more efficient SVD !routine for 3 x 3 matrices. As of now, calling LAPACK for !least-squares solution. angmom = - angmom call gelsy ( mat_mi , angmom ) angvel = angmom end if !Correct velocities to enforce angular mometum conservation do i = 1 , na_cell iatm = aic ( i ) massi = buf_aic ( i ) ri = buf_aic ( ofstc + 3 * i - 2 : ofstc + 3 * i ) call cross ( angvel , ri , vi ) !Using vi as a buffer here ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i buf_aic ( ibeg : iend ) = buf_aic ( ibeg : iend ) + vi end do !Copy back do i = 1 , na_cell iatm = aic ( i ) ibeg = ofstv + 3 * i - 2 ; iend = ofstv + 3 * i velocities (:, iatm ) = buf_aic ( ibeg : iend ) end do end do !Reverse shift do i = 1 , num_atoms_tot coordinates (:, i ) = coordinates (:, i ) - gsv end do !Wrap around periodic boundaries call simbox % wrap_all ( coordinates ) !Update energy and stress energy_kin = 0.0_rp stress_kin = 0.0_rp stress_slvnt = 0.0_rp mass_tot = 0.0_rp ; com = 0.0_rp ; vcom = 0.0_rp do i = 1 , num_atoms_tot massi = mass ( i ) mass_tot = mass_tot + massi com = com + massi * coordinates (:, i ) vcom = vcom + massi * velocities (:, i ) end do com = com / mass_tot vcom = vcom / mass_tot do i = 1 , num_atoms massi = mass ( i ) energy_kin = energy_kin + 0.5_rp * massi * sum ( velocities (:, i ) ** 2 ) vi = velocities (:, i ) - vcom stress_kin ( 1 , 1 ) = stress_kin ( 1 , 1 ) + massi * vi ( 1 ) * vi ( 1 ) stress_kin ( 2 , 1 ) = stress_kin ( 2 , 1 ) + massi * vi ( 2 ) * vi ( 1 ) stress_kin ( 3 , 1 ) = stress_kin ( 3 , 1 ) + massi * vi ( 3 ) * vi ( 1 ) stress_kin ( 1 , 2 ) = stress_kin ( 1 , 2 ) + massi * vi ( 1 ) * vi ( 2 ) stress_kin ( 2 , 2 ) = stress_kin ( 2 , 2 ) + massi * vi ( 2 ) * vi ( 2 ) stress_kin ( 3 , 2 ) = stress_kin ( 3 , 2 ) + massi * vi ( 3 ) * vi ( 2 ) stress_kin ( 1 , 3 ) = stress_kin ( 1 , 3 ) + massi * vi ( 1 ) * vi ( 3 ) stress_kin ( 2 , 3 ) = stress_kin ( 2 , 3 ) + massi * vi ( 2 ) * vi ( 3 ) stress_kin ( 3 , 3 ) = stress_kin ( 3 , 3 ) + massi * vi ( 3 ) * vi ( 3 ) end do do i = num_atoms + 1 , num_atoms_tot !Mass of MPCD particles is 1 (non-dimensionalized form). energy_kin = energy_kin + 0.5_rp * sum ( velocities (:, i ) ** 2 ) vi = velocities (:, i ) - vcom stress_slvnt ( 1 , 1 ) = stress_slvnt ( 1 , 1 ) + vi ( 1 ) * vi ( 1 ) stress_slvnt ( 2 , 1 ) = stress_slvnt ( 2 , 1 ) + vi ( 2 ) * vi ( 1 ) stress_slvnt ( 3 , 1 ) = stress_slvnt ( 3 , 1 ) + vi ( 3 ) * vi ( 1 ) stress_slvnt ( 1 , 2 ) = stress_slvnt ( 1 , 2 ) + vi ( 1 ) * vi ( 2 ) stress_slvnt ( 2 , 2 ) = stress_slvnt ( 2 , 2 ) + vi ( 2 ) * vi ( 2 ) stress_slvnt ( 3 , 2 ) = stress_slvnt ( 3 , 2 ) + vi ( 3 ) * vi ( 2 ) stress_slvnt ( 1 , 3 ) = stress_slvnt ( 1 , 3 ) + vi ( 1 ) * vi ( 3 ) stress_slvnt ( 2 , 3 ) = stress_slvnt ( 2 , 3 ) + vi ( 2 ) * vi ( 3 ) stress_slvnt ( 3 , 3 ) = stress_slvnt ( 3 , 3 ) + vi ( 3 ) * vi ( 3 ) end do energy_tot = energy_tot + energy_kin stress_kin = stress_kin / simbox % volume stress = stress + stress_kin stress_slvnt = stress_slvnt / simbox % volume end subroutine !****************************************************************************** end module m_mpcd","tags":"","loc":"sourcefile/m_mpcd.f90.html"},{"title":"m_precision.f90 – BROWNPAK","text":"Files dependent on this one sourcefile~~m_precision.f90~~AfferentGraph sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_ia_external.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_ia_external.f90->sourcefile~m_constants_math.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_ia_angle.f90->sourcefile~m_precision.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_ia_bond.f90->sourcefile~m_precision.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_constants_math.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_ia_bond.f90->sourcefile~m_strings.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_precision.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_constants_math.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_connectivity.f90->sourcefile~m_precision.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_connectivity.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_cell_list.f90->sourcefile~m_precision.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_vector.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_precision.f90 sourcefile~m_kmc.f90->sourcefile~m_globals.f90 sourcefile~m_kmc.f90->sourcefile~m_constants_math.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_kmc.f90->sourcefile~m_strings.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_kmc.f90->sourcefile~m_ran_num.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_precision.f90 sourcefile~m_setup.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_setup.f90->sourcefile~m_config_io.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_simbox.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_setup.f90->sourcefile~m_stats_io.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_ran_num.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_verlet.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_vector.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_config_io.f90->sourcefile~m_precision.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90->sourcefile~m_simbox.f90 sourcefile~m_config_io.f90->sourcefile~m_strings.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_ia_tether.f90->sourcefile~m_precision.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_constants_math.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_table.f90->sourcefile~m_precision.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_control_io.f90 m_control_io.f90 sourcefile~m_control_io.f90->sourcefile~m_precision.f90 sourcefile~m_control_io.f90->sourcefile~m_globals.f90 sourcefile~m_control_io.f90->sourcefile~m_strings.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_precision.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_constants_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_precision.f90 sourcefile~m_mpcd.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_constants_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_strings.f90 sourcefile~m_utils_math.f90 m_utils_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_utils_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_interaction.f90->sourcefile~m_precision.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_constants_math.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_stats_io.f90->sourcefile~m_precision.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_stats_io.f90->sourcefile~m_constants_math.f90 sourcefile~m_stats_io.f90->sourcefile~m_strings.f90 sourcefile~m_bd_solver.f90->sourcefile~m_precision.f90 sourcefile~m_bd_solver.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90->sourcefile~m_constants_math.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_strings.f90 sourcefile~m_bd_solver.f90->sourcefile~m_ran_num.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_utils_math.f90->sourcefile~m_precision.f90 sourcefile~m_utils_math.f90->sourcefile~m_constants_math.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_precision.f90 sourcefile~main.f90->sourcefile~m_globals.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_control_io.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_strings.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 sourcefile~m_relax.f90->sourcefile~m_precision.f90 sourcefile~m_relax.f90->sourcefile~m_globals.f90 sourcefile~m_relax.f90->sourcefile~m_config_io.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90->sourcefile~m_stats_io.f90 sourcefile~m_relax.f90->sourcefile~m_strings.f90 sourcefile~m_relax.f90->sourcefile~m_ran_num.f90 var pansourcefilem_precisionf90AfferentGraph = svgPanZoom('#sourcefilem_precisionf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_precision Source Code m_precision.f90 Source Code module m_precision use , intrinsic :: iso_fortran_env , only : int32 , int64 , real64 implicit none integer , parameter :: ip = int32 !! Default integer precision integer , parameter :: ip_long = int64 !! Default long integer precision integer , parameter :: rp = real64 !! Default real precision integer , parameter :: sizeof_char = 1 !! Size of a char in bytes integer , parameter :: sizeof_int = 4 !! Size of a default int in bytes integer , parameter :: sizeof_long_int = 8 !! Size of a default long int in bytes integer , parameter :: sizeof_real = 8 !! Size of a default real in bytes end module m_precision","tags":"","loc":"sourcefile/m_precision.f90.html"},{"title":"m_qsort.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_qsort.f90~~EfferentGraph sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_qsort.f90~~AfferentGraph sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_connectivity.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_verlet.f90->sourcefile~m_vector.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_cell_list.f90->sourcefile~m_vector.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 var pansourcefilem_qsortf90AfferentGraph = svgPanZoom('#sourcefilem_qsortf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_qsort Source Code m_qsort.f90 Source Code MODULE m_qsort !!  Implements quicksort for a sequence of integers and reals, in combination with !!  insertion sort for very short sequences. !! !! - Quick sort routine from Brainerd, W.S., Goldberg, C.H. & Adams, J.C. (1990) !! \"Programmer's Guide to Fortran 90\", McGraw-Hill  ISBN 0-07-000248-7, pages 149-150. !! - Modified by Alan Miller to include an associated integer array which gives !!   the positions of the elements in the original order. !! - Modified for integer array by Sarit Dutta USE M_PRECISION IMPLICIT NONE CONTAINS !****************************************************************************** RECURSIVE SUBROUTINE iqsort ( list , order ) !!  Sorts a sequence of integers IMPLICIT NONE INTEGER , DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of integers to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE iqsort !****************************************************************************** RECURSIVE SUBROUTINE dqsort ( list , order ) !!  Sorts a sequence of reals !\"\" IMPLICIT NONE REAL ( RP ), DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of reals to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE dqsort !****************************************************************************** END MODULE m_qsort","tags":"","loc":"sourcefile/m_qsort.f90.html"},{"title":"m_ran_num.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_ran_num.f90~~EfferentGraph sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_ran_num.f90~~AfferentGraph sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_ran_num.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_kmc.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_ran_num.f90 sourcefile~m_setup.f90->sourcefile~m_simbox.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_setup.f90->sourcefile~m_config_io.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_setup.f90->sourcefile~m_stats_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_ran_num.f90 sourcefile~m_bd_solver.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_ran_num.f90 sourcefile~m_mpcd.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_ran_num.f90 sourcefile~m_relax.f90->sourcefile~m_globals.f90 sourcefile~m_relax.f90->sourcefile~m_config_io.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90->sourcefile~m_stats_io.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_config_io.f90->sourcefile~m_simbox.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~main.f90->sourcefile~m_globals.f90 sourcefile~m_control_io.f90 m_control_io.f90 sourcefile~main.f90->sourcefile~m_control_io.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_control_io.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 var pansourcefilem_ran_numf90AfferentGraph = svgPanZoom('#sourcefilem_ran_numf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_ran_num Source Code m_ran_num.f90 Source Code module m_ran_num !!  Provides random number generation procedures, mostly calling !! routine from Intel MKL VSL. use m_precision use mkl_vsl_type use mkl_vsl implicit none private public :: & init_stream , & delete_stream , & load_stream , & save_stream , & save_seed , & get_iuniform , & get_rv_iuniform , & get_uniform , & get_rv_uniform , & get_rv_gaussian , & ransphere integer ( ip ), save :: seed type ( VSL_STREAM_STATE ), save :: stream contains !******************************************************************* subroutine init_stream ( fn ) !! Initializes a BRNG stream. !! The stream is initialized with a seed from the file `fn`. If !! `fn` is an empty string, the seed is obtained from `/dev/urandom`. character ( len =* ) :: fn !! Name of the file containing the RNG seed. integer ( ip ) :: fu integer ( ip ) :: stat if ( len_trim ( fn ) == 0 ) then open ( newunit = fu , file = '/dev/urandom' , action = 'read' , & form = 'unformatted' , access = 'stream' , status = 'old' ) read ( fu ) seed close ( fu ) seed = abs ( seed ) else open ( newunit = fu , file = fn , action = 'read' , status = 'old' ) read ( fu , * ) seed close ( fu ) end if stat = vslNewStream ( stream , VSL_BRNG_MT19937 , seed ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslNewStream' end if end subroutine !******************************************************************* subroutine delete_stream () !! Deletes a BRNG stream. integer ( ip ) :: stat stat = vslDeleteStream ( stream ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslDeleteStream' end if end subroutine !******************************************************************* subroutine load_stream ( fn ) !! Loads a BRNG stream from file `fn`. character ( len =* ), intent ( in ) :: fn integer ( ip ) :: stat stat = vslLoadStreamF ( stream , fn ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslLoadStream' end if end subroutine !******************************************************************* subroutine save_seed ( fn ) !! Saves the RNG seed to file `fn`. character ( len =* ), intent ( in ) :: fn integer ( ip ) :: fu open ( newunit = fu , file = fn , action = 'write' , status = 'replace' ) write ( fu , * ) seed close ( fu ) end subroutine !******************************************************************* subroutine save_stream ( fn ) !! Saves a BRNG stream to file `fn`. character ( len =* ), intent ( in ) :: fn integer ( ip ) :: stat stat = vslSaveStreamF ( stream , fn ) if ( stat /= VSL_STATUS_OK ) then write ( * , * ) 'error: vslSaveStream' end if end subroutine !******************************************************************* function get_uniform ( lb , ub ) result ( res ) !! Returns a random number from a uniform distribution. real ( rp ), intent ( in ) :: lb !! Lower bound real ( rp ), intent ( in ) :: ub !! Upper bound real ( rp ) :: res real ( rp ), dimension ( 1 ) :: rv integer ( ip ) :: stat stat = vdrnguniform ( VSL_RNG_METHOD_UNIFORM_STD_ACCURATE , stream , & 1 , rv , lb , ub ) res = rv ( 1 ) end function !******************************************************************* subroutine get_rv_uniform ( lb , ub , rv , block_size ) !! Returns a random vector from a uniform distribution. !! If a `block_size > 0` is provided, it fills `rv` in blocks of !! size `block_size`. real ( rp ), intent ( in ) :: lb !! Lower bound real ( rp ), intent ( in ) :: ub !! Upper bound real ( rp ), dimension (:), intent ( out ) :: rv integer ( ip ), intent ( in ), optional :: block_size integer ( ip ) :: stat integer ( ip ) :: num_blocks integer ( ip ) :: size_rv integer ( ip ) :: ini integer ( ip ) :: fin integer ( ip ) :: n if (. not . present ( block_size )) then stat = vdrnguniform ( VSL_RNG_METHOD_UNIFORM_STD_ACCURATE , stream , & size ( rv ), rv , lb , ub ) else size_rv = size ( rv ) num_blocks = ceiling ( size_rv / real ( block_size )) ini = 0 fin = 0 do if ( fin >= size_rv ) then exit end if if ( size_rv <= block_size ) then n = size_rv else if (( size_rv - fin ) < block_size ) then n = size_rv - fin else n = block_size end if ini = fin + 1 fin = fin + n stat = vdrnguniform ( VSL_RNG_METHOD_UNIFORM_STD_ACCURATE , stream , & n , rv ( ini : fin ), lb , ub ) end do end if end subroutine !******************************************************************* function get_iuniform ( lb , ub ) result ( res ) !! Returns a random integer from a uniform distribution. integer ( ip ), intent ( in ) :: lb integer ( ip ), intent ( in ) :: ub integer ( ip ) :: res integer ( ip ), dimension ( 1 ) :: rv integer ( ip ) :: stat stat = virnguniform ( VSL_RNG_METHOD_UNIFORM_STD , stream , & 1 , rv , lb , ub ) res = rv ( 1 ) end function !******************************************************************* subroutine get_rv_iuniform ( lb , ub , rv , block_size ) !! Returns a random vector of integers from a uniform distribution. integer ( ip ), intent ( in ) :: lb integer ( ip ), intent ( in ) :: ub integer ( ip ), dimension (:), intent ( out ) :: rv integer ( ip ), intent ( in ), optional :: block_size integer ( ip ) :: stat integer ( ip ) :: num_blocks integer ( ip ) :: size_rv integer ( ip ) :: ini integer ( ip ) :: fin integer ( ip ) :: n if (. not . present ( block_size )) then stat = virnguniform ( VSL_RNG_METHOD_UNIFORM_STD , stream , & size ( rv ), rv , lb , ub ) else size_rv = size ( rv ) num_blocks = ceiling ( size_rv / real ( block_size )) ini = 0 fin = 0 do if ( fin >= size_rv ) then exit end if if ( size_rv <= block_size ) then n = size_rv else if (( size_rv - fin ) < block_size ) then n = size_rv - fin else n = block_size end if ini = fin + 1 fin = fin + n stat = virnguniform ( VSL_RNG_METHOD_UNIFORM_STD , stream , & n , rv ( ini : fin ), lb , ub ) end do end if end subroutine !******************************************************************* subroutine get_rv_gaussian ( mean , std_dev , rv , block_size ) !! Generates a random vector of integers from a gaussian distribution. real ( rp ), intent ( in ) :: mean real ( rp ), intent ( in ) :: std_dev real ( rp ), dimension (:), intent ( out ) :: rv integer ( ip ), intent ( in ), optional :: block_size integer ( ip ) :: stat integer ( ip ) :: num_blocks integer ( ip ) :: size_rv integer ( ip ) :: ini integer ( ip ) :: fin integer ( ip ) :: n if (. not . present ( block_size )) then stat = vdrnggaussian ( VSL_RNG_METHOD_GAUSSIAN_BOXMULLER , stream , & size ( rv ), rv , mean , std_dev ) else size_rv = size ( rv ) num_blocks = ceiling ( size_rv / real ( block_size )) ini = 0 fin = 0 do if ( fin >= size_rv ) then exit end if if ( size_rv <= block_size ) then n = size_rv else if (( size_rv - fin ) < block_size ) then n = size_rv - fin else n = block_size end if ini = fin + 1 fin = fin + n stat = vdrnggaussian ( VSL_RNG_METHOD_GAUSSIAN_BOXMULLER , stream , & n , rv ( ini : fin ), mean , std_dev ) end do end if end subroutine !******************************************************************* subroutine ransphere ( r ) !! Generates a random vector from the surface of a unit sphere. !! !! Algorithm from Allen & Tildesley (ed 1) p. 349. real ( rp ), dimension ( 3 ), intent ( out ) :: r ( 3 ) real ( rp ), dimension ( 2 ) :: zeta real ( rp ) :: zetasq real ( rp ) :: rt r = 0.0_rp zetasq = 2.0_rp ! Any value greater than 1 do call get_rv_uniform ( - 1.0_rp , 1.0_rp , zeta ) zetasq = zeta ( 1 ) * zeta ( 1 ) + zeta ( 2 ) * zeta ( 2 ) rt = sqrt ( 1.0_rp - zetasq ) r ( 1 ) = 2.0_rp * zeta ( 1 ) * rt r ( 2 ) = 2.0_rp * zeta ( 2 ) * rt r ( 3 ) = 1.0_rp - 2.0_rp * zetasq if ( zetasq <= 1.0_rp ) exit end do end subroutine !******************************************************************* end module m_ran_num","tags":"","loc":"sourcefile/m_ran_num.f90.html"},{"title":"m_relax.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_relax.f90~~EfferentGraph sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_relax.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_relax.f90->sourcefile~m_precision.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_relax.f90->sourcefile~m_stats_io.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_relax.f90->sourcefile~m_strings.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_relax.f90->sourcefile~m_config_io.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_relax.f90->sourcefile~m_ran_num.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_relax.f90->sourcefile~m_logger.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_interaction.f90->sourcefile~m_constants_math.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_stats_io.f90->sourcefile~m_precision.f90 sourcefile~m_stats_io.f90->sourcefile~m_strings.f90 sourcefile~m_stats_io.f90->sourcefile~m_constants_math.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90->sourcefile~m_precision.f90 sourcefile~m_config_io.f90->sourcefile~m_strings.f90 sourcefile~m_config_io.f90->sourcefile~m_simbox.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_ia_external.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90->sourcefile~m_constants_math.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_precision.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_cell_list.f90->sourcefile~m_vector.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_connectivity.f90->sourcefile~m_precision.f90 sourcefile~m_connectivity.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_vector.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_precision.f90 sourcefile~m_ia_angle.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_precision.f90 sourcefile~m_ia_bond.f90->sourcefile~m_strings.f90 sourcefile~m_ia_bond.f90->sourcefile~m_logger.f90 sourcefile~m_ia_bond.f90->sourcefile~m_constants_math.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_precision.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_logger.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_precision.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_precision.f90 sourcefile~m_ia_tether.f90->sourcefile~m_constants_math.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_table.f90->sourcefile~m_precision.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 var pansourcefilem_relaxf90EfferentGraph = svgPanZoom('#sourcefilem_relaxf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_relax.f90~~AfferentGraph sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_relax Source Code m_relax.f90 Source Code module m_relax !! Performs structure relaxation (energy minimization) using steepest descent. !! !! Atom positions evolve following the gradient direction, in steps of size !! `tim_stp`. If `tim_stp` is too large, bond constraints are likely to be !! violated. !! !! If MPCD atoms are present, they do not take part in structure relaxation. use m_precision use m_ran_num use m_strings use m_globals use m_interaction , only : ia_calc_forces use m_stats_io use m_config_io use m_logger , only : logger => master_logger implicit none private public :: rlx_run contains !****************************************************************************** subroutine rlx_run () !! Driver for relaxation character ( len = :), allocatable :: fn_ldf , fn_rlx real ( rp ), parameter :: abs_tol = 1.0E-3_rp real ( rp ), parameter :: rel_tol = 1.0E-8_rp real ( rp ) :: enrg0 , enrg_dif integer :: ierr logical :: zf , has_converged fn_rlx = str_strip ( fn_cfg , '.cfg' , 'r' ) // '-rlx.cfg' fn_ldf = str_strip ( fn_cfg , '.cfg' , 'r' ) // '-rlx.txt' ierr = 0 !For isolated untethered molecule, ensure c.o.m. is at the center of the !box. if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) then call simbox % to_center ( coordinates ) end if !Log & dump starting configuration call logger % info ( 'rlx_run' , ' nts: ' // str_from_num ( nts )) call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) !Relaxation run has_converged = . false . !Assume a very high initial energy enrg0 = huge ( 1.0_rp ) do while ( nts < nts_sim ) if ( has_converged ) exit call rlx_integrate ( ierr , zf ) nts = nts + 1 !For isolated untethered molecule bring c.o.m. to the center of the box if ( ( num_tethers == 0 ) . and . ( imcon == 0 ) ) then call simbox % to_center ( coordinates ) end if !Wrap around periodic boundaries if ( imcon /= 0 ) call simbox % wrap_all ( coordinates (:, 1 : num_atoms )) !Logging if ( mod ( nts , nts_log ) == 0 ) then call logger % info ( 'rlx_run' , ' nts: ' // str_from_num ( nts )) end if !Dump revive file if ( mod ( nts , nts_dump ) == 0 ) then call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) end if !Relaxation stats if ( mod ( nts , nts_samp ) == 0 ) call stats_write () !Convergence check !I am not using relative tolerance here. if ( zf ) has_converged = . true . enrg_dif = abs ( energy_tot - enrg0 ) if ( enrg_dif <= ( rel_tol * energy_tot + abs_tol ) ) has_converged = . true . enrg0 = energy_tot end do !Log end of run if ( ierr /= 0 ) then call logger % info ( 'finish_rlx_run' , 'Relaxation completed with violations' ) else call logger % info ( 'finish_rlx_run' , 'Relaxation completed' ) end if !Dump the final configuration call write_dump ( fn_revive // trim ( adjustl ( job_tag ))) !Export final configuration to config & ldf files call write_config ( fn_rlx , ' ' ) call write_ldf ( fn_ldf , ' ' ) end subroutine !****************************************************************************** subroutine rlx_integrate ( ierr , zf ) !! Performs one step of relaxation integer , intent ( out ) :: ierr logical , intent ( out ) :: zf real ( rp ) :: scale_factor integer :: i zf = . false . !Calculate forces call ia_calc_forces ( ierr ) !If all forces are zero, nothing to do if ( all ( forces == 0.0_rp ) ) then zf = . true . return end if scale_factor = 1.0_rp / maxval ( abs ( forces )) forces = scale_factor * forces scale_factor = 1.0_rp / sum ( forces ** 2 ) forces = scale_factor * forces !Update position do i = 1 , num_atoms coordinates (:, i ) = coordinates (:, i ) + tim_stp * forces (:, i ) end do end subroutine !******************************************************************************** end module m_relax","tags":"","loc":"sourcefile/m_relax.f90.html"},{"title":"m_setup.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_setup.f90~~EfferentGraph sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_setup.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_setup.f90->sourcefile~m_precision.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_setup.f90->sourcefile~m_simbox.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_setup.f90->sourcefile~m_stats_io.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_setup.f90->sourcefile~m_config_io.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_setup.f90->sourcefile~m_ran_num.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_setup.f90->sourcefile~m_logger.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_precision.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_interaction.f90->sourcefile~m_constants_math.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_stats_io.f90->sourcefile~m_precision.f90 sourcefile~m_stats_io.f90->sourcefile~m_constants_math.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_stats_io.f90->sourcefile~m_strings.f90 sourcefile~m_bd_solver.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90->sourcefile~m_precision.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_ran_num.f90 sourcefile~m_bd_solver.f90->sourcefile~m_logger.f90 sourcefile~m_bd_solver.f90->sourcefile~m_constants_math.f90 sourcefile~m_bd_solver.f90->sourcefile~m_strings.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90->sourcefile~m_precision.f90 sourcefile~m_config_io.f90->sourcefile~m_simbox.f90 sourcefile~m_config_io.f90->sourcefile~m_strings.f90 sourcefile~m_mpcd.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_precision.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_ran_num.f90 sourcefile~m_mpcd.f90->sourcefile~m_logger.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_constants_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_strings.f90 sourcefile~m_utils_math.f90 m_utils_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_utils_math.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_connectivity.f90->sourcefile~m_precision.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_connectivity.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_ia_external.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90->sourcefile~m_constants_math.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_precision.f90 sourcefile~m_cell_list.f90->sourcefile~m_vector.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_vector.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_precision.f90 sourcefile~m_ia_angle.f90->sourcefile~m_constants_math.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_utils_math.f90->sourcefile~m_precision.f90 sourcefile~m_utils_math.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_precision.f90 sourcefile~m_ia_bond.f90->sourcefile~m_logger.f90 sourcefile~m_ia_bond.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_strings.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_precision.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_logger.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_precision.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_precision.f90 sourcefile~m_ia_tether.f90->sourcefile~m_constants_math.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_table.f90->sourcefile~m_precision.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 var pansourcefilem_setupf90EfferentGraph = svgPanZoom('#sourcefilem_setupf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_setup.f90~~AfferentGraph sourcefile~m_setup.f90 m_setup.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_setup Source Code m_setup.f90 Source Code module m_setup !! Routines for doing allocation, etc. in preparation for simulation run. use m_precision use m_ran_num use m_simbox use m_globals use m_config_io use m_interaction , only : ia_setup , ia_finish use m_bd_solver , only : bds_init , bds_finish use m_mpcd , only : mpcd_init , mpcd_finish use m_stats_io , only : stats_init , stats_finish use m_logger , only : logger => master_logger implicit none contains !******************************************************************************* subroutine setup () integer :: ierr ierr = 0 !Create the simulation box. Its attributes will change later based on input !data. call smbx_init ( simbox ) !Read configuration from files if ( lrevive ) then !Restarting simulation !Read revive file call read_dump ( fn_revive // trim ( adjustl ( job_tag ))) else !New simulation !Read initial configuration file call read_config ( fn_cfg // trim ( adjustl ( job_tag ))) !No equilibration for energy minimization if ( sim_style == 0 ) then leql = . false . else leql = . true . end if nts = 0 end if !Allocate memory for forces. Forces are not saved in revive file or !in config file as they can be calculated based from position data. !MPCD particles do not have any forces acting on them. allocate ( forces ( 3 , num_atoms ) ) forces = 0.0_rp !Initialize stats collection call stats_init () !Initialize random number generator if ( read_seed ) then call init_stream ( 'random_seed.txt' // trim ( adjustl ( job_tag ))) else call init_stream ( '' ) end if if ( write_seed ) call save_seed ( 'random_seed.txt' // trim ( adjustl ( job_tag ))) !Set up interactions call ia_setup () !Set up solver. No need to set up for structure relaxation. if ( sim_style == 1 ) then call bds_init ( ierr ) else if ( sim_style == 2 ) then call mpcd_init ( ierr ) end if if ( ierr /= 0 ) call finish () end subroutine !******************************************************************************* subroutine config_clear () !! Clears out all configuration related variables in module `m_globals`. num_atom_types = 0 ; num_atoms = 0 if ( allocated ( atom_names )) deallocate ( atom_names ) if ( allocated ( atom_styles )) deallocate ( atom_styles ) if ( allocated ( atom_mass )) deallocate ( atom_mass ) if ( allocated ( atoms )) deallocate ( atoms ) if ( allocated ( coordinates )) deallocate ( coordinates ) if ( allocated ( velocities )) deallocate ( velocities ) if ( allocated ( forces )) deallocate ( forces ) if ( allocated ( charge )) deallocate ( charge ) num_bond_types = 0 ; num_bonds = 0 if ( allocated ( bond_styles )) deallocate ( bond_styles ) if ( allocated ( bond_params )) deallocate ( bond_params ) if ( allocated ( bonds )) deallocate ( bonds ) num_angle_types = 0 ; num_angles = 0 if ( allocated ( angle_styles )) deallocate ( angle_styles ) if ( allocated ( angle_params )) deallocate ( angle_params ) if ( allocated ( angles )) deallocate ( angles ) num_dihedral_types = 0 ; num_dihedrals = 0 if ( allocated ( dihedral_styles )) deallocate ( dihedral_styles ) if ( allocated ( dihedral_params )) deallocate ( dihedral_params ) if ( allocated ( dihedrals )) deallocate ( dihedrals ) num_branches = 0 if ( allocated ( branches )) deallocate ( branches ) num_molecule_types = 0 ; num_molecules = 0 if ( allocated ( molecule_names )) deallocate ( molecule_names ) if ( allocated ( molecule_pop )) deallocate ( molecule_pop ) if ( allocated ( molecules )) deallocate ( molecules ) num_tether_types = 0 ; num_tethers = 0 if ( allocated ( tether_styles )) deallocate ( tether_styles ) if ( allocated ( tether_params )) deallocate ( tether_params ) if ( allocated ( tethers )) deallocate ( tethers ) if ( allocated ( tether_points )) deallocate ( tether_points ) num_vdw_types = 0 if ( allocated ( vdw_styles )) deallocate ( vdw_styles ) if ( allocated ( vdw_params )) deallocate ( vdw_params ) if ( allocated ( vdw_pairs )) deallocate ( vdw_pairs ) num_externals = 0 if ( allocated ( external_styles )) deallocate ( external_styles ) if ( allocated ( external_params )) deallocate ( external_params ) if ( allocated ( flow_params )) deallocate ( flow_params ) end subroutine !******************************************************************************* subroutine finish () if ( sim_style == 1 ) then call bds_finish () else if ( sim_style == 2 ) then call mpcd_finish () end if call ia_finish () call stats_finish () call config_clear () end subroutine !******************************************************************************* end module m_setup","tags":"","loc":"sourcefile/m_setup.f90.html"},{"title":"m_simbox.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_simbox.f90~~EfferentGraph sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_simbox.f90~~AfferentGraph sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_simbox.f90 sourcefile~m_setup.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_setup.f90->sourcefile~m_config_io.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_setup.f90->sourcefile~m_stats_io.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_config_io.f90->sourcefile~m_simbox.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_globals.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_control_io.f90 m_control_io.f90 sourcefile~m_control_io.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_globals.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_control_io.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_relax.f90->sourcefile~m_globals.f90 sourcefile~m_relax.f90->sourcefile~m_config_io.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90->sourcefile~m_stats_io.f90 var pansourcefilem_simboxf90AfferentGraph = svgPanZoom('#sourcefilem_simboxf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_simbox Source Code m_simbox.f90 Source Code module m_simbox !! Implements a simulation box with appropriate boundary conditions. use m_precision use m_constants_math use m_ran_num implicit none type smbx_t real ( rp ), dimension ( 3 , 3 ) :: basis real ( rp ), dimension ( 3 , 3 ) :: dl_basis real ( rp ) :: volume logical :: is_deforming logical :: is_aligned !! Whether the basis vectors are aligned with the laboratory frame contains procedure :: set_basis => smbx_set_basis procedure :: freeze => smbx_freeze procedure :: unfreeze => smbx_unfreeze procedure :: get_image => smbx_get_image procedure :: wrap_all => smbx_wrap_all procedure :: to_center => smbx_to_center procedure :: get_rnd_points => smbx_get_rnd_points end type smbx_t contains !******************************************************************************** subroutine smbx_init ( this ) !!Creates an instance of *smbx_t*. Can also be called to reset. type ( smbx_t ), intent ( in out ) :: this !Initialize to an identity matrix this % basis = 0.0_rp this % basis ( 1 , 1 ) = 1.0_rp this % basis ( 2 , 2 ) = 1.0_rp this % basis ( 3 , 3 ) = 1.0_rp this % volume = 1.0_rp this % dl_basis = this % basis this % is_deforming = . false . this % is_aligned = . true . end subroutine !******************************************************************************** subroutine smbx_set_basis ( this , bv ) !!Sets all three basis vectors. class ( smbx_t ), intent ( in out ) :: this real ( rp ), dimension ( 3 , 3 ), intent ( in ) :: bv real ( rp ), dimension ( 3 ) :: a , b , c this % basis = bv a = this % basis (:, 1 ); b = this % basis (:, 2 ); c = this % basis (:, 3 ) this % volume = a ( 1 ) * ( b ( 2 ) * c ( 3 ) - c ( 2 ) * b ( 3 ) ) - a ( 2 ) * ( b ( 1 ) * c ( 3 ) - c ( 1 ) * b ( 3 ) ) & + a ( 3 ) * ( b ( 1 ) * c ( 2 ) - c ( 1 ) * b ( 2 ) ) end subroutine !******************************************************************************** subroutine smbx_freeze ( this ) !!Specifies *this* as non-deforming. class ( smbx_t ), intent ( in out ) :: this this % is_deforming = . false . end subroutine !******************************************************************************** subroutine smbx_unfreeze ( this ) !!Specifies *this* as deforming. class ( smbx_t ), intent ( in out ) :: this this % is_deforming = . true . end subroutine !******************************************************************************** subroutine smbx_get_image ( this , r ) !!Returns the image of *r* under PBC. !https://scicomp.stackexchange.com/questions/20165/periodic-boundary-conditions-for-triclinic-box class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension ( 3 ), intent ( in out ) :: r real ( rp ), dimension ( 3 ) :: rf if ( this % is_aligned ) then r ( 1 ) = r ( 1 ) - this % basis ( 1 , 1 ) * nint ( r ( 1 ) / this % basis ( 1 , 1 ) ) r ( 2 ) = r ( 2 ) - this % basis ( 2 , 2 ) * nint ( r ( 2 ) / this % basis ( 2 , 2 ) ) r ( 3 ) = r ( 3 ) - this % basis ( 3 , 3 ) * nint ( r ( 3 ) / this % basis ( 3 , 3 ) ) else rf = matmul ( this % dl_basis , r ) rf = rf - nint ( rf ) r = matmul ( this % basis , rf ) end if end subroutine !******************************************************************************** subroutine smbx_wrap_all ( this , coords ) !!Wraps atom positions w.r.t. periodic boundary conditions. !https://scicomp.stackexchange.com/questions/20165/periodic-boundary-conditions-for-triclinic-box class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension (:,:), intent ( in out ) :: coords real ( rp ), dimension ( 3 ) :: rf real ( rp ), dimension ( 3 ) :: diag integer :: n , i n = size ( coords , 2 ) if ( this % is_aligned ) then diag = [ this % basis ( 1 , 1 ), this % basis ( 2 , 2 ), this % basis ( 3 , 3 )] do i = 1 , n coords (:, i ) = coords (:, i ) - diag * floor ( coords (:, i ) / diag ) end do else do i = 1 , n rf = matmul ( this % dl_basis , coords (:, i )) rf = rf - floor ( rf ) coords (:, i ) = matmul ( this % basis , rf ) end do end if end subroutine !******************************************************************************** subroutine smbx_to_center ( this , coords , com ) !!Adjusts atom positions such that the c.o.m. of the atoms is at the center !! of the box. Assumes all atoms to have the same mass and aligned axis. !! Optionally returns the original c.o.m. class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension (:,:), intent ( in out ) :: coords real ( rp ), dimension ( 3 ), intent ( out ), optional :: com real ( rp ), dimension ( 3 ) :: half_diag , com_ integer :: n , i half_diag = 0.5_rp * [ this % basis ( 1 , 1 ), this % basis ( 2 , 2 ), this % basis ( 3 , 3 )] n = size ( coords , 2 ) com_ = sum ( coords , 2 ) / n do i = 1 , n coords (:, i ) = coords (:, i ) - com_ + half_diag end do if ( present ( com )) com = com_ - half_diag end subroutine !******************************************************************************** subroutine smbx_get_rnd_points ( this , coords ) !!Returns uniformly distributed points within the box. class ( smbx_t ), intent ( in ) :: this real ( rp ), dimension (:,:), intent ( out ) :: coords real ( rp ), dimension ( 3 ) :: r integer :: n , i n = size ( coords , 2 ) do i = 1 , n call get_rv_uniform ( 0.0_rp , 1.0_rp , r ) coords (:, i ) = matmul ( this % basis , r ) end do end subroutine !******************************************************************************** end module m_simbox","tags":"","loc":"sourcefile/m_simbox.f90.html"},{"title":"m_stats_io.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_stats_io.f90~~EfferentGraph sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_stats_io.f90->sourcefile~m_constants_math.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_stats_io.f90->sourcefile~m_precision.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_stats_io.f90->sourcefile~m_strings.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_stats_io.f90~~AfferentGraph sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_stats_io.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_stats_io.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_stats_io Source Code m_stats_io.f90 Source Code module m_stats_io !! Computes and writes properties calculated during simulation. use m_precision use m_constants_math use m_strings use m_globals implicit none private public :: stats_init , stats_finish , stats_write integer :: fu_stats !! Unit number of file `fn_stats`. real ( rp ), dimension ( 3 ) :: span !! Span of a chain molecule. For multiple molecules this is averaged. real ( rp ) :: reedsq !! Mean squared end-to-end distance of a linear chain molecule. !! For multiple molecules this is averaged. Not defined for rings. real ( rp ) :: rgsq !! Mean squared gyration radius of a chain/ring molecule. !! For multiple molecules this is averaged. real ( rp ), dimension ( 3 ) :: reev !! End-to-end vector. Not defined for rings. real ( rp ) :: asph !! Asphericity of the entire molecule real ( rp ) :: prol !! Prolateness of the entire molecule real ( rp ) :: rgsq_bbone !! Mean squared gyration radius of the backbone of a branched !! chain/ring molecule. real ( rp ) :: rgsq_sc !! Mean squared gyration radius of the side chains of a branched !! chain/ring molecule. real ( rp ) :: reedsq_sc !! Mean squared end-to-end distance of the side chains of a branched !! chain/ring molecule. real ( rp ) :: asph_sc !! Mean asphericity of the side chains of a branched chain/ring molecule. real ( rp ) :: prol_sc !! Mean prolateness of the side chains of a branched chain/ring molecule. real ( rp ), dimension (:,:), allocatable :: molbuf !! Buffer for the largest molecule in the system contains !****************************************************************************** subroutine stats_init () !! Set up for stats collection logical :: lexists integer :: n if ( lrevive ) then !Restarting simulation if ( leql ) then !Equilibration if ( write_eql_stats ) then !Check if file exists inquire ( file = fn_stats // '.eq' // trim ( adjustl ( job_tag )), exist = lexists ) if ( lexists ) then !Open existing file for appending equilibration statistics open ( newunit = fu_stats , file = fn_stats // '.eq' // trim ( adjustl ( job_tag )), & action = 'write' , position = 'append' , status = 'old' ) else !Open new file for writing equilibration statistics open ( newunit = fu_stats , file = fn_stats // '.eq' // trim ( adjustl ( job_tag )), & action = 'write' , status = 'new' ) !Write header call stats_write_hdr () end if end if else !Production (or relaxation) !Check if file exists inquire ( file = fn_stats // trim ( adjustl ( job_tag )), exist = lexists ) if ( lexists ) then !Open existing file for appending statistics open ( newunit = fu_stats , file = fn_stats // trim ( adjustl ( job_tag )), & action = 'write' , position = 'append' , status = 'old' ) else !Open new file for writing statistics open ( newunit = fu_stats , file = fn_stats // trim ( adjustl ( job_tag )), & action = 'write' , status = 'new' ) !Write header call stats_write_hdr () end if end if else !New simulation if ( leql ) then !Open file for writing equilibration statistics if ( write_eql_stats ) then open ( newunit = fu_stats , file = fn_stats // '.eq' // trim ( adjustl ( job_tag )), & action = 'write' , status = 'replace' ) end if else !Open file for writing production (or relaxation) statistics open ( newunit = fu_stats , file = fn_stats // trim ( adjustl ( job_tag )), & action = 'write' , status = 'replace' ) end if !Write header call stats_write_hdr () end if !Allocate space for unwrapping molecule under PBC if ( ( imcon /= 0 ) . and . ( num_molecules > 0 ) ) then n = maxval ( molecules ( 2 ,:)) if ( n > 1 ) allocate ( molbuf ( 3 , n ) ) end if end subroutine !****************************************************************************** subroutine stats_finish () !! Closes any files opened in `stats_init`. integer :: fu logical :: lopened inquire ( file = fn_stats // '.eq' // trim ( adjustl ( job_tag )), number = fu , & opened = lopened ) if ( lopened ) close ( fu ) inquire ( file = fn_stats // trim ( adjustl ( job_tag )), number = fu , & opened = lopened ) if ( lopened ) close ( fu ) if ( allocated ( molbuf )) deallocate ( molbuf ) end subroutine !****************************************************************************** subroutine stats_write_hdr () !! Driver for writing header of file `fn_stats`. This is called only after !! appropriate files have been opened. write ( fu_stats , '(a12)' , advance = 'no' ) 'nts' if ( num_bonds > 0 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) & 'bndlen_avg' , 'bndlen_min' , 'bndlen_max' , 'energy_bond' end if if ( num_angles > 0 ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_angle' end if if ( num_dihedrals > 0 ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_dihedral' end if if ( lvdw ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_vdw' end if if ( num_tethers > 0 ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_tether' end if if ( num_externals > 0 ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_external' end if if ( sim_style == 2 ) then write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_kin' end if write ( fu_stats , '(2x,a16)' , advance = 'no' ) 'energy_tot' !No further properties will be calculated for structure relaxation if ( sim_style == 0 ) then write ( fu_stats , * ) return end if !Stress (written only during production run) if (. not . leql ) then if ( num_atoms > 0 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'sxx' , 'syx' , 'szx' , & 'sxy' , 'syy' , 'szy' , 'sxz' , 'syz' , 'szz' end if if ( sim_style == 2 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'slv_sxx' , 'slv_syx' , 'slv_szx' , & 'slv_sxy' , 'slv_syy' , 'slv_szy' , 'slv_sxz' , 'slv_syz' , 'slv_szz' end if end if !Structural properties: Size (for multiple molecules these will be !averaged quantities) if ( num_bonds > 0 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'reedsq' , 'rgsq' , & 'spanx' , 'spany' , 'spanz' end if !Further structural properties (for single molecule) if (. not . leql ) then if ( ( imcon == 0 ) . and . ( num_bonds > 0 ) ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'reevx' , 'reevy' , & 'reevz' , 'asph' , 'prol' if ( num_branches > 0 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'rgsq_bbone' , & 'rgsq_sc' , 'reedsq_sc' , 'asph_sc' , 'prol_sc' end if if ( flow_style == 0 ) then write ( fu_stats , '(*(2x,a16))' , advance = 'no' ) 'comx' , 'comy' , 'comz' end if end if end if write ( fu_stats , * ) end subroutine !****************************************************************************** subroutine stats_write () !! Writing statistics write ( fu_stats , '(i12)' , advance = 'no' ) nts if ( num_bonds > 0 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) & bndlen , bndlen_min , bndlen_max , energy_bond end if if ( num_angles > 0 ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_angle end if if ( num_dihedrals > 0 ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_dihedral end if if ( lvdw ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_vdw end if if ( num_tethers > 0 ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_tether end if if ( num_externals > 0 ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_external end if if ( sim_style == 2 ) then write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_kin end if write ( fu_stats , '(2x,es16.7)' , advance = 'no' ) energy_tot !No further properties will be calculated for structure relaxation if ( sim_style == 0 ) then write ( fu_stats , * ) return end if !Stress (calculated only during production run) if (. not . leql ) then if ( num_atoms > 0 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) stress end if if ( sim_style == 2 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) stress_slvnt end if end if !Structural properties: Size (for multiple molecules these will be !averaged quantities) if ( imcon == 0 ) then call stats_compute_ic0 () else call stats_compute_ic1 () end if if ( num_bonds > 0 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) reedsq , rgsq , span end if !Further structural properties (for single molecule in unbounded domain) if (. not . leql ) then if ( ( imcon == 0 ) . and . ( num_bonds > 0 ) ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) reev , asph , prol if ( num_branches > 0 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) rgsq_bbone , & rgsq_sc , reedsq_sc , asph_sc , prol_sc end if if ( flow_style == 0 ) then write ( fu_stats , '(*(2x,es16.7))' , advance = 'no' ) molecule_com end if end if end if write ( fu_stats , * ) end subroutine !****************************************************************************** subroutine stats_compute_ic1 () !! Computes statistics for a possibly multiple chains in a periodic domain. real ( rp ), dimension ( 3 ) :: com real ( rp ) :: rgsq_im integer :: natm , nmol integer :: i , imol , ibeg rgsq = 0.0_rp ; reedsq = 0.0_rp ; span = 0.0_rp do imol = 1 , num_molecules natm = molecules ( 2 , imol ) if ( natm > 1 ) then molbuf = 0.0_rp ibeg = molecules ( 3 , imol ) do i = 1 , natm molbuf (:, i ) = coordinates (:, ibeg + i - 1 ) end do do i = 1 , natm molbuf (:, i ) = molbuf (:, i ) - molbuf (:, 1 ) call simbox % get_image ( molbuf (:, i )) end do span = span + maxval ( molbuf (:, 1 : natm ), 2 ) - minval ( molbuf (:, 1 : natm ), 2 ) reev = molbuf (:, natm ) reedsq = reedsq + sum ( reev ** 2 ) rgsq_im = 0.0_rp com = sum ( molbuf (:, 1 : natm ), 2 ) / natm do i = 1 , natm rgsq_im = rgsq_im + sum (( molbuf (:, i ) - com ) ** 2 ) end do rgsq = rgsq + rgsq_im / natm end if end do nmol = count ( molecules ( 2 ,:) > 1 ) span = span / nmol ; reedsq = reedsq / nmol ; rgsq = rgsq / nmol end subroutine !****************************************************************************** subroutine stats_compute_ic0 () !! Computes statistics for a single chain in unbounded domain. real ( rp ), dimension ( 3 ) :: gt_ev , gt_ev_sc , gt_ev_isc real ( rp ), dimension ( 3 , 3 ) :: S real ( rp ), dimension ( 3 ) :: ri real ( rp ), dimension ( 3 ) :: com , com_bbone , com_sc real ( rp ), dimension ( 3 ) :: r_tp real ( rp ) :: rgsq_isc , asph_isc , prol_isc integer :: n_sc integer :: na_bbone integer :: na_sc integer :: ibr , ia_beg , ia_end integer :: i !Number of backbone atoms if ( num_branches == 0 ) then na_bbone = num_atoms n_sc = 0 !Number of side chains else na_bbone = branches ( 2 , 1 ) n_sc = num_branches - 1 !Number of side chains end if !Zero out span = 0.0_rp ; rgsq = 0.0_rp ; reedsq = 0.0_rp asph = 0.0_rp ; prol = 0.0_rp rgsq_bbone = 0.0_rp rgsq_sc = 0.0_rp ; reedsq_sc = 0.0_rp ; asph_sc = 0.0_rp ; prol_sc = 0.0_rp gt_ev = 0.0_rp ; gt_ev_sc = 0.0_rp ; S = 0.0_rp ; reev = 0.0_rp span = maxval ( coordinates , 2 ) - minval ( coordinates , 2 ) reev = coordinates (:, na_bbone ) - coordinates (:, 1 ) reedsq = reev ( 1 ) * reev ( 1 ) + reev ( 2 ) * reev ( 2 ) + reev ( 3 ) * reev ( 3 ) com = sum ( coordinates , 2 ) / num_atoms do i = 1 , num_atoms ri = coordinates (:, i ) - com S ( 1 , 1 ) = S ( 1 , 1 ) + ri ( 1 ) * ri ( 1 ) S ( 1 , 2 ) = S ( 1 , 2 ) + ri ( 1 ) * ri ( 2 ) S ( 1 , 3 ) = S ( 1 , 3 ) + ri ( 1 ) * ri ( 3 ) S ( 2 , 2 ) = S ( 2 , 2 ) + ri ( 2 ) * ri ( 2 ) S ( 2 , 3 ) = S ( 2 , 3 ) + ri ( 2 ) * ri ( 3 ) S ( 3 , 3 ) = S ( 3 , 3 ) + ri ( 3 ) * ri ( 3 ) end do S = S / num_atoms rgsq = S ( 1 , 1 ) + S ( 2 , 2 ) + S ( 3 , 3 ) !Do not compute any more stuff suring equilibration if ( leql ) return call dsyevc3 ( S , gt_ev ) call calc_shape ( gt_ev ( 1 ), gt_ev ( 3 ), gt_ev ( 2 ), asph , prol ) com_bbone = sum ( coordinates (:, 1 : na_bbone ), 2 ) / na_bbone do i = 1 , na_bbone rgsq_bbone = rgsq_bbone + sum (( coordinates (:, i ) - com_bbone ) ** 2 ) end do rgsq_bbone = rgsq_bbone / na_bbone do ibr = 2 , num_branches ia_beg = branches ( 3 , ibr ) ia_end = ia_beg + branches ( 2 , ibr ) - 1 r_tp = coordinates (:, branches ( 1 , ibr )) !Add end-to-end distance squared of this side chain reedsq_sc = reedsq_sc + sum (( coordinates (:, ia_end ) - r_tp ) ** 2 ) !Number of side chain atoms. Adding 1 for the tether point na_sc = branches ( 2 , ibr ) + 1 !Get side chain c.o.m. com_sc = r_tp + sum ( coordinates (:, ia_beg : ia_end ), 2 ) com_sc = com_sc / na_sc !Get radius of gyration squared of this side chain S = 0.0_rp ri = r_tp - com_sc S ( 1 , 1 ) = S ( 1 , 1 ) + ri ( 1 ) * ri ( 1 ) S ( 1 , 2 ) = S ( 1 , 2 ) + ri ( 1 ) * ri ( 2 ) S ( 1 , 3 ) = S ( 1 , 3 ) + ri ( 1 ) * ri ( 3 ) S ( 2 , 2 ) = S ( 2 , 2 ) + ri ( 2 ) * ri ( 2 ) S ( 2 , 3 ) = S ( 2 , 3 ) + ri ( 2 ) * ri ( 3 ) S ( 3 , 3 ) = S ( 3 , 3 ) + ri ( 3 ) * ri ( 3 ) do i = ia_beg , ia_end ri = coordinates (:, i ) - com_sc S ( 1 , 1 ) = S ( 1 , 1 ) + ri ( 1 ) * ri ( 1 ) S ( 1 , 2 ) = S ( 1 , 2 ) + ri ( 1 ) * ri ( 2 ) S ( 1 , 3 ) = S ( 1 , 3 ) + ri ( 1 ) * ri ( 3 ) S ( 2 , 2 ) = S ( 2 , 2 ) + ri ( 2 ) * ri ( 2 ) S ( 2 , 3 ) = S ( 2 , 3 ) + ri ( 2 ) * ri ( 3 ) S ( 3 , 3 ) = S ( 3 , 3 ) + ri ( 3 ) * ri ( 3 ) end do S = S / na_sc rgsq_isc = S ( 1 , 1 ) + S ( 2 , 2 ) + S ( 3 , 3 ) call dsyevc3 ( S , gt_ev_isc ) !Note: gt_ev(2) and gt_ev(3) are flipped so that the three eigen values are !in descending order call calc_shape ( gt_ev_isc ( 1 ), gt_ev_isc ( 3 ), gt_ev_isc ( 2 ), & asph_isc , prol_isc ) !Add radius of gyration, etc. of this side chain rgsq_sc = rgsq_sc + rgsq_isc gt_ev_sc = gt_ev_sc + gt_ev_isc asph_sc = asph_sc + asph_isc prol_sc = prol_sc + prol_isc end do if ( n_sc > 0 ) then rgsq_sc = rgsq_sc / n_sc reedsq_sc = reedsq_sc / n_sc gt_ev_sc = gt_ev_sc / n_sc asph_sc = asph_sc / n_sc prol_sc = prol_sc / n_sc end if end subroutine !****************************************************************************** subroutine calc_shape ( ev1 , ev2 , ev3 , asph , prol ) !! Given three eigen values of the gyration tensor, calculates asphericity !! and prolateness. Note that ev1 >= ev2 >= ev3. real ( rp ), intent ( in ) :: ev1 real ( rp ), intent ( in ) :: ev2 real ( rp ), intent ( in ) :: ev3 real ( rp ), intent ( out ) :: asph real ( rp ), intent ( out ) :: prol real ( rp ) :: rgsq real ( rp ) :: ev_av , ev1mav , ev2mav , ev3mav , evmav_sumsq rgsq = ev1 + ev2 + ev3 ev_av = rgsq * math_third ev1mav = ev1 - ev_av ev2mav = ev2 - ev_av ev3mav = ev3 - ev_av evmav_sumsq = ev1mav ** 2 + ev2mav ** 2 + ev3mav ** 2 asph = 1.5_rp * evmav_sumsq / ( rgsq * rgsq ) prol = 4 * ( ev1mav * ev2mav * ev3mav ) / (( 2 * math_third ) * evmav_sumsq ) ** 1.5 end subroutine !****************************************************************************** subroutine dsyevc3 ( a , w ) !! Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's !! analytical algorithm. !! Only the diagonal and upper triangular parts of A are accessed. The access !! is read-only. !! !! Copyright (C) 2006  Joachim Kopp ! ---------------------------------------------------------------------------- ! Parameters: !   A: The symmetric input matrix !   W: Storage buffer for eigenvalues ! ---------------------------------------------------------------------------- ! .. Arguments .. REAL ( RP ), DIMENSION ( 3 , 3 ), INTENT ( IN ) :: A REAL ( RP ), DIMENSION ( 3 ), INTENT ( OUT ) :: W ( 3 ) !.. Local Variables .. REAL ( RP ) :: M , C1 , C0 REAL ( RP ) :: DE , DD , EE , FF REAL ( RP ) :: P , SQRTP , Q , C , S , PHI !Determine coefficients of characteristic poynomial. We write !      | A   D   F  | ! A =  | D*  B   E  | !      | F*  E*  C  | DE = A ( 1 , 2 ) * A ( 2 , 3 ) DD = A ( 1 , 2 ) ** 2 EE = A ( 2 , 3 ) ** 2 FF = A ( 1 , 3 ) ** 2 M = A ( 1 , 1 ) + A ( 2 , 2 ) + A ( 3 , 3 ) C1 = ( A ( 1 , 1 ) * A ( 2 , 2 ) + A ( 1 , 1 ) * A ( 3 , 3 ) + A ( 2 , 2 ) * A ( 3 , 3 ) ) & - ( DD + EE + FF ) C0 = A ( 3 , 3 ) * DD + A ( 1 , 1 ) * EE + A ( 2 , 2 ) * FF - A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) & - 2.0_RP * A ( 1 , 3 ) * DE P = M ** 2 - 3.0_RP * C1 Q = M * ( P - ( 3.0_RP / 2.0_RP ) * C1 ) - ( 2 7.0_RP / 2.0_RP ) * C0 SQRTP = SQRT ( ABS ( P )) PHI = 2 7.0_RP * ( 0.25_RP * C1 ** 2 * ( P - C1 ) & + C0 * ( Q + ( 2 7.0_RP / 4.0_RP ) * C0 ) ) PHI = ( 1.0_RP / 3.0_RP ) * ATAN2 ( SQRT ( ABS ( PHI )), Q ) C = SQRTP * COS ( PHI ) S = ( 1.0_RP / MATH_SQRT3 ) * SQRTP * SIN ( PHI ) W ( 2 ) = ( 1.0_RP / 3.0_RP ) * ( M - C ) W ( 3 ) = W ( 2 ) + S W ( 1 ) = W ( 2 ) + C W ( 2 ) = W ( 2 ) - S END SUBROUTINE !****************************************************************************** end module m_stats_io","tags":"","loc":"sourcefile/m_stats_io.f90.html"},{"title":"m_strings.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_strings.f90~~EfferentGraph sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_strings.f90~~AfferentGraph sourcefile~m_strings.f90 m_strings.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_strings.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_stats_io.f90->sourcefile~m_strings.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_bd_solver.f90->sourcefile~m_strings.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_control_io.f90 m_control_io.f90 sourcefile~m_control_io.f90->sourcefile~m_strings.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_ia_bond.f90->sourcefile~m_strings.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_strings.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_control_io.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~m_config_io.f90->sourcefile~m_strings.f90 sourcefile~m_mpcd.f90->sourcefile~m_strings.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90->sourcefile~m_strings.f90 sourcefile~m_relax.f90->sourcefile~m_stats_io.f90 sourcefile~m_relax.f90->sourcefile~m_config_io.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90->sourcefile~m_stats_io.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_config_io.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 var pansourcefilem_stringsf90AfferentGraph = svgPanZoom('#sourcefilem_stringsf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_strings Source Code m_strings.f90 Source Code module m_strings !! summary: Routines for string handling !! author:  George Benthien & others !! !! Many of these routines were originally written by !! [George Benthien](https://gbenthien.net/strings/str-index.html), some have !! been written by Sarit Dutta or gathered/modified from other authors (appropriately credited). !! !! These routines were developed primarily to aid in the reading and manipulation !! of input data from an ASCII text file. Accordingly, it is assumed that all !! characters to be processed are ASCII characters. use m_precision implicit none private :: str_from_inum , str_from_ilnum , str_from_dnum interface str_from_num !!  Generic  interface for writing a number to a string. The calling syntax is !!  `str_from_num(num, frmt)` where `number` is a real number or an integer, !!  `format` is the format desired, e.g., *e15.6*, *i5*, etc. module procedure str_from_inum module procedure str_from_ilnum module procedure str_from_dnum end interface str_from_num contains !****************************************************************************** pure function str_is_letter ( str ) result ( res ) !! Returns `.true.` if `str` contains only letters (*a--z* or *A--Z*) and !! `.false.` otherwise. character ( len =* ), intent ( in ) :: str logical :: res character ( len = 1 ) :: ch integer :: i res = . true . do i = 1 , len ( str ) ch = str ( i : i ) select case ( ch ) case ( 'A' : 'Z' ) cycle case ( 'a' : 'z' ) cycle case default res = . false . return end select end do end function !****************************************************************************** pure function str_is_digit ( str ) result ( res ) !! Returns `.true.` if `str` contains only digits (0,1,...,9) and !!`.false.` otherwise. character ( len =* ), intent ( in ) :: str logical :: res character ( len = 1 ) :: ch integer :: i res = . true . do i = 1 , len ( str ) ch = str ( i : i ) select case ( ch ) case ( '0' : '9' ) cycle case default res = . false . return end select end do end function !******************************************************************************* pure function str_is_space ( str ) result ( res ) !! Returns `.true.` if `str` is non-empty and contains only whitespace !! characters (tab or blankspace). Otherwise `.false.` is returned. !! !! *Note*: This function will return `.false.` for an empty string. character ( len =* ), intent ( in ) :: str logical :: res integer :: lenstr integer :: ich integer :: i lenstr = len ( str ) if ( lenstr == 0 ) then res = . false . return end if res = . true . do i = 1 , lenstr ich = iachar ( str ( i : i )) select case ( ich ) case ( 9 , 32 ) res = . true . case default res = . false . return end select end do end function !******************************************************************************* pure function str_is_comment ( line , comment_str ) result ( res ) !!  Returns `.true.` if `line` is a comment, `.false.` other wise. !! !!  `line` is a comment if `comment_str` is its first non-blank character !!  sequence. If `line` is an empty string or contains only blankspaces, the !!  return value is `.false.` If `comment_str` is empty, the return value is !!  `.true.`. character ( len =* ), intent ( in ) :: line !!  Input string character ( len =* ), intent ( in ) :: comment_str !!  String marking the beginning of a comment. logical :: res res = . false . if ( index ( adjustl ( line ), comment_str ) == 1 ) then res = . true . end if end function !******************************************************************************* pure function str_compact ( str ) result ( ostr ) !! Returns a copy of `str` with multiple spaces and tabs converted to !! single spaces, control characters deleted, and leading and trailing !! spaces removed. character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: ostr character ( len = len ( str )) :: buf character ( len = 1 ) :: ch integer :: lenstr integer :: isp , ich integer :: i , k lenstr = len ( str ) isp = 0 ; k = 0 buf = '' do i = 1 , lenstr ch = str ( i : i ) ich = iachar ( ch ) select case ( ich ) case ( 9 , 32 ) ! space or tab character if ( isp == 0 ) then k = k + 1 buf ( k : k ) = ' ' end if isp = 1 case ( 33 :) ! not a space, quote, or control character k = k + 1 buf ( k : k ) = ch isp = 0 end select end do ostr = trim ( adjustl ( buf )) end function !****************************************************************************** pure function str_remove_stcc ( str ) result ( ostr ) !! Returns a copy of the string `str` with spaces, tabs, and !! control characters removed. character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: ostr character ( len = len ( str )) :: buf character ( len = 1 ) :: ch integer :: lenstr integer :: ich integer :: k integer :: i lenstr = len ( str ) k = 0 do i = 1 , lenstr ch = str ( i : i ) ich = iachar ( ch ) select case ( ich ) case ( 0 : 32 ) ! space, tab, or control character cycle case ( 33 :) k = k + 1 buf ( k : k ) = ch end select end do ostr = trim ( adjustl ( buf )) end function !****************************************************************************** pure function str_to_upper ( str ) result ( ucstr ) !!  This function returns a string that is like the string `str` with all characters !!  that are not between a pair of quotes (\"...\" or '...') converted to uppercase. character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: ucstr integer :: ilen integer :: ioffset integer :: iquote integer :: iav integer :: iqc integer :: i ilen = len ( str ) ioffset = iachar ( 'A' ) - iachar ( 'a' ) iquote = 0 ucstr = str do i = 1 , ilen iav = iachar ( str ( i : i )) if ( ( iquote == 0 ) . and . (( iav == 34 ) . or . ( iav == 39 )) ) then iquote = 1 iqc = iav cycle end if if ( ( iquote == 1 ) . and . ( iav == iqc ) ) then iquote = 0 cycle end if if ( iquote == 1 ) cycle if ( ( iav >= iachar ( 'a' )) . and . ( iav <= iachar ( 'z' )) ) then ucstr ( i : i ) = achar ( iav + ioffset ) end if end do end function !********************************************************************** pure function str_to_lower ( str ) result ( lcstr ) !!  This function returns a string that is like the string `str` with all characters !!  that are not between a pair of quotes (\"...\" or '...') converted to lowercase. character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: lcstr integer :: ilen integer :: ioffset integer :: iquote integer :: iav integer :: iqc integer :: i ilen = len ( str ) ioffset = iachar ( 'A' ) - iachar ( 'a' ) iquote = 0 lcstr = str do i = 1 , ilen iav = iachar ( str ( i : i )) if ( ( iquote == 0 ) . and . (( iav == 34 ) . or . ( iav == 39 )) ) then iquote = 1 iqc = iav cycle end if if ( ( iquote == 1 ) . and . ( iav == iqc ) ) then iquote = 0 cycle end if if ( iquote == 1 ) cycle if ( ( iav >= iachar ( 'A' )) . and . ( iav <= iachar ( 'Z' )) ) then lcstr ( i : i ) = achar ( iav - ioffset ) end if end do end function !****************************************************************************** subroutine str_shift ( str , n ) !! Shifts characters in `str` by `n` positions (positive values !! denote a right shift and negative values denote a left shift). Characters !! that are shifted off the end are lost. Positions opened up by the shift !! are replaced by spaces. character ( len =* ), intent ( in out ) :: str integer , intent ( in ) :: n integer :: lenstr integer :: nabs lenstr = len ( str ) nabs = iabs ( n ) if ( nabs >= lenstr ) then str = repeat ( ' ' , lenstr ) return end if if ( n < 0 ) str = str ( nabs + 1 :) // repeat ( ' ' , nabs ) ! shift left if ( n > 0 ) str = repeat ( ' ' , nabs ) // str (: lenstr - nabs ) ! shift right end subroutine !****************************************************************************** subroutine str_insert ( str , substr , loc ) !! Inserts the string `substr` into the string `str` at position `loc`. !! Characters in `str` starting at position `loc` are shifted right to !! make room for the inserted string. Trailing spaces of `substr` are !! removed prior to insertion. character ( len =* ), intent ( in out ) :: str character ( len =* ), intent ( in ) :: substr integer , intent ( in ) :: loc character ( len = len ( str )) :: tempstr integer :: len_substr len_substr = len_trim ( substr ) tempstr = str ( loc :) call str_shift ( tempstr , len_substr ) tempstr ( 1 : len_substr ) = substr ( 1 : len_substr ) str ( loc :) = tempstr end subroutine !****************************************************************************** subroutine str_del ( str , substr , n ) !! Deletes first `n` occurrences of substring `substr` from string `str` and !! shifts characters left to fill hole. If `n < 0`, all occurances are !! deleted.  If `n` is not explicitly provided, it defaults to removing the !! first occurrence. Trailing spaces or blanks are not considered part of !! `substr`. character ( len =* ), intent ( in out ) :: str character ( len =* ), intent ( in ) :: substr integer , optional , intent ( in ) :: n integer :: n_ integer :: lensubstr integer :: ipos integer :: cntr n_ = 1 if ( present ( n )) n_ = n lensubstr = len_trim ( substr ) cntr = 0 do if (( n_ > 0 ) . and . ( cntr > n_ )) exit ipos = index ( str , substr ) if ( ipos == 0 ) exit str = str (: ipos - 1 ) // str ( ipos + lensubstr :) cntr = cntr + 1 end do end subroutine !********************************************************************** subroutine str_strip_comment ( str , comment_str ) !!  Strips trailing comment from a string. !! !!  The comment is assumed to begin with the sequence of characters in !!  `comment_str`. If the sequence `comment_str` is not found within `str`, !!  no changes are made. character ( len =* ), intent ( in out ) :: str !!  Input string character ( len =* ), intent ( in ) :: comment_str !!  String indicating beginning of a comment. integer :: ipos ipos = index ( adjustl ( str ), comment_str ) if ( ipos /= 0 ) then str = str ( 1 :( ipos - 1 )) end if end subroutine !********************************************************************** subroutine str_get_keyval ( str , key , val , delimiter ) !! Split a string `str` into two strings, `key` and `val` based on space !! delimiter. !! !! A non-empty non-comment string should be passed to this subroutine. !! Keys can have corresponding empty values, but keys must always be present character ( len =* ), intent ( in ) :: str character ( len = :), allocatable , intent ( out ) :: key character ( len = :), allocatable , intent ( out ) :: val character ( len =* ), intent ( in ), optional :: delimiter character ( len = :), allocatable :: delimiter_ character ( len = :), allocatable :: str_just integer :: m integer :: n !blankspace is represented as the integer 32 in ascii chart. delimiter_ = achar ( 32 ) if ( present ( delimiter )) delimiter_ = delimiter str_just = trim ( adjustl ( str )) n = len ( str_just ) m = index ( str_just , delimiter_ ) if ( m == 0 ) then key = str_just val = '' else key = trim ( str_just ( 1 : m - 1 )) val = str_just ( m + len_trim ( delimiter_ ): n ) end if val = trim ( adjustl ( val )) end subroutine !****************************************************************************** subroutine str_match ( str , ipos , imatch ) !! This routine finds the delimiter in string `str` that matches the delimiter !! in position `ipos` of `str`. The argument `imatch` contains the position of !! the matching delimiter. Allowable delimiters are (), [], {}, <>. character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: ipos integer , intent ( out ) :: imatch character ( len = 1 ) :: delim1 character ( len = 1 ) :: delim2 character ( len = 1 ) :: ch integer :: lenstr integer :: istart integer :: iend integer :: inc integer :: idelim2 integer :: isum integer :: i lenstr = len_trim ( str ) delim1 = str ( ipos : ipos ) select case ( delim1 ) case ( '(' ) idelim2 = iachar ( delim1 ) + 1 istart = ipos + 1 iend = lenstr inc = 1 case ( ')' ) idelim2 = iachar ( delim1 ) - 1 istart = ipos - 1 iend = 1 inc =- 1 case ( '[' , '{' , '<' ) idelim2 = iachar ( delim1 ) + 2 istart = ipos + 1 iend = lenstr inc = 1 case ( ']' , '}' , '>' ) idelim2 = iachar ( delim1 ) - 2 istart = ipos - 1 iend = 1 inc =- 1 case default write ( * , * ) delim1 , ' is not a valid delimiter' return end select if ( istart < 1 . or . istart > lenstr ) then write ( * , * ) delim1 , ' has no matching delimiter' return end if delim2 = achar ( idelim2 ) ! matching delimiter isum = 1 do i = istart , iend , inc ch = str ( i : i ) if ( ch /= delim1 . and . ch /= delim2 ) cycle if ( ch == delim1 ) isum = isum + 1 if ( ch == delim2 ) isum = isum - 1 if ( isum == 0 ) exit end do if ( isum /= 0 ) then write ( * , * ) delim1 , ' has no matching delimiter' return end if imatch = i end subroutine !********************************************************************** pure function str_from_inum ( num , frmt ) result ( str ) integer , intent ( in ) :: num character ( len = :), allocatable :: str character ( len =* ), optional , intent ( in ) :: frmt character ( len = :), allocatable :: frmt_ character ( len = 24 ) :: buf frmt_ = '(i0)' if ( present ( frmt )) frmt_ = frmt write ( buf , frmt_ ) num str = trim ( adjustl ( buf )) end function !********************************************************************** pure function str_from_ilnum ( num , frmt ) result ( str ) integer ( ip_long ), intent ( in ) :: num character ( len = :), allocatable :: str character ( len =* ), optional , intent ( in ) :: frmt character ( len = :), allocatable :: frmt_ character ( len = 24 ) :: buf frmt_ = '(i0)' if ( present ( frmt )) frmt_ = frmt write ( buf , frmt_ ) num str = trim ( adjustl ( buf )) end function !********************************************************************** pure function str_from_dnum ( num , frmt ) result ( str ) real ( rp ), intent ( in ) :: num character ( len = :), allocatable :: str character ( len =* ), optional , intent ( in ) :: frmt character ( len = :), allocatable :: frmt_ character ( len = 32 ) :: buf frmt_ = '(g0.15)' if ( present ( frmt )) frmt_ = frmt write ( buf , frmt_ ) num str = str_trimzero ( buf ) end function !****************************************************************************** subroutine str_compact_rlstr ( str ) !! author: Izaak Beekman !! date: 02/24/2015 !! !! Compact a string representing a real number, so that the same value is !! displayed with fewer characters. character ( len =* ), intent ( in out ) :: str !! string representation of a real number. character ( len = len ( str )) :: significand character ( len = len ( str )) :: expnt character ( len = 2 ) :: separator integer :: exp_start integer :: decimal_pos integer :: sig_trim integer :: exp_trim integer :: i !! counter str = adjustl ( str ) exp_start = scan ( str , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( str , '-+' , back = . true .) decimal_pos = scan ( str , '.' ) if ( exp_start /= 0 ) separator = str ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then !possibly signed, exponent-less float significand = str sig_trim = len_trim ( significand ) do i = len_trim ( significand ), decimal_pos + 2 , - 1 !look from right to left at 0s !but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do str = trim ( significand ( 1 : sig_trim )) else if ( exp_start > decimal_pos ) then !float has exponent significand = str ( 1 : exp_start - 1 ) sig_trim = len_trim ( significand ) do i = len_trim ( significand ), decimal_pos + 2 , - 1 !look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do expnt = adjustl ( str ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( str ( exp_start + 1 :)) end if exp_trim = 1 do i = 1 ,( len_trim ( expnt ) - 1 ) !look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit end if end do str = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable end if end subroutine !******************************************************************************* pure function str_trimzero ( str ) result ( res ) !! Deletes nonsignificant trailing zeroes from number string str. If number !! string ends in a decimal point, one trailing zero is added. character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: res character ( len = len ( str )) :: buf character ( len = 10 ) :: sexp character ( len = 1 ) :: ch integer :: ipos integer :: lbuf integer :: i buf = str ipos = scan ( str , 'eE' ) if ( ipos > 0 ) then sexp = buf ( ipos :) buf = buf ( 1 : ipos - 1 ) endif lbuf = len_trim ( buf ) do i = lbuf , 1 , - 1 ch = buf ( i : i ) if ( ch == '0' ) cycle if ( ch == '.' ) then buf = buf ( 1 : i ) // '0' if ( ipos > 0 ) buf = trim ( buf ) // trim ( sexp ) exit endif buf = buf ( 1 : i ) exit end do if ( ipos > 0 ) buf = trim ( buf ) // trim ( sexp ) res = trim ( adjustl ( buf )) end function !*********************************************************************** pure function str_to_d ( str ) result ( res ) character ( len =* ), intent ( in ) :: str real ( rp ) :: res read ( str , * ) res end function !*********************************************************************** pure function str_to_i ( str ) result ( res ) character ( len =* ), intent ( in ) :: str integer :: res read ( str , * ) res end function !*********************************************************************** pure function str_strip ( str , chars , ends ) result ( ostr ) !! Returns a copy of string `str` with the leading and trailing characters !! removed. The `chars` argument is a string specifying the set of characters to !! be removed.  The `chars` argument is not a prefix or suffix; rather, all !! combinations of its values are stripped. If `ends = 'l'`, only leading !! characters are removed, if `ends = 'r'`, only trailing characters are !! removed, and if `ends = 'b'` both leading and trailing characters are !! removed. character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: chars character ( len = 1 ), intent ( in ) :: ends !! {'l', 'r', 'b'} character ( len = :), allocatable :: ostr integer :: lenstr integer :: ibeg integer :: iend lenstr = len ( str ) select case ( ends ) case ( 'l' ) ibeg = verify ( str , chars ) iend = lenstr case ( 'r' ) ibeg = 1 iend = verify ( str , chars , . true .) case ( 'b' ) ibeg = verify ( str , chars ) iend = verify ( str , chars , . true .) case default ibeg = 1 iend = lenstr end select if (( ibeg == 0 ) . or . ( iend == 0 )) then ostr = '' else ostr = str ( ibeg : iend ) end if end function !********************************************************************** subroutine str_split ( str , delimiter , before ) !! Routine finds the first instance of a character from `delims` in the the !! string `str`. The characters before the found delimiter are output in !! `before`. The characters after the found delimiter are output in `str`. !! Repeated applications of this routine can be used to parse a string into its !! component parts. Multiple whitespaces of `str` are compacted into a single !! whitespace before splitting begins. If either `str` or `delimiter` is !! empty, an empty string is retured in `before` and `str` remains !! unchanged. character ( len =* ), intent ( in out ) :: str character ( len =* ), intent ( in ) :: delimiter character ( len = :), allocatable , intent ( out ) :: before integer :: lenstr integer :: lendelim integer :: ipos str = str_compact ( str ) lenstr = len ( str ) lendelim = len ( delimiter ) if ( ( lenstr == 0 ) . or . ( lendelim == 0 ) ) then ! `str` or `delimiter` is empty before = '' return end if ipos = index ( str , delimiter ) if ( ipos == 0 ) then ! string does not contain any delimiter before = '' return else before = str ( 1 :( ipos - 1 )) str = str (( ipos + lendelim - 1 ):) end if end subroutine !********************************************************************** subroutine str_append ( dest , source , sep ) !! Appends a copy of the `source` string to the `dest` string, with !! optional string `sep` in between. It is assumed that `dest` is long !! enough to hold the result, otherwise an error will be generated. character ( len =* ), intent ( in out ) :: dest character ( len =* ), intent ( in ) :: source character ( len =* ), optional , intent ( in ) :: sep character ( len = :), allocatable :: sep_ integer :: len_dest integer :: len_source integer :: len_sep_ integer :: ipos sep_ = '' if ( present ( sep )) sep_ = sep len_dest = len_trim ( dest ) len_source = len_trim ( adjustl ( source )) len_sep_ = len ( sep_ ) ipos = len_dest + 1 dest ( ipos :( ipos + len_sep_ ) ) = sep_ ipos = ipos + len_sep_ + 1 dest ( ipos :( ipos + len_source ) ) = trim ( adjustl ( source )) end subroutine !********************************************************************** pure function str_startswith ( str , prefix , start , finish ) result ( res ) !! Returns `.true.` if the string `str` starts with `prefix`, otherwise !! returns `.false.`. With optional `start`, test beginning at that position. !! With optional `finish`, stop comparing beyond that position. character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: prefix integer , optional , intent ( in ) :: start integer , optional , intent ( in ) :: finish logical :: res integer :: ibeg integer :: iend ibeg = 1 ; iend = len ( str ) if ( present ( start )) ibeg = start if ( present ( finish )) iend = finish !Return .false. if prefix is longer than str(ibeg:iend) if ( len ( prefix ) > ( iend - ibeg + 1 )) then res = . false . return end if if ( index ( str ( ibeg : iend ), prefix ) == 1 ) then res = . true . else res = . false . end if end function !********************************************************************** pure function str_endswith ( str , suffix , start , finish ) result ( res ) !! Returns `.true.` if the string `str` ends with `suffix`, otherwise !! return `.false.`. With optional `start`, test beginning at that position. !! With optional `finish`, stop comparing beyond that position. character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: suffix integer , optional , intent ( in ) :: start integer , optional , intent ( in ) :: finish logical :: res integer :: ibeg integer :: iend integer :: iloc ibeg = 1 ; iend = len ( str ) if ( present ( start )) ibeg = start if ( present ( finish )) iend = finish !Return .false. if suffix is longer than str(ibeg:iend) if ( len ( suffix ) > ( iend - ibeg + 1 )) then res = . false . return end if ! Getting last occurrance of suffix iloc = index ( str ( ibeg : iend ), suffix , back = . true .) if ( ( iloc + len ( suffix ) - 1 ) == iend ) then res = . true . else res = . false . end if end function !****************************************************************************** subroutine readline ( nunitr , line , comment_str , ios ) !!  Reads a line from unit=nunitr, ignoring blank lines !!  and deleting comments integer , intent ( in ) :: nunitr character ( len =* ), intent ( in out ) :: line character ( len =* ), intent ( in ) :: comment_str integer , intent ( out ) :: ios do read ( nunitr , '(a)' , iostat = ios ) line ! read input line if ( ios /= 0 ) return if (( len_trim ( line ) /= 0 ) . and . (. not . str_is_comment ( line , comment_str ))) then call str_strip_comment ( line , comment_str ) exit end if end do end subroutine !****************************************************************************** end module m_strings","tags":"","loc":"sourcefile/m_strings.f90.html"},{"title":"m_table.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_table.f90~~EfferentGraph sourcefile~m_table.f90 m_table.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_table.f90->sourcefile~m_precision.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_table.f90~~AfferentGraph sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_relax.f90 var pansourcefilem_tablef90AfferentGraph = svgPanZoom('#sourcefilem_tablef90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_table Source Code m_table.f90 Source Code module m_table !! Implements a table with contiguously stored rows. use m_precision use m_vector implicit none private public :: itable_t public :: itbl_init type itable_t integer :: num_rows = 0 !Must be > 0 type ( ivector_t ) :: buffer integer , dimension (:), allocatable :: row_indx contains procedure :: delete => itbl_delete procedure :: clear => itbl_clear procedure :: append => itbl_append procedure :: set_val => itbl_set_val procedure :: is_in => itbl_is_in procedure :: get_val => itbl_get_val procedure :: get_row => itbl_get_row procedure :: shrink_to_fit => itbl_shrink_to_fit procedure :: print => itbl_print end type itable_t contains !****************************************************************************** subroutine itbl_init ( this , num_rows , ierr ) !! Creates an empty *itable_t* with *num_rows* rows and all rows having !! zero elements. type ( itable_t ), intent ( in out ) :: this integer , intent ( in ) :: num_rows !! Must be > 0 integer , intent ( out ), optional :: ierr integer :: istat if ( present ( ierr )) ierr = 0 !Set initial size guess to be num_rows call ivector_init ( this % buffer , num_rows ) allocate ( this % row_indx ( num_rows + 1 ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for this%row_indx of size' , num_rows if ( present ( ierr )) ierr = 1 return end if !Set the number of rows this % num_rows = num_rows !Empty table: All rows have zero elements this % row_indx = 1 end subroutine !****************************************************************************** subroutine itbl_delete ( this ) !! Deletes an *itable_t*. No access is allowed to this object after this call. class ( itable_t ), intent ( in out ) :: this call this % buffer % delete () if ( allocated ( this % row_indx )) deallocate ( this % row_indx ) this % num_rows = 0 end subroutine !****************************************************************************** subroutine itbl_clear ( this ) !! Clears all rows. Does not deallocate memory. class ( itable_t ), intent ( in out ) :: this call this % buffer % clear () this % row_indx = 1 end subroutine !****************************************************************************** subroutine itbl_append ( this , irow , val ) !! Appends an element `val` to row *irow*. class ( itable_t ), intent ( in out ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: val call this % buffer % append ( val ) this % row_indx ( irow + 1 :) = this % row_indx ( irow + 1 :) + 1 end subroutine !****************************************************************************** subroutine itbl_set_val ( this , irow , j , val ) !! Sets the value of the *j*th element of row *irow*. class ( itable_t ), intent ( in out ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: j integer , intent ( in ) :: val integer :: k , n n = this % row_indx ( irow + 1 ) - this % row_indx ( irow ) if ( j > n ) then write ( * , * ) 'error: out-of-bounds index ' , j write ( * , * ) 'for row length' , n stop else k = this % row_indx ( irow ) + j - 1 call this % buffer % set_val ( k , val ) end if end subroutine !****************************************************************************** function itbl_is_in ( this , irow , val ) result ( res ) !! Returns .true. if *val* is in row *irow*, .false. otherwise. class ( itable_t ), intent ( in ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: val logical :: res integer :: i res = . false . do i = this % row_indx ( irow ), this % row_indx ( irow + 1 ) - 1 if ( this % buffer % get_val ( i ) == val ) then res = . true . exit end if end do end function !****************************************************************************** function itbl_get_val ( this , irow , j ) result ( res ) !! Returns the *j*th element of row *irow* class ( itable_t ), intent ( in ) :: this integer , intent ( in ) :: irow integer , intent ( in ) :: j integer :: res integer :: k , n n = this % row_indx ( irow + 1 ) - this % row_indx ( irow ) if ( j > n ) then write ( * , * ) 'error: out-of-bounds index ' , j write ( * , * ) 'for row length' , n stop else k = this % row_indx ( irow ) + j - 1 res = this % buffer % get_val ( k ) end if end function !****************************************************************************** subroutine itbl_get_row ( this , irow , res ) !! Returns a pointer to the row data of *irow*. No bounds checking is performed. class ( itable_t ), target , intent ( in ) :: this integer , intent ( in ) :: irow integer , dimension (:), pointer , intent ( out ) :: res integer :: ibeg , iend res => null () ibeg = this % row_indx ( irow ) iend = this % row_indx ( irow + 1 ) - 1 call this % buffer % get_data ( res , ibeg , iend ) end subroutine !****************************************************************************** subroutine itbl_shrink_to_fit ( this , ierr ) !! Releases additional memory to fit underlying data. class ( itable_t ), intent ( in out ) :: this integer , intent ( out ), optional :: ierr if ( present ( ierr )) then call this % buffer % shrink_to_fit ( ierr ) else call this % buffer % shrink_to_fit () end if end subroutine !****************************************************************************** subroutine itbl_print ( this ) !! Prints an *itable_t*. class ( itable_t ), intent ( in ) :: this integer :: i , j do i = 1 , this % num_rows write ( * , '(i0,\": \",2x)' , advance = 'no' ) i do j = this % row_indx ( i ), this % row_indx ( i + 1 ) - 1 write ( * , '(i0,2x)' , advance = 'no' ) this % buffer % get_val ( j ) end do write ( * , * ) end do end subroutine !****************************************************************************** end module m_table","tags":"","loc":"sourcefile/m_table.f90.html"},{"title":"m_trajectory.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_trajectory.f90~~EfferentGraph sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_trajectory.f90~~AfferentGraph sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_bd_solver.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_globals.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90->sourcefile~m_stats_io.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_config_io.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_control_io.f90 m_control_io.f90 sourcefile~m_control_io.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_globals.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_control_io.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_relax.f90->sourcefile~m_globals.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90->sourcefile~m_stats_io.f90 sourcefile~m_relax.f90->sourcefile~m_config_io.f90 var pansourcefilem_trajectoryf90AfferentGraph = svgPanZoom('#sourcefilem_trajectoryf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_trajectory Source Code m_trajectory.f90 Source Code module m_trajectory !! Routines for reading and writing frames from a trajectory file. use m_precision use m_logger , only : logger => master_logger implicit none type trajectory_t integer :: header_size = 0 integer :: frame_size = 0 integer :: num_atoms = 0 integer :: num_mpcd_atoms = 0 integer :: num_atoms_tot = 0 integer , dimension ( 4 ) :: frmcmp = 0 character ( len = :), allocatable :: fn integer :: file_id = 0 integer :: num_frames = 0 logical :: isopen = . false . contains procedure :: create => traj_create procedure :: open => traj_open procedure :: clear => traj_clear procedure :: close => traj_close procedure :: read => traj_read procedure :: append_frame => traj_append_frame procedure :: write_frame => traj_write_frame generic :: init => create , open end type trajectory_t contains !****************************************************************************** subroutine traj_create ( this , fn , na , nam , frmcmp ) !!  Creates a `trajectory_t` object with a new underlying file named `fn`.  If !!  `fn` already exists, it will be truncated.  The file `fn` is opened for both !!  reading and writing. class ( trajectory_t ), intent ( out ) :: this !! *trajectory_t* instance. character ( len =* ), intent ( in ) :: fn !! Name of the underlying trajectory file. integer , intent ( in ) :: na !! Number of non-MPCD atoms integer , intent ( in ) :: nam !! Number of MPCD atoms, pass zero to indicate no data from MPCD !! particles are present. integer , dimension ( 4 ), intent ( in ) :: frmcmp !! Binary flags indicating whether that component is present in a frame. !! frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces, !! frmcmp(4): charges integer :: nat , file_id nat = na + nam this % num_atoms = na ; this % num_mpcd_atoms = nam ; this % num_atoms_tot = nat this % frmcmp = frmcmp !Frame components: nts, coordinates, velocities, forces, charge !nts data this % frame_size = sizeof_long_int !Coordinate data if ( frmcmp ( 1 ) /= 0 ) this % frame_size = this % frame_size + 3 * nat * sizeof_real !Velocity data if ( frmcmp ( 2 ) /= 0 ) this % frame_size = this % frame_size + 3 * nat * sizeof_real !Force data if ( frmcmp ( 3 ) /= 0 ) this % frame_size = this % frame_size + 3 * na * sizeof_real !Charge data if ( frmcmp ( 4 ) /= 0 ) this % frame_size = this % frame_size + na * sizeof_real ! Representation of header: !     * 1 int for `header_size` !     * 1 int for `frame_size` !     * 2 ints:  `num_atoms`, `num_mpcd_atoms` !     * 4 ints:  `frmcmp` this % header_size = 8 * sizeof_int !Create trajectory file open ( newunit = file_id , file = fn , access = 'stream' , form = 'unformatted' , & action = 'readwrite' , status = 'replace' ) this % fn = fn this % file_id = file_id this % num_frames = 0 this % isopen = . true . write ( this % file_id ) this % header_size write ( this % file_id ) this % frame_size write ( this % file_id ) this % num_atoms , this % num_mpcd_atoms , this % frmcmp end subroutine !****************************************************************************** subroutine traj_open ( this , fn , mode , ierr ) !!  Creates a `trajectory_t` object with a prexisting underlying file named !!  `fn`.  If `fn` does not exist, an error will be generated. If !!  `mode` == 'rw', the file `fn` is opened for both reading and writing. !!  If `mode` == 'r', the file `fn` is opened only for reading. !\"\" class ( trajectory_t ), intent ( out ) :: this character ( len =* ), intent ( in ) :: fn character ( len =* ), intent ( in ) :: mode integer , intent ( out ) :: ierr integer ( ip_long ) :: file_size ierr = 0 this % fn = fn !Readwrite mode if ( mode == 'rw' ) then open ( newunit = this % file_id , file = this % fn , access = 'stream' , & form = 'unformatted' , action = 'readwrite' , status = 'old' ) !Readonly mode else if ( mode == 'r' ) then open ( newunit = this % file_id , file = this % fn , access = 'stream' , & form = 'unformatted' , action = 'read' , status = 'old' ) !Unknown mode else call logger % fatal ( 'traj_open' , 'file open error. Bad mode ' // mode ) ierr = 1 return end if this % isopen = . true . !Get size of the file inquire ( unit = this % file_id , size = file_size ) read ( this % file_id ) this % header_size read ( this % file_id ) this % frame_size read ( this % file_id ) this % num_atoms , this % num_mpcd_atoms , this % frmcmp this % num_atoms_tot = this % num_atoms + this % num_mpcd_atoms !Integer division to find `num_frames` this % num_frames = int (( file_size - this % header_size ) / this % frame_size , ip ) end subroutine !****************************************************************************** subroutine traj_clear ( this ) !! After a call to this subroutine, all memory within `this` is deallocated, !! all components of `this` are reset to zero, and the underlying file is !! closed (if open). class ( trajectory_t ), intent ( in out ) :: this call this % close () if ( allocated ( this % fn )) deallocate ( this % fn ) this % header_size = 0 this % frame_size = 0 this % num_atoms = 0 this % num_mpcd_atoms = 0 this % num_atoms_tot = 0 this % frmcmp = 0 this % file_id = 0 this % num_frames = 0 end subroutine !****************************************************************************** subroutine traj_close ( this ) !! Closes the underlying file of a `trajectory_t`. class ( trajectory_t ), intent ( in out ) :: this if ( this % isopen ) then close ( this % file_id ) this % isopen = . false . end if end subroutine !****************************************************************************** subroutine traj_read ( this , iframe , nts , ierr , mflag , & coordinates , velocities , forces , charge ) !! Read from an open trajectory. class ( trajectory_t ), intent ( in ) :: this integer , intent ( in ) :: iframe !! Frame number integer ( ip_long ), intent ( out ) :: nts !! Time step counter integer , intent ( out ) :: ierr !! Error flag integer , intent ( in ), optional :: mflag !! 1: Only non-MPCD data, 2: Only MPCD data, 3: All data real ( rp ), dimension (:,:), intent ( out ), optional :: coordinates real ( rp ), dimension (:,:), intent ( out ), optional :: velocities real ( rp ), dimension (:,:), intent ( out ), optional :: forces real ( rp ), dimension (:), intent ( out ), optional :: charge integer ( ip_long ) :: offset_frm integer ( ip_long ) :: offset_if integer ( ip_long ) :: offset_tot integer :: na , nat , nam ierr = 0 na = this % num_atoms ; nam = this % num_mpcd_atoms ; nat = this % num_atoms_tot if ( iframe > this % num_frames ) then write ( * , * ) '`iframe`' , iframe , 'out of bounds for `num_frames`' , this % num_frames ierr = 1 return end if select case ( mflag ) case ( 1 ) if ( na == 0 ) then write ( * , * ) 'No data for non-MPCD atoms' ; ierr = 1 ; return end if case ( 2 ) if ( nam == 0 ) then write ( * , * ) 'No data for MPCD atoms' ; ierr = 1 ; return end if case ( 3 ) if ( nat == 0 ) then write ( * , * ) 'No data for any atoms' ; ierr = 1 ; return end if case default write ( * , * ) 'Unknown mflag = ' , mflag ; ierr = 1 ; return end select offset_frm = this % frame_size offset_frm = ( iframe - 1 ) * offset_frm + this % header_size + 1 read ( this % file_id , pos = offset_frm ) nts if ( present ( coordinates )) then if ( this % frmcmp ( 1 ) /= 1 ) then write ( * , * ) 'No coordinate data in frame' ; ierr = 1 ; return else select case ( mflag ) case ( 1 ) offset_if = sizeof_long_int offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) coordinates (:, 1 : na ) case ( 2 ) offset_if = sizeof_long_int + 3 * na * sizeof_real offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) coordinates (:, 1 : nam ) case ( 3 ) offset_if = sizeof_long_int offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) coordinates (:, 1 : nat ) end select end if end if if ( present ( velocities )) then if ( this % frmcmp ( 2 ) /= 1 ) then write ( * , * ) 'No velocity data in frame' ; ierr = 1 ; return else select case ( mflag ) case ( 1 ) offset_if = sizeof_long_int + 3 * nat * sizeof_real * this % frmcmp ( 1 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) velocities (:, 1 : na ) case ( 2 ) offset_if = sizeof_long_int + 3 * nat * sizeof_real * this % frmcmp ( 1 ) & + 3 * na * sizeof_real * this % frmcmp ( 2 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) velocities (:, 1 : nam ) case ( 3 ) offset_if = sizeof_long_int + 3 * nat * sizeof_real * this % frmcmp ( 1 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) velocities (:, 1 : nat ) end select end if end if if ( present ( forces )) then if ( this % frmcmp ( 3 ) /= 1 ) then write ( * , * ) 'No force data in frame' ; ierr = 1 ; return else offset_if = sizeof_long_int + 3 * nat * sizeof_real * this % frmcmp ( 1 ) & + 3 * nat * sizeof_real * this % frmcmp ( 2 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) forces (:, 1 : na ) end if end if if ( present ( charge )) then if ( this % frmcmp ( 4 ) /= 1 ) then write ( * , * ) 'No charge data in frame' ; ierr = 1 ; return else offset_if = sizeof_long_int + 3 * nat * sizeof_real * this % frmcmp ( 1 ) & + 3 * nat * sizeof_real * this % frmcmp ( 2 ) & + 3 * na * sizeof_real * this % frmcmp ( 3 ) offset_tot = offset_frm + offset_if read ( this % file_id , pos = offset_tot ) charge ( 1 : na ) end if end if end subroutine !****************************************************************************** subroutine traj_append_frame ( this , nts , coordinates , velocities , forces , charge ) !! Write a frame to an open trajectory class ( trajectory_t ), intent ( in out ) :: this integer ( ip_long ), intent ( in ) :: nts real ( rp ), dimension (:,:), intent ( in ) :: coordinates real ( rp ), dimension (:,:), intent ( in ) :: velocities real ( rp ), dimension (:,:), intent ( in ) :: forces real ( rp ), dimension (:), intent ( in ) :: charge integer :: iframe iframe = this % num_frames + 1 call this % write_frame ( iframe , nts , coordinates , velocities , forces , charge ) end subroutine !****************************************************************************** subroutine traj_write_frame ( this , iframe , nts , coordinates , velocities , forces , charge ) !! Write a frame to an open trajectory class ( trajectory_t ), intent ( in out ) :: this integer , intent ( in ) :: iframe integer ( ip_long ), intent ( in ) :: nts real ( rp ), dimension (:,:), intent ( in ) :: coordinates real ( rp ), dimension (:,:), intent ( in ) :: velocities real ( rp ), dimension (:,:), intent ( in ) :: forces real ( rp ), dimension (:), intent ( in ) :: charge integer ( ip_long ) :: offset integer :: na , nat , nam na = this % num_atoms ; nam = this % num_mpcd_atoms ; nat = this % num_atoms_tot ! Added one to handle appending a frame if ( iframe > this % num_frames + 1 ) then write ( * , * ) '`iframe`' , iframe , 'out of bounds for `num_frames`' , & ( this % num_frames + 1 ) return end if offset = this % frame_size offset = ( iframe - 1 ) * offset + this % header_size + 1 write ( this % file_id , pos = offset ) nts if ( this % frmcmp ( 1 ) == 1 ) then if ( this % num_atoms == 0 ) then write ( this % file_id ) coordinates (:, na + 1 :) else if ( this % num_mpcd_atoms == 0 ) then write ( this % file_id ) coordinates (:, 1 : na ) else write ( this % file_id ) coordinates (:, 1 : nat ) end if end if if ( this % frmcmp ( 2 ) == 1 ) then if ( this % num_atoms == 0 ) then write ( this % file_id ) velocities (:, na + 1 :) else if ( this % num_mpcd_atoms == 0 ) then write ( this % file_id ) velocities (:, 1 : na ) else write ( this % file_id ) velocities (:, 1 : nat ) end if end if if ( this % frmcmp ( 3 ) == 1 ) write ( this % file_id ) forces if ( this % frmcmp ( 4 ) == 1 ) write ( this % file_id ) charge if ( iframe == this % num_frames + 1 ) this % num_frames = this % num_frames + 1 end subroutine !****************************************************************************** end module m_trajectory","tags":"","loc":"sourcefile/m_trajectory.f90.html"},{"title":"m_utils_math.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_utils_math.f90~~EfferentGraph sourcefile~m_utils_math.f90 m_utils_math.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_utils_math.f90->sourcefile~m_constants_math.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_utils_math.f90->sourcefile~m_precision.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_utils_math.f90~~AfferentGraph sourcefile~m_utils_math.f90 m_utils_math.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_mpcd.f90->sourcefile~m_utils_math.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_setup.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_utils_math Source Code m_utils_math.f90 Source Code module m_utils_math !!Various (mostly linear algebra) functions, particularly for use with small !!matrices. use , intrinsic :: ieee_arithmetic , only : ieee_is_nan , ieee_is_finite use m_constants_math use m_precision implicit none interface allclose !! Checks if two arrays are elementwise close within tolerance module procedure allclose_rank1 module procedure allclose_rank2 module procedure allclose_rank3 end interface interface swap !! Swaps two arrays module procedure swap_integer module procedure swap_real module procedure swap_complex end interface swap contains !************************************************************************ elemental subroutine rad2deg ( rad , deg ) real ( rp ), intent ( in ) :: rad real ( rp ), intent ( out ) :: deg deg = ( 18 0.0_rp / math_pi ) * rad end subroutine !************************************************************************ elemental subroutine deg2rad ( deg , rad ) real ( rp ), intent ( in ) :: deg real ( rp ), intent ( out ) :: rad rad = ( math_pi / 18 0.0_rp ) * deg end subroutine !************************************************************************ subroutine cross ( a , b , c ) !!  Calculates the cross product between two 3-element vectors real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( in ) :: b real ( rp ), dimension ( 3 ), intent ( out ) :: c !! Cross product of `a` and `b`; **c** = **a** x **b** c ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end subroutine !****************************************************************************** subroutine cross_mat ( a , mat ) !! Calculates the cross product matrix of a 3-element vector. The cross !! product matrix **A** of **a** is defined as **a** x **b** = **A** . **b**, !! where **b** is another 3-element vector. real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 , 3 ), intent ( out ) :: mat !! Cross product matrix of `a` mat = 0.0_rp mat ( 2 , 1 ) = a ( 3 ) mat ( 3 , 1 ) = - a ( 2 ) mat ( 1 , 2 ) = - a ( 3 ) mat ( 3 , 2 ) = a ( 1 ) mat ( 1 , 3 ) = a ( 2 ) mat ( 2 , 3 ) = - a ( 1 ) end subroutine !****************************************************************************** subroutine outer ( a , b , c ) !! Calculates the outer product of two vectors, c_{ij} = a_i  b_j. real ( rp ), dimension (:), intent ( in ) :: a !! (m,) array real ( rp ), dimension (:), intent ( in ) :: b !! (n,) array real ( rp ), dimension (:,:), intent ( out ) :: c !! (m,n) array; Outer product integer :: m , n integer :: i , j m = size ( a ) n = size ( b ) do j = 1 , n do i = 1 , m c ( i , j ) = a ( i ) * b ( j ) end do end do end subroutine !****************************************************************************** function scalar_triple_product ( a , b , c ) result ( res ) !! Returns the scalar triple product **a**.(**b** x **c**) real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( in ) :: b real ( rp ), dimension ( 3 ), intent ( in ) :: c real ( rp ) :: res res = a ( 1 ) * ( b ( 2 ) * c ( 3 ) - c ( 2 ) * b ( 3 ) ) - a ( 2 ) * ( b ( 1 ) * c ( 3 ) - c ( 1 ) * b ( 3 ) ) & + a ( 3 ) * ( b ( 1 ) * c ( 2 ) - c ( 1 ) * b ( 2 ) ) end function !****************************************************************************** subroutine vector_triple_product ( a , b , c , d ) !! Returns the vector triple product **d** = **a** x (**b** x **c**) real ( rp ), dimension ( 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( in ) :: b real ( rp ), dimension ( 3 ), intent ( in ) :: c real ( rp ), dimension ( 3 ), intent ( out ) :: d !! Vector triple product d = b * ( a ( 1 ) * c ( 1 ) + a ( 2 ) * c ( 2 ) + a ( 3 ) * c ( 3 ) ) & - c * ( a ( 1 ) * b ( 1 ) + a ( 2 ) * b ( 2 ) + a ( 3 ) * b ( 3 ) ) end subroutine !****************************************************************************** function det ( A ) result ( res ) !!  Returns the determinant of an (N x N) matrix, where N = 2, 3, or 4. !! !!  Original routine by [David Simpson](http://www.davidgsimpson.com/software.html) !!  @note For a general NxN matrix do an LU decomp !\"\" real ( rp ), dimension (:,:), intent ( in ) :: A !! (N,N) array, where N = 2, 3, or 4. real ( rp ) :: res integer :: nrows nrows = size ( A , 1 ) if ( nrows == 2 ) then res = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) else if ( nrows == 3 ) then res = A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 1 , 1 ) * A ( 2 , 3 ) * A ( 3 , 2 ) & - A ( 1 , 2 ) * A ( 2 , 1 ) * A ( 3 , 3 ) + A ( 1 , 2 ) * A ( 2 , 3 ) * A ( 3 , 1 ) & + A ( 1 , 3 ) * A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 1 , 3 ) * A ( 2 , 2 ) * A ( 3 , 1 ) else if ( nrows == 4 ) then res = A ( 1 , 1 ) * ( A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) & + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) & + A ( 2 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) ) & - A ( 1 , 2 ) * ( A ( 2 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) & + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) & + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 )) ) & + A ( 1 , 3 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) & + A ( 2 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) & + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )) ) & - A ( 1 , 4 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) & + A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 )) & + A ( 2 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )) ) else stop 'matrix size must be 2, 3, or 4' end if end function !****************************************************************************** function trace ( mat ) result ( res ) !! Returns the trace of a square matrix real ( rp ), intent ( in ) :: mat (:,:) !! (N,N) array real ( rp ) :: res integer :: nrows integer :: i nrows = size ( mat , 1 ) res = 0.0_rp do i = 1 , nrows res = res + mat ( i , i ) end do end function !****************************************************************************** elemental logical function isclose ( a , b , rel_tol , abs_tol ) !!  Checks if two floating point numbers of type double are close within !!  tolerance. !! !!  Based on python implementation at !!  <https://github.com/PythonCHB/close_pep/blob/master/is_close.py>. !!  The *method='weak'* option is used here. !\"\" real ( rp ), intent ( in ) :: a real ( rp ), intent ( in ) :: b real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance, `rel_tol` >= 0, default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance, `abs_tol` >= 0, default 0.0 real ( rp ) :: rel_tol_ real ( rp ) :: abs_tol_ real ( rp ) :: diff rel_tol_ = 1e-10_rp abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol if ( a == b ) then ! short-circuit exact equality isclose = . true . end if if ((. not . ieee_is_finite ( a )) . or . (. not . ieee_is_finite ( b ))) then ! Includes the case of two infinities of opposite sign, or ! one infinity and one finite number. Two infinities of opposite sign ! would otherwise have an infinite relative tolerance. isclose = . false . end if diff = abs ( b - a ) isclose = ( (( diff <= abs ( rel_tol_ * b )) . or . ( diff <= abs ( rel_tol_ * a ))) & . or . ( diff <= abs_tol_ ) ) end function !****************************************************************************** logical function allclose_rank1 ( a , b , rel_tol , abs_tol ) !!  Checks if two rank-1 floating point arrays of type double are close within !!  tolerance. !\"\" real ( rp ), dimension (:), intent ( in ) :: a !! (m,) array real ( rp ), dimension (:), intent ( in ) :: b !! (m,) array real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance; default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance; default 0.0 real ( rp ) :: rel_tol_ = 1e-10_rp real ( rp ) :: abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol allclose_rank1 = all ( isclose ( a , b , rel_tol_ , abs_tol_ )) end function logical function allclose_rank2 ( a , b , rel_tol , abs_tol ) !!  Checks if two rank-2 floating point arrays of type double are close within !!  tolerance. !\"\" real ( rp ), dimension (:,:), intent ( in ) :: a !! (m,n) array real ( rp ), dimension (:,:), intent ( in ) :: b !! (m,n) array real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance; default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance; default 0.0 real ( rp ) :: rel_tol_ = 1e-10_rp real ( rp ) :: abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol allclose_rank2 = all ( isclose ( a , b , rel_tol_ , abs_tol_ )) end function logical function allclose_rank3 ( a , b , rel_tol , abs_tol ) !!  Checks if two rank-3 floating point arrays of type double are close within !!  tolerance. !\"\" real ( rp ), dimension (:,:,:), intent ( in ) :: a !! (m,n,p) array real ( rp ), dimension (:,:,:), intent ( in ) :: b !! (m,n,p) array real ( rp ), intent ( in ), optional :: rel_tol !! Relative tolerance; default 1e-10 real ( rp ), intent ( in ), optional :: abs_tol !! Absolute tolerance; default 0.0 real ( rp ) :: rel_tol_ = 1e-10_rp real ( rp ) :: abs_tol_ = 0.0_rp if ( present ( rel_tol )) rel_tol_ = rel_tol if ( present ( abs_tol )) abs_tol_ = abs_tol allclose_rank3 = all ( isclose ( a , b , rel_tol_ , abs_tol_ )) end function !****************************************************************************** elemental subroutine swap_integer ( a , b ) integer , intent ( in out ) :: a integer , intent ( in out ) :: b integer :: temp temp = a a = b b = temp end subroutine elemental subroutine swap_real ( a , b ) real ( rp ), intent ( in out ) :: a real ( rp ), intent ( in out ) :: b real ( rp ) :: temp temp = a a = b b = temp end subroutine elemental subroutine swap_complex ( a , b ) complex ( rp ), intent ( in out ) :: a complex ( rp ), intent ( in out ) :: b complex ( rp ) :: temp temp = a a = b b = temp end subroutine !****************************************************************************** subroutine unitize ( a ) !! Normalizes a vector in-place. If the magnitude of the vector is nearly !! zero, no normalization takes place and the vector is returned as is with !! a warning message. real ( rp ), dimension (:), intent ( in out ) :: a !! (m,) array real ( rp ) :: norm norm = norm2 ( a ) if ( isclose ( norm , 0.0_rp , rel_tol = 1.e-15_rp , abs_tol = 0.0_rp )) then write ( * , * ) '[unitize] norm close to zero' else a = a / norm2 ( a ) end if end subroutine !****************************************************************************** subroutine linspace ( start , finish , num , val , step ) !! Generates evenly spaced numbers over a specified interval. Both end !! points are included. If `start` < `finish`, the returned step size (if !! `step` is present) will be negative. !\"\" real ( rp ), intent ( in ) :: start !! Starting point real ( rp ), intent ( in ) :: finish !! Ending point, `finish` /= `start` integer , intent ( in ) :: num !! Number of values to generate, `num >= 2` real ( rp ), dimension (:), intent ( out ) :: val !! (`num`,) array; Generated values real ( rp ), intent ( out ), optional :: step !! Step size real ( rp ) :: step_ integer :: i if ( num < 2 ) then write ( * , * ) '[linspace] `num` must be >= 2' stop end if if ( num < size ( val )) then write ( * , * ) '[linspace] `size(val)` must be >= `num`' stop end if if ( start == finish ) then write ( * , * ) '[linspace] `start` must not be equal to `finish`' stop end if val = 0.0_rp step_ = ( finish - start ) / ( num - 1 ) if ( present ( step )) step = step_ val ( 1 ) = start val ( num ) = finish do i = 2 , ( num - 1 ) val ( i ) = start + ( i - 1 ) * step_ end do end subroutine !****************************************************************************** subroutine logspace ( start , finish , num , val , base ) !!  Generates numbers spaced evenly on a log scale. !!  In linear space, the sequence starts at `base ** start` !!  (`base` to the power of `start`) and ends with `base ** stop` !\"\" real ( rp ), intent ( in ) :: start !! Starting point, `base ** start` is the starting value real ( rp ), intent ( in ) :: finish !! Ending point, `finish` /= `start`,  `base ** start` !! is the ending value integer , intent ( in ) :: num !! Number of values to generate, `num >= 2` real ( rp ), dimension (:), intent ( out ) :: val !! (`num`,) array; Generated values real ( rp ), intent ( in ), optional :: base !! Base of the logspace, default 10 real ( rp ) :: base_ integer :: i if ( num < 2 ) then write ( * , * ) 'logspace `num` must be >= 2' stop end if if ( num < size ( val )) then write ( * , * ) 'logspace `size(val)` must be >= `num`' stop end if if ( start == finish ) then write ( * , * ) 'logspace `start` must not be equal to `finish`' stop end if val = 0.0_rp base_ = 1 0.0_rp if ( present ( base )) base_ = base call linspace ( start , finish , num , val ) do i = 1 , num val ( i ) = base_ ** val ( i ) end do end subroutine !****************************************************************************** subroutine identity ( mat_eye ) !! Creates an identity matrix of size n x n. real ( rp ), dimension (:,:), intent ( out ) :: mat_eye !! (n,n) array integer :: nrows integer :: i nrows = size ( mat_eye , 1 ) mat_eye = 0.0_rp do i = 1 , nrows mat_eye ( i , i ) = 1.0_rp end do end subroutine !****************************************************************************** subroutine get_diagonal ( mat , d ) !! Returns the diagonal elements of a square matrix. real ( rp ), dimension (:,:), intent ( in ) :: mat !! (n,n) array real ( rp ), dimension (:), intent ( out ) :: d !! (n,) array; contains the entries of the main diagonal integer :: n integer :: i n = size ( mat , 1 ) do i = 1 , n d ( i ) = mat ( i , i ) end do end subroutine !****************************************************************************** subroutine add_transpose ( mat ) !! Adds a square matrix and its transpose in place: A_{ij} = A_{ij } + A_{ji} real ( rp ), dimension (:,:), intent ( in out ) :: mat !! (n,n) array integer :: n integer :: i integer :: j n = size ( mat , 1 ) !Dealing with the upper triangular part (including diagonal) do j = 1 , n do i = 1 , j mat ( i , j ) = mat ( i , j ) + mat ( j , i ) end do end do !Dealing with the strictly lower triangular part (i.e. excluding diagonal) do j = 1 , ( n - 1 ) do i = ( j + 1 ), n mat ( i , j ) = mat ( j , i ) end do end do end subroutine !****************************************************************************** subroutine subtract_transpose ( mat ) !! Calculates the difference of a square matrix and its transpose in place: !! A_{ij} = A_{ij } - A_{ji} real ( rp ), dimension (:,:), intent ( in out ) :: mat integer :: n integer :: i integer :: j n = size ( mat , 1 ) !Dealing with the strictly upper triangular part (i.e. excluding diagonal) do j = 2 , n do i = 1 , ( j - 1 ) mat ( i , j ) = mat ( i , j ) - mat ( j , i ) end do end do !Dealing with the strictly lower triangular part (i.e. excluding diagonal) do j = 1 , ( n - 1 ) do i = ( j + 1 ), n mat ( i , j ) = - mat ( j , i ) end do end do !Putting the diagonal to zero do i = 1 , n mat ( i , j ) = 0.0_rp end do end subroutine !****************************************************************************** subroutine multiply_transpose ( A , B ) !! Multiplies a matrix with its transpose: !! \\mathbf{\\mathrm{B}} = \\mathbf{\\mathrm{A}} \\cdot \\mathbf{\\mathrm{A}}&#94;T !\"\" real ( rp ), dimension (:,:), intent ( in ) :: A !! (m,n) array real ( rp ), dimension (:,:), intent ( out ) :: B !! (m,m) array !A is m x n, A&#94;T is n x m, so B is m x m B = matmul ( A , transpose ( A )) end subroutine !****************************************************************************** function get_quad_form ( A , x ) result ( res ) !!  Calculates the quadratic form *x&#94;T A x*, where A is an *n x n* matrix and *x* is a !!  vector of length *n* !\"\" real ( rp ), dimension (:,:), intent ( in ) :: A !! (n,n) array real ( rp ), dimension (:), intent ( in ) :: x !! (n,) array real ( rp ) :: res integer :: n integer :: i , j n = size ( A , 2 ) res = 0.0_rp do j = 1 , n do i = 1 , n res = res + A ( i , j ) * x ( j ) * x ( i ) end do end do end function !****************************************************************************** subroutine orth ( a ) !! Orthogonalizes a set of vectors in-place using Gram-Schmidt orthonormalization !! !! *Reference:* Golub and Van Loan, Matrix Computations, 3rd edition, Section 5.2.8, !! Algorithm 5.2.5, p. 231. real ( rp ), dimension (:,:), intent ( in out ) :: a !! (m,n) array, where m <= n. The first m columns of the matrix are !!  overwritten with the orthogonal basis vectors. integer :: m integer :: i , j m = size ( a , 1 ) do i = 1 , m a ( i ,:) = a ( i ,:) / norm2 ( a ( i ,:)) do j = ( i + 1 ), m a ( j ,:) = a ( j ,:) - dot_product ( a ( j ,:), a ( i ,:)) * a ( i ,:) end do end do end subroutine !****************************************************************************** subroutine invert_mat33 ( a , inv_a ) !! Inverts a 3x3 matrix. !! !!*Reference:* https://www.geometrictools.com/Documentation/LaplaceExpansionTheorem.pdf real ( rp ), dimension ( 3 , 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 , 3 ), intent ( out ) :: inv_a real ( rp ) :: det_a inv_a ( 1 , 1 ) = a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 ) inv_a ( 2 , 1 ) = - ( a ( 2 , 1 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 1 )) inv_a ( 3 , 1 ) = a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 ) inv_a ( 1 , 2 ) = - ( a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 2 )) inv_a ( 2 , 2 ) = a ( 1 , 1 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 1 ) inv_a ( 3 , 2 ) = - ( a ( 1 , 1 ) * a ( 3 , 2 ) - a ( 1 , 2 ) * a ( 3 , 1 )) inv_a ( 1 , 3 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ) inv_a ( 2 , 3 ) = - ( a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 1 )) inv_a ( 3 , 3 ) = a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 ) !Determinant det_a = a ( 1 , 1 ) * inv_a ( 1 , 1 ) + a ( 1 , 2 ) * inv_a ( 2 , 1 ) + a ( 1 , 3 ) * inv_a ( 3 , 1 ) inv_a = inv_a / det_a end subroutine !****************************************************************************** subroutine eigval_33rsym ( a , ev ) !! Calculates the eigenvalues of a 3 x 3 real symmetric matrix. The !! eigenvalues calculated are in decreasing order. Only the diagonal and !! lower triangular part of the matrix is accessed. !! !! *Reference:* https://en.wikipedia.org/wiki/Eigenvalue_algorithm#cite_note-Smith-12 !! !! See also David Eberly's notes and implementation at !! https://www.geometrictools.com/Documentation/RobustEigenSymmetric3x3.pdf real ( rp ), dimension ( 3 , 3 ), intent ( in ) :: a real ( rp ), dimension ( 3 ), intent ( out ) :: ev real ( rp ), dimension ( 3 , 3 ) :: eye real ( rp ), dimension ( 3 , 3 ) :: b real ( rp ) :: p , q , r real ( rp ) :: p1 , p2 real ( rp ) :: phi !Sum of the elements in the lower triangular part p1 = a ( 2 , 1 ) ** 2 + a ( 3 , 1 ) ** 2 + a ( 3 , 2 ) ** 2 if ( isclose ( p1 , 0.0_rp ) ) then !Matrix a is diagonal ev ( 1 ) = a ( 1 , 1 ); ev ( 2 ) = a ( 2 , 2 ); ev ( 3 ) = a ( 3 , 3 ) return else q = ( a ( 1 , 1 ) + a ( 2 , 2 ) + a ( 3 , 3 )) / 3.0_rp p2 = ( a ( 1 , 1 ) - q ) ** 2 + ( a ( 2 , 2 ) - q ) ** 2 + ( a ( 3 , 3 ) - q ) ** 2 + 2 * p1 p = sqrt ( p2 / 6.0_rp ) call identity ( eye ) b = ( a - q * eye ) / p r = 0.5_rp * det ( b ) !r must be within [-1, 1] in exact computation; but need to handle !slightly out of range in computation. if ( r <= - 1.0_rp ) then phi = math_pi / 3.0_rp else if ( r >= 1.0_rp ) then phi = 0.0_rp else phi = acos ( r ) / 3.0_rp end if !Eigen values are ordered as ev(3) <= ev(2) <= ev(1) ev ( 1 ) = q + 2 * p * cos ( phi ) ev ( 3 ) = q + 2 * p * cos ( phi + ( 2 * math_pi / 3.0_rp )) ev ( 2 ) = 3 * q - ev ( 1 ) - ev ( 3 ) end if end subroutine !****************************************************************************** subroutine dsyevc3 ( a , w ) !!author: Joachim Kopp !!date: 2006 !! !! Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's !! analytical algorithm. !! Only the diagonal and upper triangular parts of A are accessed. The access !! is read-only. !! !! Copyright (C) 2006  Joachim Kopp ! ---------------------------------------------------------------------------- ! Parameters: !   A: The symmetric input matrix !   W: Storage buffer for eigenvalues ! ---------------------------------------------------------------------------- ! .. Arguments .. REAL ( RP ), DIMENSION ( 3 , 3 ), INTENT ( IN ) :: A REAL ( RP ), DIMENSION ( 3 ), INTENT ( OUT ) :: W ( 3 ) !.. Local Variables .. REAL ( RP ) :: M , C1 , C0 REAL ( RP ) :: DE , DD , EE , FF REAL ( RP ) :: P , SQRTP , Q , C , S , PHI !Determine coefficients of characteristic poynomial. We write !      | A   D   F  | ! A =  | D*  B   E  | !      | F*  E*  C  | DE = A ( 1 , 2 ) * A ( 2 , 3 ) DD = A ( 1 , 2 ) ** 2 EE = A ( 2 , 3 ) ** 2 FF = A ( 1 , 3 ) ** 2 M = A ( 1 , 1 ) + A ( 2 , 2 ) + A ( 3 , 3 ) C1 = ( A ( 1 , 1 ) * A ( 2 , 2 ) + A ( 1 , 1 ) * A ( 3 , 3 ) + A ( 2 , 2 ) * A ( 3 , 3 ) ) & - ( DD + EE + FF ) C0 = A ( 3 , 3 ) * DD + A ( 1 , 1 ) * EE + A ( 2 , 2 ) * FF - A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) & - 2.0_RP * A ( 1 , 3 ) * DE P = M ** 2 - 3.0_RP * C1 Q = M * ( P - ( 3.0_RP / 2.0_RP ) * C1 ) - ( 2 7.0_RP / 2.0_RP ) * C0 SQRTP = SQRT ( ABS ( P )) PHI = 2 7.0_RP * ( 0.25_RP * C1 ** 2 * ( P - C1 ) & + C0 * ( Q + ( 2 7.0_RP / 4.0_RP ) * C0 ) ) PHI = ( 1.0_RP / 3.0_RP ) * ATAN2 ( SQRT ( ABS ( PHI )), Q ) C = SQRTP * COS ( PHI ) S = ( 1.0_RP / MATH_SQRT3 ) * SQRTP * SIN ( PHI ) W ( 2 ) = ( 1.0_RP / 3.0_RP ) * ( M - C ) W ( 3 ) = W ( 2 ) + S W ( 1 ) = W ( 2 ) + C W ( 2 ) = W ( 2 ) - S END SUBROUTINE !****************************************************************************** end module m_utils_math","tags":"","loc":"sourcefile/m_utils_math.f90.html"},{"title":"m_vector.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_vector.f90~~EfferentGraph sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_vector.f90~~AfferentGraph sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_connectivity.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_verlet.f90->sourcefile~m_vector.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_cell_list.f90->sourcefile~m_vector.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 var pansourcefilem_vectorf90AfferentGraph = svgPanZoom('#sourcefilem_vectorf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_vector Source Code m_vector.f90 Source Code module m_vector !! Implements a vector as an extendable array. use m_precision use m_qsort implicit none type ivector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init integer , dimension (:), allocatable :: buffer contains procedure :: delete => ivector_delete procedure :: clear => ivector_clear procedure :: get_val => ivector_get_val procedure :: set_val => ivector_set_val procedure :: get_data => ivector_get_data procedure :: append => ivector_append procedure :: shrink_to_fit => ivector_shrink_to_fit procedure :: sort => ivector_sort procedure :: unique => ivector_unique procedure :: print => ivector_print end type ivector_t type dvector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init real ( rp ), dimension (:), allocatable :: buffer contains procedure :: delete => dvector_delete procedure :: clear => dvector_clear procedure :: get_val => dvector_get_val procedure :: set_val => dvector_set_val procedure :: get_data => dvector_get_data procedure :: append => dvector_append procedure :: shrink_to_fit => dvector_shrink_to_fit procedure :: sort => dvector_sort procedure :: unique => dvector_unique procedure :: print => dvector_print end type dvector_t interface assignment ( = ) module procedure ivector_assign module procedure dvector_assign module procedure i_dvector_assign end interface contains !****************************************************************************** !> Creates an empty *ivector* with all elements equal to zero. subroutine ivector_init ( this , len_init , ierr ) type ( ivector_t ), intent ( in out ) :: this integer , intent ( in ), optional :: len_init !! Must be > 0 integer , intent ( out ), optional :: ierr integer :: istat if ( present ( ierr )) ierr = 0 if ( present ( len_init )) then if ( len_init > 0 ) this % len_init = len_init this % len_max = 2 * len_init end if allocate ( this % buffer ( this % len_max ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for this%buffer of size' , this % len_max if ( present ( ierr )) ierr = 1 return end if this % buffer = 0 end subroutine !****************************************************************************** !> Creates an empty *dvector* with all elements equal to zero. subroutine dvector_init ( this , len_init , ierr ) type ( dvector_t ), intent ( in out ) :: this integer , intent ( in ), optional :: len_init !! Must be > 0 integer , intent ( out ), optional :: ierr integer :: istat if ( present ( ierr )) ierr = 0 if ( present ( len_init )) then if ( len_init > 0 ) this % len_init = len_init this % len_max = 2 * len_init end if allocate ( this % buffer ( this % len_max ), stat = istat ) if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for this%buffer of size' , this % len_max if ( present ( ierr )) ierr = 1 return end if this % buffer = 0.0_rp end subroutine !****************************************************************************** !> Creates an *ivector* with all elements from an array subroutine ivector_from_array ( this , x ) type ( ivector_t ), intent ( in out ) :: this integer , dimension (:), intent ( in ) :: x integer , dimension (:), allocatable :: temp integer :: n call ivector_init ( this ) n = size ( x , 1 ) if ( this % len_max < n ) then allocate ( temp ( 2 * n )) temp = 0 temp ( 1 : n ) = x call move_alloc ( temp , this % buffer ) this % len = n this % len_max = 2 * n else this % buffer ( 1 : n ) = x this % len = n end if end subroutine !****************************************************************************** !> Creates a *dvector* with all elements from an array subroutine dvector_from_array ( this , x ) type ( dvector_t ), intent ( in out ) :: this real ( rp ), dimension (:), intent ( in ) :: x real ( rp ), dimension (:), allocatable :: temp integer :: n call dvector_init ( this ) n = size ( x , 1 ) if ( this % len_max < n ) then allocate ( temp ( 2 * n )) temp = 0 temp ( 1 : n ) = x call move_alloc ( temp , this % buffer ) this % len = n this % len_max = 2 * n else this % buffer ( 1 : n ) = x this % len = n end if end subroutine !****************************************************************************** !> Deletes an *ivector*. No access is allowed to this object after this call. subroutine ivector_delete ( this ) class ( ivector_t ), intent ( in out ) :: this if ( allocated ( this % buffer )) deallocate ( this % buffer ) this % len = 0 end subroutine !****************************************************************************** !> Deletes a *dvector*. No access is allowed to this object after this call. subroutine dvector_delete ( this ) class ( dvector_t ), intent ( in out ) :: this if ( allocated ( this % buffer )) deallocate ( this % buffer ) this % len = 0 end subroutine !****************************************************************************** !> Clears an *ivector*. Access allowed after a call to clear. subroutine ivector_clear ( this ) class ( ivector_t ), intent ( in out ) :: this this % len = 0 this % buffer = 0 end subroutine !****************************************************************************** !> Clears a *dvector*. Access allowed after a call to clear. subroutine dvector_clear ( this ) class ( dvector_t ), intent ( in out ) :: this this % len = 0 this % buffer = 0.0_rp end subroutine !****************************************************************************** !> Copies the contents of *ivector* `other` to *ivector* `this` !! subroutine ivector_assign ( this , other ) class ( ivector_t ), intent ( in out ) :: this class ( ivector_t ), intent ( in ) :: other integer :: n n = other % len if ( this % len >= n ) then !Copy contents if buffer is large enough this % buffer ( 1 : n ) = other % buffer this % len = n else !Need to enlarge buffer. Reallocate and copy deallocate ( this % buffer ) allocate ( this % buffer , source = other % buffer ( 1 : n )) this % len = n this % len_max = n end if end subroutine !****************************************************************************** !> Copies the contents of *dvector* `other` to *dvector* `this` !! subroutine dvector_assign ( this , other ) class ( dvector_t ), intent ( in out ) :: this class ( dvector_t ), intent ( in ) :: other integer :: n n = other % len if ( this % len >= n ) then !Copy contents if buffer is large enough this % buffer ( 1 : n ) = other % buffer ( 1 : n ) this % len = n else !Need to enlarge buffer. Reallocate and copy deallocate ( this % buffer ) allocate ( this % buffer , source = other % buffer ( 1 : n )) this % len = n this % len_max = n end if end subroutine !****************************************************************************** subroutine i_dvector_assign ( this , other ) !!  Copies the contents of *ivector* `other` to *dvector* `this`. Integers !!  are cast to reals. !\"\" class ( dvector_t ), intent ( in out ) :: this class ( ivector_t ), intent ( in ) :: other integer :: n n = other % len if ( this % len >= n ) then !Copy contents if buffer is large enough this % buffer ( 1 : n ) = dble ( other % buffer ( 1 : n )) this % len = n else !Need to enlarge buffer. Reallocate and copy deallocate ( this % buffer ) allocate ( this % buffer ( n )) this % buffer = dble ( other % buffer ( 1 : n )) this % len = n this % len_max = n end if end subroutine !****************************************************************************** !> Returns the length of an *ivector* function ivector_get_len ( this ) result ( res ) class ( ivector_t ), intent ( in ) :: this integer :: res res = this % len end function !****************************************************************************** !> Returns the length of a *dvector* function dvector_get_len ( this ) result ( res ) class ( dvector_t ), intent ( in ) :: this integer :: res res = this % len end function !****************************************************************************** !> Returns the ith element of an *ivector*. function ivector_get_val ( this , i ) result ( res ) class ( ivector_t ), intent ( in ) :: this integer , intent ( in ) :: i integer :: res if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else res = this % buffer ( i ) end if end function !****************************************************************************** !> Returns the ith element of a *dvector*. function dvector_get_val ( this , i ) result ( res ) class ( dvector_t ), intent ( in ) :: this integer , intent ( in ) :: i real ( rp ) :: res if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else res = this % buffer ( i ) end if end function !****************************************************************************** !> Sets the value of the ith element of an *ivector*. No bounds check is performed. subroutine ivector_set_val ( this , i , val ) class ( ivector_t ), intent ( in out ) :: this integer , intent ( in ) :: i integer , intent ( in ) :: val if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else this % buffer ( i ) = val end if end subroutine !****************************************************************************** !> Sets the value of the ith element of a *dvector*. No bounds check is performed. subroutine dvector_set_val ( this , i , val ) class ( dvector_t ), intent ( in out ) :: this integer , intent ( in ) :: i real ( rp ), intent ( in ) :: val if ( i > this % len ) then write ( * , * ) 'error: out-of-bounds index ' , i write ( * , * ) 'for ubound' , this % len stop else this % buffer ( i ) = val end if end subroutine !****************************************************************************** !> Adds an element to the end of an *ivector*. Reallocation will take place if required. subroutine ivector_append ( this , val ) class ( ivector_t ), intent ( in out ) :: this integer , intent ( in ) :: val integer , dimension (:), allocatable :: temp !Double len_max if current length is equal to len_max if ( this % len == this % len_max ) then allocate ( temp ( 2 * this % len_max )) temp = 0 temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) call move_alloc ( temp , this % buffer ) this % len_max = 2 * this % len_max end if this % buffer ( this % len + 1 ) = val this % len = this % len + 1 end subroutine !****************************************************************************** !> Adds an element to the end of a *dvector*. Reallocation will take place if required. subroutine dvector_append ( this , val ) class ( dvector_t ), intent ( in out ) :: this real ( rp ), intent ( in ) :: val real ( rp ), dimension (:), allocatable :: temp !Double len_max if current length is equal to len_max if ( this % len == this % len_max ) then allocate ( temp ( 2 * this % len_max )) temp = 0 temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) call move_alloc ( temp , this % buffer ) this % len_max = 2 * this % len_max end if this % buffer ( this % len + 1 ) = val this % len = this % len + 1 end subroutine !****************************************************************************** !> Returns a pointer to the underlying data of an *ivector* ! No bounds checking is performed subroutine ivector_get_data ( this , res , ibeg , iend ) class ( ivector_t ), target , intent ( in ) :: this integer , dimension (:), pointer , intent ( out ) :: res integer , intent ( in ), optional :: ibeg integer , intent ( in ), optional :: iend integer :: ibeg_ integer :: iend_ res => null () ibeg_ = 1 iend_ = this % len if ( present ( ibeg )) then ibeg_ = ibeg end if if ( present ( iend )) then iend_ = iend end if res => this % buffer ( ibeg_ : iend_ ) end subroutine !****************************************************************************** !> Returns a pointer to the underlying data of a *dvector* ! No bounds checking is performed subroutine dvector_get_data ( this , res , ibeg , iend ) class ( dvector_t ), target , intent ( in ) :: this real ( rp ), dimension (:), pointer , intent ( out ) :: res integer , intent ( in ), optional :: ibeg integer , intent ( in ), optional :: iend integer :: ibeg_ integer :: iend_ res => null () ibeg_ = 1 iend_ = this % len if ( present ( ibeg )) then ibeg_ = ibeg end if if ( present ( iend )) then iend_ = iend end if res => this % buffer ( ibeg_ : iend_ ) end subroutine !****************************************************************************** !> Releases additional memory to fit underlying data of an *ivector* to a size !> this%len_init. subroutine ivector_shrink_to_fit ( this , ierr ) class ( ivector_t ), intent ( in out ) :: this integer , intent ( out ), optional :: ierr integer , dimension (:), allocatable :: temp integer :: istat if ( present ( ierr )) ierr = 0 if ( this % len > this % len_init ) then allocate ( temp , source = this % buffer ( 1 : this % len ), stat = istat ) else allocate ( temp ( this % len_init ), stat = istat ) temp = 0 temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) end if if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for `temp` from `this%buffer`.' if ( present ( ierr )) ierr = 1 return end if call move_alloc ( temp , this % buffer ) this % len_max = size ( this % buffer ) end subroutine !****************************************************************************** !> Releases additional memory to fit underlying data of a *dvector* to a size !> this%len_init. subroutine dvector_shrink_to_fit ( this , ierr ) class ( dvector_t ), intent ( in out ) :: this integer , intent ( out ), optional :: ierr real ( rp ), dimension (:), allocatable :: temp integer :: istat if ( present ( ierr )) ierr = 0 if ( this % len > this % len_init ) then allocate ( temp , source = this % buffer ( 1 : this % len ), stat = istat ) else allocate ( temp ( this % len_init ), stat = istat ) temp = 0.0_rp temp ( 1 : this % len ) = this % buffer ( 1 : this % len ) end if if ( istat /= 0 ) then write ( * , * ) 'error: allocation failure for `temp` from `this%buffer`.' if ( present ( ierr )) ierr = 1 return end if call move_alloc ( temp , this % buffer ) this % len_max = size ( this % buffer ) end subroutine !****************************************************************************** !>  Sorts an *ivector* in ascending order. If `order` is provided, it will contain !!  the sorted indices.  The size of `order` must be at least `this%len`. subroutine ivector_sort ( this , order ) class ( ivector_t ), intent ( in out ) :: this integer , dimension (:), intent ( out ), optional :: order integer :: n n = this % len if ( n > 1 ) then if ( present ( order )) then call iqsort ( this % buffer ( 1 : n ), order ) else call iqsort ( this % buffer ( 1 : n )) end if end if end subroutine !****************************************************************************** !>  Sorts a *dvector* in ascending order. If `order` is provided, it will contain !!  the sorted indices.  The size of `order` must be at least `this%len`. subroutine dvector_sort ( this , order ) class ( dvector_t ), intent ( in out ) :: this integer , dimension (:), intent ( out ), optional :: order integer :: n n = this % len if ( n > 1 ) then if ( present ( order )) then call dqsort ( this % buffer ( 1 : n ), order ) else call dqsort ( this % buffer ( 1 : n )) end if end if end subroutine !****************************************************************************** !> Sorts and removes all duplicate entries of an *ivector*. Note that the internal !! buffer size remains unchanged. To reduce the buffer size, call !! `ivector_shrink_to_fit`. subroutine ivector_unique ( this ) class ( ivector_t ), intent ( in out ) :: this integer , dimension ( this % len ) :: temp integer :: n integer :: i if ( this % len < 2 ) return !Already sorted temp = this % buffer ( 1 : this % len ) call iqsort ( temp ) !The first element is unique by default this % buffer ( 1 ) = temp ( 1 ) n = 1 !Successively copy non-duplicate elements do i = 2 , this % len if ( temp ( i ) /= this % buffer ( n )) then this % buffer ( n + 1 ) = temp ( i ) n = n + 1 end if end do !Set the length to number of unique elements this % len = n end subroutine !****************************************************************************** !> Sorts and removes all duplicate entries of a *dvector*. Note that the internal !! buffer size remains unchanged. To reduce the buffer size, call !! `dvector_shrink_to_fit`. subroutine dvector_unique ( this ) class ( dvector_t ), intent ( in out ) :: this real ( rp ), dimension ( this % len ) :: temp integer :: n integer :: i if ( this % len < 2 ) return !Already sorted temp = this % buffer call dqsort ( temp ) !The first element is unique by default this % buffer ( 1 ) = temp ( 1 ) n = 1 !Successively copy non-duplicate elements do i = 2 , this % len if ( temp ( i ) /= this % buffer ( n )) then this % buffer ( n + 1 ) = temp ( i ) n = n + 1 end if end do !Set the length to number of unique elements this % len = n end subroutine !****************************************************************************** !> Prints an *ivector* subroutine ivector_print ( this ) class ( ivector_t ), intent ( in ) :: this integer :: i do i = 1 , this % len write ( * , '(i0,1x,i0)' ) i , this % buffer ( i ) end do end subroutine !****************************************************************************** !> Prints a *dvector* subroutine dvector_print ( this ) class ( dvector_t ), intent ( in ) :: this integer :: i do i = 1 , this % len write ( * , '(i0,1x,f0.15)' ) i , this % buffer ( i ) end do end subroutine !****************************************************************************** end module m_vector","tags":"","loc":"sourcefile/m_vector.f90.html"},{"title":"m_verlet.f90 – BROWNPAK","text":"This file depends on sourcefile~~m_verlet.f90~~EfferentGraph sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_precision.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_verlet.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_table.f90->sourcefile~m_precision.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~m_verlet.f90~~AfferentGraph sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_kmc.f90 m_kmc.f90 sourcefile~m_kmc.f90->sourcefile~m_interaction.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~main.f90->sourcefile~m_relax.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules m_verlet Source Code m_verlet.f90 Source Code module m_verlet !! Routines for building Verlet neighbor table. use m_precision use m_vector use m_table use m_globals implicit none private public :: verlet_init , verlet_build , verlet_delete public :: verlet_tab type ( itable_t ) :: verlet_tab !! Verlet table real ( rp ), dimension (:,:), allocatable :: coordinates_save !!  (3, *num_atoms*) array real ( rp ), dimension (:,:), allocatable :: coordinates_dr !!  (3, *num_atoms*) array real ( rp ) :: rskin_sq = 0.0_rp real ( rp ) :: tskin_sq = 0.0_rp contains !****************************************************************************** subroutine verlet_init ( rskin , tskin ) real ( rp ), intent ( in ) :: rskin real ( rp ), intent ( in ) :: tskin rskin_sq = rskin ** 2 tskin_sq = tskin ** 2 call itbl_init ( verlet_tab , num_atoms - 1 ) allocate ( coordinates_save ( 3 , num_atoms ) ) allocate ( coordinates_dr ( 3 , num_atoms ) ) !Initializing to zero coordinates_save = 0.0_rp coordinates_dr = 0.0_rp end subroutine !****************************************************************************** subroutine verlet_delete () if ( allocated ( coordinates_save )) deallocate ( coordinates_save ) if ( allocated ( coordinates_dr ) ) deallocate ( coordinates_dr ) call verlet_tab % delete () end subroutine !****************************************************************************** subroutine verlet_build () real ( rp ), dimension ( 3 ) :: ri real ( rp ), dimension ( 3 ) :: rj real ( rp ), dimension ( 3 ) :: rij real ( rp ) :: dr_sq_max real ( rp ) :: rij_sq logical , save :: first_call = . true . integer :: i , j !On first call no check for rebuilding if (. not . first_call ) then !Check whether rebuilding the list is necessary coordinates_dr = coordinates (:, 1 : num_atoms ) - coordinates_save if ( imcon /= 0 ) then do i = 1 , num_atoms call simbox % get_image ( coordinates_dr (:, i )) end do end if dr_sq_max = maxval ( sum ( coordinates_dr ** 2 , dim = 1 )) if ( 4 * dr_sq_max < tskin_sq ) then return end if end if first_call = . false . !Clear table call verlet_tab % clear () !Loop over all pairs to build list do i = 1 , num_atoms - 1 ri = coordinates (:, i ) do j = i + 1 , num_atoms rj = coordinates (:, j ) rij = rj - ri if ( imcon /= 0 ) call simbox % get_image ( rij ) rij_sq = sum ( rij ** 2 ) if ( rij_sq < rskin_sq ) call verlet_tab % append ( i , j ) end do end do !Release additional memory call verlet_tab % shrink_to_fit () !Back up positions coordinates_save = coordinates (:, 1 : num_atoms ) end subroutine !******************************************************************************** end module m_verlet","tags":"","loc":"sourcefile/m_verlet.f90.html"},{"title":"main.f90 – BROWNPAK","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~m_globals.f90 m_globals.f90 sourcefile~main.f90->sourcefile~m_globals.f90 sourcefile~m_precision.f90 m_precision.f90 sourcefile~main.f90->sourcefile~m_precision.f90 sourcefile~m_setup.f90 m_setup.f90 sourcefile~main.f90->sourcefile~m_setup.f90 sourcefile~m_bd_solver.f90 m_bd_solver.f90 sourcefile~main.f90->sourcefile~m_bd_solver.f90 sourcefile~m_control_io.f90 m_control_io.f90 sourcefile~main.f90->sourcefile~m_control_io.f90 sourcefile~m_strings.f90 m_strings.f90 sourcefile~main.f90->sourcefile~m_strings.f90 sourcefile~m_mpcd.f90 m_mpcd.f90 sourcefile~main.f90->sourcefile~m_mpcd.f90 sourcefile~m_logger.f90 m_logger.f90 sourcefile~main.f90->sourcefile~m_logger.f90 sourcefile~m_relax.f90 m_relax.f90 sourcefile~main.f90->sourcefile~m_relax.f90 sourcefile~m_globals.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90 m_simbox.f90 sourcefile~m_globals.f90->sourcefile~m_simbox.f90 sourcefile~m_trajectory.f90 m_trajectory.f90 sourcefile~m_globals.f90->sourcefile~m_trajectory.f90 sourcefile~m_setup.f90->sourcefile~m_globals.f90 sourcefile~m_setup.f90->sourcefile~m_precision.f90 sourcefile~m_setup.f90->sourcefile~m_bd_solver.f90 sourcefile~m_setup.f90->sourcefile~m_mpcd.f90 sourcefile~m_setup.f90->sourcefile~m_logger.f90 sourcefile~m_setup.f90->sourcefile~m_simbox.f90 sourcefile~m_interaction.f90 m_interaction.f90 sourcefile~m_setup.f90->sourcefile~m_interaction.f90 sourcefile~m_stats_io.f90 m_stats_io.f90 sourcefile~m_setup.f90->sourcefile~m_stats_io.f90 sourcefile~m_config_io.f90 m_config_io.f90 sourcefile~m_setup.f90->sourcefile~m_config_io.f90 sourcefile~m_ran_num.f90 m_ran_num.f90 sourcefile~m_setup.f90->sourcefile~m_ran_num.f90 sourcefile~m_bd_solver.f90->sourcefile~m_globals.f90 sourcefile~m_bd_solver.f90->sourcefile~m_precision.f90 sourcefile~m_bd_solver.f90->sourcefile~m_strings.f90 sourcefile~m_bd_solver.f90->sourcefile~m_logger.f90 sourcefile~m_bd_solver.f90->sourcefile~m_interaction.f90 sourcefile~m_bd_solver.f90->sourcefile~m_stats_io.f90 sourcefile~m_constants_math.f90 m_constants_math.f90 sourcefile~m_bd_solver.f90->sourcefile~m_constants_math.f90 sourcefile~m_bd_solver.f90->sourcefile~m_config_io.f90 sourcefile~m_bd_solver.f90->sourcefile~m_ran_num.f90 sourcefile~m_control_io.f90->sourcefile~m_globals.f90 sourcefile~m_control_io.f90->sourcefile~m_precision.f90 sourcefile~m_control_io.f90->sourcefile~m_strings.f90 sourcefile~m_strings.f90->sourcefile~m_precision.f90 sourcefile~m_mpcd.f90->sourcefile~m_globals.f90 sourcefile~m_mpcd.f90->sourcefile~m_precision.f90 sourcefile~m_mpcd.f90->sourcefile~m_strings.f90 sourcefile~m_mpcd.f90->sourcefile~m_logger.f90 sourcefile~m_cell_list.f90 m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_cell_list.f90 sourcefile~m_mpcd.f90->sourcefile~m_interaction.f90 sourcefile~m_mpcd.f90->sourcefile~m_stats_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_constants_math.f90 sourcefile~m_utils_math.f90 m_utils_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_utils_math.f90 sourcefile~m_mpcd.f90->sourcefile~m_config_io.f90 sourcefile~m_mpcd.f90->sourcefile~m_ran_num.f90 sourcefile~m_relax.f90->sourcefile~m_globals.f90 sourcefile~m_relax.f90->sourcefile~m_precision.f90 sourcefile~m_relax.f90->sourcefile~m_strings.f90 sourcefile~m_relax.f90->sourcefile~m_logger.f90 sourcefile~m_relax.f90->sourcefile~m_interaction.f90 sourcefile~m_relax.f90->sourcefile~m_stats_io.f90 sourcefile~m_relax.f90->sourcefile~m_config_io.f90 sourcefile~m_relax.f90->sourcefile~m_ran_num.f90 sourcefile~m_cell_list.f90->sourcefile~m_globals.f90 sourcefile~m_cell_list.f90->sourcefile~m_precision.f90 sourcefile~m_vector.f90 m_vector.f90 sourcefile~m_cell_list.f90->sourcefile~m_vector.f90 sourcefile~m_simbox.f90->sourcefile~m_precision.f90 sourcefile~m_simbox.f90->sourcefile~m_constants_math.f90 sourcefile~m_simbox.f90->sourcefile~m_ran_num.f90 sourcefile~m_interaction.f90->sourcefile~m_globals.f90 sourcefile~m_interaction.f90->sourcefile~m_precision.f90 sourcefile~m_interaction.f90->sourcefile~m_cell_list.f90 sourcefile~m_interaction.f90->sourcefile~m_constants_math.f90 sourcefile~m_connectivity.f90 m_connectivity.f90 sourcefile~m_interaction.f90->sourcefile~m_connectivity.f90 sourcefile~m_ia_external.f90 m_ia_external.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_external.f90 sourcefile~m_verlet.f90 m_verlet.f90 sourcefile~m_interaction.f90->sourcefile~m_verlet.f90 sourcefile~m_ia_angle.f90 m_ia_angle.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_angle.f90 sourcefile~m_ia_bond.f90 m_ia_bond.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_bond.f90 sourcefile~m_ia_vdw.f90 m_ia_vdw.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_vdw.f90 sourcefile~m_ia_dihedral.f90 m_ia_dihedral.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_dihedral.f90 sourcefile~m_ia_tether.f90 m_ia_tether.f90 sourcefile~m_interaction.f90->sourcefile~m_ia_tether.f90 sourcefile~m_stats_io.f90->sourcefile~m_globals.f90 sourcefile~m_stats_io.f90->sourcefile~m_precision.f90 sourcefile~m_stats_io.f90->sourcefile~m_strings.f90 sourcefile~m_stats_io.f90->sourcefile~m_constants_math.f90 sourcefile~m_constants_math.f90->sourcefile~m_precision.f90 sourcefile~m_utils_math.f90->sourcefile~m_precision.f90 sourcefile~m_utils_math.f90->sourcefile~m_constants_math.f90 sourcefile~m_trajectory.f90->sourcefile~m_precision.f90 sourcefile~m_trajectory.f90->sourcefile~m_logger.f90 sourcefile~m_config_io.f90->sourcefile~m_globals.f90 sourcefile~m_config_io.f90->sourcefile~m_precision.f90 sourcefile~m_config_io.f90->sourcefile~m_strings.f90 sourcefile~m_config_io.f90->sourcefile~m_simbox.f90 sourcefile~m_ran_num.f90->sourcefile~m_precision.f90 sourcefile~m_connectivity.f90->sourcefile~m_globals.f90 sourcefile~m_connectivity.f90->sourcefile~m_precision.f90 sourcefile~m_connectivity.f90->sourcefile~m_vector.f90 sourcefile~m_table.f90 m_table.f90 sourcefile~m_connectivity.f90->sourcefile~m_table.f90 sourcefile~m_ia_external.f90->sourcefile~m_globals.f90 sourcefile~m_ia_external.f90->sourcefile~m_precision.f90 sourcefile~m_ia_external.f90->sourcefile~m_constants_math.f90 sourcefile~m_verlet.f90->sourcefile~m_globals.f90 sourcefile~m_verlet.f90->sourcefile~m_precision.f90 sourcefile~m_verlet.f90->sourcefile~m_vector.f90 sourcefile~m_verlet.f90->sourcefile~m_table.f90 sourcefile~m_ia_angle.f90->sourcefile~m_globals.f90 sourcefile~m_ia_angle.f90->sourcefile~m_precision.f90 sourcefile~m_ia_angle.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_bond.f90->sourcefile~m_globals.f90 sourcefile~m_ia_bond.f90->sourcefile~m_precision.f90 sourcefile~m_ia_bond.f90->sourcefile~m_strings.f90 sourcefile~m_ia_bond.f90->sourcefile~m_logger.f90 sourcefile~m_ia_bond.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_globals.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_precision.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_logger.f90 sourcefile~m_ia_vdw.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_globals.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_precision.f90 sourcefile~m_ia_dihedral.f90->sourcefile~m_constants_math.f90 sourcefile~m_ia_tether.f90->sourcefile~m_globals.f90 sourcefile~m_ia_tether.f90->sourcefile~m_precision.f90 sourcefile~m_ia_tether.f90->sourcefile~m_constants_math.f90 sourcefile~m_vector.f90->sourcefile~m_precision.f90 sourcefile~m_qsort.f90 m_qsort.f90 sourcefile~m_vector.f90->sourcefile~m_qsort.f90 sourcefile~m_table.f90->sourcefile~m_precision.f90 sourcefile~m_table.f90->sourcefile~m_vector.f90 sourcefile~m_qsort.f90->sourcefile~m_precision.f90 var pansourcefilemainf90EfferentGraph = svgPanZoom('#sourcefilemainf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs main Source Code main.f90 Source Code program main use m_precision use m_strings use m_logger , only : logger_init , logger => master_logger use m_globals , only : sim_style , job_tag use m_control_io , only : read_control use m_setup , only : setup , finish use m_relax , only : rlx_run use m_bd_solver , only : bds_run use m_mpcd , only : mpcd_run implicit none !******************************************************************************* character ( len = 64 ) :: cla character ( len = :), allocatable :: key character ( len = :), allocatable :: val character ( len = :), allocatable :: fn_control character ( len = 512 ) :: msg real ( rp ) :: t_start , t_end integer :: ierr integer :: icla integer :: ncla ! number of command line arguments, without the command name !Two command line arguments may be provided -- (i) fn_control=val and !(ii) job_tag=val fn_control = 'control.txt' ncla = command_argument_count () do icla = 1 , ncla call get_command_argument ( icla , value = cla , status = ierr ) if ( ierr > 0 ) then write ( * , '(a,1x,i0)' ) \"read failure for command argument\" , icla stop else if ( ierr == - 1 ) then write ( * , '(a,1x,i0)' ) \"command argument truncated\" , icla stop end if call str_get_keyval ( cla , key , val , '=' ) if ( key == 'fn_control' ) then fn_control = val else if ( key == 'job_tag' ) then job_tag = '.' // val end if end do !Initialize logger call logger_init ( 'brownpak.log' // trim ( adjustl ( job_tag )), stderr_threshold = 100 , & stdout_threshold = 100 , logfile_threshold = 0 ) call read_control ( fn_control ) call setup () call cpu_time ( t_start ) select case ( sim_style ) case ( 0 ) call rlx_run () case ( 1 ) call bds_run () case ( 2 ) call mpcd_run () case default continue end select call cpu_time ( t_end ) write ( msg , '(g0.6)' ) ( t_end - t_start ) call logger % info ( 'Total execution time (s)' , trim ( adjustl ( msg ))) call finish () call logger % destroy () !******************************************************************************* end program","tags":"","loc":"sourcefile/main.f90.html"},{"title":"logger – BROWNPAK ","text":"type, public :: logger Contents Variables stdout stderr fileunit logfile stderr_threshold stdout_threshold logfile_threshold Constructor logger Finalization Procedures logger_finalize Type-Bound Procedures message debug trivia info warning error fatal destroy is_open Source Code logger Components Type Visibility Attributes Name Initial integer, private :: stdout = output_unit Unit corresponding to STDOUT integer, private :: stderr = error_unit Unit corresponding to STDERR integer, private :: fileunit = closed_unit Unit corresponding to log-file character(len=:), private, allocatable :: logfile Name of the log-file integer, private :: stderr_threshold = infinity Cutoff for which messages with greater or equal priority will\n be written to STDERR. integer, private :: stdout_threshold = infinity Cutoff for which messages with greater or equal priority will\n be written to STDOUT. integer, private :: logfile_threshold = infinity Cutoff for which messages with greater or equal priority will\n be written to the log-file. Constructor public interface logger private function constructor (logfile, stderr_threshold, stdout_threshold, logfile_threshold) result(this) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: logfile Name of the log-file to which output will be written integer, intent(in), optional :: stderr_threshold Threshold priority, at and above which messages will be\n written to standard error. Defaults to error . integer, intent(in), optional :: stdout_threshold Threshold priority, at and above which messages will be\n written to standard out. Defaults to info . integer, intent(in), optional :: logfile_threshold Threshold priority, at and above which messages will be\n written to the log file. Defaults to trivia . Return Value type( logger ) Finalization Procedures final :: logger_finalize private subroutine logger_finalize (this) Arguments Type Intent Optional Attributes Name type( logger ), intent(inout) :: this Type-Bound Procedures procedure, public :: message => logger_message Write a message of a given priority to the appropriate\n location(s) private subroutine logger_message (this, source, priority, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error integer, intent(in) :: priority The importance of the message, determining where it will be\n written. character(len=*), intent(in) :: message The information to be written. procedure, public :: debug => logger_debug Write debug information private subroutine logger_debug (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. procedure, public :: trivia => logger_trivia Write trivial run-time information private subroutine logger_trivia (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. procedure, public :: info => logger_info Write run-time information private subroutine logger_info (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. procedure, public :: warning => logger_warning Write warning message private subroutine logger_warning (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. procedure, public :: error => logger_error Write error message private subroutine logger_error (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. procedure, public :: fatal => logger_fatal Write notification of fatal error private subroutine logger_fatal (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. procedure, public :: destroy => logger_destroy Closes the log-file private subroutine logger_destroy (this) Arguments Type Intent Optional Attributes Name class( logger ), intent(inout) :: this procedure, public :: is_open => logger_is_open Return .true. if the log-file is open for writing private pure function logger_is_open (this) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this Return Value logical Source Code type , public :: logger !* Author: Chris MacMackinc !  Date: December 2016 ! ! An object to handle output of information about the executing ! program to the terminal and to a log-file. ! private integer :: stdout = output_unit !! Unit corresponding to STDOUT integer :: stderr = error_unit !! Unit corresponding to STDERR integer :: fileunit = closed_unit !! Unit corresponding to log-file character ( len = :), allocatable :: logfile !! Name of the log-file integer :: stderr_threshold = infinity !! Cutoff for which messages with greater or equal priority will !! be written to STDERR. integer :: stdout_threshold = infinity !! Cutoff for which messages with greater or equal priority will !! be written to STDOUT. integer :: logfile_threshold = infinity !! Cutoff for which messages with greater or equal priority will !! be written to the log-file. contains procedure :: message => logger_message !! Write a message of a given priority to the appropriate !! location(s) procedure :: debug => logger_debug !! Write debug information procedure :: trivia => logger_trivia !! Write trivial run-time information procedure :: info => logger_info !! Write run-time information procedure :: warning => logger_warning !! Write warning message procedure :: error => logger_error !! Write error message procedure :: fatal => logger_fatal !! Write notification of fatal error procedure :: destroy => logger_destroy !! Closes the log-file procedure :: is_open => logger_is_open !! Return `.true.` if the log-file is open for writing final :: logger_finalize end type logger","tags":"","loc":"type/logger.html"},{"title":"smbx_t – BROWNPAK ","text":"type, public :: smbx_t Contents Variables basis dl_basis volume is_deforming is_aligned Type-Bound Procedures set_basis freeze unfreeze get_image wrap_all to_center get_rnd_points Source Code smbx_t Components Type Visibility Attributes Name Initial real(kind=rp), public, dimension(3,3) :: basis real(kind=rp), public, dimension(3,3) :: dl_basis real(kind=rp), public :: volume logical, public :: is_deforming logical, public :: is_aligned Whether the basis vectors are aligned with the laboratory frame Type-Bound Procedures procedure, public :: set_basis => smbx_set_basis public subroutine smbx_set_basis (this, bv) Sets all three basis vectors. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(3,3) :: bv procedure, public :: freeze => smbx_freeze public subroutine smbx_freeze (this) Specifies this as non-deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this procedure, public :: unfreeze => smbx_unfreeze public subroutine smbx_unfreeze (this) Specifies this as deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this procedure, public :: get_image => smbx_get_image public subroutine smbx_get_image (this, r) Returns the image of r under PBC. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(3) :: r procedure, public :: wrap_all => smbx_wrap_all public subroutine smbx_wrap_all (this, coords) Wraps atom positions w.r.t. periodic boundary conditions. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords procedure, public :: to_center => smbx_to_center public subroutine smbx_to_center (this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the center \n of the box. Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com procedure, public :: get_rnd_points => smbx_get_rnd_points public subroutine smbx_get_rnd_points (this, coords) Returns uniformly distributed points within the box. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(out), dimension(:,:) :: coords Source Code type smbx_t real ( rp ), dimension ( 3 , 3 ) :: basis real ( rp ), dimension ( 3 , 3 ) :: dl_basis real ( rp ) :: volume logical :: is_deforming logical :: is_aligned !! Whether the basis vectors are aligned with the laboratory frame contains procedure :: set_basis => smbx_set_basis procedure :: freeze => smbx_freeze procedure :: unfreeze => smbx_unfreeze procedure :: get_image => smbx_get_image procedure :: wrap_all => smbx_wrap_all procedure :: to_center => smbx_to_center procedure :: get_rnd_points => smbx_get_rnd_points end type smbx_t","tags":"","loc":"type/smbx_t.html"},{"title":"itable_t – BROWNPAK ","text":"type, public :: itable_t Inherits type~~itable_t~~InheritsGraph type~itable_t itable_t type~ivector_t ivector_t type~itable_t->type~ivector_t buffer Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables num_rows buffer row_indx Type-Bound Procedures delete clear append set_val is_in get_val get_row shrink_to_fit print Source Code itable_t Components Type Visibility Attributes Name Initial integer, public :: num_rows = 0 type( ivector_t ), public :: buffer integer, public, dimension(:), allocatable :: row_indx Type-Bound Procedures procedure, public :: delete => itbl_delete private subroutine itbl_delete (this) Deletes an itable_t . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this procedure, public :: clear => itbl_clear private subroutine itbl_clear (this) Clears all rows. Does not deallocate memory. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this procedure, public :: append => itbl_append private subroutine itbl_append (this, irow, val) Appends an element val to row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: val procedure, public :: set_val => itbl_set_val private subroutine itbl_set_val (this, irow, j, val) Sets the value of the j th element of row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: j integer, intent(in) :: val procedure, public :: is_in => itbl_is_in private function itbl_is_in (this, irow, val) result(res) Returns .true. if val is in row irow , .false. otherwise. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: val Return Value logical procedure, public :: get_val => itbl_get_val private function itbl_get_val (this, irow, j) result(res) Returns the j th element of row irow Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: j Return Value integer procedure, public :: get_row => itbl_get_row private subroutine itbl_get_row (this, irow, res) Returns a pointer to the row data of irow . No bounds checking is performed. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in), target :: this integer, intent(in) :: irow integer, intent(out), dimension(:), pointer :: res procedure, public :: shrink_to_fit => itbl_shrink_to_fit private subroutine itbl_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(out), optional :: ierr procedure, public :: print => itbl_print private subroutine itbl_print (this) Prints an itable_t . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this Source Code type itable_t integer :: num_rows = 0 !Must be > 0 type ( ivector_t ) :: buffer integer , dimension (:), allocatable :: row_indx contains procedure :: delete => itbl_delete procedure :: clear => itbl_clear procedure :: append => itbl_append procedure :: set_val => itbl_set_val procedure :: is_in => itbl_is_in procedure :: get_val => itbl_get_val procedure :: get_row => itbl_get_row procedure :: shrink_to_fit => itbl_shrink_to_fit procedure :: print => itbl_print end type itable_t","tags":"","loc":"type/itable_t.html"},{"title":"trajectory_t – BROWNPAK ","text":"type, public :: trajectory_t Contents Variables header_size frame_size num_atoms num_mpcd_atoms num_atoms_tot frmcmp fn file_id num_frames isopen Type-Bound Procedures create open clear close read append_frame write_frame init Source Code trajectory_t Components Type Visibility Attributes Name Initial integer, public :: header_size = 0 integer, public :: frame_size = 0 integer, public :: num_atoms = 0 integer, public :: num_mpcd_atoms = 0 integer, public :: num_atoms_tot = 0 integer, public, dimension(4) :: frmcmp = 0 character(len=:), public, allocatable :: fn integer, public :: file_id = 0 integer, public :: num_frames = 0 logical, public :: isopen = .false. Type-Bound Procedures procedure, public :: create => traj_create public subroutine traj_create (this, fn, na, nam, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of non-MPCD atoms integer, intent(in) :: nam Number of MPCD atoms, pass zero to indicate no data from MPCD\n particles are present. integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges procedure, public :: open => traj_open public subroutine traj_open (this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr procedure, public :: clear => traj_clear public subroutine traj_clear (this) After a call to this subroutine, all memory within this is deallocated,\n all components of this are reset to zero, and the underlying file is\n closed (if open). Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this procedure, public :: close => traj_close public subroutine traj_close (this) Closes the underlying file of a trajectory_t . Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this procedure, public :: read => traj_read public subroutine traj_read (this, iframe, nts, ierr, mflag, coordinates, velocities, forces, charge) Read from an open trajectory. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(in) :: this integer, intent(in) :: iframe Frame number integer(kind=ip_long), intent(out) :: nts Time step counter integer, intent(out) :: ierr Error flag integer, intent(in), optional :: mflag 1: Only non-MPCD data, 2: Only MPCD data, 3: All data real(kind=rp), intent(out), optional dimension(:,:) :: coordinates real(kind=rp), intent(out), optional dimension(:,:) :: velocities real(kind=rp), intent(out), optional dimension(:,:) :: forces real(kind=rp), intent(out), optional dimension(:) :: charge procedure, public :: append_frame => traj_append_frame public subroutine traj_append_frame (this, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge procedure, public :: write_frame => traj_write_frame public subroutine traj_write_frame (this, iframe, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer, intent(in) :: iframe integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge generic, public :: init => create , open public subroutine traj_create (this, fn, na, nam, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of non-MPCD atoms integer, intent(in) :: nam Number of MPCD atoms, pass zero to indicate no data from MPCD\n particles are present. integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges public subroutine traj_open (this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr Source Code type trajectory_t integer :: header_size = 0 integer :: frame_size = 0 integer :: num_atoms = 0 integer :: num_mpcd_atoms = 0 integer :: num_atoms_tot = 0 integer , dimension ( 4 ) :: frmcmp = 0 character ( len = :), allocatable :: fn integer :: file_id = 0 integer :: num_frames = 0 logical :: isopen = . false . contains procedure :: create => traj_create procedure :: open => traj_open procedure :: clear => traj_clear procedure :: close => traj_close procedure :: read => traj_read procedure :: append_frame => traj_append_frame procedure :: write_frame => traj_write_frame generic :: init => create , open end type trajectory_t","tags":"","loc":"type/trajectory_t.html"},{"title":"ivector_t – BROWNPAK ","text":"type, public :: ivector_t Inherited by type~~ivector_t~~InheritedByGraph type~ivector_t ivector_t type~itable_t itable_t type~itable_t->type~ivector_t buffer Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables len_init len len_max buffer Type-Bound Procedures delete clear get_val set_val get_data append shrink_to_fit sort unique print Source Code ivector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 integer, public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => ivector_delete public subroutine ivector_delete (this) Deletes an ivector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this procedure, public :: clear => ivector_clear public subroutine ivector_clear (this) Clears an ivector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this procedure, public :: get_val => ivector_get_val public function ivector_get_val (this, i) result(res) Returns the ith element of an ivector . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this integer, intent(in) :: i Return Value integer procedure, public :: set_val => ivector_set_val public subroutine ivector_set_val (this, i, val) Sets the value of the ith element of an ivector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: val procedure, public :: get_data => ivector_get_data public subroutine ivector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in), target :: this integer, intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend procedure, public :: append => ivector_append public subroutine ivector_append (this, val) Adds an element to the end of an ivector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: val procedure, public :: shrink_to_fit => ivector_shrink_to_fit public subroutine ivector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of an ivector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional :: ierr procedure, public :: sort => ivector_sort public subroutine ivector_sort (this, order) Sorts an ivector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order procedure, public :: unique => ivector_unique public subroutine ivector_unique (this) Sorts and removes all duplicate entries of an ivector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call ivector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this procedure, public :: print => ivector_print public subroutine ivector_print (this) Prints an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Source Code type ivector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init integer , dimension (:), allocatable :: buffer contains procedure :: delete => ivector_delete procedure :: clear => ivector_clear procedure :: get_val => ivector_get_val procedure :: set_val => ivector_set_val procedure :: get_data => ivector_get_data procedure :: append => ivector_append procedure :: shrink_to_fit => ivector_shrink_to_fit procedure :: sort => ivector_sort procedure :: unique => ivector_unique procedure :: print => ivector_print end type ivector_t","tags":"","loc":"type/ivector_t.html"},{"title":"dvector_t – BROWNPAK ","text":"type, public :: dvector_t Contents Variables len_init len len_max buffer Type-Bound Procedures delete clear get_val set_val get_data append shrink_to_fit sort unique print Source Code dvector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 real(kind=rp), public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => dvector_delete public subroutine dvector_delete (this) Deletes a dvector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this procedure, public :: clear => dvector_clear public subroutine dvector_clear (this) Clears a dvector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this procedure, public :: get_val => dvector_get_val public function dvector_get_val (this, i) result(res) Returns the ith element of a dvector . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rp) procedure, public :: set_val => dvector_set_val public subroutine dvector_set_val (this, i, val) Sets the value of the ith element of a dvector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: i real(kind=rp), intent(in) :: val procedure, public :: get_data => dvector_get_data public subroutine dvector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in), target :: this real(kind=rp), intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend procedure, public :: append => dvector_append public subroutine dvector_append (this, val) Adds an element to the end of a dvector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this real(kind=rp), intent(in) :: val procedure, public :: shrink_to_fit => dvector_shrink_to_fit public subroutine dvector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of a dvector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional :: ierr procedure, public :: sort => dvector_sort public subroutine dvector_sort (this, order) Sorts a dvector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order procedure, public :: unique => dvector_unique public subroutine dvector_unique (this) Sorts and removes all duplicate entries of a dvector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call dvector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this procedure, public :: print => dvector_print public subroutine dvector_print (this) Prints a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Source Code type dvector_t integer :: len_init = 8 !Must be > 0 integer :: len = 0 integer :: len_max = 16 !Must be > len_init real ( rp ), dimension (:), allocatable :: buffer contains procedure :: delete => dvector_delete procedure :: clear => dvector_clear procedure :: get_val => dvector_get_val procedure :: set_val => dvector_set_val procedure :: get_data => dvector_get_data procedure :: append => dvector_append procedure :: shrink_to_fit => dvector_shrink_to_fit procedure :: sort => dvector_sort procedure :: unique => dvector_unique procedure :: print => dvector_print end type dvector_t","tags":"","loc":"type/dvector_t.html"},{"title":"bds_init – BROWNPAK","text":"public subroutine bds_init(ierr) Initializes the BD solver. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Called by proc~~bds_init~~CalledByGraph proc~bds_init bds_init proc~setup setup proc~setup->proc~bds_init program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bds_init.html"},{"title":"bds_finish – BROWNPAK","text":"public subroutine bds_finish() Clears up memory allocated in bds_init . Arguments None Called by proc~~bds_finish~~CalledByGraph proc~bds_finish bds_finish proc~finish finish proc~finish->proc~bds_finish program~main main program~main->proc~finish Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bds_finish.html"},{"title":"bds_run – BROWNPAK","text":"public subroutine bds_run() Driver for BD integrator. Repeatedly calls bds_integrate_fd or bds_integrate_hi to update\n atom positions. Arguments None Calls proc~~bds_run~~CallsGraph proc~bds_run bds_run proc~bds_integrate_fd bds_integrate_fd proc~bds_run->proc~bds_integrate_fd proc~stats_finish stats_finish proc~bds_run->proc~stats_finish proc~bds_integrate_hi bds_integrate_hi proc~bds_run->proc~bds_integrate_hi proc~stats_write stats_write proc~bds_run->proc~stats_write interface~str_from_num str_from_num proc~bds_run->interface~str_from_num proc~ia_calc_forces ia_calc_forces proc~bds_integrate_fd->proc~ia_calc_forces proc~calc_ambient_velocity calc_ambient_velocity proc~bds_integrate_fd->proc~calc_ambient_velocity proc~get_rv_gaussian get_rv_gaussian proc~bds_integrate_fd->proc~get_rv_gaussian proc~bds_integrate_hi->interface~str_from_num trmv trmv proc~bds_integrate_hi->trmv proc~bds_integrate_hi->proc~ia_calc_forces potrf potrf proc~bds_integrate_hi->potrf proc~bds_integrate_hi->proc~calc_ambient_velocity symv symv proc~bds_integrate_hi->symv proc~calc_bdw_kryl calc_Bdw_kryl proc~bds_integrate_hi->proc~calc_bdw_kryl proc~bds_integrate_hi->proc~get_rv_gaussian proc~calc_rpy_tensor calc_rpy_tensor proc~bds_integrate_hi->proc~calc_rpy_tensor proc~stats_compute_ic1 stats_compute_ic1 proc~stats_write->proc~stats_compute_ic1 proc~stats_compute_ic0 stats_compute_ic0 proc~stats_write->proc~stats_compute_ic0 proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian proc~dsyevc3 dsyevc3 proc~stats_compute_ic0->proc~dsyevc3 proc~cl_get_contents cl_get_contents proc~ia_add_vdw_forces_cl->proc~cl_get_contents proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_cl->proc~ia_get_vdw_force proc~cl_get_num_cells cl_get_num_cells proc~ia_add_vdw_forces_cl->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~ia_add_vdw_forces_cl->proc~cl_get_nbr_cells proc~verlet_build verlet_build proc~ia_add_vdw_forces_vl->proc~verlet_build proc~ia_add_vdw_forces_vl->proc~ia_get_vdw_force proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bds_run~~CalledByGraph proc~bds_run bds_run program~main main program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bds_run.html"},{"title":"bds_integrate_fd – BROWNPAK","text":"private subroutine bds_integrate_fd(ierr) Performs one step of free-draining BD integeration. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~bds_integrate_fd~~CallsGraph proc~bds_integrate_fd bds_integrate_fd proc~get_rv_gaussian get_rv_gaussian proc~bds_integrate_fd->proc~get_rv_gaussian proc~ia_calc_forces ia_calc_forces proc~bds_integrate_fd->proc~ia_calc_forces proc~calc_ambient_velocity calc_ambient_velocity proc~bds_integrate_fd->proc~calc_ambient_velocity vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~cl_get_contents cl_get_contents proc~ia_add_vdw_forces_cl->proc~cl_get_contents proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_cl->proc~ia_get_vdw_force proc~cl_get_num_cells cl_get_num_cells proc~ia_add_vdw_forces_cl->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~ia_add_vdw_forces_cl->proc~cl_get_nbr_cells proc~verlet_build verlet_build proc~ia_add_vdw_forces_vl->proc~verlet_build proc~ia_add_vdw_forces_vl->proc~ia_get_vdw_force proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bds_integrate_fd~~CalledByGraph proc~bds_integrate_fd bds_integrate_fd proc~bds_run bds_run proc~bds_run->proc~bds_integrate_fd program~main main program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bds_integrate_fd.html"},{"title":"bds_integrate_hi – BROWNPAK","text":"private subroutine bds_integrate_hi(ierr) Performs one step of BD integeration including HI. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~bds_integrate_hi~~CallsGraph proc~bds_integrate_hi bds_integrate_hi trmv trmv proc~bds_integrate_hi->trmv proc~ia_calc_forces ia_calc_forces proc~bds_integrate_hi->proc~ia_calc_forces potrf potrf proc~bds_integrate_hi->potrf proc~calc_ambient_velocity calc_ambient_velocity proc~bds_integrate_hi->proc~calc_ambient_velocity symv symv proc~bds_integrate_hi->symv proc~calc_bdw_kryl calc_Bdw_kryl proc~bds_integrate_hi->proc~calc_bdw_kryl proc~get_rv_gaussian get_rv_gaussian proc~bds_integrate_hi->proc~get_rv_gaussian proc~calc_rpy_tensor calc_rpy_tensor proc~bds_integrate_hi->proc~calc_rpy_tensor interface~str_from_num str_from_num proc~bds_integrate_hi->interface~str_from_num proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~cl_get_contents cl_get_contents proc~ia_add_vdw_forces_cl->proc~cl_get_contents proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_cl->proc~ia_get_vdw_force proc~cl_get_num_cells cl_get_num_cells proc~ia_add_vdw_forces_cl->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~ia_add_vdw_forces_cl->proc~cl_get_nbr_cells proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero proc~verlet_build verlet_build proc~ia_add_vdw_forces_vl->proc~verlet_build proc~ia_add_vdw_forces_vl->proc~ia_get_vdw_force proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bds_integrate_hi~~CalledByGraph proc~bds_integrate_hi bds_integrate_hi proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi program~main main program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bds_integrate_hi.html"},{"title":"calc_ambient_velocity – BROWNPAK","text":"private subroutine calc_ambient_velocity() Calculates ambient velocity at the atom positions and store it in module\n variable drift . Arguments None Called by proc~~calc_ambient_velocity~~CalledByGraph proc~calc_ambient_velocity calc_ambient_velocity proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~calc_ambient_velocity proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~calc_ambient_velocity proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd program~main main program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/calc_ambient_velocity.html"},{"title":"calc_rpy_tensor – BROWNPAK","text":"private subroutine calc_rpy_tensor() Calculates the RPY approximation to the mobility tensor. Overwrites\n the upper triangular part of mobility . Arguments None Called by proc~~calc_rpy_tensor~~CalledByGraph proc~calc_rpy_tensor calc_rpy_tensor proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~calc_rpy_tensor proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi program~main main program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/calc_rpy_tensor.html"},{"title":"calc_Bdw_kryl – BROWNPAK","text":"private subroutine calc_Bdw_kryl(D, Bdw, ierr) Calculates B.dW using Krylov subspace method. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: D (3N,3N) symmetric positive definite matrix. Diffusivity matrix. Only the upper triangular part of the matrix is used. real(kind=rp), intent(inout), dimension(:) :: Bdw (3N,) vector. On entry contains vector dW . On return, contains B.dW , where B is the square root matrix of D . integer, intent(out) :: ierr Error flag Called by proc~~calc_bdw_kryl~~CalledByGraph proc~calc_bdw_kryl calc_Bdw_kryl proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~calc_bdw_kryl proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi program~main main program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/calc_bdw_kryl.html"},{"title":"cl_get_num_cells – BROWNPAK","text":"public function cl_get_num_cells() result(res) Returns the total number of cells Arguments None Return Value integer Called by proc~~cl_get_num_cells~~CalledByGraph proc~cl_get_num_cells cl_get_num_cells proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_add_vdw_forces_cl->proc~cl_get_num_cells proc~mpcd_collide mpcd_collide proc~mpcd_collide->proc~cl_get_num_cells proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_collide proc~mpcd_stream mpcd_stream proc~mpcd_run->proc~mpcd_stream proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~mpcd_stream->proc~ia_calc_forces program~main main program~main->proc~mpcd_run proc~bds_run bds_run program~main->proc~bds_run proc~rlx_run rlx_run program~main->proc~rlx_run proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~bds_run->proc~bds_integrate_fd proc~bds_run->proc~bds_integrate_hi proc~rlx_run->proc~rlx_integrate var panproccl_get_num_cellsCalledByGraph = svgPanZoom('#proccl_get_num_cellsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_get_num_cells.html"},{"title":"cl_init – BROWNPAK","text":"public subroutine cl_init(na_max, cs_min) Initializes a cell list. Arguments Type Intent Optional Attributes Name integer, intent(in) :: na_max Maximum number of atoms to be handled. real(kind=rp), intent(in) :: cs_min Minimum size (i.e. length) of a cell. Calls proc~~cl_init~~CallsGraph proc~cl_init cl_init proc~ivector_init ivector_init proc~cl_init->proc~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cl_init~~CalledByGraph proc~cl_init cl_init proc~ia_setup ia_setup proc~ia_setup->proc~cl_init proc~setup setup proc~setup->proc~ia_setup program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_init.html"},{"title":"cl_set_cell_size – BROWNPAK","text":"public subroutine cl_set_cell_size(cs) Sets the cell size. The actual cell size may be slightly larger. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: cs Called by proc~~cl_set_cell_size~~CalledByGraph proc~cl_set_cell_size cl_set_cell_size proc~ia_setup ia_setup proc~ia_setup->proc~cl_set_cell_size proc~mpcd_collide mpcd_collide proc~mpcd_collide->proc~cl_set_cell_size proc~setup setup proc~setup->proc~ia_setup proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_collide program~main main program~main->proc~setup program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_set_cell_size.html"},{"title":"cl_build_cell_nbrs – BROWNPAK","text":"public subroutine cl_build_cell_nbrs() Makes a table of neighboring cells. Arguments None Called by proc~~cl_build_cell_nbrs~~CalledByGraph proc~cl_build_cell_nbrs cl_build_cell_nbrs proc~ia_setup ia_setup proc~ia_setup->proc~cl_build_cell_nbrs proc~setup setup proc~setup->proc~ia_setup program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_build_cell_nbrs.html"},{"title":"cl_delete – BROWNPAK","text":"public subroutine cl_delete() Deallocates memory allocated in cl_init . Arguments None Contents None","tags":"","loc":"proc/cl_delete.html"},{"title":"cl_build – BROWNPAK","text":"public subroutine cl_build(coords) Sorts atoms into cells for calculating short-range interations Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: coords Called by proc~~cl_build~~CalledByGraph proc~cl_build cl_build proc~mpcd_collide mpcd_collide proc~mpcd_collide->proc~cl_build proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_collide program~main main program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_build.html"},{"title":"cl_get_contents – BROWNPAK","text":"public subroutine cl_get_contents(ic, res) Returns a pointer to the entries of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res Called by proc~~cl_get_contents~~CalledByGraph proc~cl_get_contents cl_get_contents proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_add_vdw_forces_cl->proc~cl_get_contents proc~cl_print cl_print proc~cl_print->proc~cl_get_contents proc~mpcd_collide mpcd_collide proc~mpcd_collide->proc~cl_get_contents proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_collide proc~mpcd_stream mpcd_stream proc~mpcd_run->proc~mpcd_stream proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~mpcd_stream->proc~ia_calc_forces program~main main program~main->proc~mpcd_run proc~bds_run bds_run program~main->proc~bds_run proc~rlx_run rlx_run program~main->proc~rlx_run proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~bds_run->proc~bds_integrate_fd proc~bds_run->proc~bds_integrate_hi proc~rlx_run->proc~rlx_integrate var panproccl_get_contentsCalledByGraph = svgPanZoom('#proccl_get_contentsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_get_contents.html"},{"title":"cl_get_nbr_cells – BROWNPAK","text":"public subroutine cl_get_nbr_cells(ic, res) Returns a pointer to the neighbor cells of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res Called by proc~~cl_get_nbr_cells~~CalledByGraph proc~cl_get_nbr_cells cl_get_nbr_cells proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_add_vdw_forces_cl->proc~cl_get_nbr_cells proc~cl_print cl_print proc~cl_print->proc~cl_get_nbr_cells proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run var panproccl_get_nbr_cellsCalledByGraph = svgPanZoom('#proccl_get_nbr_cellsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_get_nbr_cells.html"},{"title":"cl_print – BROWNPAK","text":"public subroutine cl_print() Prints a cell list Arguments None Calls proc~~cl_print~~CallsGraph proc~cl_print cl_print proc~cl_get_contents cl_get_contents proc~cl_print->proc~cl_get_contents proc~cl_get_nbr_cells cl_get_nbr_cells proc~cl_print->proc~cl_get_nbr_cells Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cl_print.html"},{"title":"read_dump – BROWNPAK","text":"public subroutine read_dump(fn) Reads from DUMP file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Contents None","tags":"","loc":"proc/read_dump.html"},{"title":"write_dump – BROWNPAK","text":"public subroutine write_dump(fn) Writes to DUMP file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Contents None","tags":"","loc":"proc/write_dump.html"},{"title":"read_config – BROWNPAK","text":"public subroutine read_config(fn) Read from CONFIG file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Calls proc~~read_config~~CallsGraph proc~read_config read_config proc~str_split str_split proc~read_config->proc~str_split proc~str_startswith str_startswith proc~read_config->proc~str_startswith proc~readline readline proc~read_config->proc~readline proc~str_to_i str_to_i proc~read_config->proc~str_to_i proc~str_compact str_compact proc~str_split->proc~str_compact proc~str_is_comment str_is_comment proc~readline->proc~str_is_comment proc~str_strip_comment str_strip_comment proc~readline->proc~str_strip_comment Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/read_config.html"},{"title":"write_config – BROWNPAK","text":"public subroutine write_config(fn, title) Write to cfg file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn character(len=*), intent(in) :: title Called by proc~~write_config~~CalledByGraph proc~write_config write_config proc~rlx_run rlx_run proc~rlx_run->proc~write_config program~main main program~main->proc~rlx_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/write_config.html"},{"title":"write_ldf – BROWNPAK","text":"public subroutine write_ldf(fn_ld, title, with_mpcd_atoms) Write to a LAMMPS data file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn_ld Name of the file character(len=*), intent(in) :: title Title of the configuation logical, intent(in), optional :: with_mpcd_atoms Include MPCD atoms in the file? {T, F} Called by proc~~write_ldf~~CalledByGraph proc~write_ldf write_ldf proc~rlx_run rlx_run proc~rlx_run->proc~write_ldf program~main main program~main->proc~rlx_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/write_ldf.html"},{"title":"write_xyz – BROWNPAK","text":"public subroutine write_xyz(fn_xyz, title, with_mpcd_atoms) Write to an XYZ file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn_xyz Name of the XYZ file character(len=*), intent(in) :: title Title (for the configuration) logical, intent(in), optional :: with_mpcd_atoms Include MPCD atoms in the file? {T, F} Contents None","tags":"","loc":"proc/write_xyz.html"},{"title":"atbo_build – BROWNPAK","text":"public subroutine atbo_build() Arguments None Calls proc~~atbo_build~~CallsGraph proc~atbo_build atbo_build proc~itbl_init itbl_init proc~atbo_build->proc~itbl_init proc~ivector_init ivector_init proc~itbl_init->proc~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~atbo_build~~CalledByGraph proc~atbo_build atbo_build proc~ia_setup ia_setup proc~ia_setup->proc~atbo_build proc~setup setup proc~setup->proc~ia_setup program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/atbo_build.html"},{"title":"atan_build – BROWNPAK","text":"public subroutine atan_build() Arguments None Calls proc~~atan_build~~CallsGraph proc~atan_build atan_build proc~itbl_init itbl_init proc~atan_build->proc~itbl_init proc~ivector_init ivector_init proc~itbl_init->proc~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/atan_build.html"},{"title":"atdh_build – BROWNPAK","text":"public subroutine atdh_build() Arguments None Calls proc~~atdh_build~~CallsGraph proc~atdh_build atdh_build proc~itbl_init itbl_init proc~atdh_build->proc~itbl_init proc~ivector_init ivector_init proc~itbl_init->proc~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/atdh_build.html"},{"title":"atat_build – BROWNPAK","text":"private subroutine atat_build() Arguments None Calls proc~~atat_build~~CallsGraph proc~atat_build atat_build proc~itbl_init itbl_init proc~atat_build->proc~itbl_init proc~ivector_init ivector_init proc~atat_build->proc~ivector_init proc~itbl_init->proc~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~atat_build~~CalledByGraph proc~atat_build atat_build proc~exat_build exat_build proc~exat_build->proc~atat_build proc~ia_setup ia_setup proc~ia_setup->proc~exat_build proc~setup setup proc~setup->proc~ia_setup program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/atat_build.html"},{"title":"exat_build – BROWNPAK","text":"public subroutine exat_build() Arguments None Calls proc~~exat_build~~CallsGraph proc~exat_build exat_build proc~atat_build atat_build proc~exat_build->proc~atat_build proc~itbl_init itbl_init proc~exat_build->proc~itbl_init proc~ivector_init ivector_init proc~exat_build->proc~ivector_init proc~atat_build->proc~itbl_init proc~atat_build->proc~ivector_init proc~itbl_init->proc~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~exat_build~~CalledByGraph proc~exat_build exat_build proc~ia_setup ia_setup proc~ia_setup->proc~exat_build proc~setup setup proc~setup->proc~ia_setup program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/exat_build.html"},{"title":"read_control – BROWNPAK","text":"public subroutine read_control(fn) Reads simulation parameters from file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Name of parameters file. Calls proc~~read_control~~CallsGraph proc~read_control read_control proc~str_get_keyval str_get_keyval proc~read_control->proc~str_get_keyval proc~str_to_d str_to_d proc~read_control->proc~str_to_d proc~str_to_i str_to_i proc~read_control->proc~str_to_i proc~readline readline proc~read_control->proc~readline proc~str_is_comment str_is_comment proc~readline->proc~str_is_comment proc~str_strip_comment str_strip_comment proc~readline->proc~str_strip_comment Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_control~~CalledByGraph proc~read_control read_control program~main main program~main->proc~read_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/read_control.html"},{"title":"write_control – BROWNPAK","text":"public subroutine write_control(fn) Write simulation parameters to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn File name Contents None","tags":"","loc":"proc/write_control.html"},{"title":"ia_angle_setup – BROWNPAK","text":"public subroutine ia_angle_setup() Sets up parameters for angle potentials Arguments None Contents None","tags":"","loc":"proc/ia_angle_setup.html"},{"title":"ia_get_angle_force – BROWNPAK","text":"public subroutine ia_get_angle_force(q1, q2, typ, enrg, fim1, fi, fip1) Calculates the energy & force due to an angle. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 integer, intent(in) :: typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fim1 real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fip1 Called by proc~~ia_get_angle_force~~CalledByGraph proc~ia_get_angle_force ia_get_angle_force proc~ia_add_angle_forces ia_add_angle_forces proc~ia_add_angle_forces->proc~ia_get_angle_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_get_angle_force.html"},{"title":"ang_cos_set – BROWNPAK","text":"private subroutine ang_cos_set(params, k) Setter for angular cosine interaction. U ( theta ) = k * ( 1 - cos theta ), where theta is the complementary angle between bonds i & ( i + 1 ). User-set parameters: params(1) = k Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k Contents None","tags":"","loc":"proc/ang_cos_set.html"},{"title":"ia_bond_setup – BROWNPAK","text":"public subroutine ia_bond_setup() Sets up parameters for bond potentials Arguments None Contents None","tags":"","loc":"proc/ia_bond_setup.html"},{"title":"ia_get_bond_force – BROWNPAK","text":"public subroutine ia_get_bond_force(rij_mag, bnd_typ, enrg, frc, ierr) Calculates the energy & its derivative due to a bond. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between bonded atoms integer, intent(in) :: bnd_typ Type of the bond real(kind=rp), intent(out) :: enrg Bond energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of the force due\n to this potential. integer, intent(out) :: ierr Error flag Called by proc~~ia_get_bond_force~~CalledByGraph proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces ia_add_bond_forces proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run var panprocia_get_bond_forceCalledByGraph = svgPanZoom('#procia_get_bond_forceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_get_bond_force.html"},{"title":"bond_harm_set – BROWNPAK","text":"private subroutine bond_harm_set(params, k, r0) Setter for harmonic bond interaction. U = ( 1 / 2 ) * k * ( r - r0 ) &#94; 2 User-set parameters: params(1) = k (spring constant) params(2) = r0 (equilibrium distance) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 Contents None","tags":"","loc":"proc/bond_harm_set.html"},{"title":"bond_harm – BROWNPAK","text":"private subroutine bond_harm(r, params, enrg, frc) Calculates energy & its derivative for harmonic bond. See bond_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/bond_harm.html"},{"title":"bond_fene_set – BROWNPAK","text":"private subroutine bond_fene_set(params, k, rmax, r0) Setter for FENE bond. U = - 0 . 5 k rmax &#94; 2 log [ 1 - (( r - r0 ) / rmax ) &#94; 2 ] User-set parameters: params(1) = k params(2) = rmax params(3) = r0 Note The bond cannot extend beyond (rmax+r0), where r0 is the\n equilibrium bond length. If r0 = 0, this reduces to the standard definition\n of FENE bonds. Internally stored parameters: params(4) = rmax&#94;2 Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: r0 Contents None","tags":"","loc":"proc/bond_fene_set.html"},{"title":"bond_fene – BROWNPAK","text":"private subroutine bond_fene(r, params, enrg, frc, ierr) Calculates energy & its derivative for FENE bond. See bond_fene_set . If bond length exceeds maximum extensible spring length, an error will be\n reported by ierr = 1 . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Calls proc~~bond_fene~~CallsGraph proc~bond_fene bond_fene interface~str_from_num str_from_num proc~bond_fene->interface~str_from_num proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bond_fene.html"},{"title":"bond_kg_set – BROWNPAK","text":"private subroutine bond_kg_set(params, k, rmax, eps, sigma) Setter for FENE bond interaction. V = 4 * eps * [( r / sigma ) &#94; 12 - ( r / sigma ) &#94; 6 ] + eps W = - 0 . 5 k rmax &#94; 2 log [ 1 - ( r / rmax ) &#94; 2 ] U = W + V , r < 2 &#94; ( 1 / 6 ) * sigma W , r >= 2 &#94; ( 1 / 6 ) * sigma User-set parameters: params(1) = k params(2) = rmax params(3) = eps params(4) = sigma Internally stored parameters: params(5) = rmax&#94;2 params(6) = 2&#94;(1/6)*sigma Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma Contents None","tags":"","loc":"proc/bond_kg_set.html"},{"title":"bond_kg – BROWNPAK","text":"private subroutine bond_kg(r, params, enrg, frc, ierr) Calculates energy & its derivative for Kremer-Grest bond. See bond_kg_set . If bond length exceeds maximum extensible spring length, an error will be\n reported as ierr = 1 . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Calls proc~~bond_kg~~CallsGraph proc~bond_kg bond_kg interface~str_from_num str_from_num proc~bond_kg->interface~str_from_num proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bond_kg.html"},{"title":"bond_ms_set – BROWNPAK","text":"private subroutine bond_ms_set(params, lp, rmax) Setter for Marko-Siggia bond. U = [ - ( 1 / 2 ) * rtilde &#94; 2 + 0 . 25 / ( 1 - rtilde ) &#94; 2 + 0 . 25 * rtilde ] * ( rmax / lp ), r < rmax where rtilde = r / rmax . User-set parameters: params(1) = lp (persistence length) params(2) = rmax Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: lp real(kind=rp), intent(in), optional :: rmax Contents None","tags":"","loc":"proc/bond_ms_set.html"},{"title":"bond_ms – BROWNPAK","text":"private subroutine bond_ms(r, params, enrg, frc, ierr) Evaluates the potential & its derivative for Marko-Siggia bond.\n See bond_ms_set . If bond length exceeds maximum extensible spring length, an error will be\n reported as ierr = 1 . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Calls proc~~bond_ms~~CallsGraph proc~bond_ms bond_ms interface~str_from_num str_from_num proc~bond_ms->interface~str_from_num proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bond_ms.html"},{"title":"ia_dihedral_setup – BROWNPAK","text":"public subroutine ia_dihedral_setup() Sets up parameters for dihedral potentials Arguments None Contents None","tags":"","loc":"proc/ia_dihedral_setup.html"},{"title":"ia_get_dihedral_force – BROWNPAK","text":"public subroutine ia_get_dihedral_force(q1, q2, q3, typ, enrg, fi, fj, fk, fl) Calculates the force & energy due to a dihedral. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 real(kind=rp), intent(in), dimension(3) :: q3 integer, intent(in) :: typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fj real(kind=rp), intent(out), dimension(3) :: fk real(kind=rp), intent(out), dimension(3) :: fl Called by proc~~ia_get_dihedral_force~~CalledByGraph proc~ia_get_dihedral_force ia_get_dihedral_force proc~ia_add_dihedral_forces ia_add_dihedral_forces proc~ia_add_dihedral_forces->proc~ia_get_dihedral_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_get_dihedral_force.html"},{"title":"ia_external_setup – BROWNPAK","text":"public subroutine ia_external_setup() Sets up parameters for external potentials. Usually there is nothing to\n set for externals, but this acts as a placeholder for special cases. Arguments None Contents None","tags":"","loc":"proc/ia_external_setup.html"},{"title":"ia_add_external_forces – BROWNPAK","text":"public subroutine ia_add_external_forces(ierr) Calculates the force and energy due to an external field and adds to energy_external , 'forces , & stress in module m_globals`. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Called by proc~~ia_add_external_forces~~CalledByGraph proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_external_forces.html"},{"title":"ia_tether_setup – BROWNPAK","text":"public subroutine ia_tether_setup() Sets up parameters for tether potentials Arguments None Contents None","tags":"","loc":"proc/ia_tether_setup.html"},{"title":"ia_get_tether_force – BROWNPAK","text":"public subroutine ia_get_tether_force(qmag, teth_typ, enrg, frc, ierr) Calculates the energy and its derivative due to a tether. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: qmag Distance between the tethered atom & the tether point integer, intent(in) :: teth_typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Called by proc~~ia_get_tether_force~~CalledByGraph proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces ia_add_tether_forces proc~ia_add_tether_forces->proc~ia_get_tether_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run var panprocia_get_tether_forceCalledByGraph = svgPanZoom('#procia_get_tether_forceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_get_tether_force.html"},{"title":"teth_rigid_set – BROWNPAK","text":"private subroutine teth_rigid_set(params, r0, eps) Setter for rigid tether interaction. User-set parameters: params(1) = r0 (fixed separation distance) params(2) = eps (allowed tolerance) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: r0 real(kind=rp), intent(in), optional :: eps Contents None","tags":"","loc":"proc/teth_rigid_set.html"},{"title":"teth_rigid – BROWNPAK","text":"private subroutine teth_rigid(r, params, enrg, frc, ierr) Not implemented, needs constraint formalism. See teth_rigid_set . Calculates energy for rigid tether interaction. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/teth_rigid.html"},{"title":"teth_harm_set – BROWNPAK","text":"private subroutine teth_harm_set(params, k, r0) Setter for harmonic tether interaction. U = ( 1 / 2 ) * k * ( r - r0 ) &#94; 2 User-set parameters: params(1) = k (spring constant) params(2) = r0 (equilibrium distance) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 Contents None","tags":"","loc":"proc/teth_harm_set.html"},{"title":"teth_harm – BROWNPAK","text":"private subroutine teth_harm(r, params, enrg, frc) Calculates energy and its derivative for harmonic tether interaction. See teth_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/teth_harm.html"},{"title":"ia_vdw_setup – BROWNPAK","text":"public subroutine ia_vdw_setup() Sets up parameters for vdw potentials Arguments None Contents None","tags":"","loc":"proc/ia_vdw_setup.html"},{"title":"ia_get_vdw_force – BROWNPAK","text":"public subroutine ia_get_vdw_force(rij_mag, qi, qj, typ, enrg, frc, ierr) Calculates the energy & its derivative due to a single interacting pair of atoms. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between two atoms real(kind=rp), intent(in) :: qi Charge on atom i real(kind=rp), intent(in) :: qj Charge on atom j integer, intent(in) :: typ Type of vdw interaction real(kind=rp), intent(out) :: enrg Energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of force due to\n this potential. integer, intent(out) :: ierr Error flag Called by proc~~ia_get_vdw_force~~CalledByGraph proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_add_vdw_forces_cl->proc~ia_get_vdw_force proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_add_vdw_forces_vl->proc~ia_get_vdw_force proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run var panprocia_get_vdw_forceCalledByGraph = svgPanZoom('#procia_get_vdw_forceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_get_vdw_force.html"},{"title":"vdw_lj_set – BROWNPAK","text":"private subroutine vdw_lj_set(params, eps, sigma, rcut) Setter for 12-6 LJ (cut & shifted) interaction. V = 4 * eps * [( r / sigma ) &#94; 12 - ( r / sigma ) &#94; 6 ] U = V - V ( rcut ), r < rcut 0 , r >= rcut User-set parameters: params(1) = eps params(2) = sigma params(3) = rcut Internally stored parameters: params(4) = V(rcut) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut Contents None","tags":"","loc":"proc/vdw_lj_set.html"},{"title":"vdw_lj – BROWNPAK","text":"private pure subroutine vdw_lj(r, params, enrg, frc) Evaluates the potential and its derivative for LJ interaction. See vdw_lj_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/vdw_lj.html"},{"title":"vdw_gaussian_set – BROWNPAK","text":"private subroutine vdw_gaussian_set(params, A, B, rcut) Setter for gaussian interaction. V = A * exp ( - B * r &#94; 2 ) U = V - V ( rcut ), r < rcut 0 , r >= rcut User-set parameters: params(1) = A params(2) = B params(3) = rcut Internally stored parameters: params(4) = V(rcut) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: B real(kind=rp), intent(in), optional :: rcut Contents None","tags":"","loc":"proc/vdw_gaussian_set.html"},{"title":"vdw_gaussian – BROWNPAK","text":"private pure subroutine vdw_gaussian(r, params, enrg, frc) Calculates energy & its derivative for gaussian interaction. See vdw_gaussian_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/vdw_gaussian.html"},{"title":"vdw_cosine_set – BROWNPAK","text":"private subroutine vdw_cosine_set(params, A, rcut) Setter for cosine interaction. U = A * cos ( pi * r / rcut ) User-set parameters: params(1) = A params(2) = rcut Internally stored parameters: params(3) = pi/rcut params(4) = pi*A/rcut Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: rcut Contents None","tags":"","loc":"proc/vdw_cosine_set.html"},{"title":"vdw_cosine – BROWNPAK","text":"private pure subroutine vdw_cosine(r, params, enrg, frc) Evaluates the potential and its derivative for  cosine interaction.\n See vdw_cosine_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/vdw_cosine.html"},{"title":"vdw_lj_coul_debye_set – BROWNPAK","text":"private subroutine vdw_lj_coul_debye_set(params, eps, sigma, rcut, rcut_coul, C, kappa) Setter for 12-6 LJ with screened Coulombic interaction. V = 4 * eps * [ ( r / sigma ) &#94; 12 - ( r / sigma ) &#94; 6 ] W = C * qi * qj * exp ( - kappa * r ) / r if rcut_coul > 0 : U = V - V ( rcut ) + W - W ( rcut_coul ) , r < rcut W - W ( rcut_coul ) , rcut <= r < rcut_coul 0 , r >= rcut_coul if rcut_coul <= 0 : U = V - V ( rcut ) + W , r < rcut W , r >= rcut The LJ potential V is cut & shifted at r = rcut . If rcut_coul > 0 , the screened Coulombic potential W is cut & shifted\n at r = rcut_coul . If rcut_coul <= 0 , no cutoff is applied on W . rcut_coul must be >= rcut . User-set parameters: params(1) = eps params(2) = sigma params(3) = rcut params(4) = rcut_coul params(5) = C params(6) = kappa Internally stored parameters: params(7) = V(rcut) params(8) = C*exp(-kappa*rcut_coul)/rcut_coul Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C real(kind=rp), intent(in), optional :: kappa Contents None","tags":"","loc":"proc/vdw_lj_coul_debye_set.html"},{"title":"vdw_lj_coul_debye – BROWNPAK","text":"private pure subroutine vdw_lj_coul_debye(r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for screened Coulombic interaction\ncombined with 12-6 LJ (cut & shifted). See vdw_lj_coul_debye_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/vdw_lj_coul_debye.html"},{"title":"vdw_lj_coul_set – BROWNPAK","text":"private subroutine vdw_lj_coul_set(params, eps, sigma, rcut, rcut_coul, C) Setter for 12-6 LJ with Coulombic interaction. V = 4 * eps * [ ( r / sigma ) &#94; 12 - ( r / sigma ) &#94; 6 ] W = C * qi * qj / r if rcut_coul > 0 : U = V - V ( rcut ) + W - W ( rcut_coul ) , r < rcut W - W ( rcut_coul ) , rcut <= r < rcut_coul 0 , r >= rcut_coul if rcut_coul <= 0 : U = V - V ( rcut ) + W , r < rcut W , r >= rcut The LJ potential V is cut & shifted at r = rcut . If rcut_coul > 0 , the Coulombic potential W is cut & shifted at r = rcut_coul . If rcut_coul <= 0 , no cutoff is applied on W . rcut_coul must be >= rcut . User-set parameters: params(1) = eps params(2) = sigma params(3) = rcut params(4) = rcut_coul params(5) = C Internally stored parameters: params(6) = V(rcut) params(7) = V(rcut) params(8) = C/rcut_coul Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C Contents None","tags":"","loc":"proc/vdw_lj_coul_set.html"},{"title":"vdw_lj_coul – BROWNPAK","text":"private pure subroutine vdw_lj_coul(r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for Coulombic interaction\n combined with 12-6 LJ (cut & shifted). See vdw_lj_coul_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc Contents None","tags":"","loc":"proc/vdw_lj_coul.html"},{"title":"ia_setup – BROWNPAK","text":"public subroutine ia_setup() Sets up parameters for potentials Arguments None Calls proc~~ia_setup~~CallsGraph proc~ia_setup ia_setup proc~cl_build_cell_nbrs cl_build_cell_nbrs proc~ia_setup->proc~cl_build_cell_nbrs proc~cl_init cl_init proc~ia_setup->proc~cl_init proc~atbo_build atbo_build proc~ia_setup->proc~atbo_build proc~cl_set_cell_size cl_set_cell_size proc~ia_setup->proc~cl_set_cell_size proc~exat_build exat_build proc~ia_setup->proc~exat_build proc~ivector_init ivector_init proc~cl_init->proc~ivector_init proc~itbl_init itbl_init proc~atbo_build->proc~itbl_init proc~atat_build atat_build proc~exat_build->proc~atat_build proc~exat_build->proc~itbl_init proc~exat_build->proc~ivector_init proc~atat_build->proc~itbl_init proc~atat_build->proc~ivector_init proc~itbl_init->proc~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_setup~~CalledByGraph proc~ia_setup ia_setup proc~setup setup proc~setup->proc~ia_setup program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_setup.html"},{"title":"ia_finish – BROWNPAK","text":"public subroutine ia_finish() Releases memory allocated in ia_setup . Arguments None Called by proc~~ia_finish~~CalledByGraph proc~ia_finish ia_finish proc~finish finish proc~finish->proc~ia_finish program~main main program~main->proc~finish Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_finish.html"},{"title":"ia_calc_forces – BROWNPAK","text":"public subroutine ia_calc_forces(ierr) Calculates total forces and energies Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~ia_calc_forces~~CallsGraph proc~ia_calc_forces ia_calc_forces proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~cl_get_contents cl_get_contents proc~ia_add_vdw_forces_cl->proc~cl_get_contents proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_cl->proc~ia_get_vdw_force proc~cl_get_num_cells cl_get_num_cells proc~ia_add_vdw_forces_cl->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~ia_add_vdw_forces_cl->proc~cl_get_nbr_cells proc~verlet_build verlet_build proc~ia_add_vdw_forces_vl->proc~verlet_build proc~ia_add_vdw_forces_vl->proc~ia_get_vdw_force proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_calc_forces~~CalledByGraph proc~ia_calc_forces ia_calc_forces proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_calc_forces.html"},{"title":"ia_add_vdw_forces – BROWNPAK","text":"private subroutine ia_add_vdw_forces(ierr) Calculates force and energy due to all short-ranged non-bonded pairwise\n interactions and adds to energy_vdw & 'forces in module m_globals`.\n Uses direct N&#94;2 calculation. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~ia_add_vdw_forces~~CallsGraph proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_add_vdw_forces~~CalledByGraph proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_vdw_forces.html"},{"title":"ia_add_vdw_forces_vl – BROWNPAK","text":"private subroutine ia_add_vdw_forces_vl(ierr) Calculates force and energy due to all short-ranged non-bonded pairwise\n interactions and adds to energy_vdw & 'forces in module m_globals`.\n Uses Verlet table. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~ia_add_vdw_forces_vl~~CallsGraph proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~verlet_build verlet_build proc~ia_add_vdw_forces_vl->proc~verlet_build proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_vl->proc~ia_get_vdw_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_add_vdw_forces_vl~~CalledByGraph proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_vdw_forces_vl.html"},{"title":"ia_add_vdw_forces_cl – BROWNPAK","text":"private subroutine ia_add_vdw_forces_cl(ierr) Calculates force and energy due to all short-ranged non-bonded pairwise\n interactions and adds to energy_vdw & 'forces in module m_globals`.\n Uses cell list. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~ia_add_vdw_forces_cl~~CallsGraph proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~cl_get_contents cl_get_contents proc~ia_add_vdw_forces_cl->proc~cl_get_contents proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_cl->proc~ia_get_vdw_force proc~cl_get_nbr_cells cl_get_nbr_cells proc~ia_add_vdw_forces_cl->proc~cl_get_nbr_cells proc~cl_get_num_cells cl_get_num_cells proc~ia_add_vdw_forces_cl->proc~cl_get_num_cells Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_add_vdw_forces_cl~~CalledByGraph proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_vdw_forces_cl.html"},{"title":"ia_add_bond_forces – BROWNPAK","text":"private subroutine ia_add_bond_forces(ierr) Calculates forces & energy due to all bonds. Will add to energy_bond & and 'forces in module m_globals`. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~ia_add_bond_forces~~CallsGraph proc~ia_add_bond_forces ia_add_bond_forces proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_add_bond_forces~~CalledByGraph proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_bond_forces.html"},{"title":"ia_add_angle_forces – BROWNPAK","text":"private subroutine ia_add_angle_forces() Calculates forces & energy due to all angles. Will add to energy_angle & 'forces in module m_globals`. Arguments None Calls proc~~ia_add_angle_forces~~CallsGraph proc~ia_add_angle_forces ia_add_angle_forces proc~ia_get_angle_force ia_get_angle_force proc~ia_add_angle_forces->proc~ia_get_angle_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_angle_forces.html"},{"title":"ia_add_dihedral_forces – BROWNPAK","text":"private subroutine ia_add_dihedral_forces() Calculates forces & energy due to all dihedrals. Will add to energy_dihedral & 'forces in module m_globals`. Arguments None Calls proc~~ia_add_dihedral_forces~~CallsGraph proc~ia_add_dihedral_forces ia_add_dihedral_forces proc~ia_get_dihedral_force ia_get_dihedral_force proc~ia_add_dihedral_forces->proc~ia_get_dihedral_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_dihedral_forces.html"},{"title":"ia_add_tether_forces – BROWNPAK","text":"private subroutine ia_add_tether_forces(ierr) Calculates forces & energy due to all tethers. Will add to energy_tether &\n 'forces in module m_globals`. Tether forces cannot be subject to\n periodic boundary conditions. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~ia_add_tether_forces~~CallsGraph proc~ia_add_tether_forces ia_add_tether_forces proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ia_add_tether_forces~~CalledByGraph proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ia_add_tether_forces.html"},{"title":"kmc_init – BROWNPAK","text":"public subroutine kmc_init() Arguments None Contents None","tags":"","loc":"proc/kmc_init.html"},{"title":"kmc_finish – BROWNPAK","text":"public subroutine kmc_finish() Arguments None Contents None","tags":"","loc":"proc/kmc_finish.html"},{"title":"kmc_hop – BROWNPAK","text":"public subroutine kmc_hop() Arguments None Contents None","tags":"","loc":"proc/kmc_hop.html"},{"title":"constructor – BROWNPAK","text":"private function constructor(logfile, stderr_threshold, stdout_threshold, logfile_threshold) result(this) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: logfile Name of the log-file to which output will be written integer, intent(in), optional :: stderr_threshold Threshold priority, at and above which messages will be\n written to standard error. Defaults to error . integer, intent(in), optional :: stdout_threshold Threshold priority, at and above which messages will be\n written to standard out. Defaults to info . integer, intent(in), optional :: logfile_threshold Threshold priority, at and above which messages will be\n written to the log file. Defaults to trivia . Return Value type( logger ) Called by proc~~constructor~~CalledByGraph proc~constructor constructor interface~logger logger interface~logger->proc~constructor proc~logger_init logger_init proc~logger_init->interface~logger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code constructor Source Code function constructor ( logfile , stderr_threshold , stdout_threshold , & logfile_threshold ) result ( this ) type ( logger ) :: this character ( len =* ), intent ( in ) :: logfile !! Name of the log-file to which output will be written integer , intent ( in ), optional :: stderr_threshold !! Threshold priority, at and above which messages will be !! written to standard error. Defaults to `error`. integer , intent ( in ), optional :: stdout_threshold !! Threshold priority, at and above which messages will be !! written to standard out. Defaults to `info`. integer , intent ( in ), optional :: logfile_threshold !! Threshold priority, at and above which messages will be !! written to the log file. Defaults to `trivia`. integer :: flag this % logfile = logfile open ( newunit = this % fileunit , file = this % logfile , action = 'write' , & iostat = flag , status = 'replace' ) if ( flag /= 0 ) error stop 'Error opening log file.' if ( present ( stderr_threshold )) then this % stderr_threshold = stderr_threshold else this % stderr_threshold = default_stderr_threshold end if if ( present ( stdout_threshold )) then this % stdout_threshold = stdout_threshold else this % stdout_threshold = default_stdout_threshold end if if ( present ( logfile_threshold )) then this % logfile_threshold = logfile_threshold else this % logfile_threshold = default_logfile_threshold end if end function constructor","tags":"","loc":"proc/constructor.html"},{"title":"get_designator – BROWNPAK","text":"private function get_designator(priority) result(des) Arguments Type Intent Optional Attributes Name integer, intent(in) :: priority The priority level for which to get the designator Return Value character(len=:),\n  allocatable Called by proc~~get_designator~~CalledByGraph proc~get_designator get_designator proc~logger_message logger_message proc~logger_message->proc~get_designator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_designator Source Code function get_designator ( priority ) result ( des ) !* Author: Chris MacMackin !  Date: December 2016 ! !  Removed dependence on the **face** module by removing optional input !  `ansi_colours` ! For a given priority, returns the appropriate, optionally ! colourised, designator. ! integer , intent ( in ) :: priority !! The priority level for which to get the designator character ( len = :), allocatable :: des integer :: descriminator descriminator = priority / 10 if ( descriminator < 1 ) then des = '' else if ( descriminator < 2 ) then des = '<debug> ' else if ( descriminator < 3 ) then des = '<trivia> ' else if ( descriminator < 4 ) then des = '<info> ' else if ( descriminator < 5 ) then des = '<warning> ' else if ( descriminator < 6 ) then des = '<error> ' else des = '<fatal> ' end if end function get_designator","tags":"","loc":"proc/get_designator.html"},{"title":"current_time – BROWNPAK","text":"private function current_time() Arguments None Return Value character(len=20) Called by proc~~current_time~~CalledByGraph proc~current_time current_time proc~logger_message logger_message proc~logger_message->proc~current_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code current_time Source Code function current_time () !* Author: Chris MacMackin !  Date: November 2016 ! ! Returns the formatted current date and time. ! character ( len = 20 ) :: current_time integer ( i8 ), dimension ( 8 ) :: time_vals character ( len = 3 ), dimension ( 12 ), parameter :: months = [ 'Jan' , & 'Feb' , & 'Mar' , & 'Apr' , & 'May' , & 'Jun' , & 'Jul' , & 'Aug' , & 'Sep' , & 'Oct' , & 'Nov' , & 'Dec' ] character ( len = 42 ), parameter :: time_format = '(a3,1x,i2,1x,i4,1x,' // & 'i2.2,\":\",i2.2,\":\",i2.2)' call date_and_time ( values = time_vals ) write ( current_time , time_format ) months ( time_vals ( 2 )), time_vals ( 3 ), & time_vals ( 1 ), time_vals ( 5 ), time_vals ( 6 ), & time_vals ( 7 ) end function current_time","tags":"","loc":"proc/current_time.html"},{"title":"logger_is_open – BROWNPAK","text":"private pure function logger_is_open(this) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this Return Value logical Contents Source Code logger_is_open Source Code pure function logger_is_open ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Returns `.true.` if the log-file is open for writing. ! class ( logger ), intent ( in ) :: this logical :: logger_is_open logger_is_open = ( this % fileunit /= closed_unit ) end function logger_is_open","tags":"","loc":"proc/logger_is_open.html"},{"title":"logger_finalize – BROWNPAK","text":"private subroutine logger_finalize(this) Arguments Type Intent Optional Attributes Name type( logger ), intent(inout) :: this Contents Source Code logger_finalize Source Code subroutine logger_finalize ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Closes the log-file of this logger object. ! type ( logger ), intent ( inout ) :: this call this % destroy () end subroutine logger_finalize","tags":"","loc":"proc/logger_finalize.html"},{"title":"logger_init – BROWNPAK","text":"public subroutine logger_init(logfile, stderr_threshold, stdout_threshold, logfile_threshold) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: logfile Name of the log-file to which output will be written integer, intent(in), optional :: stderr_threshold Threshold priority, at and above which messages will be\n written to standard error. Defaults to error . integer, intent(in), optional :: stdout_threshold Threshold priority, at and above which messages will be\n written to standard out. Defaults to info . integer, intent(in), optional :: logfile_threshold Threshold priority, at and above which messages will be\n written to the log file. Defaults to trivia . Calls proc~~logger_init~~CallsGraph proc~logger_init logger_init interface~logger logger proc~logger_init->interface~logger proc~constructor constructor interface~logger->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code logger_init Source Code subroutine logger_init ( logfile , stderr_threshold , stdout_threshold , & logfile_threshold ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Initalises the master logging object. This subroutine must be ! called before the master logger is used. It should only be ! called once. ! character ( len =* ), intent ( in ) :: logfile !! Name of the log-file to which output will be written integer , intent ( in ), optional :: stderr_threshold !! Threshold priority, at and above which messages will be !! written to standard error. Defaults to `error`. integer , intent ( in ), optional :: stdout_threshold !! Threshold priority, at and above which messages will be !! written to standard out. Defaults to `info`. integer , intent ( in ), optional :: logfile_threshold !! Threshold priority, at and above which messages will be !! written to the log file. Defaults to `trivia`. master_logger = logger ( logfile , stderr_threshold , stdout_threshold , & logfile_threshold ) end subroutine logger_init","tags":"","loc":"proc/logger_init.html"},{"title":"logger_message – BROWNPAK","text":"private subroutine logger_message(this, source, priority, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error integer, intent(in) :: priority The importance of the message, determining where it will be\n written. character(len=*), intent(in) :: message The information to be written. Calls proc~~logger_message~~CallsGraph proc~logger_message logger_message proc~get_designator get_designator proc~logger_message->proc~get_designator proc~current_time current_time proc~logger_message->proc~current_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code logger_message Source Code subroutine logger_message ( this , source , priority , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Write the provided message to STDERR, STDOUT, and/or a log-file, ! based on its priority level. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error integer , intent ( in ) :: priority !! The importance of the message, determining where it will be !! written. character ( len =* ), intent ( in ) :: message !! The information to be written. character ( len = :), allocatable :: output if ( priority >= this % stderr_threshold ) then output = get_designator ( priority ) // message write ( this % stderr , default_format ) current_time (), source , output else if ( priority >= this % stdout_threshold ) then output = get_designator ( priority ) // message write ( this % stdout , default_format ) current_time (), source , output end if if ( priority >= this % logfile_threshold ) then output = get_designator ( priority ) // message write ( this % fileunit , default_format ) current_time (), source , output end if end subroutine logger_message","tags":"","loc":"proc/logger_message.html"},{"title":"logger_debug – BROWNPAK","text":"private subroutine logger_debug(this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. Contents Source Code logger_debug Source Code subroutine logger_debug ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes debug information to STDERR, STDOUT, and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , debug , message ) end subroutine logger_debug","tags":"","loc":"proc/logger_debug.html"},{"title":"logger_trivia – BROWNPAK","text":"private subroutine logger_trivia(this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. Contents Source Code logger_trivia Source Code subroutine logger_trivia ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes unimportant run-time information to STDERR, STDOUT, ! and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , trivia , message ) end subroutine logger_trivia","tags":"","loc":"proc/logger_trivia.html"},{"title":"logger_info – BROWNPAK","text":"private subroutine logger_info(this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. Contents Source Code logger_info Source Code subroutine logger_info ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes run-time information to STDERR, STDOUT, and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , info , message ) end subroutine logger_info","tags":"","loc":"proc/logger_info.html"},{"title":"logger_warning – BROWNPAK","text":"private subroutine logger_warning(this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. Contents Source Code logger_warning Source Code subroutine logger_warning ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes warning information to STDERR, STDOUT, and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , warning , message ) end subroutine logger_warning","tags":"","loc":"proc/logger_warning.html"},{"title":"logger_error – BROWNPAK","text":"private subroutine logger_error(this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. Contents Source Code logger_error Source Code subroutine logger_error ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes error information to STDERR, STDOUT, and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , error , message ) end subroutine logger_error","tags":"","loc":"proc/logger_error.html"},{"title":"logger_fatal – BROWNPAK","text":"private subroutine logger_fatal(this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. Contents Source Code logger_fatal Source Code subroutine logger_fatal ( this , source , message ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Writes fatal information to STDERR, STDOUT, and/or a log-file. ! class ( logger ), intent ( in ) :: this character ( len =* ), intent ( in ) :: source !! The name of the procedure which produced the error character ( len =* ), intent ( in ) :: message !! The information to be written. call this % message ( source , fatal , message ) end subroutine logger_fatal","tags":"","loc":"proc/logger_fatal.html"},{"title":"logger_destroy – BROWNPAK","text":"private subroutine logger_destroy(this) Arguments Type Intent Optional Attributes Name class( logger ), intent(inout) :: this Contents Source Code logger_destroy Source Code subroutine logger_destroy ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Closes the log-file of this logger object. Destroys only the ! logger object, *not* the output. ! class ( logger ), intent ( inout ) :: this if ( this % fileunit == closed_unit ) return close ( this % fileunit ) this % fileunit = closed_unit this % stderr_threshold = infinity this % stdout_threshold = infinity this % logfile_threshold = infinity end subroutine logger_destroy","tags":"","loc":"proc/logger_destroy.html"},{"title":"logger – BROWNPAK","text":"public interface logger Calls interface~~logger~~CallsGraph interface~logger logger proc~constructor constructor interface~logger->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~logger~~CalledByGraph interface~logger logger proc~logger_init logger_init proc~logger_init->interface~logger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures constructor Module Procedures private function constructor (logfile, stderr_threshold, stdout_threshold, logfile_threshold) result(this) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: logfile Name of the log-file to which output will be written integer, intent(in), optional :: stderr_threshold Threshold priority, at and above which messages will be\n written to standard error. Defaults to error . integer, intent(in), optional :: stdout_threshold Threshold priority, at and above which messages will be\n written to standard out. Defaults to info . integer, intent(in), optional :: logfile_threshold Threshold priority, at and above which messages will be\n written to the log file. Defaults to trivia . Return Value type( logger )","tags":"","loc":"interface/logger.html"},{"title":"mpcd_init – BROWNPAK","text":"public subroutine mpcd_init(ierr) Initializes the MPCD solver. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Called by proc~~mpcd_init~~CalledByGraph proc~mpcd_init mpcd_init proc~setup setup proc~setup->proc~mpcd_init program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpcd_init.html"},{"title":"mpcd_finish – BROWNPAK","text":"public subroutine mpcd_finish() Clean up MPCD solver. Arguments None Called by proc~~mpcd_finish~~CalledByGraph proc~mpcd_finish mpcd_finish proc~finish finish proc~finish->proc~mpcd_finish program~main main program~main->proc~finish Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpcd_finish.html"},{"title":"mpcd_run – BROWNPAK","text":"public subroutine mpcd_run() Driver for MPCD integrator. Repeatedly calls mpcd_stream and mpcd_collide to update atom\n positions. Handling of flow field is not imlemented yet. If a non-zero flow_style is specified, it will be set to zero. Arguments None Calls proc~~mpcd_run~~CallsGraph proc~mpcd_run mpcd_run proc~mpcd_stream mpcd_stream proc~mpcd_run->proc~mpcd_stream proc~stats_finish stats_finish proc~mpcd_run->proc~stats_finish proc~mpcd_collide mpcd_collide proc~mpcd_run->proc~mpcd_collide proc~stats_write stats_write proc~mpcd_run->proc~stats_write interface~str_from_num str_from_num proc~mpcd_run->interface~str_from_num proc~ia_calc_forces ia_calc_forces proc~mpcd_stream->proc~ia_calc_forces proc~cl_get_contents cl_get_contents proc~mpcd_collide->proc~cl_get_contents gelsy gelsy proc~mpcd_collide->gelsy proc~cl_build cl_build proc~mpcd_collide->proc~cl_build proc~get_rv_uniform get_rv_uniform proc~mpcd_collide->proc~get_rv_uniform proc~cl_get_num_cells cl_get_num_cells proc~mpcd_collide->proc~cl_get_num_cells proc~cross cross proc~mpcd_collide->proc~cross proc~det det proc~mpcd_collide->proc~det proc~cl_set_cell_size cl_set_cell_size proc~mpcd_collide->proc~cl_set_cell_size proc~invert_mat33 invert_mat33 proc~mpcd_collide->proc~invert_mat33 proc~stats_compute_ic1 stats_compute_ic1 proc~stats_write->proc~stats_compute_ic1 proc~stats_compute_ic0 stats_compute_ic0 proc~stats_write->proc~stats_compute_ic0 proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum vdrnguniform vdrnguniform proc~get_rv_uniform->vdrnguniform proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero proc~dsyevc3 dsyevc3 proc~stats_compute_ic0->proc~dsyevc3 proc~ia_add_vdw_forces_cl->proc~cl_get_contents proc~ia_add_vdw_forces_cl->proc~cl_get_num_cells proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_cl->proc~ia_get_vdw_force proc~cl_get_nbr_cells cl_get_nbr_cells proc~ia_add_vdw_forces_cl->proc~cl_get_nbr_cells proc~verlet_build verlet_build proc~ia_add_vdw_forces_vl->proc~verlet_build proc~ia_add_vdw_forces_vl->proc~ia_get_vdw_force proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force var panprocmpcd_runCallsGraph = svgPanZoom('#procmpcd_runCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~mpcd_run~~CalledByGraph proc~mpcd_run mpcd_run program~main main program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpcd_run.html"},{"title":"mpcd_stream – BROWNPAK","text":"private subroutine mpcd_stream(ierr) Performs one step of streaming. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr Calls proc~~mpcd_stream~~CallsGraph proc~mpcd_stream mpcd_stream proc~ia_calc_forces ia_calc_forces proc~mpcd_stream->proc~ia_calc_forces proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~cl_get_contents cl_get_contents proc~ia_add_vdw_forces_cl->proc~cl_get_contents proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_cl->proc~ia_get_vdw_force proc~cl_get_num_cells cl_get_num_cells proc~ia_add_vdw_forces_cl->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~ia_add_vdw_forces_cl->proc~cl_get_nbr_cells proc~verlet_build verlet_build proc~ia_add_vdw_forces_vl->proc~verlet_build proc~ia_add_vdw_forces_vl->proc~ia_get_vdw_force proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~mpcd_stream~~CalledByGraph proc~mpcd_stream mpcd_stream proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpcd_stream.html"},{"title":"mpcd_collide – BROWNPAK","text":"private subroutine mpcd_collide() Performs one step of MPCD collision. Arguments None Calls proc~~mpcd_collide~~CallsGraph proc~mpcd_collide mpcd_collide proc~cl_get_contents cl_get_contents proc~mpcd_collide->proc~cl_get_contents gelsy gelsy proc~mpcd_collide->gelsy proc~cl_build cl_build proc~mpcd_collide->proc~cl_build proc~get_rv_uniform get_rv_uniform proc~mpcd_collide->proc~get_rv_uniform proc~cl_get_num_cells cl_get_num_cells proc~mpcd_collide->proc~cl_get_num_cells proc~cross cross proc~mpcd_collide->proc~cross proc~det det proc~mpcd_collide->proc~det proc~cl_set_cell_size cl_set_cell_size proc~mpcd_collide->proc~cl_set_cell_size proc~invert_mat33 invert_mat33 proc~mpcd_collide->proc~invert_mat33 vdrnguniform vdrnguniform proc~get_rv_uniform->vdrnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~mpcd_collide~~CalledByGraph proc~mpcd_collide mpcd_collide proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_collide program~main main program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpcd_collide.html"},{"title":"iqsort – BROWNPAK","text":"public subroutine iqsort(list, order) Sorts a sequence of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), DIMENSION (:) :: list Sequence of integers to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence Called by proc~~iqsort~~CalledByGraph proc~iqsort iqsort proc~ivector_sort ivector_sort proc~ivector_sort->proc~iqsort proc~ivector_unique ivector_unique proc~ivector_unique->proc~iqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code iqsort Source Code RECURSIVE SUBROUTINE iqsort ( list , order ) !!  Sorts a sequence of integers IMPLICIT NONE INTEGER , DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of integers to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp INTEGER :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE iqsort","tags":"","loc":"proc/iqsort.html"},{"title":"dqsort – BROWNPAK","text":"public subroutine dqsort(list, order) Sorts a sequence of reals Arguments Type Intent Optional Attributes Name real(kind=RP), intent(inout), DIMENSION (:) :: list Sequence of reals to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence Called by proc~~dqsort~~CalledByGraph proc~dqsort dqsort proc~dvector_unique dvector_unique proc~dvector_unique->proc~dqsort proc~dvector_sort dvector_sort proc~dvector_sort->proc~dqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dqsort Source Code RECURSIVE SUBROUTINE dqsort ( list , order ) !!  Sorts a sequence of reals !\"\" IMPLICIT NONE REAL ( RP ), DIMENSION (:), INTENT ( IN OUT ) :: list !!  Sequence of reals to be sorted INTEGER , DIMENSION (:), INTENT ( OUT ), OPTIONAL :: order !!  Indices of the sorted sequence ! Local variable INTEGER :: i IF ( PRESENT ( order )) THEN DO i = 1 , SIZE ( list ) order ( i ) = i END DO END IF CALL quick_sort_1 ( 1 , SIZE ( list )) CONTAINS RECURSIVE SUBROUTINE quick_sort_1 ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: reference , temp INTEGER , PARAMETER :: max_simple_sort_size = 8 IF ( right_end < left_end + max_simple_sort_size ) THEN ! Use interchange sort for small lists CALL interchange_sort ( left_end , right_end ) ELSE ! Use partition (\"quick\") sort reference = list (( left_end + right_end ) / 2 ) i = left_end - 1 ; j = right_end + 1 DO ! Scan list from left end until element >= reference is found DO i = i + 1 IF ( list ( i ) >= reference ) EXIT END DO ! Scan list from right end until element <= reference is found DO j = j - 1 IF ( list ( j ) <= reference ) EXIT END DO IF ( i < j ) THEN ! Swap two out-of-order elements temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF ELSE IF ( i == j ) THEN i = i + 1 EXIT ELSE EXIT END IF END DO IF ( left_end < j ) CALL quick_sort_1 ( left_end , j ) IF ( i < right_end ) CALL quick_sort_1 ( i , right_end ) END IF END SUBROUTINE quick_sort_1 SUBROUTINE interchange_sort ( left_end , right_end ) INTEGER , INTENT ( IN ) :: left_end , right_end !     Local variables INTEGER :: i , j , itemp REAL ( RP ) :: temp DO i = left_end , right_end - 1 DO j = i + 1 , right_end IF ( list ( i ) > list ( j )) THEN temp = list ( i ); list ( i ) = list ( j ); list ( j ) = temp IF ( PRESENT ( order )) THEN itemp = order ( i ); order ( i ) = order ( j ); order ( j ) = itemp END IF END IF END DO END DO END SUBROUTINE interchange_sort END SUBROUTINE dqsort","tags":"","loc":"proc/dqsort.html"},{"title":"get_uniform – BROWNPAK","text":"public function get_uniform(lb, ub) result(res) Returns a random number from a uniform distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound Return Value real(kind=rp) Calls proc~~get_uniform~~CallsGraph proc~get_uniform get_uniform vdrnguniform vdrnguniform proc~get_uniform->vdrnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_uniform.html"},{"title":"get_iuniform – BROWNPAK","text":"public function get_iuniform(lb, ub) result(res) Returns a random integer from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub Return Value integer(kind=ip) Calls proc~~get_iuniform~~CallsGraph proc~get_iuniform get_iuniform virnguniform virnguniform proc~get_iuniform->virnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_iuniform.html"},{"title":"init_stream – BROWNPAK","text":"public subroutine init_stream(fn) Initializes a BRNG stream. The stream is initialized with a seed from the file fn . If fn is an empty string, the seed is obtained from /dev/urandom . Arguments Type Intent Optional Attributes Name character(len=*) :: fn Name of the file containing the RNG seed. Calls proc~~init_stream~~CallsGraph proc~init_stream init_stream vslnewstream vslnewstream proc~init_stream->vslnewstream Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_stream~~CalledByGraph proc~init_stream init_stream proc~setup setup proc~setup->proc~init_stream program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/init_stream.html"},{"title":"delete_stream – BROWNPAK","text":"public subroutine delete_stream() Deletes a BRNG stream. Arguments None Calls proc~~delete_stream~~CallsGraph proc~delete_stream delete_stream vsldeletestream vsldeletestream proc~delete_stream->vsldeletestream Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/delete_stream.html"},{"title":"load_stream – BROWNPAK","text":"public subroutine load_stream(fn) Loads a BRNG stream from file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Calls proc~~load_stream~~CallsGraph proc~load_stream load_stream vslloadstreamf vslloadstreamf proc~load_stream->vslloadstreamf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/load_stream.html"},{"title":"save_seed – BROWNPAK","text":"public subroutine save_seed(fn) Saves the RNG seed to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Contents None","tags":"","loc":"proc/save_seed.html"},{"title":"save_stream – BROWNPAK","text":"public subroutine save_stream(fn) Saves a BRNG stream to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Calls proc~~save_stream~~CallsGraph proc~save_stream save_stream vslsavestreamf vslsavestreamf proc~save_stream->vslsavestreamf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/save_stream.html"},{"title":"get_rv_uniform – BROWNPAK","text":"public subroutine get_rv_uniform(lb, ub, rv, block_size) Returns a random vector from a uniform distribution. If a block_size > 0 is provided, it fills rv in blocks of\n size block_size . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size Calls proc~~get_rv_uniform~~CallsGraph proc~get_rv_uniform get_rv_uniform vdrnguniform vdrnguniform proc~get_rv_uniform->vdrnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_rv_uniform~~CalledByGraph proc~get_rv_uniform get_rv_uniform proc~ransphere ransphere proc~ransphere->proc~get_rv_uniform proc~smbx_get_rnd_points smbx_get_rnd_points proc~smbx_get_rnd_points->proc~get_rv_uniform proc~mpcd_collide mpcd_collide proc~mpcd_collide->proc~get_rv_uniform proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_collide program~main main program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_rv_uniform.html"},{"title":"get_rv_iuniform – BROWNPAK","text":"public subroutine get_rv_iuniform(lb, ub, rv, block_size) Returns a random vector of integers from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub integer(kind=ip), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size Calls proc~~get_rv_iuniform~~CallsGraph proc~get_rv_iuniform get_rv_iuniform virnguniform virnguniform proc~get_rv_iuniform->virnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_rv_iuniform.html"},{"title":"get_rv_gaussian – BROWNPAK","text":"public subroutine get_rv_gaussian(mean, std_dev, rv, block_size) Generates a random vector of integers from a gaussian distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: std_dev real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size Calls proc~~get_rv_gaussian~~CallsGraph proc~get_rv_gaussian get_rv_gaussian vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_rv_gaussian~~CalledByGraph proc~get_rv_gaussian get_rv_gaussian proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~get_rv_gaussian proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~get_rv_gaussian proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd program~main main program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_rv_gaussian.html"},{"title":"ransphere – BROWNPAK","text":"public subroutine ransphere(r) Generates a random vector from the surface of a unit sphere. Algorithm from Allen & Tildesley (ed 1) p. 349. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(3) :: r (3) Calls proc~~ransphere~~CallsGraph proc~ransphere ransphere proc~get_rv_uniform get_rv_uniform proc~ransphere->proc~get_rv_uniform vdrnguniform vdrnguniform proc~get_rv_uniform->vdrnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ransphere.html"},{"title":"rlx_run – BROWNPAK","text":"public subroutine rlx_run() Driver for relaxation Arguments None Calls proc~~rlx_run~~CallsGraph proc~rlx_run rlx_run proc~rlx_integrate rlx_integrate proc~rlx_run->proc~rlx_integrate interface~str_from_num str_from_num proc~rlx_run->interface~str_from_num proc~str_strip str_strip proc~rlx_run->proc~str_strip proc~write_config write_config proc~rlx_run->proc~write_config proc~write_ldf write_ldf proc~rlx_run->proc~write_ldf proc~ia_calc_forces ia_calc_forces proc~rlx_integrate->proc~ia_calc_forces proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~cl_get_contents cl_get_contents proc~ia_add_vdw_forces_cl->proc~cl_get_contents proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_cl->proc~ia_get_vdw_force proc~cl_get_num_cells cl_get_num_cells proc~ia_add_vdw_forces_cl->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~ia_add_vdw_forces_cl->proc~cl_get_nbr_cells proc~verlet_build verlet_build proc~ia_add_vdw_forces_vl->proc~verlet_build proc~ia_add_vdw_forces_vl->proc~ia_get_vdw_force proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~rlx_run~~CalledByGraph proc~rlx_run rlx_run program~main main program~main->proc~rlx_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/rlx_run.html"},{"title":"rlx_integrate – BROWNPAK","text":"private subroutine rlx_integrate(ierr, zf) Performs one step of relaxation Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr logical, intent(out) :: zf Calls proc~~rlx_integrate~~CallsGraph proc~rlx_integrate rlx_integrate proc~ia_calc_forces ia_calc_forces proc~rlx_integrate->proc~ia_calc_forces proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~cl_get_contents cl_get_contents proc~ia_add_vdw_forces_cl->proc~cl_get_contents proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_cl->proc~ia_get_vdw_force proc~cl_get_num_cells cl_get_num_cells proc~ia_add_vdw_forces_cl->proc~cl_get_num_cells proc~cl_get_nbr_cells cl_get_nbr_cells proc~ia_add_vdw_forces_cl->proc~cl_get_nbr_cells proc~verlet_build verlet_build proc~ia_add_vdw_forces_vl->proc~verlet_build proc~ia_add_vdw_forces_vl->proc~ia_get_vdw_force proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~rlx_integrate~~CalledByGraph proc~rlx_integrate rlx_integrate proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate program~main main program~main->proc~rlx_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/rlx_integrate.html"},{"title":"setup – BROWNPAK","text":"public subroutine setup() Arguments None Calls proc~~setup~~CallsGraph proc~setup setup proc~mpcd_init mpcd_init proc~setup->proc~mpcd_init proc~ia_setup ia_setup proc~setup->proc~ia_setup proc~init_stream init_stream proc~setup->proc~init_stream proc~bds_init bds_init proc~setup->proc~bds_init proc~smbx_init smbx_init proc~setup->proc~smbx_init proc~stats_init stats_init proc~setup->proc~stats_init proc~cl_build_cell_nbrs cl_build_cell_nbrs proc~ia_setup->proc~cl_build_cell_nbrs proc~cl_init cl_init proc~ia_setup->proc~cl_init proc~atbo_build atbo_build proc~ia_setup->proc~atbo_build proc~cl_set_cell_size cl_set_cell_size proc~ia_setup->proc~cl_set_cell_size proc~exat_build exat_build proc~ia_setup->proc~exat_build vslnewstream vslnewstream proc~init_stream->vslnewstream proc~stats_write_hdr stats_write_hdr proc~stats_init->proc~stats_write_hdr proc~ivector_init ivector_init proc~cl_init->proc~ivector_init proc~itbl_init itbl_init proc~atbo_build->proc~itbl_init proc~atat_build atat_build proc~exat_build->proc~atat_build proc~exat_build->proc~itbl_init proc~exat_build->proc~ivector_init proc~atat_build->proc~itbl_init proc~atat_build->proc~ivector_init proc~itbl_init->proc~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup~~CalledByGraph proc~setup setup program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/setup.html"},{"title":"config_clear – BROWNPAK","text":"public subroutine config_clear() Clears out all configuration related variables in module m_globals . Arguments None Called by proc~~config_clear~~CalledByGraph proc~config_clear config_clear proc~finish finish proc~finish->proc~config_clear program~main main program~main->proc~finish Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/config_clear.html"},{"title":"finish – BROWNPAK","text":"public subroutine finish() Arguments None Calls proc~~finish~~CallsGraph proc~finish finish proc~config_clear config_clear proc~finish->proc~config_clear proc~mpcd_finish mpcd_finish proc~finish->proc~mpcd_finish proc~stats_finish stats_finish proc~finish->proc~stats_finish proc~ia_finish ia_finish proc~finish->proc~ia_finish proc~bds_finish bds_finish proc~finish->proc~bds_finish Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~finish~~CalledByGraph proc~finish finish program~main main program~main->proc~finish Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/finish.html"},{"title":"smbx_init – BROWNPAK","text":"public subroutine smbx_init(this) Creates an instance of smbx_t . Can also be called to reset. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(inout) :: this Called by proc~~smbx_init~~CalledByGraph proc~smbx_init smbx_init proc~setup setup proc~setup->proc~smbx_init program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/smbx_init.html"},{"title":"smbx_set_basis – BROWNPAK","text":"public subroutine smbx_set_basis(this, bv) Sets all three basis vectors. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(3,3) :: bv Contents None","tags":"","loc":"proc/smbx_set_basis.html"},{"title":"smbx_freeze – BROWNPAK","text":"public subroutine smbx_freeze(this) Specifies this as non-deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/smbx_freeze.html"},{"title":"smbx_unfreeze – BROWNPAK","text":"public subroutine smbx_unfreeze(this) Specifies this as deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/smbx_unfreeze.html"},{"title":"smbx_get_image – BROWNPAK","text":"public subroutine smbx_get_image(this, r) Returns the image of r under PBC. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(3) :: r Contents None","tags":"","loc":"proc/smbx_get_image.html"},{"title":"smbx_wrap_all – BROWNPAK","text":"public subroutine smbx_wrap_all(this, coords) Wraps atom positions w.r.t. periodic boundary conditions. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords Contents None","tags":"","loc":"proc/smbx_wrap_all.html"},{"title":"smbx_to_center – BROWNPAK","text":"public subroutine smbx_to_center(this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the center \n of the box. Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com Contents None","tags":"","loc":"proc/smbx_to_center.html"},{"title":"smbx_get_rnd_points – BROWNPAK","text":"public subroutine smbx_get_rnd_points(this, coords) Returns uniformly distributed points within the box. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(out), dimension(:,:) :: coords Calls proc~~smbx_get_rnd_points~~CallsGraph proc~smbx_get_rnd_points smbx_get_rnd_points proc~get_rv_uniform get_rv_uniform proc~smbx_get_rnd_points->proc~get_rv_uniform vdrnguniform vdrnguniform proc~get_rv_uniform->vdrnguniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/smbx_get_rnd_points.html"},{"title":"stats_init – BROWNPAK","text":"public subroutine stats_init() Set up for stats collection Arguments None Calls proc~~stats_init~~CallsGraph proc~stats_init stats_init proc~stats_write_hdr stats_write_hdr proc~stats_init->proc~stats_write_hdr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~stats_init~~CalledByGraph proc~stats_init stats_init proc~setup setup proc~setup->proc~stats_init program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/stats_init.html"},{"title":"stats_finish – BROWNPAK","text":"public subroutine stats_finish() Closes any files opened in stats_init . Arguments None Called by proc~~stats_finish~~CalledByGraph proc~stats_finish stats_finish proc~bds_run bds_run proc~bds_run->proc~stats_finish proc~finish finish proc~finish->proc~stats_finish proc~mpcd_run mpcd_run proc~mpcd_run->proc~stats_finish program~main main program~main->proc~bds_run program~main->proc~finish program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/stats_finish.html"},{"title":"stats_write_hdr – BROWNPAK","text":"private subroutine stats_write_hdr() Driver for writing header of file fn_stats . This is called only after\n appropriate files have been opened. Arguments None Called by proc~~stats_write_hdr~~CalledByGraph proc~stats_write_hdr stats_write_hdr proc~stats_init stats_init proc~stats_init->proc~stats_write_hdr proc~setup setup proc~setup->proc~stats_init program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/stats_write_hdr.html"},{"title":"stats_write – BROWNPAK","text":"public subroutine stats_write() Writing statistics Arguments None Calls proc~~stats_write~~CallsGraph proc~stats_write stats_write proc~stats_compute_ic1 stats_compute_ic1 proc~stats_write->proc~stats_compute_ic1 proc~stats_compute_ic0 stats_compute_ic0 proc~stats_write->proc~stats_compute_ic0 proc~dsyevc3 dsyevc3 proc~stats_compute_ic0->proc~dsyevc3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~stats_write~~CalledByGraph proc~stats_write stats_write proc~bds_run bds_run proc~bds_run->proc~stats_write proc~mpcd_run mpcd_run proc~mpcd_run->proc~stats_write program~main main program~main->proc~bds_run program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/stats_write.html"},{"title":"stats_compute_ic1 – BROWNPAK","text":"private subroutine stats_compute_ic1() Computes statistics for a possibly multiple chains in a periodic domain. Arguments None Called by proc~~stats_compute_ic1~~CalledByGraph proc~stats_compute_ic1 stats_compute_ic1 proc~stats_write stats_write proc~stats_write->proc~stats_compute_ic1 proc~bds_run bds_run proc~bds_run->proc~stats_write proc~mpcd_run mpcd_run proc~mpcd_run->proc~stats_write program~main main program~main->proc~bds_run program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/stats_compute_ic1.html"},{"title":"stats_compute_ic0 – BROWNPAK","text":"private subroutine stats_compute_ic0() Computes statistics for a single chain in unbounded domain. Arguments None Calls proc~~stats_compute_ic0~~CallsGraph proc~stats_compute_ic0 stats_compute_ic0 proc~dsyevc3 dsyevc3 proc~stats_compute_ic0->proc~dsyevc3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~stats_compute_ic0~~CalledByGraph proc~stats_compute_ic0 stats_compute_ic0 proc~stats_write stats_write proc~stats_write->proc~stats_compute_ic0 proc~bds_run bds_run proc~bds_run->proc~stats_write proc~mpcd_run mpcd_run proc~mpcd_run->proc~stats_write program~main main program~main->proc~bds_run program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/stats_compute_ic0.html"},{"title":"calc_shape – BROWNPAK","text":"private subroutine calc_shape(ev1, ev2, ev3, asph, prol) Given three eigen values of the gyration tensor, calculates asphericity\n and prolateness. Note that ev1 >= ev2 >= ev3. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ev1 real(kind=rp), intent(in) :: ev2 real(kind=rp), intent(in) :: ev3 real(kind=rp), intent(out) :: asph real(kind=rp), intent(out) :: prol Contents None","tags":"","loc":"proc/calc_shape.html"},{"title":"dsyevc3 – BROWNPAK","text":"private subroutine dsyevc3(A, W) Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's\n analytical algorithm.\n Only the diagonal and upper triangular parts of A are accessed. The access\n is read-only. Copyright (C) 2006  Joachim Kopp Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), DIMENSION(3,3) :: A real(kind=RP), intent(out), DIMENSION(3) :: W (3) Called by proc~~dsyevc3~~CalledByGraph proc~dsyevc3 dsyevc3 proc~stats_compute_ic0 stats_compute_ic0 proc~stats_compute_ic0->proc~dsyevc3 proc~stats_write stats_write proc~stats_write->proc~stats_compute_ic0 proc~bds_run bds_run proc~bds_run->proc~stats_write proc~mpcd_run mpcd_run proc~mpcd_run->proc~stats_write program~main main program~main->proc~bds_run program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dsyevc3.html"},{"title":"str_is_letter – BROWNPAK","text":"public pure function str_is_letter(str) result(res) Returns .true. if str contains only letters ( a--z or A--Z ) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical Contents None","tags":"","loc":"proc/str_is_letter.html"},{"title":"str_is_digit – BROWNPAK","text":"public pure function str_is_digit(str) result(res) Returns .true. if str contains only digits (0,1,...,9) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical Contents None","tags":"","loc":"proc/str_is_digit.html"},{"title":"str_is_space – BROWNPAK","text":"public pure function str_is_space(str) result(res) Returns .true. if str is non-empty and contains only whitespace\n characters (tab or blankspace). Otherwise .false. is returned. Note : This function will return .false. for an empty string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical Contents None","tags":"","loc":"proc/str_is_space.html"},{"title":"str_is_comment – BROWNPAK","text":"public pure function str_is_comment(line, comment_str) result(res) Returns .true. if line is a comment, .false. other wise. line is a comment if comment_str is its first non-blank character\n  sequence. If line is an empty string or contains only blankspaces, the\n  return value is .false. If comment_str is empty, the return value is .true. . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Input string character(len=*), intent(in) :: comment_str String marking the beginning of a comment. Return Value logical Called by proc~~str_is_comment~~CalledByGraph proc~str_is_comment str_is_comment proc~readline readline proc~readline->proc~str_is_comment proc~read_config read_config proc~read_config->proc~readline proc~read_control read_control proc~read_control->proc~readline program~main main program~main->proc~read_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_is_comment.html"},{"title":"str_compact – BROWNPAK","text":"public pure function str_compact(str) result(ostr) Returns a copy of str with multiple spaces and tabs converted to\n single spaces, control characters deleted, and leading and trailing\n spaces removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable Called by proc~~str_compact~~CalledByGraph proc~str_compact str_compact proc~str_split str_split proc~str_split->proc~str_compact proc~read_config read_config proc~read_config->proc~str_split Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_compact.html"},{"title":"str_remove_stcc – BROWNPAK","text":"public pure function str_remove_stcc(str) result(ostr) Returns a copy of the string str with spaces, tabs, and\n control characters removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_remove_stcc.html"},{"title":"str_to_upper – BROWNPAK","text":"public pure function str_to_upper(str) result(ucstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to uppercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) Contents None","tags":"","loc":"proc/str_to_upper.html"},{"title":"str_to_lower – BROWNPAK","text":"public pure function str_to_lower(str) result(lcstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to lowercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) Contents None","tags":"","loc":"proc/str_to_lower.html"},{"title":"str_from_inum – BROWNPAK","text":"private pure function str_from_inum(num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Called by proc~~str_from_inum~~CalledByGraph proc~str_from_inum str_from_inum interface~str_from_num str_from_num interface~str_from_num->proc~str_from_inum proc~mpcd_run mpcd_run proc~mpcd_run->interface~str_from_num proc~rlx_run rlx_run proc~rlx_run->interface~str_from_num proc~bond_fene bond_fene proc~bond_fene->interface~str_from_num proc~bond_ms bond_ms proc~bond_ms->interface~str_from_num proc~bds_run bds_run proc~bds_run->interface~str_from_num proc~bds_integrate_hi bds_integrate_hi proc~bds_run->proc~bds_integrate_hi proc~bds_integrate_hi->interface~str_from_num proc~bond_kg bond_kg proc~bond_kg->interface~str_from_num program~main main program~main->proc~mpcd_run program~main->proc~rlx_run program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_from_inum.html"},{"title":"str_from_ilnum – BROWNPAK","text":"private pure function str_from_ilnum(num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Called by proc~~str_from_ilnum~~CalledByGraph proc~str_from_ilnum str_from_ilnum interface~str_from_num str_from_num interface~str_from_num->proc~str_from_ilnum proc~mpcd_run mpcd_run proc~mpcd_run->interface~str_from_num proc~rlx_run rlx_run proc~rlx_run->interface~str_from_num proc~bond_fene bond_fene proc~bond_fene->interface~str_from_num proc~bond_ms bond_ms proc~bond_ms->interface~str_from_num proc~bds_run bds_run proc~bds_run->interface~str_from_num proc~bds_integrate_hi bds_integrate_hi proc~bds_run->proc~bds_integrate_hi proc~bds_integrate_hi->interface~str_from_num proc~bond_kg bond_kg proc~bond_kg->interface~str_from_num program~main main program~main->proc~mpcd_run program~main->proc~rlx_run program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_from_ilnum.html"},{"title":"str_from_dnum – BROWNPAK","text":"private pure function str_from_dnum(num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Calls proc~~str_from_dnum~~CallsGraph proc~str_from_dnum str_from_dnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~str_from_dnum~~CalledByGraph proc~str_from_dnum str_from_dnum interface~str_from_num str_from_num interface~str_from_num->proc~str_from_dnum proc~mpcd_run mpcd_run proc~mpcd_run->interface~str_from_num proc~rlx_run rlx_run proc~rlx_run->interface~str_from_num proc~bond_fene bond_fene proc~bond_fene->interface~str_from_num proc~bond_ms bond_ms proc~bond_ms->interface~str_from_num proc~bds_run bds_run proc~bds_run->interface~str_from_num proc~bds_integrate_hi bds_integrate_hi proc~bds_run->proc~bds_integrate_hi proc~bds_integrate_hi->interface~str_from_num proc~bond_kg bond_kg proc~bond_kg->interface~str_from_num program~main main program~main->proc~mpcd_run program~main->proc~rlx_run program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_from_dnum.html"},{"title":"str_trimzero – BROWNPAK","text":"public pure function str_trimzero(str) result(res) Deletes nonsignificant trailing zeroes from number string str. If number\n string ends in a decimal point, one trailing zero is added. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable Called by proc~~str_trimzero~~CalledByGraph proc~str_trimzero str_trimzero proc~str_from_dnum str_from_dnum proc~str_from_dnum->proc~str_trimzero interface~str_from_num str_from_num interface~str_from_num->proc~str_from_dnum proc~mpcd_run mpcd_run proc~mpcd_run->interface~str_from_num proc~rlx_run rlx_run proc~rlx_run->interface~str_from_num proc~bond_fene bond_fene proc~bond_fene->interface~str_from_num proc~bond_ms bond_ms proc~bond_ms->interface~str_from_num proc~bds_run bds_run proc~bds_run->interface~str_from_num proc~bds_integrate_hi bds_integrate_hi proc~bds_run->proc~bds_integrate_hi proc~bds_integrate_hi->interface~str_from_num proc~bond_kg bond_kg proc~bond_kg->interface~str_from_num program~main main program~main->proc~mpcd_run program~main->proc~rlx_run program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_trimzero.html"},{"title":"str_to_d – BROWNPAK","text":"public pure function str_to_d(str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value real(kind=rp) Called by proc~~str_to_d~~CalledByGraph proc~str_to_d str_to_d proc~read_control read_control proc~read_control->proc~str_to_d program~main main program~main->proc~read_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_to_d.html"},{"title":"str_to_i – BROWNPAK","text":"public pure function str_to_i(str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer Called by proc~~str_to_i~~CalledByGraph proc~str_to_i str_to_i proc~read_config read_config proc~read_config->proc~str_to_i proc~read_control read_control proc~read_control->proc~str_to_i program~main main program~main->proc~read_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_to_i.html"},{"title":"str_strip – BROWNPAK","text":"public pure function str_strip(str, chars, ends) result(ostr) Returns a copy of string str with the leading and trailing characters\n removed. The chars argument is a string specifying the set of characters to\n be removed.  The chars argument is not a prefix or suffix; rather, all\n combinations of its values are stripped. If ends = 'l' , only leading\n characters are removed, if ends = 'r' , only trailing characters are\n removed, and if ends = 'b' both leading and trailing characters are\n removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: chars character(len=1), intent(in) :: ends {'l', 'r', 'b'} Return Value character(len=:),\n  allocatable Called by proc~~str_strip~~CalledByGraph proc~str_strip str_strip proc~rlx_run rlx_run proc~rlx_run->proc~str_strip program~main main program~main->proc~rlx_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_strip.html"},{"title":"str_startswith – BROWNPAK","text":"public pure function str_startswith(str, prefix, start, finish) result(res) Returns .true. if the string str starts with prefix , otherwise\n returns .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: prefix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical Called by proc~~str_startswith~~CalledByGraph proc~str_startswith str_startswith proc~read_config read_config proc~read_config->proc~str_startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_startswith.html"},{"title":"str_endswith – BROWNPAK","text":"public pure function str_endswith(str, suffix, start, finish) result(res) Returns .true. if the string str ends with suffix , otherwise\n return .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical Contents None","tags":"","loc":"proc/str_endswith.html"},{"title":"str_shift – BROWNPAK","text":"public subroutine str_shift(str, n) Shifts characters in str by n positions (positive values\n denote a right shift and negative values denote a left shift). Characters\n that are shifted off the end are lost. Positions opened up by the shift \n are replaced by spaces. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str integer, intent(in) :: n Called by proc~~str_shift~~CalledByGraph proc~str_shift str_shift proc~str_insert str_insert proc~str_insert->proc~str_shift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_shift.html"},{"title":"str_insert – BROWNPAK","text":"public subroutine str_insert(str, substr, loc) Inserts the string substr into the string str at position loc . \n Characters in str starting at position loc are shifted right to\n make room for the inserted string. Trailing spaces of substr are \n removed prior to insertion. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in) :: loc Calls proc~~str_insert~~CallsGraph proc~str_insert str_insert proc~str_shift str_shift proc~str_insert->proc~str_shift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_insert.html"},{"title":"str_del – BROWNPAK","text":"public subroutine str_del(str, substr, n) Deletes first n occurrences of substring substr from string str and\n shifts characters left to fill hole. If n < 0 , all occurances are\n deleted.  If n is not explicitly provided, it defaults to removing the\n first occurrence. Trailing spaces or blanks are not considered part of substr . Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in), optional :: n Contents None","tags":"","loc":"proc/str_del.html"},{"title":"str_strip_comment – BROWNPAK","text":"public subroutine str_strip_comment(str, comment_str) Strips trailing comment from a string. The comment is assumed to begin with the sequence of characters in comment_str . If the sequence comment_str is not found within str ,\n  no changes are made. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str Input string character(len=*), intent(in) :: comment_str String indicating beginning of a comment. Called by proc~~str_strip_comment~~CalledByGraph proc~str_strip_comment str_strip_comment proc~readline readline proc~readline->proc~str_strip_comment proc~read_config read_config proc~read_config->proc~readline proc~read_control read_control proc~read_control->proc~readline program~main main program~main->proc~read_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_strip_comment.html"},{"title":"str_get_keyval – BROWNPAK","text":"public subroutine str_get_keyval(str, key, val, delimiter) Split a string str into two strings, key and val based on space\n delimiter. A non-empty non-comment string should be passed to this subroutine.\n Keys can have corresponding empty values, but keys must always be present Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=:), intent(out), allocatable :: key character(len=:), intent(out), allocatable :: val character(len=*), intent(in), optional :: delimiter Called by proc~~str_get_keyval~~CalledByGraph proc~str_get_keyval str_get_keyval proc~read_control read_control proc~read_control->proc~str_get_keyval program~main main program~main->proc~str_get_keyval program~main->proc~read_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_get_keyval.html"},{"title":"str_match – BROWNPAK","text":"public subroutine str_match(str, ipos, imatch) This routine finds the delimiter in string str that matches the delimiter\n in position ipos of str . The argument imatch contains the position of\n the matching delimiter. Allowable delimiters are (), [], {}, <>. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: ipos integer, intent(out) :: imatch Contents None","tags":"","loc":"proc/str_match.html"},{"title":"str_compact_rlstr – BROWNPAK","text":"public subroutine str_compact_rlstr(str) Compact a string representing a real number, so that the same value is\n displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str string representation of a real number. Contents None","tags":"","loc":"proc/str_compact_rlstr.html"},{"title":"str_split – BROWNPAK","text":"public subroutine str_split(str, delimiter, before) Routine finds the first instance of a character from delims in the the\n string str . The characters before the found delimiter are output in before . The characters after the found delimiter are output in str .\n Repeated applications of this routine can be used to parse a string into its\n component parts. Multiple whitespaces of str are compacted into a single\n whitespace before splitting begins. If either str or delimiter is\n empty, an empty string is retured in before and str remains\n unchanged. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: delimiter character(len=:), intent(out), allocatable :: before Calls proc~~str_split~~CallsGraph proc~str_split str_split proc~str_compact str_compact proc~str_split->proc~str_compact Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~str_split~~CalledByGraph proc~str_split str_split proc~read_config read_config proc~read_config->proc~str_split Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_split.html"},{"title":"str_append – BROWNPAK","text":"public subroutine str_append(dest, source, sep) Appends a copy of the source string to the dest string, with \n optional string sep in between. It is assumed that dest is long\n enough to hold the result, otherwise an error will be generated. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: dest character(len=*), intent(in) :: source character(len=*), intent(in), optional :: sep Contents None","tags":"","loc":"proc/str_append.html"},{"title":"readline – BROWNPAK","text":"public subroutine readline(nunitr, line, comment_str, ios) Reads a line from unit=nunitr, ignoring blank lines\n  and deleting comments Arguments Type Intent Optional Attributes Name integer, intent(in) :: nunitr character(len=*), intent(inout) :: line character(len=*), intent(in) :: comment_str integer, intent(out) :: ios Calls proc~~readline~~CallsGraph proc~readline readline proc~str_is_comment str_is_comment proc~readline->proc~str_is_comment proc~str_strip_comment str_strip_comment proc~readline->proc~str_strip_comment Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readline~~CalledByGraph proc~readline readline proc~read_config read_config proc~read_config->proc~readline proc~read_control read_control proc~read_control->proc~readline program~main main program~main->proc~read_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/readline.html"},{"title":"str_from_num – BROWNPAK","text":"public interface str_from_num Generic  interface for writing a number to a string. The calling syntax is str_from_num(num, frmt) where number is a real number or an integer, format is the format desired, e.g., e15.6 , i5 , etc. Calls interface~~str_from_num~~CallsGraph interface~str_from_num str_from_num proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~str_from_num~~CalledByGraph interface~str_from_num str_from_num proc~mpcd_run mpcd_run proc~mpcd_run->interface~str_from_num proc~rlx_run rlx_run proc~rlx_run->interface~str_from_num proc~bond_fene bond_fene proc~bond_fene->interface~str_from_num proc~bond_ms bond_ms proc~bond_ms->interface~str_from_num proc~bds_run bds_run proc~bds_run->interface~str_from_num proc~bds_integrate_hi bds_integrate_hi proc~bds_run->proc~bds_integrate_hi proc~bds_integrate_hi->interface~str_from_num proc~bond_kg bond_kg proc~bond_kg->interface~str_from_num program~main main program~main->proc~mpcd_run program~main->proc~rlx_run program~main->proc~bds_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures str_from_inum str_from_ilnum str_from_dnum Module Procedures private pure function str_from_inum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_ilnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_dnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/str_from_num.html"},{"title":"itbl_is_in – BROWNPAK","text":"private function itbl_is_in(this, irow, val) result(res) Returns .true. if val is in row irow , .false. otherwise. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: val Return Value logical Contents None","tags":"","loc":"proc/itbl_is_in.html"},{"title":"itbl_get_val – BROWNPAK","text":"private function itbl_get_val(this, irow, j) result(res) Returns the j th element of row irow Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: j Return Value integer Contents None","tags":"","loc":"proc/itbl_get_val.html"},{"title":"itbl_init – BROWNPAK","text":"public subroutine itbl_init(this, num_rows, ierr) Creates an empty itable_t with num_rows rows and all rows having\n zero elements. Arguments Type Intent Optional Attributes Name type( itable_t ), intent(inout) :: this integer, intent(in) :: num_rows Must be > 0 integer, intent(out), optional :: ierr Calls proc~~itbl_init~~CallsGraph proc~itbl_init itbl_init proc~ivector_init ivector_init proc~itbl_init->proc~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~itbl_init~~CalledByGraph proc~itbl_init itbl_init proc~verlet_init verlet_init proc~verlet_init->proc~itbl_init proc~atdh_build atdh_build proc~atdh_build->proc~itbl_init proc~atan_build atan_build proc~atan_build->proc~itbl_init proc~atbo_build atbo_build proc~atbo_build->proc~itbl_init proc~atat_build atat_build proc~atat_build->proc~itbl_init proc~exat_build exat_build proc~exat_build->proc~itbl_init proc~exat_build->proc~atat_build proc~ia_setup ia_setup proc~ia_setup->proc~atbo_build proc~ia_setup->proc~exat_build proc~setup setup proc~setup->proc~ia_setup program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/itbl_init.html"},{"title":"itbl_delete – BROWNPAK","text":"private subroutine itbl_delete(this) Deletes an itable_t . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/itbl_delete.html"},{"title":"itbl_clear – BROWNPAK","text":"private subroutine itbl_clear(this) Clears all rows. Does not deallocate memory. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/itbl_clear.html"},{"title":"itbl_append – BROWNPAK","text":"private subroutine itbl_append(this, irow, val) Appends an element val to row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: val Contents None","tags":"","loc":"proc/itbl_append.html"},{"title":"itbl_set_val – BROWNPAK","text":"private subroutine itbl_set_val(this, irow, j, val) Sets the value of the j th element of row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: j integer, intent(in) :: val Contents None","tags":"","loc":"proc/itbl_set_val.html"},{"title":"itbl_get_row – BROWNPAK","text":"private subroutine itbl_get_row(this, irow, res) Returns a pointer to the row data of irow . No bounds checking is performed. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in), target :: this integer, intent(in) :: irow integer, intent(out), dimension(:), pointer :: res Contents None","tags":"","loc":"proc/itbl_get_row.html"},{"title":"itbl_shrink_to_fit – BROWNPAK","text":"private subroutine itbl_shrink_to_fit(this, ierr) Releases additional memory to fit underlying data. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/itbl_shrink_to_fit.html"},{"title":"itbl_print – BROWNPAK","text":"private subroutine itbl_print(this) Prints an itable_t . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this Contents None","tags":"","loc":"proc/itbl_print.html"},{"title":"traj_create – BROWNPAK","text":"public subroutine traj_create(this, fn, na, nam, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of non-MPCD atoms integer, intent(in) :: nam Number of MPCD atoms, pass zero to indicate no data from MPCD\n particles are present. integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges Contents None","tags":"","loc":"proc/traj_create.html"},{"title":"traj_open – BROWNPAK","text":"public subroutine traj_open(this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/traj_open.html"},{"title":"traj_clear – BROWNPAK","text":"public subroutine traj_clear(this) After a call to this subroutine, all memory within this is deallocated,\n all components of this are reset to zero, and the underlying file is\n closed (if open). Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/traj_clear.html"},{"title":"traj_close – BROWNPAK","text":"public subroutine traj_close(this) Closes the underlying file of a trajectory_t . Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/traj_close.html"},{"title":"traj_read – BROWNPAK","text":"public subroutine traj_read(this, iframe, nts, ierr, mflag, coordinates, velocities, forces, charge) Read from an open trajectory. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(in) :: this integer, intent(in) :: iframe Frame number integer(kind=ip_long), intent(out) :: nts Time step counter integer, intent(out) :: ierr Error flag integer, intent(in), optional :: mflag 1: Only non-MPCD data, 2: Only MPCD data, 3: All data real(kind=rp), intent(out), optional dimension(:,:) :: coordinates real(kind=rp), intent(out), optional dimension(:,:) :: velocities real(kind=rp), intent(out), optional dimension(:,:) :: forces real(kind=rp), intent(out), optional dimension(:) :: charge Contents None","tags":"","loc":"proc/traj_read.html"},{"title":"traj_append_frame – BROWNPAK","text":"public subroutine traj_append_frame(this, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge Contents None","tags":"","loc":"proc/traj_append_frame.html"},{"title":"traj_write_frame – BROWNPAK","text":"public subroutine traj_write_frame(this, iframe, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer, intent(in) :: iframe integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge Contents None","tags":"","loc":"proc/traj_write_frame.html"},{"title":"scalar_triple_product – BROWNPAK","text":"public function scalar_triple_product(a, b, c) result(res) Returns the scalar triple product a .( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c Return Value real(kind=rp) Contents None","tags":"","loc":"proc/scalar_triple_product.html"},{"title":"det – BROWNPAK","text":"public function det(A) result(res) Returns the determinant of an (N x N) matrix, where N = 2, 3, or 4. Original routine by David Simpson Note For a general NxN matrix do an LU decomp Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (N,N) array, where N = 2, 3, or 4. Return Value real(kind=rp) Called by proc~~det~~CalledByGraph proc~det det proc~mpcd_collide mpcd_collide proc~mpcd_collide->proc~det proc~eigval_33rsym eigval_33rsym proc~eigval_33rsym->proc~det proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_collide program~main main program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/det.html"},{"title":"trace – BROWNPAK","text":"public function trace(mat) result(res) Returns the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mat (:,:) (N,N) array Return Value real(kind=rp) Contents None","tags":"","loc":"proc/trace.html"},{"title":"isclose – BROWNPAK","text":"public elemental function isclose(a, b, rel_tol, abs_tol) Checks if two floating point numbers of type double are close within\n  tolerance. Based on python implementation at https://github.com/PythonCHB/close_pep/blob/master/is_close.py .\n  The method='weak' option is used here. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b real(kind=rp), intent(in), optional :: rel_tol Relative tolerance, rel_tol >= 0, default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance, abs_tol >= 0, default 0.0 Return Value logical Called by proc~~isclose~~CalledByGraph proc~isclose isclose proc~allclose_rank1 allclose_rank1 proc~allclose_rank1->proc~isclose proc~unitize unitize proc~unitize->proc~isclose proc~eigval_33rsym eigval_33rsym proc~eigval_33rsym->proc~isclose proc~allclose_rank2 allclose_rank2 proc~allclose_rank2->proc~isclose proc~allclose_rank3 allclose_rank3 proc~allclose_rank3->proc~isclose interface~allclose allclose interface~allclose->proc~allclose_rank1 interface~allclose->proc~allclose_rank2 interface~allclose->proc~allclose_rank3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/isclose.html"},{"title":"allclose_rank1 – BROWNPAK","text":"public function allclose_rank1(a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical Calls proc~~allclose_rank1~~CallsGraph proc~allclose_rank1 allclose_rank1 proc~isclose isclose proc~allclose_rank1->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allclose_rank1~~CalledByGraph proc~allclose_rank1 allclose_rank1 interface~allclose allclose interface~allclose->proc~allclose_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/allclose_rank1.html"},{"title":"allclose_rank2 – BROWNPAK","text":"public function allclose_rank2(a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical Calls proc~~allclose_rank2~~CallsGraph proc~allclose_rank2 allclose_rank2 proc~isclose isclose proc~allclose_rank2->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allclose_rank2~~CalledByGraph proc~allclose_rank2 allclose_rank2 interface~allclose allclose interface~allclose->proc~allclose_rank2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/allclose_rank2.html"},{"title":"allclose_rank3 – BROWNPAK","text":"public function allclose_rank3(a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical Calls proc~~allclose_rank3~~CallsGraph proc~allclose_rank3 allclose_rank3 proc~isclose isclose proc~allclose_rank3->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allclose_rank3~~CalledByGraph proc~allclose_rank3 allclose_rank3 interface~allclose allclose interface~allclose->proc~allclose_rank3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/allclose_rank3.html"},{"title":"get_quad_form – BROWNPAK","text":"public function get_quad_form(A, x) result(res) Calculates the quadratic form x&#94;T A x , where A is an n x n matrix and x is a\n  vector of length n Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (n,n) array real(kind=rp), intent(in), dimension(:) :: x (n,) array Return Value real(kind=rp) Contents None","tags":"","loc":"proc/get_quad_form.html"},{"title":"rad2deg – BROWNPAK","text":"public elemental subroutine rad2deg(rad, deg) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rad real(kind=rp), intent(out) :: deg Contents None","tags":"","loc":"proc/rad2deg.html"},{"title":"deg2rad – BROWNPAK","text":"public elemental subroutine deg2rad(deg, rad) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: deg real(kind=rp), intent(out) :: rad Contents None","tags":"","loc":"proc/deg2rad.html"},{"title":"cross – BROWNPAK","text":"public subroutine cross(a, b, c) Calculates the cross product between two 3-element vectors Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(out), dimension(3) :: c Cross product of a and b ; c = a x b Called by proc~~cross~~CalledByGraph proc~cross cross proc~mpcd_collide mpcd_collide proc~mpcd_collide->proc~cross proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_collide program~main main program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cross.html"},{"title":"cross_mat – BROWNPAK","text":"public subroutine cross_mat(a, mat) Calculates the cross product matrix of a 3-element vector. The cross\n product matrix A of a is defined as a x b = A . b ,\n where b is another 3-element vector. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(out), dimension(3,3) :: mat Cross product matrix of a Contents None","tags":"","loc":"proc/cross_mat.html"},{"title":"outer – BROWNPAK","text":"public subroutine outer(a, b, c) Calculates the outer product of two vectors, c_{ij} = a_i  b_j . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (n,) array real(kind=rp), intent(out), dimension(:,:) :: c (m,n) array; Outer product Contents None","tags":"","loc":"proc/outer.html"},{"title":"vector_triple_product – BROWNPAK","text":"public subroutine vector_triple_product(a, b, c, d) Returns the vector triple product d = a x ( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c real(kind=rp), intent(out), dimension(3) :: d Vector triple product Contents None","tags":"","loc":"proc/vector_triple_product.html"},{"title":"swap_integer – BROWNPAK","text":"public elemental subroutine swap_integer(a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b Called by proc~~swap_integer~~CalledByGraph proc~swap_integer swap_integer interface~swap swap interface~swap->proc~swap_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_integer.html"},{"title":"swap_real – BROWNPAK","text":"public elemental subroutine swap_real(a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b Called by proc~~swap_real~~CalledByGraph proc~swap_real swap_real interface~swap swap interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_real.html"},{"title":"swap_complex – BROWNPAK","text":"public elemental subroutine swap_complex(a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b Called by proc~~swap_complex~~CalledByGraph proc~swap_complex swap_complex interface~swap swap interface~swap->proc~swap_complex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_complex.html"},{"title":"unitize – BROWNPAK","text":"public subroutine unitize(a) Normalizes a vector in-place. If the magnitude of the vector is nearly\n zero, no normalization takes place and the vector is returned as is with\n a warning message. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: a (m,) array Calls proc~~unitize~~CallsGraph proc~unitize unitize proc~isclose isclose proc~unitize->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/unitize.html"},{"title":"linspace – BROWNPAK","text":"public subroutine linspace(start, finish, num, val, step) Generates evenly spaced numbers over a specified interval. Both end\n points are included. If start < finish , the returned step size (if step is present) will be negative. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point real(kind=rp), intent(in) :: finish Ending point, finish /= start integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(out), optional :: step Step size Called by proc~~linspace~~CalledByGraph proc~linspace linspace proc~logspace logspace proc~logspace->proc~linspace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/linspace.html"},{"title":"logspace – BROWNPAK","text":"public subroutine logspace(start, finish, num, val, base) Generates numbers spaced evenly on a log scale.\n  In linear space, the sequence starts at base ** start ( base to the power of start ) and ends with base ** stop Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point, base ** start is the starting value real(kind=rp), intent(in) :: finish Ending point, finish /= start , base ** start is the ending value integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(in), optional :: base Base of the logspace, default 10 Calls proc~~logspace~~CallsGraph proc~logspace logspace proc~linspace linspace proc~logspace->proc~linspace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/logspace.html"},{"title":"identity – BROWNPAK","text":"public subroutine identity(mat_eye) Creates an identity matrix of size n x n. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:) :: mat_eye (n,n) array Called by proc~~identity~~CalledByGraph proc~identity identity proc~eigval_33rsym eigval_33rsym proc~eigval_33rsym->proc~identity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/identity.html"},{"title":"get_diagonal – BROWNPAK","text":"public subroutine get_diagonal(mat, d) Returns the diagonal elements of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mat (n,n) array real(kind=rp), intent(out), dimension(:) :: d (n,) array; contains the entries of the main diagonal Contents None","tags":"","loc":"proc/get_diagonal.html"},{"title":"add_transpose – BROWNPAK","text":"public subroutine add_transpose(mat) Adds a square matrix and its transpose in place: A_{ij} = A_{ij } + A_{ji} Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat (n,n) array Contents None","tags":"","loc":"proc/add_transpose.html"},{"title":"subtract_transpose – BROWNPAK","text":"public subroutine subtract_transpose(mat) Calculates the difference of a square matrix and its transpose in place: A_{ij} = A_{ij } - A_{ji} Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat Contents None","tags":"","loc":"proc/subtract_transpose.html"},{"title":"multiply_transpose – BROWNPAK","text":"public subroutine multiply_transpose(A, B) Multiplies a matrix with its transpose: \\mathbf{\\mathrm{B}} = \\mathbf{\\mathrm{A}} \\cdot \\mathbf{\\mathrm{A}}&#94;T Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (m,n) array real(kind=rp), intent(out), dimension(:,:) :: B (m,m) array Contents None","tags":"","loc":"proc/multiply_transpose.html"},{"title":"orth – BROWNPAK","text":"public subroutine orth(a) Orthogonalizes a set of vectors in-place using Gram-Schmidt orthonormalization Reference: Golub and Van Loan, Matrix Computations, 3rd edition, Section 5.2.8,\n Algorithm 5.2.5, p. 231. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: a (m,n) array, where m <= n. The first m columns of the matrix are\n  overwritten with the orthogonal basis vectors. Contents None","tags":"","loc":"proc/orth.html"},{"title":"invert_mat33 – BROWNPAK","text":"public subroutine invert_mat33(a, inv_a) Inverts a 3x3 matrix. Reference: https://www.geometrictools.com/Documentation/LaplaceExpansionTheorem.pdf Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3,3) :: inv_a Called by proc~~invert_mat33~~CalledByGraph proc~invert_mat33 invert_mat33 proc~mpcd_collide mpcd_collide proc~mpcd_collide->proc~invert_mat33 proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_collide program~main main program~main->proc~mpcd_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/invert_mat33.html"},{"title":"eigval_33rsym – BROWNPAK","text":"public subroutine eigval_33rsym(a, ev) Calculates the eigenvalues of a 3 x 3 real symmetric matrix. The\n eigenvalues calculated are in decreasing order. Only the diagonal and\n lower triangular part of the matrix is accessed. Reference: https://en.wikipedia.org/wiki/Eigenvalue_algorithm#cite_note-Smith-12 See also David Eberly's notes and implementation at \n https://www.geometrictools.com/Documentation/RobustEigenSymmetric3x3.pdf Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3) :: ev Calls proc~~eigval_33rsym~~CallsGraph proc~eigval_33rsym eigval_33rsym proc~isclose isclose proc~eigval_33rsym->proc~isclose proc~det det proc~eigval_33rsym->proc~det proc~identity identity proc~eigval_33rsym->proc~identity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/eigval_33rsym.html"},{"title":"dsyevc3 – BROWNPAK","text":"public subroutine dsyevc3(A, W) Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's\n analytical algorithm.\n Only the diagonal and upper triangular parts of A are accessed. The access\n is read-only. Copyright (C) 2006  Joachim Kopp Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), DIMENSION(3,3) :: A real(kind=RP), intent(out), DIMENSION(3) :: W (3) Contents None","tags":"","loc":"proc/dsyevc3~2.html"},{"title":"allclose – BROWNPAK","text":"public interface allclose Checks if two arrays are elementwise close within tolerance Calls interface~~allclose~~CallsGraph interface~allclose allclose proc~allclose_rank1 allclose_rank1 interface~allclose->proc~allclose_rank1 proc~allclose_rank2 allclose_rank2 interface~allclose->proc~allclose_rank2 proc~allclose_rank3 allclose_rank3 interface~allclose->proc~allclose_rank3 proc~isclose isclose proc~allclose_rank1->proc~isclose proc~allclose_rank2->proc~isclose proc~allclose_rank3->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures allclose_rank1 allclose_rank2 allclose_rank3 Module Procedures public function allclose_rank1 (a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank2 (a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank3 (a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical","tags":"","loc":"interface/allclose.html"},{"title":"swap – BROWNPAK","text":"public interface swap Swaps two arrays Calls interface~~swap~~CallsGraph interface~swap swap proc~swap_real swap_real interface~swap->proc~swap_real proc~swap_integer swap_integer interface~swap->proc~swap_integer proc~swap_complex swap_complex interface~swap->proc~swap_complex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures swap_integer swap_real swap_complex Module Procedures public elemental subroutine swap_integer (a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b public elemental subroutine swap_real (a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b public elemental subroutine swap_complex (a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b","tags":"","loc":"interface/swap.html"},{"title":"ivector_get_len – BROWNPAK","text":"public function ivector_get_len(this) result(res) Returns the length of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/ivector_get_len.html"},{"title":"dvector_get_len – BROWNPAK","text":"public function dvector_get_len(this) result(res) Returns the length of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/dvector_get_len.html"},{"title":"ivector_get_val – BROWNPAK","text":"public function ivector_get_val(this, i) result(res) Returns the ith element of an ivector . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/ivector_get_val.html"},{"title":"dvector_get_val – BROWNPAK","text":"public function dvector_get_val(this, i) result(res) Returns the ith element of a dvector . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rp) Contents None","tags":"","loc":"proc/dvector_get_val.html"},{"title":"ivector_init – BROWNPAK","text":"public subroutine ivector_init(this, len_init, ierr) Creates an empty ivector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr Called by proc~~ivector_init~~CalledByGraph proc~ivector_init ivector_init proc~itbl_init itbl_init proc~itbl_init->proc~ivector_init proc~cl_init cl_init proc~cl_init->proc~ivector_init proc~ivector_from_array ivector_from_array proc~ivector_from_array->proc~ivector_init proc~atat_build atat_build proc~atat_build->proc~ivector_init proc~atat_build->proc~itbl_init proc~exat_build exat_build proc~exat_build->proc~ivector_init proc~exat_build->proc~itbl_init proc~exat_build->proc~atat_build proc~verlet_init verlet_init proc~verlet_init->proc~itbl_init proc~ia_setup ia_setup proc~ia_setup->proc~cl_init proc~ia_setup->proc~exat_build proc~atbo_build atbo_build proc~ia_setup->proc~atbo_build proc~atdh_build atdh_build proc~atdh_build->proc~itbl_init proc~atan_build atan_build proc~atan_build->proc~itbl_init proc~atbo_build->proc~itbl_init proc~setup setup proc~setup->proc~ia_setup program~main main program~main->proc~setup var panprocivector_initCalledByGraph = svgPanZoom('#procivector_initCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ivector_init.html"},{"title":"dvector_init – BROWNPAK","text":"public subroutine dvector_init(this, len_init, ierr) Creates an empty dvector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr Called by proc~~dvector_init~~CalledByGraph proc~dvector_init dvector_init proc~dvector_from_array dvector_from_array proc~dvector_from_array->proc~dvector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dvector_init.html"},{"title":"ivector_from_array – BROWNPAK","text":"public subroutine ivector_from_array(this, x) Creates an ivector with all elements from an array Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), dimension(:) :: x Calls proc~~ivector_from_array~~CallsGraph proc~ivector_from_array ivector_from_array proc~ivector_init ivector_init proc~ivector_from_array->proc~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ivector_from_array.html"},{"title":"dvector_from_array – BROWNPAK","text":"public subroutine dvector_from_array(this, x) Creates a dvector with all elements from an array Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(:) :: x Calls proc~~dvector_from_array~~CallsGraph proc~dvector_from_array dvector_from_array proc~dvector_init dvector_init proc~dvector_from_array->proc~dvector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dvector_from_array.html"},{"title":"ivector_delete – BROWNPAK","text":"public subroutine ivector_delete(this) Deletes an ivector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/ivector_delete.html"},{"title":"dvector_delete – BROWNPAK","text":"public subroutine dvector_delete(this) Deletes a dvector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/dvector_delete.html"},{"title":"ivector_clear – BROWNPAK","text":"public subroutine ivector_clear(this) Clears an ivector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/ivector_clear.html"},{"title":"dvector_clear – BROWNPAK","text":"public subroutine dvector_clear(this) Clears a dvector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Contents None","tags":"","loc":"proc/dvector_clear.html"},{"title":"ivector_assign – BROWNPAK","text":"public subroutine ivector_assign(this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other Called by proc~~ivector_assign~~CalledByGraph proc~ivector_assign ivector_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~ivector_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ivector_assign.html"},{"title":"dvector_assign – BROWNPAK","text":"public subroutine dvector_assign(this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other Called by proc~~dvector_assign~~CalledByGraph proc~dvector_assign dvector_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~dvector_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dvector_assign.html"},{"title":"i_dvector_assign – BROWNPAK","text":"public subroutine i_dvector_assign(this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other Called by proc~~i_dvector_assign~~CalledByGraph proc~i_dvector_assign i_dvector_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~i_dvector_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/i_dvector_assign.html"},{"title":"ivector_set_val – BROWNPAK","text":"public subroutine ivector_set_val(this, i, val) Sets the value of the ith element of an ivector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: val Contents None","tags":"","loc":"proc/ivector_set_val.html"},{"title":"dvector_set_val – BROWNPAK","text":"public subroutine dvector_set_val(this, i, val) Sets the value of the ith element of a dvector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: i real(kind=rp), intent(in) :: val Contents None","tags":"","loc":"proc/dvector_set_val.html"},{"title":"ivector_append – BROWNPAK","text":"public subroutine ivector_append(this, val) Adds an element to the end of an ivector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: val Contents None","tags":"","loc":"proc/ivector_append.html"},{"title":"dvector_append – BROWNPAK","text":"public subroutine dvector_append(this, val) Adds an element to the end of a dvector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this real(kind=rp), intent(in) :: val Contents None","tags":"","loc":"proc/dvector_append.html"},{"title":"ivector_get_data – BROWNPAK","text":"public subroutine ivector_get_data(this, res, ibeg, iend) Returns a pointer to the underlying data of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in), target :: this integer, intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend Contents None","tags":"","loc":"proc/ivector_get_data.html"},{"title":"dvector_get_data – BROWNPAK","text":"public subroutine dvector_get_data(this, res, ibeg, iend) Returns a pointer to the underlying data of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in), target :: this real(kind=rp), intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend Contents None","tags":"","loc":"proc/dvector_get_data.html"},{"title":"ivector_shrink_to_fit – BROWNPAK","text":"public subroutine ivector_shrink_to_fit(this, ierr) Releases additional memory to fit underlying data of an ivector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/ivector_shrink_to_fit.html"},{"title":"dvector_shrink_to_fit – BROWNPAK","text":"public subroutine dvector_shrink_to_fit(this, ierr) Releases additional memory to fit underlying data of a dvector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/dvector_shrink_to_fit.html"},{"title":"ivector_sort – BROWNPAK","text":"public subroutine ivector_sort(this, order) Sorts an ivector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order Calls proc~~ivector_sort~~CallsGraph proc~ivector_sort ivector_sort proc~iqsort iqsort proc~ivector_sort->proc~iqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ivector_sort.html"},{"title":"dvector_sort – BROWNPAK","text":"public subroutine dvector_sort(this, order) Sorts a dvector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order Calls proc~~dvector_sort~~CallsGraph proc~dvector_sort dvector_sort proc~dqsort dqsort proc~dvector_sort->proc~dqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dvector_sort.html"},{"title":"ivector_unique – BROWNPAK","text":"public subroutine ivector_unique(this) Sorts and removes all duplicate entries of an ivector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call ivector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this Calls proc~~ivector_unique~~CallsGraph proc~ivector_unique ivector_unique proc~iqsort iqsort proc~ivector_unique->proc~iqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ivector_unique.html"},{"title":"dvector_unique – BROWNPAK","text":"public subroutine dvector_unique(this) Sorts and removes all duplicate entries of a dvector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call dvector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this Calls proc~~dvector_unique~~CallsGraph proc~dvector_unique dvector_unique proc~dqsort dqsort proc~dvector_unique->proc~dqsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dvector_unique.html"},{"title":"ivector_print – BROWNPAK","text":"public subroutine ivector_print(this) Prints an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Contents None","tags":"","loc":"proc/ivector_print.html"},{"title":"dvector_print – BROWNPAK","text":"public subroutine dvector_print(this) Prints a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Contents None","tags":"","loc":"proc/dvector_print.html"},{"title":"assignment(=) – BROWNPAK","text":"public interface assignment(=) Calls interface~~assignment(=)~~CallsGraph interface~assignment(=) assignment(=) proc~ivector_assign ivector_assign interface~assignment(=)->proc~ivector_assign proc~dvector_assign dvector_assign interface~assignment(=)->proc~dvector_assign proc~i_dvector_assign i_dvector_assign interface~assignment(=)->proc~i_dvector_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures ivector_assign dvector_assign i_dvector_assign Module Procedures public subroutine ivector_assign (this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine dvector_assign (this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other public subroutine i_dvector_assign (this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other","tags":"","loc":"interface/assignment(=).html"},{"title":"verlet_init – BROWNPAK","text":"public subroutine verlet_init(rskin, tskin) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rskin real(kind=rp), intent(in) :: tskin Calls proc~~verlet_init~~CallsGraph proc~verlet_init verlet_init proc~itbl_init itbl_init proc~verlet_init->proc~itbl_init proc~ivector_init ivector_init proc~itbl_init->proc~ivector_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/verlet_init.html"},{"title":"verlet_delete – BROWNPAK","text":"public subroutine verlet_delete() Arguments None Contents None","tags":"","loc":"proc/verlet_delete.html"},{"title":"verlet_build – BROWNPAK","text":"public subroutine verlet_build() Arguments None Called by proc~~verlet_build~~CalledByGraph proc~verlet_build verlet_build proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_add_vdw_forces_vl->proc~verlet_build proc~ia_calc_forces ia_calc_forces proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~mpcd_stream mpcd_stream proc~mpcd_stream->proc~ia_calc_forces proc~bds_integrate_hi bds_integrate_hi proc~bds_integrate_hi->proc~ia_calc_forces proc~rlx_integrate rlx_integrate proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd bds_integrate_fd proc~bds_integrate_fd->proc~ia_calc_forces proc~rlx_run rlx_run proc~rlx_run->proc~rlx_integrate proc~bds_run bds_run proc~bds_run->proc~bds_integrate_hi proc~bds_run->proc~bds_integrate_fd proc~mpcd_run mpcd_run proc~mpcd_run->proc~mpcd_stream program~main main program~main->proc~rlx_run program~main->proc~bds_run program~main->proc~mpcd_run var panprocverlet_buildCalledByGraph = svgPanZoom('#procverlet_buildCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/verlet_build.html"},{"title":"m_bd_solver – BROWNPAK","text":"Routines implementing Brownian Dynamics (BD) solver. Uses iso_c_binding blas95 lapack95 f95_precision m_precision m_constants_math m_strings m_ran_num m_globals m_interaction m_stats_io m_config_io m_logger module~~m_bd_solver~~UsesGraph module~m_bd_solver m_bd_solver module~m_constants_math m_constants_math module~m_bd_solver->module~m_constants_math module~m_logger m_logger module~m_bd_solver->module~m_logger module~m_interaction m_interaction module~m_bd_solver->module~m_interaction lapack95 lapack95 module~m_bd_solver->lapack95 module~m_ran_num m_ran_num module~m_bd_solver->module~m_ran_num module~m_config_io m_config_io module~m_bd_solver->module~m_config_io f95_precision f95_precision module~m_bd_solver->f95_precision module~m_precision m_precision module~m_bd_solver->module~m_precision module~m_strings m_strings module~m_bd_solver->module~m_strings blas95 blas95 module~m_bd_solver->blas95 module~m_stats_io m_stats_io module~m_bd_solver->module~m_stats_io iso_c_binding iso_c_binding module~m_bd_solver->iso_c_binding module~m_globals m_globals module~m_bd_solver->module~m_globals module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_logger->iso_fortran_env module~m_interaction->module~m_constants_math module~m_interaction->module~m_precision module~m_interaction->module~m_globals module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_cell_list m_cell_list module~m_interaction->module~m_cell_list module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl module~m_config_io->module~m_precision module~m_config_io->module~m_strings module~m_config_io->module~m_globals module~m_simbox m_simbox module~m_config_io->module~m_simbox module~m_precision->iso_fortran_env module~m_strings->module~m_precision module~m_stats_io->module~m_constants_math module~m_stats_io->module~m_precision module~m_stats_io->module~m_strings module~m_stats_io->module~m_globals module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_globals->module~m_simbox module~m_ia_dihedral->module~m_constants_math module~m_ia_dihedral->module~m_precision module~m_ia_dihedral->module~m_globals module~m_ia_angle->module~m_constants_math module~m_ia_angle->module~m_precision module~m_ia_angle->module~m_globals module~m_trajectory->module~m_logger module~m_trajectory->module~m_precision module~m_verlet->module~m_precision module~m_verlet->module~m_globals module~m_vector m_vector module~m_verlet->module~m_vector module~m_table m_table module~m_verlet->module~m_table module~m_simbox->module~m_constants_math module~m_simbox->module~m_ran_num module~m_simbox->module~m_precision module~m_cell_list->module~m_precision module~m_cell_list->module~m_globals module~m_cell_list->module~m_vector module~m_connectivity->module~m_precision module~m_connectivity->module~m_globals module~m_connectivity->module~m_vector module~m_connectivity->module~m_table module~m_ia_external->module~m_constants_math module~m_ia_external->module~m_precision module~m_ia_external->module~m_globals module~m_ia_tether->module~m_constants_math module~m_ia_tether->module~m_precision module~m_ia_tether->module~m_globals module~m_ia_bond->module~m_constants_math module~m_ia_bond->module~m_logger module~m_ia_bond->module~m_precision module~m_ia_bond->module~m_strings module~m_ia_bond->module~m_globals module~m_ia_vdw->module~m_constants_math module~m_ia_vdw->module~m_logger module~m_ia_vdw->module~m_precision module~m_ia_vdw->module~m_globals module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort module~m_table->module~m_precision module~m_table->module~m_vector module~m_qsort->module~m_precision var panmodulem_bd_solverUsesGraph = svgPanZoom('#modulem_bd_solverUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_bd_solver~~UsedByGraph module~m_bd_solver m_bd_solver program~main main program~main->module~m_bd_solver module~m_setup m_setup program~main->module~m_setup module~m_setup->module~m_bd_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables drift diffusion mobility Subroutines bds_init bds_finish bds_run bds_integrate_fd bds_integrate_hi calc_ambient_velocity calc_rpy_tensor calc_Bdw_kryl Variables Type Visibility Attributes Name Initial real(kind=rp), private, dimension(:), allocatable :: drift real(kind=rp), private, dimension(:), allocatable :: diffusion real(kind=rp), private, dimension(:,:), allocatable :: mobility Subroutines public subroutine bds_init (ierr) Initializes the BD solver. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr public subroutine bds_finish () Clears up memory allocated in bds_init . Arguments None public subroutine bds_run () Driver for BD integrator. Read more… Arguments None private subroutine bds_integrate_fd (ierr) Performs one step of free-draining BD integeration. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine bds_integrate_hi (ierr) Performs one step of BD integeration including HI. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine calc_ambient_velocity () Calculates ambient velocity at the atom positions and store it in module\n variable drift . Arguments None private subroutine calc_rpy_tensor () Calculates the RPY approximation to the mobility tensor. Overwrites\n the upper triangular part of mobility . Arguments None private subroutine calc_Bdw_kryl (D, Bdw, ierr) Calculates B.dW using Krylov subspace method. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: D (3N,3N) symmetric positive definite matrix. Read more… real(kind=rp), intent(inout), dimension(:) :: Bdw (3N,) vector. On entry contains vector dW . On return, contains B.dW , where B is the square root matrix of D . integer, intent(out) :: ierr Error flag","tags":"","loc":"module/m_bd_solver.html"},{"title":"m_cell_list – BROWNPAK","text":"Sorts atoms using a cell list. The algorithm to build the cell list partially follows the techniques in Watanabe et\n al, 2011, “Efficient Implementations of Molecular Dynamics Simulations for\n Lennard-Jones Systems,” Prog. Theor. Phys. 126, 203–235. The pairlist is not explicitly built, rather the cells are directly\n looped over during force calculation. Uses m_precision m_vector m_globals module~~m_cell_list~~UsesGraph module~m_cell_list m_cell_list module~m_vector m_vector module~m_cell_list->module~m_vector module~m_precision m_precision module~m_cell_list->module~m_precision module~m_globals m_globals module~m_cell_list->module~m_globals module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_globals->module~m_precision module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_qsort->module~m_precision module~m_simbox->module~m_precision module~m_constants_math m_constants_math module~m_simbox->module~m_constants_math module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_trajectory->module~m_precision module~m_logger m_logger module~m_trajectory->module~m_logger module~m_constants_math->module~m_precision module~m_logger->iso_fortran_env module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_cell_list~~UsedByGraph module~m_cell_list m_cell_list module~m_interaction m_interaction module~m_interaction->module~m_cell_list module~m_mpcd m_mpcd module~m_mpcd->module~m_cell_list module~m_mpcd->module~m_interaction module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_mpcd module~m_setup->module~m_bd_solver program~main main program~main->module~m_mpcd program~main->module~m_bd_solver program~main->module~m_setup module~m_relax m_relax program~main->module~m_relax module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax->module~m_interaction Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cell_size nc_max nc nct_max nct cells cells_pos cell_nbrs cell_nbrs_pos host_cells cell_pop d Functions cl_get_num_cells Subroutines cl_init cl_set_cell_size cl_build_cell_nbrs cl_delete cl_build cl_get_contents cl_get_nbr_cells cl_print Variables Type Visibility Attributes Name Initial real(kind=rp), private, dimension(3) :: cell_size = 0.0_rp Cell size along x , y , & z . integer, private, dimension(3) :: nc_max = 0 Maximum number of cells along x , y , & z . integer, private, dimension(3) :: nc = 0 Number of cells along x , y , & z . integer, private :: nct_max = 0 Maximum total number of cells. integer, private :: nct = 0 Total of cells. integer, private, dimension(:), allocatable, target :: cells (na_max,) array. Listing atoms in each cell. integer, private, dimension(:), allocatable :: cells_pos (0:nct_max,) index array. Note: 0-based indexing. type( ivector_t ), private :: cell_nbrs Lists neighbor cells for each cell. integer, private, dimension(:), allocatable :: cell_nbrs_pos (0:nct_max,) index array. Note: 0-based indexing. integer, private, dimension(:), allocatable :: host_cells (na_max,) array. host_cells(i) stores the linear index of the cell\n containing atom i . na_max is the total number of atoms under consideration. integer, private, dimension(:), allocatable :: cell_pop (0:nct_max-1,) array storing population of each cell. Note: 0-based indexing. integer, private, parameter, dimension(3,13) :: d = reshape([1, 0, 0, 1, 1, 0, -1, 1, 0, 0, 1, 0, 0, 0, 1, -1, 0, 1, 1, 0, 1, -1, -1, 1, 0, -1, 1, 1, -1, 1, -1, 1, 1, 0, 1, 1, 1, 1, 1], [3, 13]) Functions public function cl_get_num_cells () result(res) Returns the total number of cells Arguments None Return Value integer Subroutines public subroutine cl_init (na_max, cs_min) Initializes a cell list. Arguments Type Intent Optional Attributes Name integer, intent(in) :: na_max Maximum number of atoms to be handled. real(kind=rp), intent(in) :: cs_min Minimum size (i.e. length) of a cell. public subroutine cl_set_cell_size (cs) Sets the cell size. The actual cell size may be slightly larger. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: cs public subroutine cl_build_cell_nbrs () Makes a table of neighboring cells. Arguments None public subroutine cl_delete () Deallocates memory allocated in cl_init . Arguments None public subroutine cl_build (coords) Sorts atoms into cells for calculating short-range interations Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: coords public subroutine cl_get_contents (ic, res) Returns a pointer to the entries of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res public subroutine cl_get_nbr_cells (ic, res) Returns a pointer to the neighbor cells of cell with linear index ic . Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(out), dimension(:), pointer :: res public subroutine cl_print () Prints a cell list Arguments None","tags":"","loc":"module/m_cell_list.html"},{"title":"m_config_io – BROWNPAK","text":"Routines for IO of config and dump files. Uses m_precision m_strings m_simbox m_globals module~~m_config_io~~UsesGraph module~m_config_io m_config_io module~m_simbox m_simbox module~m_config_io->module~m_simbox module~m_precision m_precision module~m_config_io->module~m_precision module~m_strings m_strings module~m_config_io->module~m_strings module~m_globals m_globals module~m_config_io->module~m_globals module~m_simbox->module~m_precision module~m_constants_math m_constants_math module~m_simbox->module~m_constants_math module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_strings->module~m_precision module~m_globals->module~m_simbox module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_constants_math->module~m_precision module~m_trajectory->module~m_precision module~m_logger m_logger module~m_trajectory->module~m_logger module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl module~m_logger->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_config_io~~UsedByGraph module~m_config_io m_config_io module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_config_io module~m_setup m_setup module~m_setup->module~m_config_io module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_relax m_relax module~m_relax->module~m_config_io module~m_mpcd->module~m_config_io program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_relax program~main->module~m_mpcd Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines read_dump write_dump read_config write_config write_ldf write_xyz Subroutines public subroutine read_dump (fn) Reads from DUMP file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine write_dump (fn) Writes to DUMP file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine read_config (fn) Read from CONFIG file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine write_config (fn, title) Write to cfg file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn character(len=*), intent(in) :: title public subroutine write_ldf (fn_ld, title, with_mpcd_atoms) Write to a LAMMPS data file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn_ld Name of the file character(len=*), intent(in) :: title Title of the configuation logical, intent(in), optional :: with_mpcd_atoms Include MPCD atoms in the file? {T, F} public subroutine write_xyz (fn_xyz, title, with_mpcd_atoms) Write to an XYZ file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn_xyz Name of the XYZ file character(len=*), intent(in) :: title Title (for the configuration) logical, intent(in), optional :: with_mpcd_atoms Include MPCD atoms in the file? {T, F}","tags":"","loc":"module/m_config_io.html"},{"title":"m_connectivity – BROWNPAK","text":"Routines for building atom->bond, atom->angle, etc. tables and excluded\n atoms table. Uses m_precision m_vector m_table m_globals module~~m_connectivity~~UsesGraph module~m_connectivity m_connectivity module~m_vector m_vector module~m_connectivity->module~m_vector module~m_precision m_precision module~m_connectivity->module~m_precision module~m_table m_table module~m_connectivity->module~m_table module~m_globals m_globals module~m_connectivity->module~m_globals module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_table->module~m_vector module~m_table->module~m_precision module~m_globals->module~m_precision module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_qsort->module~m_precision module~m_simbox->module~m_precision module~m_constants_math m_constants_math module~m_simbox->module~m_constants_math module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_trajectory->module~m_precision module~m_logger m_logger module~m_trajectory->module~m_logger module~m_constants_math->module~m_precision module~m_logger->iso_fortran_env module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl var panmodulem_connectivityUsesGraph = svgPanZoom('#modulem_connectivityUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_connectivity~~UsedByGraph module~m_connectivity m_connectivity module~m_interaction m_interaction module~m_interaction->module~m_connectivity module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_mpcd->module~m_interaction module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax m_relax module~m_relax->module~m_interaction program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd program~main->module~m_relax Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables atbo_tab atan_tab atdh_tab atat_tab exat_tab Subroutines atbo_build atan_build atdh_build atat_build exat_build Variables Type Visibility Attributes Name Initial type( itable_t ), public :: atbo_tab Atoms -> bonds table type( itable_t ), public :: atan_tab Atoms -> angles table type( itable_t ), public :: atdh_tab Atoms -> dihedrals table type( itable_t ), private :: atat_tab Atoms -> bonded atoms table (1-ring) type( itable_t ), public :: exat_tab Atoms -> excluded atoms (from vdw calculation) table Subroutines public subroutine atbo_build () Arguments None public subroutine atan_build () Arguments None public subroutine atdh_build () Arguments None private subroutine atat_build () Arguments None public subroutine exat_build () Arguments None","tags":"","loc":"module/m_connectivity.html"},{"title":"m_constants_math – BROWNPAK","text":"Various math constants. Uses m_precision module~~m_constants_math~~UsesGraph module~m_constants_math m_constants_math module~m_precision m_precision module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_constants_math~~UsedByGraph module~m_constants_math m_constants_math module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_constants_math module~m_interaction m_interaction module~m_bd_solver->module~m_interaction module~m_stats_io m_stats_io module~m_bd_solver->module~m_stats_io module~m_config_io m_config_io module~m_bd_solver->module~m_config_io module~m_globals m_globals module~m_bd_solver->module~m_globals module~m_interaction->module~m_constants_math module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_interaction->module~m_globals module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_cell_list m_cell_list module~m_interaction->module~m_cell_list module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_dihedral->module~m_constants_math module~m_ia_dihedral->module~m_globals module~m_utils_math m_utils_math module~m_utils_math->module~m_constants_math module~m_stats_io->module~m_constants_math module~m_stats_io->module~m_globals module~m_ia_angle->module~m_constants_math module~m_ia_angle->module~m_globals module~m_simbox m_simbox module~m_simbox->module~m_constants_math module~m_ia_external->module~m_constants_math module~m_ia_external->module~m_globals module~m_ia_tether->module~m_constants_math module~m_ia_tether->module~m_globals module~m_kmc m_kmc module~m_kmc->module~m_constants_math module~m_kmc->module~m_interaction module~m_kmc->module~m_globals module~m_mpcd m_mpcd module~m_mpcd->module~m_constants_math module~m_mpcd->module~m_interaction module~m_mpcd->module~m_utils_math module~m_mpcd->module~m_stats_io module~m_mpcd->module~m_config_io module~m_mpcd->module~m_globals module~m_mpcd->module~m_cell_list module~m_ia_bond->module~m_constants_math module~m_ia_bond->module~m_globals module~m_ia_vdw->module~m_constants_math module~m_ia_vdw->module~m_globals module~m_setup m_setup module~m_setup->module~m_bd_solver module~m_setup->module~m_interaction module~m_setup->module~m_stats_io module~m_setup->module~m_simbox module~m_setup->module~m_mpcd module~m_setup->module~m_config_io module~m_setup->module~m_globals module~m_config_io->module~m_simbox module~m_config_io->module~m_globals program~main main program~main->module~m_bd_solver program~main->module~m_mpcd program~main->module~m_setup program~main->module~m_globals module~m_relax m_relax program~main->module~m_relax module~m_control_io m_control_io program~main->module~m_control_io module~m_globals->module~m_simbox module~m_relax->module~m_interaction module~m_relax->module~m_stats_io module~m_relax->module~m_config_io module~m_relax->module~m_globals module~m_verlet->module~m_globals module~m_control_io->module~m_globals module~m_cell_list->module~m_globals module~m_connectivity->module~m_globals var panmodulem_constants_mathUsedByGraph = svgPanZoom('#modulem_constants_mathUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables math_third math_pi math_pi_2 math_pi_4 math_1_pi math_2_pi math_2_sqrtpi math_sqrt2 math_cbrt2 math_sxrt2 math_sqrt1_2 math_sqrt3 math_sqrt_e math_sqrt_pi math_e math_log2e math_log10e math_ln2 math_ln10 Variables Type Visibility Attributes Name Initial real(kind=rp), public, parameter :: math_third = 0.333333333333333_rp real(kind=rp), public, parameter :: math_pi = 3.1415926535897931_rp pi real(kind=rp), public, parameter :: math_pi_2 = 1.5707963267948966_rp pi divided by two real(kind=rp), public, parameter :: math_pi_4 = 0.78539816339744828_rp pi divided by four real(kind=rp), public, parameter :: math_1_pi = 0.31830988618379069_rp reciprocal of pi real(kind=rp), public, parameter :: math_2_pi = 0.63661977236758138_rp two times reciprocal of pi real(kind=rp), public, parameter :: math_2_sqrtpi = 1.1283791670955126_rp two times the reciprocal of the square root of pi. real(kind=rp), public, parameter :: math_sqrt2 = 1.4142135623730951_rp square root of two real(kind=rp), public, parameter :: math_cbrt2 = 1.2599210498948732_rp cube root of two real(kind=rp), public, parameter :: math_sxrt2 = 1.122462048309373_rp sixth root of two real(kind=rp), public, parameter :: math_sqrt1_2 = 0.70710678118654746_rp reciprocal of the square root of two real(kind=rp), public, parameter :: math_sqrt3 = 1.7320508075688772_rp square root of three real(kind=rp), public, parameter :: math_sqrt_e = 1.6487212707001282_rp square root of M_E real(kind=rp), public, parameter :: math_sqrt_pi = 1.7724538509055159_rp square root of pi real(kind=rp), public, parameter :: math_e = 2.7182818284590451_rp The base of natural logarithms real(kind=rp), public, parameter :: math_log2e = 1.4426950408889634_rp The logarithm of M_E to base two real(kind=rp), public, parameter :: math_log10e = 0.43429448190325182_rp The logarithm of M_E to base 10 real(kind=rp), public, parameter :: math_ln2 = 0.69314718055994529_rp The natural logarithm of two real(kind=rp), public, parameter :: math_ln10 = 2.3025850929940459_rp The natural logarithm of 10","tags":"","loc":"module/m_constants_math.html"},{"title":"m_control_io – BROWNPAK","text":"Routines for reading and witing control file. Uses m_precision m_strings m_globals module~~m_control_io~~UsesGraph module~m_control_io m_control_io module~m_precision m_precision module~m_control_io->module~m_precision module~m_strings m_strings module~m_control_io->module~m_strings module~m_globals m_globals module~m_control_io->module~m_globals iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_strings->module~m_precision module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_trajectory->module~m_precision module~m_logger m_logger module~m_trajectory->module~m_logger module~m_simbox->module~m_precision module~m_constants_math m_constants_math module~m_simbox->module~m_constants_math module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_constants_math->module~m_precision module~m_logger->iso_fortran_env module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_control_io~~UsedByGraph module~m_control_io m_control_io program~main main program~main->module~m_control_io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines read_control write_control Subroutines public subroutine read_control (fn) Reads simulation parameters from file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Name of parameters file. public subroutine write_control (fn) Write simulation parameters to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn File name","tags":"","loc":"module/m_control_io.html"},{"title":"m_globals – BROWNPAK","text":"Global variables, primarily dealing with system configuration\n and simulation execution. Uses m_precision m_trajectory m_simbox module~~m_globals~~UsesGraph module~m_globals m_globals module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_precision m_precision module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_simbox->module~m_precision module~m_constants_math m_constants_math module~m_simbox->module~m_constants_math module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_trajectory->module~m_precision module~m_logger m_logger module~m_trajectory->module~m_logger module~m_constants_math->module~m_precision module~m_logger->iso_fortran_env module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_globals~~UsedByGraph module~m_globals m_globals module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_globals module~m_interaction m_interaction module~m_bd_solver->module~m_interaction module~m_config_io m_config_io module~m_bd_solver->module~m_config_io module~m_stats_io m_stats_io module~m_bd_solver->module~m_stats_io module~m_interaction->module~m_globals module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_cell_list m_cell_list module~m_interaction->module~m_cell_list module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_ia_dihedral->module~m_globals module~m_setup m_setup module~m_setup->module~m_globals module~m_setup->module~m_bd_solver module~m_setup->module~m_interaction module~m_setup->module~m_config_io module~m_setup->module~m_stats_io module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_config_io->module~m_globals module~m_stats_io->module~m_globals module~m_ia_angle->module~m_globals program~main main program~main->module~m_globals program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd module~m_control_io m_control_io program~main->module~m_control_io module~m_relax m_relax program~main->module~m_relax module~m_verlet->module~m_globals module~m_cell_list->module~m_globals module~m_connectivity->module~m_globals module~m_ia_external->module~m_globals module~m_ia_tether->module~m_globals module~m_kmc m_kmc module~m_kmc->module~m_globals module~m_kmc->module~m_interaction module~m_mpcd->module~m_globals module~m_mpcd->module~m_interaction module~m_mpcd->module~m_config_io module~m_mpcd->module~m_stats_io module~m_mpcd->module~m_cell_list module~m_control_io->module~m_globals module~m_ia_bond->module~m_globals module~m_relax->module~m_globals module~m_relax->module~m_interaction module~m_relax->module~m_config_io module~m_relax->module~m_stats_io module~m_ia_vdw->module~m_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables mxrdln mxparam simbox imcon num_atom_types atom_names atom_styles atom_mass mpcd_avnc num_mpcd_atoms num_atoms num_atoms_tot atoms charge coordinates orientation velocities forces num_bond_types bond_styles bond_params num_bonds bonds num_angle_types angle_styles angle_params num_angles angles num_dihedral_types dihedral_styles dihedral_params num_dihedrals dihedrals num_branches branches num_molecule_types molecule_names molecule_pop num_molecules molecules molecule_com num_tether_types tether_styles tether_params num_tethers tethers tether_points num_vdw_types vdw_styles vdw_params vdw_pairs num_externals external_styles external_params flow_style flow_params sim_style leql lrevive tim_stp nts nts_md nts_log nts_dump nts_samp nts_eql nts_eql_samp nts_sim use_verlet_tab rcutoff tskin use_cell_list fn_cfg fn_revive fn_traj fn_stats traj job_tag read_seed write_seed write_eql_stats write_traj traj_frmcmp traj_wmpcd stress stress_slvnt energy_kin energy_bond energy_angle energy_dihedral energy_vdw energy_tether energy_external energy_tot bndlen bndlen_min bndlen_max excluded_atoms lvdw mob_fctr lhdia lelectrostatics Variables Type Visibility Attributes Name Initial integer, public, parameter :: mxrdln = 1024 Maximum length of character string for input line buffer. integer, public, parameter :: mxparam = 12 Maximum number of parameters for bonds, angles, etc. type( smbx_t ), public :: simbox Simulation box. integer, public :: imcon = 0 Flag specifying boundary conditions on the simulation box. imcon = 0 : Unbounded domain. While not explicitly enforced this \n    is useful only for a single molecule. The dynamics is performed in the \n    c.o.m. frame of reference. imcon = 1 : PBC along x , y , & z . There are no restrictions on\n    the number of molecules. integer, public :: num_atom_types = 0 Number of atom_type s character(len=8), public, dimension(:), allocatable :: atom_names ( num_atom_types ,) array. Name of atoms of each type. integer, public, dimension(:), allocatable :: atom_styles ( num_atom_types ,) array. Style of atoms of each type. real(kind=rp), public, dimension(:), allocatable :: atom_mass ( num_atom_types ,) array. Mass of atoms of each type. integer, public :: mpcd_avnc = 0 Average number of MPCD atoms per collision cell integer, public :: num_mpcd_atoms = 0 Number of MPCD atoms integer, public :: num_atoms = 0 Number of atoms (excluding MPCD atoms) integer, public :: num_atoms_tot = 0 Total number of atoms (includes MPCD atoms) integer, public, dimension(:), allocatable :: atoms ( num_atoms ,) array. For atom i , its type at = atoms(i) , with style atom_styles(at) , name atom_names(at) , mass atom_mass(at) , charge charge(i) , position coordinates(:,i) , velocity velocities(:,i) ,\n orientation (if the style requires) orientations(:,i) . The force acting on atom i is forces(:,i) . real(kind=rp), public, dimension(:), allocatable :: charge ( num_atoms ,) array. real(kind=rp), public, dimension(:,:), allocatable :: coordinates (3, num_atoms_tot ) array real(kind=rp), public, dimension(:,:), allocatable :: orientation (4, num_atoms ) array real(kind=rp), public, dimension(:,:), allocatable, target :: velocities (3, num_atoms_tot ) array. The first num_atoms columns stores\n velocities of non-MPCD atoms, the rest, i.e num_atoms+1 to num_atoms_tot , store velocities of MPCD atoms. real(kind=rp), public, dimension(:,:), allocatable, target :: forces (3, num_atoms_tot ) array integer, public :: num_bond_types = 0 Number of bond_type s integer, public, dimension(:), allocatable :: bond_styles ( num_bond_types ,) array. real(kind=rp), public, dimension(:,:), allocatable :: bond_params ( mxparam , num_bond_types ) array. integer, public :: num_bonds = 0 Total number of bonds. integer, public, dimension(:,:), allocatable :: bonds (3, num_bonds ) array. Bond i is of type bt = bonds(1,i) ,  directed from\n atom bonds(2,i) to bonds(3,i) . Its style is bond_styles(bt) with\n parameters bond_params(:,bt) . integer, public :: num_angle_types = 0 Number of angle_type s integer, public, dimension(:), allocatable :: angle_styles ( num_angle_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: angle_params ( mxparam , num_angle_types ) array integer, public :: num_angles = 0 Number of angles integer, public, dimension(:,:), allocatable :: angles (4, num_angles ) array. Angle i is of type ant = angles(1,i) , incident\n to atoms angles(2,i) , angles(3,i) , and angles(4,i) . Its style is angle_styles(ant) with parameters angle_params(:,ant) . integer, public :: num_dihedral_types = 0 Number of dihedral_type s integer, public, dimension(:), allocatable :: dihedral_styles ( num_dihedral_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: dihedral_params ( mxparam , num_dihedral_types ) array integer, public :: num_dihedrals = 0 Number of dihedrals integer, public, dimension(:,:), allocatable :: dihedrals (5, num_dihedrals ) array. Dihedral i is of type dt = dihedrals(1,i) , incident\n to atoms dihedrals(2,i) , dihedrals(3,i) , dihedrals(4,i) , and dihedrals(5,i) .\n Its style is dihedral_styles(dt) with parameters dihedral_params(:,dt) . integer, public :: num_branches = 0 Total number of branches (including the backbone) integer, public, dimension(:,:), allocatable :: branches (3, num_branches ) array. Branch i is tethered to atom branches(1,i) ,\n contains branches(2,i) atoms, with the beginning atom index branches(3,i) . integer, public :: num_molecule_types = 0 Number of molecule_type s character(len=8), public, dimension(:), allocatable :: molecule_names ( num_molecule_types ,) array integer, public, dimension(:), allocatable :: molecule_pop ( num_molecule_types ,) array integer, public :: num_molecules = 0 Number of molecules integer, public, dimension(:,:), allocatable :: molecules (9, num_molecules ) array. For molecule i , its type mt = molecules(1,i) , \n containing molecules(2,i) atoms with beginning index molecules(3,i) , molecules(4,i) bonds with beginning index molecules(5,i) , molecules(6,i) angles with beginning index molecules(7,i) , and molecules(8,i) dihedrals with beginning index molecules(9,i) . real(kind=rp), public, dimension(3) :: molecule_com = 0.0_rp Center of mass of the molecule. This is used only when imcon == 0, i.e.\n for a single molecule without periodic boundaries. integer, public :: num_tether_types = 0 Number of tether_type s integer, public, dimension(:), allocatable :: tether_styles ( num_tether_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: tether_params ( mxparam , num_tether_types ) array integer, public :: num_tethers = 0 Number of tethers integer, public, dimension(:,:), allocatable :: tethers (2, num_tethers ) array. Tether i is of type tt = tethers(1,i) , tethering\n atom tethers(2,i) to a point tether_points(:,i) .\n Its style is tether_styles(tt) with parameters tether_params(:,tt) . real(kind=rp), public, dimension(:,:), allocatable :: tether_points (3, num_tethers ) array integer, public :: num_vdw_types = 0 Number of vdw_type s integer, public, dimension(:), allocatable :: vdw_styles ( num_vdw_types ,) array real(kind=rp), public, dimension(:,:), allocatable :: vdw_params ( mxparam , num_vdw_types ) array integer, public, dimension(:,:), allocatable :: vdw_pairs (2, num_vdw_types ) array. Stores atom type of interacting pairs, such\n that at_i >= at_j. integer, public :: num_externals = 0 Number of external fields integer, public, dimension(:), allocatable :: external_styles ( num_external ,) array real(kind=rp), public, dimension(:,:), allocatable :: external_params ( mxparam , num_external ) array integer, public :: flow_style = 0 real(kind=rp), public, dimension(:), allocatable :: flow_params ( mxparam ,) array integer, public :: sim_style = 1 '0': Structure relaxation, '1' : Brownian dynamics, '2' : MPCD logical, public :: leql = .true. Is the system equilibrating? {T, F} logical, public :: lrevive = .false. Is this a restart run? {T, F}. real(kind=rp), public :: tim_stp BD/MPCD time step size integer(kind=ip_long), public :: nts Counter for BD/MPCD time steps integer(kind=ip), public :: nts_md = 1 Number of MD steps per MPCD step integer(kind=ip_long), public :: nts_log = 1 Interval for logging (in BD time steps) integer(kind=ip_long), public :: nts_dump = 1 Interval for dumping to revive file (in BD time steps) integer(kind=ip_long), public :: nts_samp = 1 Interval for sampling statistics (in BD time steps) integer(kind=ip_long), public :: nts_eql = 0 Number of BD time steps for equilibration integer(kind=ip_long), public :: nts_eql_samp = 1 Sampling interval during equilibration (in BD time steps) integer(kind=ip_long), public :: nts_sim = 0 Total number of BD time steps in production run logical, public :: use_verlet_tab = .false. Use Verlet neighbor table? {T, F} real(kind=rp), public :: rcutoff = 0.0_rp Cut off for short-ranged interaction. Also used as the radius of the\n skin sphere for short-ranged forces real(kind=rp), public :: tskin = 0.0_rp Thickness of the skin sphere (same for all) logical, public :: use_cell_list = .false. Use cell list for short-range interactions? {T, F} character(len=:), public, allocatable :: fn_cfg Name of the file containing the initial configuration character(len=:), public, allocatable :: fn_revive Name of the revive file character(len=:), public, allocatable :: fn_traj Name of the trajectory file character(len=:), public, allocatable :: fn_stats Name of the statistics file type( trajectory_t ), public :: traj Trajectory object character(len=8), public :: job_tag = '' A tag useful for array jobs, available only as a command line argument logical, public :: read_seed = .false. {T, F} Whether to initialize the random number generator by reading a seed from\n a file. If read_seed == T, the seed will be read from a file\n 'random_seed.txt' logical, public :: write_seed = .false. {T, F} Whether to write the random number generator seed. If write_seed == T the seed will be written to a file named\n  'random_seed.txt' logical, public :: write_eql_stats = .false. During equilibration, should the statistics file be written? {T, F} logical, public :: write_traj = .false. Should the trajectory be written to file? {T, F} integer, public, dimension(4) :: traj_frmcmp = 0 Control for what gets written to a trajectory frame.\n 1: coordinates; 2: velocities; 3: forces; 4: charge logical, public :: traj_wmpcd = .false. Depending on the values in traj_frmcmp , whether the corresponding\n quantities for the MPCD atoms are written as well. real(kind=rp), public, dimension(3,3) :: stress = 0.0_rp Stress tensor due to non-MPCD atoms real(kind=rp), public, dimension(3,3) :: stress_slvnt = 0.0_rp Stress tensor due to MPCD atoms (solvent) real(kind=rp), public :: energy_kin = 0.0_rp Kinetic energy real(kind=rp), public :: energy_bond = 0.0_rp Bond energy real(kind=rp), public :: energy_angle = 0.0_rp Angle energy real(kind=rp), public :: energy_dihedral = 0.0_rp Dihedral energy real(kind=rp), public :: energy_vdw = 0.0_rp vdw interaction energy real(kind=rp), public :: energy_tether = 0.0_rp Energetic contribution from tethers real(kind=rp), public :: energy_external = 0.0_rp Energetic contribution from external fields real(kind=rp), public :: energy_tot = 0.0_rp Total energy real(kind=rp), public :: bndlen = 0.0_rp Average bond length real(kind=rp), public :: bndlen_min = 0.0_rp Minimum bond length real(kind=rp), public :: bndlen_max = 0.0_rp Maximum bond length integer, public :: excluded_atoms = 0 Control for excluded atoms in vdw calculation.\n 0: No exclusion, 1: exclude 1-ring bonded neighbors,\n 2: exclude 2-ring bonded neighbors, 3: exclude 3-ring bonded neighbors. logical, public :: lvdw = .true. Whether to calculate VDW interactions character(len=4), public :: mob_fctr Factorization method for mobility matrix {'CHOL', 'KRYL'} logical, public :: lhdia = .true. Whether to include hydrodynamic interactions in BD logical, public :: lelectrostatics = .false. Whether to calculate electrostatic interactions","tags":"","loc":"module/m_globals.html"},{"title":"m_ia_angle – BROWNPAK","text":"Angle potentials Style 0: None (Only topology) Style 1: Cosine. See ang_cos_set . Uses m_precision m_constants_math m_globals module~~m_ia_angle~~UsesGraph module~m_ia_angle m_ia_angle module~m_constants_math m_constants_math module~m_ia_angle->module~m_constants_math module~m_precision m_precision module~m_ia_angle->module~m_precision module~m_globals m_globals module~m_ia_angle->module~m_globals module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_trajectory->module~m_precision module~m_logger m_logger module~m_trajectory->module~m_logger module~m_simbox->module~m_constants_math module~m_simbox->module~m_precision module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_logger->iso_fortran_env module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_ia_angle~~UsedByGraph module~m_ia_angle m_ia_angle module~m_interaction m_interaction module~m_interaction->module~m_ia_angle module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_mpcd->module~m_interaction module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax m_relax module~m_relax->module~m_interaction program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd program~main->module~m_relax Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_angle_setup ia_get_angle_force ang_cos_set Subroutines public subroutine ia_angle_setup () Sets up parameters for angle potentials Arguments None public subroutine ia_get_angle_force (q1, q2, typ, enrg, fim1, fi, fip1) Calculates the energy & force due to an angle. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 integer, intent(in) :: typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fim1 real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fip1 private subroutine ang_cos_set (params, k) Setter for angular cosine interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k","tags":"","loc":"module/m_ia_angle.html"},{"title":"m_ia_bond – BROWNPAK","text":"This module contains routines to evaluate bond potentials and their\n derivative. The following styles are available: Style 0. None (only topology) Style 1. Harmonic. See bond_harm_set . Style 2. FENE. See bond_fene_set . Style 3. Kremer-Grest. See bond_kg_set . Style 4. Marko-Siggia. See bond_ms_set . Uses m_precision m_constants_math m_strings m_globals m_logger module~~m_ia_bond~~UsesGraph module~m_ia_bond m_ia_bond module~m_constants_math m_constants_math module~m_ia_bond->module~m_constants_math module~m_logger m_logger module~m_ia_bond->module~m_logger module~m_precision m_precision module~m_ia_bond->module~m_precision module~m_strings m_strings module~m_ia_bond->module~m_strings module~m_globals m_globals module~m_ia_bond->module~m_globals module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_logger->iso_fortran_env module~m_precision->iso_fortran_env module~m_strings->module~m_precision module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_trajectory->module~m_logger module~m_trajectory->module~m_precision module~m_simbox->module~m_constants_math module~m_simbox->module~m_precision module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl var panmodulem_ia_bondUsesGraph = svgPanZoom('#modulem_ia_bondUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_ia_bond~~UsedByGraph module~m_ia_bond m_ia_bond module~m_interaction m_interaction module~m_interaction->module~m_ia_bond module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_mpcd->module~m_interaction module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax m_relax module~m_relax->module~m_interaction program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd program~main->module~m_relax Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_bond_setup ia_get_bond_force bond_harm_set bond_harm bond_fene_set bond_fene bond_kg_set bond_kg bond_ms_set bond_ms Subroutines public subroutine ia_bond_setup () Sets up parameters for bond potentials Arguments None public subroutine ia_get_bond_force (rij_mag, bnd_typ, enrg, frc, ierr) Calculates the energy & its derivative due to a bond. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between bonded atoms integer, intent(in) :: bnd_typ Type of the bond real(kind=rp), intent(out) :: enrg Bond energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of the force due\n to this potential. integer, intent(out) :: ierr Error flag private subroutine bond_harm_set (params, k, r0) Setter for harmonic bond interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 private subroutine bond_harm (r, params, enrg, frc) Calculates energy & its derivative for harmonic bond. See bond_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine bond_fene_set (params, k, rmax, r0) Setter for FENE bond. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: r0 private subroutine bond_fene (r, params, enrg, frc, ierr) Calculates energy & its derivative for FENE bond. See bond_fene_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr private subroutine bond_kg_set (params, k, rmax, eps, sigma) Setter for FENE bond interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: rmax real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma private subroutine bond_kg (r, params, enrg, frc, ierr) Calculates energy & its derivative for Kremer-Grest bond. See bond_kg_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr private subroutine bond_ms_set (params, lp, rmax) Setter for Marko-Siggia bond. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: lp real(kind=rp), intent(in), optional :: rmax private subroutine bond_ms (r, params, enrg, frc, ierr) Evaluates the potential & its derivative for Marko-Siggia bond.\n See bond_ms_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr","tags":"","loc":"module/m_ia_bond.html"},{"title":"m_ia_dihedral – BROWNPAK","text":"Dihedral potentials (none implemented) Uses m_precision m_constants_math m_globals module~~m_ia_dihedral~~UsesGraph module~m_ia_dihedral m_ia_dihedral module~m_constants_math m_constants_math module~m_ia_dihedral->module~m_constants_math module~m_precision m_precision module~m_ia_dihedral->module~m_precision module~m_globals m_globals module~m_ia_dihedral->module~m_globals module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_trajectory->module~m_precision module~m_logger m_logger module~m_trajectory->module~m_logger module~m_simbox->module~m_constants_math module~m_simbox->module~m_precision module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_logger->iso_fortran_env module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl var panmodulem_ia_dihedralUsesGraph = svgPanZoom('#modulem_ia_dihedralUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_ia_dihedral~~UsedByGraph module~m_ia_dihedral m_ia_dihedral module~m_interaction m_interaction module~m_interaction->module~m_ia_dihedral module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_mpcd->module~m_interaction module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax m_relax module~m_relax->module~m_interaction program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd program~main->module~m_relax Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_dihedral_setup ia_get_dihedral_force Subroutines public subroutine ia_dihedral_setup () Sets up parameters for dihedral potentials Arguments None public subroutine ia_get_dihedral_force (q1, q2, q3, typ, enrg, fi, fj, fk, fl) Calculates the force & energy due to a dihedral. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: q1 real(kind=rp), intent(in), dimension(3) :: q2 real(kind=rp), intent(in), dimension(3) :: q3 integer, intent(in) :: typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out), dimension(3) :: fi real(kind=rp), intent(out), dimension(3) :: fj real(kind=rp), intent(out), dimension(3) :: fk real(kind=rp), intent(out), dimension(3) :: fl","tags":"","loc":"module/m_ia_dihedral.html"},{"title":"m_ia_external – BROWNPAK","text":"External potentials This module is meant to be a placeholder to any external fields that the user\n wants to add. Accordingly replace/add to the existing routines. The\n subroutines ia_external_setup and ia_add_external_forces must remain\n for interfacing to the force calculation driver routine ia_calc_forces . Style 0: None Style 1: Pulling force along +ve x-axis Style 2: Hard planar wall Uses m_precision m_constants_math m_globals module~~m_ia_external~~UsesGraph module~m_ia_external m_ia_external module~m_constants_math m_constants_math module~m_ia_external->module~m_constants_math module~m_precision m_precision module~m_ia_external->module~m_precision module~m_globals m_globals module~m_ia_external->module~m_globals module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_trajectory->module~m_precision module~m_logger m_logger module~m_trajectory->module~m_logger module~m_simbox->module~m_constants_math module~m_simbox->module~m_precision module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_logger->iso_fortran_env module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl var panmodulem_ia_externalUsesGraph = svgPanZoom('#modulem_ia_externalUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_ia_external~~UsedByGraph module~m_ia_external m_ia_external module~m_interaction m_interaction module~m_interaction->module~m_ia_external module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_mpcd->module~m_interaction module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax m_relax module~m_relax->module~m_interaction program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd program~main->module~m_relax Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_external_setup ia_add_external_forces Subroutines public subroutine ia_external_setup () Sets up parameters for external potentials. Usually there is nothing to\n set for externals, but this acts as a placeholder for special cases. Arguments None public subroutine ia_add_external_forces (ierr) Calculates the force and energy due to an external field and adds to energy_external , 'forces , & stress in module m_globals`. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr","tags":"","loc":"module/m_ia_external.html"},{"title":"m_ia_tether – BROWNPAK","text":"Tether potentials Style 0: None Style 1: Rigid connector (not implemented)\n *Style 2: Harmonic spring. See teth_harm_set . Uses m_precision m_constants_math m_globals module~~m_ia_tether~~UsesGraph module~m_ia_tether m_ia_tether module~m_constants_math m_constants_math module~m_ia_tether->module~m_constants_math module~m_precision m_precision module~m_ia_tether->module~m_precision module~m_globals m_globals module~m_ia_tether->module~m_globals module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_trajectory->module~m_precision module~m_logger m_logger module~m_trajectory->module~m_logger module~m_simbox->module~m_constants_math module~m_simbox->module~m_precision module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_logger->iso_fortran_env module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_ia_tether~~UsedByGraph module~m_ia_tether m_ia_tether module~m_interaction m_interaction module~m_interaction->module~m_ia_tether module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_mpcd->module~m_interaction module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax m_relax module~m_relax->module~m_interaction program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd program~main->module~m_relax Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_tether_setup ia_get_tether_force teth_rigid_set teth_rigid teth_harm_set teth_harm Subroutines public subroutine ia_tether_setup () Sets up parameters for tether potentials Arguments None public subroutine ia_get_tether_force (qmag, teth_typ, enrg, frc, ierr) Calculates the energy and its derivative due to a tether. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: qmag Distance between the tethered atom & the tether point integer, intent(in) :: teth_typ real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr private subroutine teth_rigid_set (params, r0, eps) Setter for rigid tether interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: r0 real(kind=rp), intent(in), optional :: eps private subroutine teth_rigid (r, params, enrg, frc, ierr) Not implemented, needs constraint formalism. See teth_rigid_set . Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc integer, intent(out) :: ierr private subroutine teth_harm_set (params, k, r0) Setter for harmonic tether interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: k real(kind=rp), intent(in), optional :: r0 private subroutine teth_harm (r, params, enrg, frc) Calculates energy and its derivative for harmonic tether interaction. See teth_harm_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc","tags":"","loc":"module/m_ia_tether.html"},{"title":"m_ia_vdw – BROWNPAK","text":"Routines to evaulate pairwise potentials and their derivative. The following styles are available: Style 1. 12-6 LJ (cut & shifted). See vdw_lj_set . Style 2. Gaussian (cut & shifted). See vdw_gaussian_set . Style 3. Cosine. See vdw_cosine_set . Style 4. Screened Coulomb + LJ (cut & shifted). See vdw_lj_coul_debye_set . Style 5. Coulomb + LJ (cut & shifted) See vdw_lj_coul_set . Uses m_precision m_constants_math m_globals m_logger module~~m_ia_vdw~~UsesGraph module~m_ia_vdw m_ia_vdw module~m_constants_math m_constants_math module~m_ia_vdw->module~m_constants_math module~m_logger m_logger module~m_ia_vdw->module~m_logger module~m_precision m_precision module~m_ia_vdw->module~m_precision module~m_globals m_globals module~m_ia_vdw->module~m_globals module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_logger->iso_fortran_env module~m_precision->iso_fortran_env module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_trajectory->module~m_logger module~m_trajectory->module~m_precision module~m_simbox->module~m_constants_math module~m_simbox->module~m_precision module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_ia_vdw~~UsedByGraph module~m_ia_vdw m_ia_vdw module~m_interaction m_interaction module~m_interaction->module~m_ia_vdw module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_mpcd->module~m_interaction module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax m_relax module~m_relax->module~m_interaction program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd program~main->module~m_relax Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_vdw_setup ia_get_vdw_force vdw_lj_set vdw_lj vdw_gaussian_set vdw_gaussian vdw_cosine_set vdw_cosine vdw_lj_coul_debye_set vdw_lj_coul_debye vdw_lj_coul_set vdw_lj_coul Subroutines public subroutine ia_vdw_setup () Sets up parameters for vdw potentials Arguments None public subroutine ia_get_vdw_force (rij_mag, qi, qj, typ, enrg, frc, ierr) Calculates the energy & its derivative due to a single interacting pair of atoms. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rij_mag Distance between two atoms real(kind=rp), intent(in) :: qi Charge on atom i real(kind=rp), intent(in) :: qj Charge on atom j integer, intent(in) :: typ Type of vdw interaction real(kind=rp), intent(out) :: enrg Energy real(kind=rp), intent(out) :: frc Derivative of the potential. This is the magnitude of force due to\n this potential. integer, intent(out) :: ierr Error flag private subroutine vdw_lj_set (params, eps, sigma, rcut) Setter for 12-6 LJ (cut & shifted) interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut private pure subroutine vdw_lj (r, params, enrg, frc) Evaluates the potential and its derivative for LJ interaction. See vdw_lj_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_gaussian_set (params, A, B, rcut) Setter for gaussian interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: B real(kind=rp), intent(in), optional :: rcut private pure subroutine vdw_gaussian (r, params, enrg, frc) Calculates energy & its derivative for gaussian interaction. See vdw_gaussian_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_cosine_set (params, A, rcut) Setter for cosine interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: A real(kind=rp), intent(in), optional :: rcut private pure subroutine vdw_cosine (r, params, enrg, frc) Evaluates the potential and its derivative for  cosine interaction.\n See vdw_cosine_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_lj_coul_debye_set (params, eps, sigma, rcut, rcut_coul, C, kappa) Setter for 12-6 LJ with screened Coulombic interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C real(kind=rp), intent(in), optional :: kappa private pure subroutine vdw_lj_coul_debye (r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for screened Coulombic interaction\ncombined with 12-6 LJ (cut & shifted). See vdw_lj_coul_debye_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc private subroutine vdw_lj_coul_set (params, eps, sigma, rcut, rcut_coul, C) Setter for 12-6 LJ with Coulombic interaction. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: params real(kind=rp), intent(in), optional :: eps real(kind=rp), intent(in), optional :: sigma real(kind=rp), intent(in), optional :: rcut real(kind=rp), intent(in), optional :: rcut_coul real(kind=rp), intent(in), optional :: C private pure subroutine vdw_lj_coul (r, qiqj, params, enrg, frc) Evaluates the potential and its derivative for Coulombic interaction\n combined with 12-6 LJ (cut & shifted). See vdw_lj_coul_set . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: qiqj real(kind=rp), intent(in), dimension(:) :: params real(kind=rp), intent(out) :: enrg real(kind=rp), intent(out) :: frc","tags":"","loc":"module/m_ia_vdw.html"},{"title":"m_interaction – BROWNPAK","text":"Driver routines for force & energy calculation. Uses m_precision m_constants_math m_globals m_connectivity m_verlet m_cell_list m_ia_bond m_ia_angle m_ia_dihedral m_ia_vdw m_ia_tether m_ia_external module~~m_interaction~~UsesGraph module~m_interaction m_interaction module~m_constants_math m_constants_math module~m_interaction->module~m_constants_math module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_precision m_precision module~m_interaction->module~m_precision module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_cell_list m_cell_list module~m_interaction->module~m_cell_list module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_globals m_globals module~m_interaction->module~m_globals module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_constants_math->module~m_precision module~m_ia_dihedral->module~m_constants_math module~m_ia_dihedral->module~m_precision module~m_ia_dihedral->module~m_globals iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_ia_angle->module~m_constants_math module~m_ia_angle->module~m_precision module~m_ia_angle->module~m_globals module~m_verlet->module~m_precision module~m_verlet->module~m_globals module~m_vector m_vector module~m_verlet->module~m_vector module~m_table m_table module~m_verlet->module~m_table module~m_cell_list->module~m_precision module~m_cell_list->module~m_globals module~m_cell_list->module~m_vector module~m_connectivity->module~m_precision module~m_connectivity->module~m_globals module~m_connectivity->module~m_vector module~m_connectivity->module~m_table module~m_ia_external->module~m_constants_math module~m_ia_external->module~m_precision module~m_ia_external->module~m_globals module~m_ia_tether->module~m_constants_math module~m_ia_tether->module~m_precision module~m_ia_tether->module~m_globals module~m_ia_bond->module~m_constants_math module~m_ia_bond->module~m_precision module~m_ia_bond->module~m_globals module~m_logger m_logger module~m_ia_bond->module~m_logger module~m_strings m_strings module~m_ia_bond->module~m_strings module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_ia_vdw->module~m_constants_math module~m_ia_vdw->module~m_precision module~m_ia_vdw->module~m_globals module~m_ia_vdw->module~m_logger module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort module~m_logger->iso_fortran_env module~m_table->module~m_precision module~m_table->module~m_vector module~m_strings->module~m_precision module~m_trajectory->module~m_precision module~m_trajectory->module~m_logger module~m_simbox->module~m_constants_math module~m_simbox->module~m_precision module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_qsort->module~m_precision module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl var panmodulem_interactionUsesGraph = svgPanZoom('#modulem_interactionUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_interaction~~UsedByGraph module~m_interaction m_interaction module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_mpcd->module~m_interaction module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax m_relax module~m_relax->module~m_interaction program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd program~main->module~m_relax Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ia_setup ia_finish ia_calc_forces ia_add_vdw_forces ia_add_vdw_forces_vl ia_add_vdw_forces_cl ia_add_bond_forces ia_add_angle_forces ia_add_dihedral_forces ia_add_tether_forces Subroutines public subroutine ia_setup () Sets up parameters for potentials Arguments None public subroutine ia_finish () Releases memory allocated in ia_setup . Arguments None public subroutine ia_calc_forces (ierr) Calculates total forces and energies Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine ia_add_vdw_forces (ierr) Calculates force and energy due to all short-ranged non-bonded pairwise\n interactions and adds to energy_vdw & 'forces in module m_globals`.\n Uses direct N&#94;2 calculation. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine ia_add_vdw_forces_vl (ierr) Calculates force and energy due to all short-ranged non-bonded pairwise\n interactions and adds to energy_vdw & 'forces in module m_globals`.\n Uses Verlet table. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine ia_add_vdw_forces_cl (ierr) Calculates force and energy due to all short-ranged non-bonded pairwise\n interactions and adds to energy_vdw & 'forces in module m_globals`.\n Uses cell list. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine ia_add_bond_forces (ierr) Calculates forces & energy due to all bonds. Will add to energy_bond & and 'forces in module m_globals`. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine ia_add_angle_forces () Calculates forces & energy due to all angles. Will add to energy_angle & 'forces in module m_globals`. Arguments None private subroutine ia_add_dihedral_forces () Calculates forces & energy due to all dihedrals. Will add to energy_dihedral & 'forces in module m_globals`. Arguments None private subroutine ia_add_tether_forces (ierr) Calculates forces & energy due to all tethers. Will add to energy_tether &\n 'forces in module m_globals`. Tether forces cannot be subject to\n periodic boundary conditions. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr","tags":"","loc":"module/m_interaction.html"},{"title":"m_kmc – BROWNPAK","text":"Implements charge hopping via Kinetic Monte Carlo. Uses m_precision m_constants_math m_strings m_ran_num m_globals m_interaction m_logger module~~m_kmc~~UsesGraph module~m_kmc m_kmc module~m_constants_math m_constants_math module~m_kmc->module~m_constants_math module~m_logger m_logger module~m_kmc->module~m_logger module~m_interaction m_interaction module~m_kmc->module~m_interaction module~m_ran_num m_ran_num module~m_kmc->module~m_ran_num module~m_precision m_precision module~m_kmc->module~m_precision module~m_strings m_strings module~m_kmc->module~m_strings module~m_globals m_globals module~m_kmc->module~m_globals module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_logger->iso_fortran_env module~m_interaction->module~m_constants_math module~m_interaction->module~m_precision module~m_interaction->module~m_globals module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_cell_list m_cell_list module~m_interaction->module~m_cell_list module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl module~m_precision->iso_fortran_env module~m_strings->module~m_precision module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_ia_dihedral->module~m_constants_math module~m_ia_dihedral->module~m_precision module~m_ia_dihedral->module~m_globals module~m_ia_angle->module~m_constants_math module~m_ia_angle->module~m_precision module~m_ia_angle->module~m_globals module~m_trajectory->module~m_logger module~m_trajectory->module~m_precision module~m_verlet->module~m_precision module~m_verlet->module~m_globals module~m_vector m_vector module~m_verlet->module~m_vector module~m_table m_table module~m_verlet->module~m_table module~m_simbox->module~m_constants_math module~m_simbox->module~m_ran_num module~m_simbox->module~m_precision module~m_cell_list->module~m_precision module~m_cell_list->module~m_globals module~m_cell_list->module~m_vector module~m_connectivity->module~m_precision module~m_connectivity->module~m_globals module~m_connectivity->module~m_vector module~m_connectivity->module~m_table module~m_ia_external->module~m_constants_math module~m_ia_external->module~m_precision module~m_ia_external->module~m_globals module~m_ia_tether->module~m_constants_math module~m_ia_tether->module~m_precision module~m_ia_tether->module~m_globals module~m_ia_bond->module~m_constants_math module~m_ia_bond->module~m_logger module~m_ia_bond->module~m_precision module~m_ia_bond->module~m_strings module~m_ia_bond->module~m_globals module~m_ia_vdw->module~m_constants_math module~m_ia_vdw->module~m_logger module~m_ia_vdw->module~m_precision module~m_ia_vdw->module~m_globals module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort module~m_table->module~m_precision module~m_table->module~m_vector module~m_qsort->module~m_precision var panmodulem_kmcUsesGraph = svgPanZoom('#modulem_kmcUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines kmc_init kmc_finish kmc_hop Subroutines public subroutine kmc_init () Arguments None public subroutine kmc_finish () Arguments None public subroutine kmc_hop () Arguments None","tags":"","loc":"module/m_kmc.html"},{"title":"m_logger – BROWNPAK","text":"Provides routines for printing different types of messages to\n standard out, standard error, and/or a log file. Uses iso_fortran_env module~~m_logger~~UsesGraph module~m_logger m_logger iso_fortran_env iso_fortran_env module~m_logger->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_logger~~UsedByGraph module~m_logger m_logger module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_logger module~m_interaction m_interaction module~m_bd_solver->module~m_interaction module~m_globals m_globals module~m_bd_solver->module~m_globals module~m_config_io m_config_io module~m_bd_solver->module~m_config_io module~m_stats_io m_stats_io module~m_bd_solver->module~m_stats_io module~m_setup m_setup module~m_setup->module~m_logger module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_setup->module~m_interaction module~m_setup->module~m_globals module~m_setup->module~m_config_io module~m_setup->module~m_stats_io program~main main program~main->module~m_logger program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd module~m_relax m_relax program~main->module~m_relax program~main->module~m_globals module~m_control_io m_control_io program~main->module~m_control_io module~m_trajectory m_trajectory module~m_trajectory->module~m_logger module~m_kmc m_kmc module~m_kmc->module~m_logger module~m_kmc->module~m_interaction module~m_kmc->module~m_globals module~m_mpcd->module~m_logger module~m_mpcd->module~m_interaction module~m_mpcd->module~m_globals module~m_mpcd->module~m_config_io module~m_mpcd->module~m_stats_io module~m_cell_list m_cell_list module~m_mpcd->module~m_cell_list module~m_ia_bond m_ia_bond module~m_ia_bond->module~m_logger module~m_ia_bond->module~m_globals module~m_relax->module~m_logger module~m_relax->module~m_interaction module~m_relax->module~m_globals module~m_relax->module~m_config_io module~m_relax->module~m_stats_io module~m_ia_vdw m_ia_vdw module~m_ia_vdw->module~m_logger module~m_ia_vdw->module~m_globals module~m_interaction->module~m_ia_bond module~m_interaction->module~m_ia_vdw module~m_interaction->module~m_globals module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_interaction->module~m_cell_list module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_globals->module~m_trajectory module~m_ia_dihedral->module~m_globals module~m_config_io->module~m_globals module~m_stats_io->module~m_globals module~m_ia_angle->module~m_globals module~m_verlet->module~m_globals module~m_cell_list->module~m_globals module~m_connectivity->module~m_globals module~m_ia_external->module~m_globals module~m_ia_tether->module~m_globals module~m_control_io->module~m_globals var panmodulem_loggerUsedByGraph = svgPanZoom('#modulem_loggerUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables debug trivia info warning error fatal default_stderr_threshold default_stdout_threshold default_logfile_threshold closed_unit infinity default_format master_logger Interfaces logger Derived Types logger Functions constructor get_designator current_time logger_is_open Subroutines logger_finalize logger_init logger_message logger_debug logger_trivia logger_info logger_warning logger_error logger_fatal logger_destroy Variables Type Visibility Attributes Name Initial integer, public, parameter :: debug = 10 Priority level for output only useful for debugging integer, public, parameter :: trivia = 20 Priority level for output which may be useful but is very\n detailed or not especially important. integer, public, parameter :: info = 30 Priority level for output generated by the normal execution of\n the program. integer, public, parameter :: warning = 40 Priority level for output which indicates some part of the\n program is not behaving as it ideally should. integer, public, parameter :: error = 50 Priority level for output which indicates an error has\n occurred which will affect the continued execution of the\n program. integer, public, parameter :: fatal = 60 Priority level for output which notifies the user than a\n serious error has occured which will result in the immediate\n termination of the program. integer, private, parameter :: default_stderr_threshold = error Default priority level needed for a message to be printed to\n standard-error. integer, private, parameter :: default_stdout_threshold = info Default priority level needed for a message to be printed to\n standard out. integer, private, parameter :: default_logfile_threshold = trivia Default priority level needed for a message to be printed to\n the log file. integer, private, parameter :: closed_unit = -9999 integer, private, parameter :: infinity = huge(1) character(len=29), private, parameter :: default_format = \"('[',a,']','[',a,']',\"//\"*(1x,a))\" type( logger ), public :: master_logger The main logger object for a program to use. Must be\n initialised in the main program with a call to logger_init . Interfaces public interface logger private function constructor (logfile, stderr_threshold, stdout_threshold, logfile_threshold) result(this) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: logfile Name of the log-file to which output will be written integer, intent(in), optional :: stderr_threshold Threshold priority, at and above which messages will be\n written to standard error. Defaults to error . integer, intent(in), optional :: stdout_threshold Threshold priority, at and above which messages will be\n written to standard out. Defaults to info . integer, intent(in), optional :: logfile_threshold Threshold priority, at and above which messages will be\n written to the log file. Defaults to trivia . Return Value type( logger ) Derived Types type, public :: logger Components Type Visibility Attributes Name Initial integer, private :: stdout = output_unit Unit corresponding to STDOUT integer, private :: stderr = error_unit Unit corresponding to STDERR integer, private :: fileunit = closed_unit Unit corresponding to log-file character(len=:), private, allocatable :: logfile Name of the log-file integer, private :: stderr_threshold = infinity Cutoff for which messages with greater or equal priority will\n be written to STDERR. integer, private :: stdout_threshold = infinity Cutoff for which messages with greater or equal priority will\n be written to STDOUT. integer, private :: logfile_threshold = infinity Cutoff for which messages with greater or equal priority will\n be written to the log-file. Constructor private  function constructor (logfile, stderr_threshold, stdout_threshold, logfile_threshold) Finalizations Procedures final :: logger_finalize Type-Bound Procedures procedure, public :: message => logger_message Write a message of a given priority to the appropriate\n location(s) procedure, public :: debug => logger_debug Write debug information procedure, public :: trivia => logger_trivia Write trivial run-time information procedure, public :: info => logger_info Write run-time information procedure, public :: warning => logger_warning Write warning message procedure, public :: error => logger_error Write error message procedure, public :: fatal => logger_fatal Write notification of fatal error procedure, public :: destroy => logger_destroy Closes the log-file procedure, public :: is_open => logger_is_open Return .true. if the log-file is open for writing Functions private function constructor (logfile, stderr_threshold, stdout_threshold, logfile_threshold) result(this) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: logfile Name of the log-file to which output will be written integer, intent(in), optional :: stderr_threshold Threshold priority, at and above which messages will be\n written to standard error. Defaults to error . integer, intent(in), optional :: stdout_threshold Threshold priority, at and above which messages will be\n written to standard out. Defaults to info . integer, intent(in), optional :: logfile_threshold Threshold priority, at and above which messages will be\n written to the log file. Defaults to trivia . Return Value type( logger ) private function get_designator (priority) result(des) Arguments Type Intent Optional Attributes Name integer, intent(in) :: priority The priority level for which to get the designator Return Value character(len=:),\n  allocatable private function current_time () Arguments None Return Value character(len=20) private pure function logger_is_open (this) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this Return Value logical Subroutines private subroutine logger_finalize (this) Arguments Type Intent Optional Attributes Name type( logger ), intent(inout) :: this public subroutine logger_init (logfile, stderr_threshold, stdout_threshold, logfile_threshold) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: logfile Name of the log-file to which output will be written integer, intent(in), optional :: stderr_threshold Threshold priority, at and above which messages will be\n written to standard error. Defaults to error . integer, intent(in), optional :: stdout_threshold Threshold priority, at and above which messages will be\n written to standard out. Defaults to info . integer, intent(in), optional :: logfile_threshold Threshold priority, at and above which messages will be\n written to the log file. Defaults to trivia . private subroutine logger_message (this, source, priority, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error integer, intent(in) :: priority The importance of the message, determining where it will be\n written. character(len=*), intent(in) :: message The information to be written. private subroutine logger_debug (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. private subroutine logger_trivia (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. private subroutine logger_info (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. private subroutine logger_warning (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. private subroutine logger_error (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. private subroutine logger_fatal (this, source, message) Arguments Type Intent Optional Attributes Name class( logger ), intent(in) :: this character(len=*), intent(in) :: source The name of the procedure which produced the error character(len=*), intent(in) :: message The information to be written. private subroutine logger_destroy (this) Arguments Type Intent Optional Attributes Name class( logger ), intent(inout) :: this","tags":"","loc":"module/m_logger.html"},{"title":"m_mpcd – BROWNPAK","text":"Routines implementing the MPCD solver. Uses f95_precision lapack95 m_precision m_constants_math m_utils_math m_strings m_ran_num m_globals m_cell_list m_interaction m_stats_io m_config_io m_logger module~~m_mpcd~~UsesGraph module~m_mpcd m_mpcd module~m_constants_math m_constants_math module~m_mpcd->module~m_constants_math module~m_logger m_logger module~m_mpcd->module~m_logger module~m_interaction m_interaction module~m_mpcd->module~m_interaction lapack95 lapack95 module~m_mpcd->lapack95 module~m_utils_math m_utils_math module~m_mpcd->module~m_utils_math module~m_ran_num m_ran_num module~m_mpcd->module~m_ran_num module~m_config_io m_config_io module~m_mpcd->module~m_config_io f95_precision f95_precision module~m_mpcd->f95_precision module~m_precision m_precision module~m_mpcd->module~m_precision module~m_strings m_strings module~m_mpcd->module~m_strings module~m_stats_io m_stats_io module~m_mpcd->module~m_stats_io module~m_cell_list m_cell_list module~m_mpcd->module~m_cell_list module~m_globals m_globals module~m_mpcd->module~m_globals module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_logger->iso_fortran_env module~m_interaction->module~m_constants_math module~m_interaction->module~m_precision module~m_interaction->module~m_cell_list module~m_interaction->module~m_globals module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_utils_math->module~m_constants_math module~m_utils_math->module~m_precision ieee_arithmetic ieee_arithmetic module~m_utils_math->ieee_arithmetic module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl module~m_config_io->module~m_precision module~m_config_io->module~m_strings module~m_config_io->module~m_globals module~m_simbox m_simbox module~m_config_io->module~m_simbox module~m_precision->iso_fortran_env module~m_strings->module~m_precision module~m_stats_io->module~m_constants_math module~m_stats_io->module~m_precision module~m_stats_io->module~m_strings module~m_stats_io->module~m_globals module~m_cell_list->module~m_precision module~m_cell_list->module~m_globals module~m_vector m_vector module~m_cell_list->module~m_vector module~m_globals->module~m_precision module~m_globals->module~m_simbox module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort module~m_ia_dihedral->module~m_constants_math module~m_ia_dihedral->module~m_precision module~m_ia_dihedral->module~m_globals module~m_ia_angle->module~m_constants_math module~m_ia_angle->module~m_precision module~m_ia_angle->module~m_globals module~m_verlet->module~m_precision module~m_verlet->module~m_globals module~m_verlet->module~m_vector module~m_table m_table module~m_verlet->module~m_table module~m_simbox->module~m_constants_math module~m_simbox->module~m_ran_num module~m_simbox->module~m_precision module~m_trajectory->module~m_logger module~m_trajectory->module~m_precision module~m_connectivity->module~m_precision module~m_connectivity->module~m_globals module~m_connectivity->module~m_vector module~m_connectivity->module~m_table module~m_ia_external->module~m_constants_math module~m_ia_external->module~m_precision module~m_ia_external->module~m_globals module~m_ia_tether->module~m_constants_math module~m_ia_tether->module~m_precision module~m_ia_tether->module~m_globals module~m_ia_bond->module~m_constants_math module~m_ia_bond->module~m_logger module~m_ia_bond->module~m_precision module~m_ia_bond->module~m_strings module~m_ia_bond->module~m_globals module~m_ia_vdw->module~m_constants_math module~m_ia_vdw->module~m_logger module~m_ia_vdw->module~m_precision module~m_ia_vdw->module~m_globals module~m_qsort->module~m_precision module~m_table->module~m_precision module~m_table->module~m_vector var panmodulem_mpcdUsesGraph = svgPanZoom('#modulem_mpcdUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_mpcd~~UsedByGraph module~m_mpcd m_mpcd program~main main program~main->module~m_mpcd module~m_setup m_setup program~main->module~m_setup module~m_setup->module~m_mpcd Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables mass buf_aic Subroutines mpcd_init mpcd_finish mpcd_run mpcd_stream mpcd_collide Variables Type Visibility Attributes Name Initial real(kind=rp), private, dimension(:), allocatable :: mass (num_atoms_tot,) array. Stores mass of each atom (including MPCD\n atoms). The mass of each MPCD atom is taken as unity. real(kind=rp), private, dimension(:), allocatable :: buf_aic Buffer for atoms in cell storing mass, coordinates, & velocities.\n For nc atoms, the first nc elements stores the mass, the next 3*nc elements stores the coordinates, and the next 3*nc elements\n store the velocities. The velocities part of this buffer may be overwritten\n for relative velocity calculations. Subroutines public subroutine mpcd_init (ierr) Initializes the MPCD solver. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr public subroutine mpcd_finish () Clean up MPCD solver. Arguments None public subroutine mpcd_run () Driver for MPCD integrator. Read more… Arguments None private subroutine mpcd_stream (ierr) Performs one step of streaming. Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr private subroutine mpcd_collide () Performs one step of MPCD collision. Arguments None","tags":"","loc":"module/m_mpcd.html"},{"title":"m_precision – BROWNPAK","text":"Uses iso_fortran_env module~~m_precision~~UsesGraph module~m_precision m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_precision~~UsedByGraph module~m_precision m_precision module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_precision module~m_globals m_globals module~m_bd_solver->module~m_globals module~m_constants_math m_constants_math module~m_bd_solver->module~m_constants_math module~m_interaction m_interaction module~m_bd_solver->module~m_interaction module~m_ran_num m_ran_num module~m_bd_solver->module~m_ran_num module~m_config_io m_config_io module~m_bd_solver->module~m_config_io module~m_strings m_strings module~m_bd_solver->module~m_strings module~m_stats_io m_stats_io module~m_bd_solver->module~m_stats_io module~m_utils_math m_utils_math module~m_utils_math->module~m_precision module~m_utils_math->module~m_constants_math program~main main program~main->module~m_precision program~main->module~m_bd_solver module~m_mpcd m_mpcd program~main->module~m_mpcd program~main->module~m_globals module~m_control_io m_control_io program~main->module~m_control_io program~main->module~m_strings module~m_setup m_setup program~main->module~m_setup module~m_relax m_relax program~main->module~m_relax module~m_simbox m_simbox module~m_simbox->module~m_precision module~m_simbox->module~m_constants_math module~m_simbox->module~m_ran_num module~m_connectivity m_connectivity module~m_connectivity->module~m_precision module~m_connectivity->module~m_globals module~m_vector m_vector module~m_connectivity->module~m_vector module~m_table m_table module~m_connectivity->module~m_table module~m_mpcd->module~m_precision module~m_mpcd->module~m_utils_math module~m_mpcd->module~m_globals module~m_mpcd->module~m_constants_math module~m_mpcd->module~m_interaction module~m_cell_list m_cell_list module~m_mpcd->module~m_cell_list module~m_mpcd->module~m_ran_num module~m_mpcd->module~m_config_io module~m_mpcd->module~m_strings module~m_mpcd->module~m_stats_io module~m_globals->module~m_precision module~m_globals->module~m_simbox module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_constants_math->module~m_precision module~m_interaction->module~m_precision module~m_interaction->module~m_connectivity module~m_interaction->module~m_globals module~m_interaction->module~m_constants_math module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_interaction->module~m_cell_list module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_ia_angle->module~m_precision module~m_ia_angle->module~m_globals module~m_ia_angle->module~m_constants_math module~m_verlet->module~m_precision module~m_verlet->module~m_globals module~m_verlet->module~m_vector module~m_verlet->module~m_table module~m_cell_list->module~m_precision module~m_cell_list->module~m_globals module~m_cell_list->module~m_vector module~m_ia_external->module~m_precision module~m_ia_external->module~m_globals module~m_ia_external->module~m_constants_math module~m_kmc m_kmc module~m_kmc->module~m_precision module~m_kmc->module~m_globals module~m_kmc->module~m_constants_math module~m_kmc->module~m_interaction module~m_kmc->module~m_ran_num module~m_kmc->module~m_strings module~m_control_io->module~m_precision module~m_control_io->module~m_globals module~m_control_io->module~m_strings module~m_ia_bond->module~m_precision module~m_ia_bond->module~m_globals module~m_ia_bond->module~m_constants_math module~m_ia_bond->module~m_strings module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort module~m_qsort->module~m_precision module~m_table->module~m_precision module~m_table->module~m_vector module~m_ran_num->module~m_precision module~m_config_io->module~m_precision module~m_config_io->module~m_simbox module~m_config_io->module~m_globals module~m_config_io->module~m_strings module~m_strings->module~m_precision module~m_stats_io->module~m_precision module~m_stats_io->module~m_globals module~m_stats_io->module~m_constants_math module~m_stats_io->module~m_strings module~m_ia_dihedral->module~m_precision module~m_ia_dihedral->module~m_globals module~m_ia_dihedral->module~m_constants_math module~m_setup->module~m_precision module~m_setup->module~m_bd_solver module~m_setup->module~m_simbox module~m_setup->module~m_mpcd module~m_setup->module~m_globals module~m_setup->module~m_interaction module~m_setup->module~m_ran_num module~m_setup->module~m_config_io module~m_setup->module~m_stats_io module~m_trajectory->module~m_precision module~m_ia_tether->module~m_precision module~m_ia_tether->module~m_globals module~m_ia_tether->module~m_constants_math module~m_relax->module~m_precision module~m_relax->module~m_globals module~m_relax->module~m_interaction module~m_relax->module~m_ran_num module~m_relax->module~m_config_io module~m_relax->module~m_strings module~m_relax->module~m_stats_io module~m_ia_vdw->module~m_precision module~m_ia_vdw->module~m_globals module~m_ia_vdw->module~m_constants_math var panmodulem_precisionUsedByGraph = svgPanZoom('#modulem_precisionUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ip ip_long rp sizeof_char sizeof_int sizeof_long_int sizeof_real Variables Type Visibility Attributes Name Initial integer, public, parameter :: ip = int32 Default integer precision integer, public, parameter :: ip_long = int64 Default long integer precision integer, public, parameter :: rp = real64 Default real precision integer, public, parameter :: sizeof_char = 1 Size of a char in bytes integer, public, parameter :: sizeof_int = 4 Size of a default int in bytes integer, public, parameter :: sizeof_long_int = 8 Size of a default long int in bytes integer, public, parameter :: sizeof_real = 8 Size of a default real in bytes","tags":"","loc":"module/m_precision.html"},{"title":"m_qsort – BROWNPAK","text":"Implements quicksort for a sequence of integers and reals, in combination with\n  insertion sort for very short sequences. Quick sort routine from Brainerd, W.S., Goldberg, C.H. & Adams, J.C. (1990)\n \"Programmer's Guide to Fortran 90\", McGraw-Hill  ISBN 0-07-000248-7, pages 149-150. Modified by Alan Miller to include an associated integer array which gives\n   the positions of the elements in the original order. Modified for integer array by Sarit Dutta Uses m_precision module~~m_qsort~~UsesGraph module~m_qsort m_qsort module~m_precision m_precision module~m_qsort->module~m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_qsort~~UsedByGraph module~m_qsort m_qsort module~m_vector m_vector module~m_vector->module~m_qsort module~m_verlet m_verlet module~m_verlet->module~m_vector module~m_table m_table module~m_verlet->module~m_table module~m_cell_list m_cell_list module~m_cell_list->module~m_vector module~m_connectivity m_connectivity module~m_connectivity->module~m_vector module~m_connectivity->module~m_table module~m_table->module~m_vector module~m_interaction m_interaction module~m_interaction->module~m_verlet module~m_interaction->module~m_cell_list module~m_interaction->module~m_connectivity module~m_mpcd m_mpcd module~m_mpcd->module~m_cell_list module~m_mpcd->module~m_interaction module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_mpcd module~m_setup->module~m_bd_solver program~main main program~main->module~m_mpcd program~main->module~m_bd_solver program~main->module~m_setup module~m_relax m_relax program~main->module~m_relax module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax->module~m_interaction var panmodulem_qsortUsedByGraph = svgPanZoom('#modulem_qsortUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines iqsort dqsort Subroutines public subroutine iqsort (list, order) Sorts a sequence of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), DIMENSION (:) :: list Sequence of integers to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence public subroutine dqsort (list, order) Sorts a sequence of reals Arguments Type Intent Optional Attributes Name real(kind=RP), intent(inout), DIMENSION (:) :: list Sequence of reals to be sorted integer, intent(out), optional DIMENSION (:) :: order Indices of the sorted sequence","tags":"","loc":"module/m_qsort.html"},{"title":"m_ran_num – BROWNPAK","text":"Provides random number generation procedures, mostly calling\n routine from Intel MKL VSL. Uses m_precision mkl_vsl_type mkl_vsl module~~m_ran_num~~UsesGraph module~m_ran_num m_ran_num mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type module~m_precision m_precision module~m_ran_num->module~m_precision mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_ran_num~~UsedByGraph module~m_ran_num m_ran_num module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_ran_num module~m_config_io m_config_io module~m_bd_solver->module~m_config_io module~m_globals m_globals module~m_bd_solver->module~m_globals module~m_interaction m_interaction module~m_bd_solver->module~m_interaction module~m_stats_io m_stats_io module~m_bd_solver->module~m_stats_io module~m_setup m_setup module~m_setup->module~m_ran_num module~m_setup->module~m_bd_solver module~m_simbox m_simbox module~m_setup->module~m_simbox module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_setup->module~m_config_io module~m_setup->module~m_globals module~m_setup->module~m_interaction module~m_setup->module~m_stats_io module~m_simbox->module~m_ran_num module~m_mpcd->module~m_ran_num module~m_mpcd->module~m_config_io module~m_mpcd->module~m_globals module~m_mpcd->module~m_interaction module~m_mpcd->module~m_stats_io module~m_cell_list m_cell_list module~m_mpcd->module~m_cell_list module~m_kmc m_kmc module~m_kmc->module~m_ran_num module~m_kmc->module~m_globals module~m_kmc->module~m_interaction module~m_relax m_relax module~m_relax->module~m_ran_num module~m_relax->module~m_config_io module~m_relax->module~m_globals module~m_relax->module~m_interaction module~m_relax->module~m_stats_io module~m_config_io->module~m_simbox module~m_config_io->module~m_globals program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd program~main->module~m_relax program~main->module~m_globals module~m_control_io m_control_io program~main->module~m_control_io module~m_globals->module~m_simbox module~m_interaction->module~m_globals module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_interaction->module~m_cell_list module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_ia_dihedral->module~m_globals module~m_stats_io->module~m_globals module~m_ia_angle->module~m_globals module~m_verlet->module~m_globals module~m_cell_list->module~m_globals module~m_connectivity->module~m_globals module~m_ia_external->module~m_globals module~m_ia_tether->module~m_globals module~m_control_io->module~m_globals module~m_ia_bond->module~m_globals module~m_ia_vdw->module~m_globals var panmodulem_ran_numUsedByGraph = svgPanZoom('#modulem_ran_numUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables seed stream Functions get_uniform get_iuniform Subroutines init_stream delete_stream load_stream save_seed save_stream get_rv_uniform get_rv_iuniform get_rv_gaussian ransphere Variables Type Visibility Attributes Name Initial integer(kind=ip), private, save :: seed type(VSL_STREAM_STATE), private, save :: stream Functions public function get_uniform (lb, ub) result(res) Returns a random number from a uniform distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound Return Value real(kind=rp) public function get_iuniform (lb, ub) result(res) Returns a random integer from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub Return Value integer(kind=ip) Subroutines public subroutine init_stream (fn) Initializes a BRNG stream. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: fn Name of the file containing the RNG seed. public subroutine delete_stream () Deletes a BRNG stream. Arguments None public subroutine load_stream (fn) Loads a BRNG stream from file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine save_seed (fn) Saves the RNG seed to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine save_stream (fn) Saves a BRNG stream to file fn . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn public subroutine get_rv_uniform (lb, ub, rv, block_size) Returns a random vector from a uniform distribution. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: lb Lower bound real(kind=rp), intent(in) :: ub Upper bound real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size public subroutine get_rv_iuniform (lb, ub, rv, block_size) Returns a random vector of integers from a uniform distribution. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: lb integer(kind=ip), intent(in) :: ub integer(kind=ip), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size public subroutine get_rv_gaussian (mean, std_dev, rv, block_size) Generates a random vector of integers from a gaussian distribution. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: std_dev real(kind=rp), intent(out), dimension(:) :: rv integer(kind=ip), intent(in), optional :: block_size public subroutine ransphere (r) Generates a random vector from the surface of a unit sphere. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(3) :: r (3)","tags":"","loc":"module/m_ran_num.html"},{"title":"m_relax – BROWNPAK","text":"Performs structure relaxation (energy minimization) using steepest descent. Atom positions evolve following the gradient direction, in steps of size tim_stp . If tim_stp is too large, bond constraints are likely to be\n violated. If MPCD atoms are present, they do not take part in structure relaxation. Uses m_precision m_ran_num m_strings m_globals m_interaction m_stats_io m_config_io m_logger module~~m_relax~~UsesGraph module~m_relax m_relax module~m_logger m_logger module~m_relax->module~m_logger module~m_interaction m_interaction module~m_relax->module~m_interaction module~m_ran_num m_ran_num module~m_relax->module~m_ran_num module~m_config_io m_config_io module~m_relax->module~m_config_io module~m_precision m_precision module~m_relax->module~m_precision module~m_strings m_strings module~m_relax->module~m_strings module~m_stats_io m_stats_io module~m_relax->module~m_stats_io module~m_globals m_globals module~m_relax->module~m_globals iso_fortran_env iso_fortran_env module~m_logger->iso_fortran_env module~m_interaction->module~m_precision module~m_interaction->module~m_globals module~m_constants_math m_constants_math module~m_interaction->module~m_constants_math module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_cell_list m_cell_list module~m_interaction->module~m_cell_list module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl module~m_config_io->module~m_precision module~m_config_io->module~m_strings module~m_config_io->module~m_globals module~m_simbox m_simbox module~m_config_io->module~m_simbox module~m_precision->iso_fortran_env module~m_strings->module~m_precision module~m_stats_io->module~m_precision module~m_stats_io->module~m_strings module~m_stats_io->module~m_globals module~m_stats_io->module~m_constants_math module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_globals->module~m_simbox module~m_constants_math->module~m_precision module~m_ia_dihedral->module~m_precision module~m_ia_dihedral->module~m_globals module~m_ia_dihedral->module~m_constants_math module~m_ia_angle->module~m_precision module~m_ia_angle->module~m_globals module~m_ia_angle->module~m_constants_math module~m_trajectory->module~m_logger module~m_trajectory->module~m_precision module~m_verlet->module~m_precision module~m_verlet->module~m_globals module~m_vector m_vector module~m_verlet->module~m_vector module~m_table m_table module~m_verlet->module~m_table module~m_simbox->module~m_ran_num module~m_simbox->module~m_precision module~m_simbox->module~m_constants_math module~m_cell_list->module~m_precision module~m_cell_list->module~m_globals module~m_cell_list->module~m_vector module~m_connectivity->module~m_precision module~m_connectivity->module~m_globals module~m_connectivity->module~m_vector module~m_connectivity->module~m_table module~m_ia_external->module~m_precision module~m_ia_external->module~m_globals module~m_ia_external->module~m_constants_math module~m_ia_tether->module~m_precision module~m_ia_tether->module~m_globals module~m_ia_tether->module~m_constants_math module~m_ia_bond->module~m_logger module~m_ia_bond->module~m_precision module~m_ia_bond->module~m_strings module~m_ia_bond->module~m_globals module~m_ia_bond->module~m_constants_math module~m_ia_vdw->module~m_logger module~m_ia_vdw->module~m_precision module~m_ia_vdw->module~m_globals module~m_ia_vdw->module~m_constants_math module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort module~m_table->module~m_precision module~m_table->module~m_vector module~m_qsort->module~m_precision var panmodulem_relaxUsesGraph = svgPanZoom('#modulem_relaxUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_relax~~UsedByGraph module~m_relax m_relax program~main main program~main->module~m_relax Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines rlx_run rlx_integrate Subroutines public subroutine rlx_run () Driver for relaxation Arguments None private subroutine rlx_integrate (ierr, zf) Performs one step of relaxation Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr logical, intent(out) :: zf","tags":"","loc":"module/m_relax.html"},{"title":"m_setup – BROWNPAK","text":"Routines for doing allocation, etc. in preparation for simulation run. Uses m_precision m_ran_num m_simbox m_globals m_config_io m_interaction m_bd_solver m_mpcd m_stats_io m_logger module~~m_setup~~UsesGraph module~m_setup m_setup module~m_bd_solver m_bd_solver module~m_setup->module~m_bd_solver module~m_logger m_logger module~m_setup->module~m_logger module~m_interaction m_interaction module~m_setup->module~m_interaction module~m_ran_num m_ran_num module~m_setup->module~m_ran_num module~m_config_io m_config_io module~m_setup->module~m_config_io module~m_precision m_precision module~m_setup->module~m_precision module~m_stats_io m_stats_io module~m_setup->module~m_stats_io module~m_simbox m_simbox module~m_setup->module~m_simbox module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_globals m_globals module~m_setup->module~m_globals module~m_bd_solver->module~m_logger module~m_bd_solver->module~m_interaction module~m_bd_solver->module~m_ran_num module~m_bd_solver->module~m_config_io module~m_bd_solver->module~m_precision module~m_bd_solver->module~m_stats_io module~m_bd_solver->module~m_globals module~m_constants_math m_constants_math module~m_bd_solver->module~m_constants_math lapack95 lapack95 module~m_bd_solver->lapack95 f95_precision f95_precision module~m_bd_solver->f95_precision module~m_strings m_strings module~m_bd_solver->module~m_strings blas95 blas95 module~m_bd_solver->blas95 iso_c_binding iso_c_binding module~m_bd_solver->iso_c_binding iso_fortran_env iso_fortran_env module~m_logger->iso_fortran_env module~m_interaction->module~m_precision module~m_interaction->module~m_globals module~m_interaction->module~m_constants_math module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_cell_list m_cell_list module~m_interaction->module~m_cell_list module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl module~m_config_io->module~m_precision module~m_config_io->module~m_simbox module~m_config_io->module~m_globals module~m_config_io->module~m_strings module~m_precision->iso_fortran_env module~m_stats_io->module~m_precision module~m_stats_io->module~m_globals module~m_stats_io->module~m_constants_math module~m_stats_io->module~m_strings module~m_simbox->module~m_ran_num module~m_simbox->module~m_precision module~m_simbox->module~m_constants_math module~m_mpcd->module~m_logger module~m_mpcd->module~m_interaction module~m_mpcd->module~m_ran_num module~m_mpcd->module~m_config_io module~m_mpcd->module~m_precision module~m_mpcd->module~m_stats_io module~m_mpcd->module~m_globals module~m_mpcd->module~m_constants_math module~m_mpcd->lapack95 module~m_utils_math m_utils_math module~m_mpcd->module~m_utils_math module~m_mpcd->f95_precision module~m_mpcd->module~m_strings module~m_mpcd->module~m_cell_list module~m_globals->module~m_precision module~m_globals->module~m_simbox module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_constants_math->module~m_precision module~m_ia_dihedral->module~m_precision module~m_ia_dihedral->module~m_globals module~m_ia_dihedral->module~m_constants_math module~m_utils_math->module~m_precision module~m_utils_math->module~m_constants_math ieee_arithmetic ieee_arithmetic module~m_utils_math->ieee_arithmetic module~m_strings->module~m_precision module~m_ia_angle->module~m_precision module~m_ia_angle->module~m_globals module~m_ia_angle->module~m_constants_math module~m_verlet->module~m_precision module~m_verlet->module~m_globals module~m_vector m_vector module~m_verlet->module~m_vector module~m_table m_table module~m_verlet->module~m_table module~m_trajectory->module~m_logger module~m_trajectory->module~m_precision module~m_cell_list->module~m_precision module~m_cell_list->module~m_globals module~m_cell_list->module~m_vector module~m_connectivity->module~m_precision module~m_connectivity->module~m_globals module~m_connectivity->module~m_vector module~m_connectivity->module~m_table module~m_ia_external->module~m_precision module~m_ia_external->module~m_globals module~m_ia_external->module~m_constants_math module~m_ia_tether->module~m_precision module~m_ia_tether->module~m_globals module~m_ia_tether->module~m_constants_math module~m_ia_bond->module~m_logger module~m_ia_bond->module~m_precision module~m_ia_bond->module~m_globals module~m_ia_bond->module~m_constants_math module~m_ia_bond->module~m_strings module~m_ia_vdw->module~m_logger module~m_ia_vdw->module~m_precision module~m_ia_vdw->module~m_globals module~m_ia_vdw->module~m_constants_math module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort module~m_table->module~m_precision module~m_table->module~m_vector module~m_qsort->module~m_precision var panmodulem_setupUsesGraph = svgPanZoom('#modulem_setupUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_setup~~UsedByGraph module~m_setup m_setup program~main main program~main->module~m_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setup config_clear finish Subroutines public subroutine setup () Arguments None public subroutine config_clear () Clears out all configuration related variables in module m_globals . Arguments None public subroutine finish () Arguments None","tags":"","loc":"module/m_setup.html"},{"title":"m_simbox – BROWNPAK","text":"Implements a simulation box with appropriate boundary conditions. Uses m_precision m_constants_math m_ran_num module~~m_simbox~~UsesGraph module~m_simbox m_simbox module~m_constants_math m_constants_math module~m_simbox->module~m_constants_math module~m_precision m_precision module~m_simbox->module~m_precision module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_simbox~~UsedByGraph module~m_simbox m_simbox module~m_config_io m_config_io module~m_config_io->module~m_simbox module~m_globals m_globals module~m_config_io->module~m_globals module~m_globals->module~m_simbox module~m_setup m_setup module~m_setup->module~m_simbox module~m_setup->module~m_config_io module~m_setup->module~m_globals module~m_bd_solver m_bd_solver module~m_setup->module~m_bd_solver module~m_interaction m_interaction module~m_setup->module~m_interaction module~m_stats_io m_stats_io module~m_setup->module~m_stats_io module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_bd_solver->module~m_config_io module~m_bd_solver->module~m_globals module~m_bd_solver->module~m_interaction module~m_bd_solver->module~m_stats_io module~m_ia_dihedral m_ia_dihedral module~m_ia_dihedral->module~m_globals module~m_interaction->module~m_globals module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_cell_list m_cell_list module~m_interaction->module~m_cell_list module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_stats_io->module~m_globals module~m_ia_angle->module~m_globals program~main main program~main->module~m_globals program~main->module~m_setup program~main->module~m_bd_solver program~main->module~m_mpcd module~m_control_io m_control_io program~main->module~m_control_io module~m_relax m_relax program~main->module~m_relax module~m_verlet->module~m_globals module~m_cell_list->module~m_globals module~m_connectivity->module~m_globals module~m_ia_external->module~m_globals module~m_mpcd->module~m_config_io module~m_mpcd->module~m_globals module~m_mpcd->module~m_interaction module~m_mpcd->module~m_stats_io module~m_mpcd->module~m_cell_list module~m_ia_tether->module~m_globals module~m_kmc m_kmc module~m_kmc->module~m_globals module~m_kmc->module~m_interaction module~m_control_io->module~m_globals module~m_ia_bond->module~m_globals module~m_relax->module~m_config_io module~m_relax->module~m_globals module~m_relax->module~m_interaction module~m_relax->module~m_stats_io module~m_ia_vdw->module~m_globals var panmodulem_simboxUsedByGraph = svgPanZoom('#modulem_simboxUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types smbx_t Subroutines smbx_init smbx_set_basis smbx_freeze smbx_unfreeze smbx_get_image smbx_wrap_all smbx_to_center smbx_get_rnd_points Derived Types type, public :: smbx_t Components Type Visibility Attributes Name Initial real(kind=rp), public, dimension(3,3) :: basis real(kind=rp), public, dimension(3,3) :: dl_basis real(kind=rp), public :: volume logical, public :: is_deforming logical, public :: is_aligned Whether the basis vectors are aligned with the laboratory frame Type-Bound Procedures procedure, public :: set_basis => smbx_set_basis procedure, public :: freeze => smbx_freeze procedure, public :: unfreeze => smbx_unfreeze procedure, public :: get_image => smbx_get_image procedure, public :: wrap_all => smbx_wrap_all procedure, public :: to_center => smbx_to_center procedure, public :: get_rnd_points => smbx_get_rnd_points Subroutines public subroutine smbx_init (this) Creates an instance of smbx_t . Can also be called to reset. Arguments Type Intent Optional Attributes Name type( smbx_t ), intent(inout) :: this public subroutine smbx_set_basis (this, bv) Sets all three basis vectors. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(3,3) :: bv public subroutine smbx_freeze (this) Specifies this as non-deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this public subroutine smbx_unfreeze (this) Specifies this as deforming. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(inout) :: this public subroutine smbx_get_image (this, r) Returns the image of r under PBC. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(3) :: r public subroutine smbx_wrap_all (this, coords) Wraps atom positions w.r.t. periodic boundary conditions. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords public subroutine smbx_to_center (this, coords, com) Adjusts atom positions such that the c.o.m. of the atoms is at the center \n of the box. Assumes all atoms to have the same mass and aligned axis.\n Optionally returns the original c.o.m. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(inout), dimension(:,:) :: coords real(kind=rp), intent(out), optional dimension(3) :: com public subroutine smbx_get_rnd_points (this, coords) Returns uniformly distributed points within the box. Arguments Type Intent Optional Attributes Name class( smbx_t ), intent(in) :: this real(kind=rp), intent(out), dimension(:,:) :: coords","tags":"","loc":"module/m_simbox.html"},{"title":"m_stats_io – BROWNPAK","text":"Computes and writes properties calculated during simulation. Uses m_precision m_constants_math m_strings m_globals module~~m_stats_io~~UsesGraph module~m_stats_io m_stats_io module~m_constants_math m_constants_math module~m_stats_io->module~m_constants_math module~m_precision m_precision module~m_stats_io->module~m_precision module~m_strings m_strings module~m_stats_io->module~m_strings module~m_globals m_globals module~m_stats_io->module~m_globals module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_strings->module~m_precision module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_trajectory->module~m_precision module~m_logger m_logger module~m_trajectory->module~m_logger module~m_simbox->module~m_constants_math module~m_simbox->module~m_precision module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_logger->iso_fortran_env module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_stats_io~~UsedByGraph module~m_stats_io m_stats_io module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_stats_io module~m_setup m_setup module~m_setup->module~m_stats_io module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_relax m_relax module~m_relax->module~m_stats_io module~m_mpcd->module~m_stats_io program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_relax program~main->module~m_mpcd Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables fu_stats span reedsq rgsq reev asph prol rgsq_bbone rgsq_sc reedsq_sc asph_sc prol_sc molbuf Subroutines stats_init stats_finish stats_write_hdr stats_write stats_compute_ic1 stats_compute_ic0 calc_shape dsyevc3 Variables Type Visibility Attributes Name Initial integer, private :: fu_stats Unit number of file fn_stats . real(kind=rp), private, dimension(3) :: span Span of a chain molecule. For multiple molecules this is averaged. real(kind=rp), private :: reedsq Mean squared end-to-end distance of a linear chain molecule.\n For multiple molecules this is averaged. Not defined for rings. real(kind=rp), private :: rgsq Mean squared gyration radius of a chain/ring molecule.\n For multiple molecules this is averaged. real(kind=rp), private, dimension(3) :: reev End-to-end vector. Not defined for rings. real(kind=rp), private :: asph Asphericity of the entire molecule real(kind=rp), private :: prol Prolateness of the entire molecule real(kind=rp), private :: rgsq_bbone Mean squared gyration radius of the backbone of a branched\n chain/ring molecule. real(kind=rp), private :: rgsq_sc Mean squared gyration radius of the side chains of a branched\n chain/ring molecule. real(kind=rp), private :: reedsq_sc Mean squared end-to-end distance of the side chains of a branched\n chain/ring molecule. real(kind=rp), private :: asph_sc Mean asphericity of the side chains of a branched chain/ring molecule. real(kind=rp), private :: prol_sc Mean prolateness of the side chains of a branched chain/ring molecule. real(kind=rp), private, dimension(:,:), allocatable :: molbuf Buffer for the largest molecule in the system Subroutines public subroutine stats_init () Set up for stats collection Arguments None public subroutine stats_finish () Closes any files opened in stats_init . Arguments None private subroutine stats_write_hdr () Driver for writing header of file fn_stats . This is called only after\n appropriate files have been opened. Arguments None public subroutine stats_write () Writing statistics Arguments None private subroutine stats_compute_ic1 () Computes statistics for a possibly multiple chains in a periodic domain. Arguments None private subroutine stats_compute_ic0 () Computes statistics for a single chain in unbounded domain. Arguments None private subroutine calc_shape (ev1, ev2, ev3, asph, prol) Given three eigen values of the gyration tensor, calculates asphericity\n and prolateness. Note that ev1 >= ev2 >= ev3. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ev1 real(kind=rp), intent(in) :: ev2 real(kind=rp), intent(in) :: ev3 real(kind=rp), intent(out) :: asph real(kind=rp), intent(out) :: prol private subroutine dsyevc3 (A, W) Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's\n analytical algorithm.\n Only the diagonal and upper triangular parts of A are accessed. The access\n is read-only. Read more… Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), DIMENSION(3,3) :: A real(kind=RP), intent(out), DIMENSION(3) :: W (3)","tags":"","loc":"module/m_stats_io.html"},{"title":"m_strings – BROWNPAK","text":"Many of these routines were originally written by George Benthien , some have\n been written by Sarit Dutta or gathered/modified from other authors (appropriately credited). These routines were developed primarily to aid in the reading and manipulation\n of input data from an ASCII text file. Accordingly, it is assumed that all\n characters to be processed are ASCII characters. Uses m_precision module~~m_strings~~UsesGraph module~m_strings m_strings module~m_precision m_precision module~m_strings->module~m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_strings~~UsedByGraph module~m_strings m_strings module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_strings module~m_config_io m_config_io module~m_bd_solver->module~m_config_io module~m_stats_io m_stats_io module~m_bd_solver->module~m_stats_io module~m_interaction m_interaction module~m_bd_solver->module~m_interaction module~m_config_io->module~m_strings program~main main program~main->module~m_strings program~main->module~m_bd_solver module~m_mpcd m_mpcd program~main->module~m_mpcd module~m_control_io m_control_io program~main->module~m_control_io module~m_relax m_relax program~main->module~m_relax module~m_setup m_setup program~main->module~m_setup module~m_stats_io->module~m_strings module~m_kmc m_kmc module~m_kmc->module~m_strings module~m_kmc->module~m_interaction module~m_mpcd->module~m_strings module~m_mpcd->module~m_config_io module~m_mpcd->module~m_stats_io module~m_mpcd->module~m_interaction module~m_control_io->module~m_strings module~m_ia_bond m_ia_bond module~m_ia_bond->module~m_strings module~m_relax->module~m_strings module~m_relax->module~m_config_io module~m_relax->module~m_stats_io module~m_relax->module~m_interaction module~m_interaction->module~m_ia_bond module~m_setup->module~m_bd_solver module~m_setup->module~m_config_io module~m_setup->module~m_stats_io module~m_setup->module~m_mpcd module~m_setup->module~m_interaction Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces str_from_num Functions str_is_letter str_is_digit str_is_space str_is_comment str_compact str_remove_stcc str_to_upper str_to_lower str_from_inum str_from_ilnum str_from_dnum str_trimzero str_to_d str_to_i str_strip str_startswith str_endswith Subroutines str_shift str_insert str_del str_strip_comment str_get_keyval str_match str_compact_rlstr str_split str_append readline Interfaces public interface str_from_num Generic  interface for writing a number to a string. The calling syntax is str_from_num(num, frmt) where number is a real number or an integer, format is the format desired, e.g., e15.6 , i5 , etc. private pure function str_from_inum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_ilnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_dnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable Functions public pure function str_is_letter (str) result(res) Returns .true. if str contains only letters ( a--z or A--Z ) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical public pure function str_is_digit (str) result(res) Returns .true. if str contains only digits (0,1,...,9) and .false. otherwise. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical public pure function str_is_space (str) result(res) Returns .true. if str is non-empty and contains only whitespace\n characters (tab or blankspace). Otherwise .false. is returned. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical public pure function str_is_comment (line, comment_str) result(res) Returns .true. if line is a comment, .false. other wise. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Input string character(len=*), intent(in) :: comment_str String marking the beginning of a comment. Return Value logical public pure function str_compact (str) result(ostr) Returns a copy of str with multiple spaces and tabs converted to\n single spaces, control characters deleted, and leading and trailing\n spaces removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable public pure function str_remove_stcc (str) result(ostr) Returns a copy of the string str with spaces, tabs, and\n control characters removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable public pure function str_to_upper (str) result(ucstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to uppercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) public pure function str_to_lower (str) result(lcstr) This function returns a string that is like the string str with all characters\n  that are not between a pair of quotes (\"...\" or '...') converted to lowercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) private pure function str_from_inum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_ilnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name integer(kind=ip_long), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable private pure function str_from_dnum (num, frmt) result(str) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: num character(len=*), intent(in), optional :: frmt Return Value character(len=:),\n  allocatable public pure function str_trimzero (str) result(res) Deletes nonsignificant trailing zeroes from number string str. If number\n string ends in a decimal point, one trailing zero is added. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable public pure function str_to_d (str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value real(kind=rp) public pure function str_to_i (str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer public pure function str_strip (str, chars, ends) result(ostr) Returns a copy of string str with the leading and trailing characters\n removed. The chars argument is a string specifying the set of characters to\n be removed.  The chars argument is not a prefix or suffix; rather, all\n combinations of its values are stripped. If ends = 'l' , only leading\n characters are removed, if ends = 'r' , only trailing characters are\n removed, and if ends = 'b' both leading and trailing characters are\n removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: chars character(len=1), intent(in) :: ends {'l', 'r', 'b'} Return Value character(len=:),\n  allocatable public pure function str_startswith (str, prefix, start, finish) result(res) Returns .true. if the string str starts with prefix , otherwise\n returns .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: prefix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical public pure function str_endswith (str, suffix, start, finish) result(res) Returns .true. if the string str ends with suffix , otherwise\n return .false. . With optional start , test beginning at that position.\n With optional finish , stop comparing beyond that position. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value logical Subroutines public subroutine str_shift (str, n) Shifts characters in str by n positions (positive values\n denote a right shift and negative values denote a left shift). Characters\n that are shifted off the end are lost. Positions opened up by the shift \n are replaced by spaces. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str integer, intent(in) :: n public subroutine str_insert (str, substr, loc) Inserts the string substr into the string str at position loc . \n Characters in str starting at position loc are shifted right to\n make room for the inserted string. Trailing spaces of substr are \n removed prior to insertion. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in) :: loc public subroutine str_del (str, substr, n) Deletes first n occurrences of substring substr from string str and\n shifts characters left to fill hole. If n < 0 , all occurances are\n deleted.  If n is not explicitly provided, it defaults to removing the\n first occurrence. Trailing spaces or blanks are not considered part of substr . Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: substr integer, intent(in), optional :: n public subroutine str_strip_comment (str, comment_str) Strips trailing comment from a string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str Input string character(len=*), intent(in) :: comment_str String indicating beginning of a comment. public subroutine str_get_keyval (str, key, val, delimiter) Split a string str into two strings, key and val based on space\n delimiter. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=:), intent(out), allocatable :: key character(len=:), intent(out), allocatable :: val character(len=*), intent(in), optional :: delimiter public subroutine str_match (str, ipos, imatch) This routine finds the delimiter in string str that matches the delimiter\n in position ipos of str . The argument imatch contains the position of\n the matching delimiter. Allowable delimiters are (), [], {}, <>. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: ipos integer, intent(out) :: imatch public subroutine str_compact_rlstr (str) Author Izaak Beekman Date 02/24/2015 Compact a string representing a real number, so that the same value is\n displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str string representation of a real number. public subroutine str_split (str, delimiter, before) Routine finds the first instance of a character from delims in the the\n string str . The characters before the found delimiter are output in before . The characters after the found delimiter are output in str .\n Repeated applications of this routine can be used to parse a string into its\n component parts. Multiple whitespaces of str are compacted into a single\n whitespace before splitting begins. If either str or delimiter is\n empty, an empty string is retured in before and str remains\n unchanged. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str character(len=*), intent(in) :: delimiter character(len=:), intent(out), allocatable :: before public subroutine str_append (dest, source, sep) Appends a copy of the source string to the dest string, with \n optional string sep in between. It is assumed that dest is long\n enough to hold the result, otherwise an error will be generated. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: dest character(len=*), intent(in) :: source character(len=*), intent(in), optional :: sep public subroutine readline (nunitr, line, comment_str, ios) Reads a line from unit=nunitr, ignoring blank lines\n  and deleting comments Arguments Type Intent Optional Attributes Name integer, intent(in) :: nunitr character(len=*), intent(inout) :: line character(len=*), intent(in) :: comment_str integer, intent(out) :: ios","tags":"","loc":"module/m_strings.html"},{"title":"m_table – BROWNPAK","text":"Implements a table with contiguously stored rows. Uses m_precision m_vector module~~m_table~~UsesGraph module~m_table m_table module~m_vector m_vector module~m_table->module~m_vector module~m_precision m_precision module~m_table->module~m_precision module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_qsort->module~m_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_table~~UsedByGraph module~m_table m_table module~m_verlet m_verlet module~m_verlet->module~m_table module~m_connectivity m_connectivity module~m_connectivity->module~m_table module~m_interaction m_interaction module~m_interaction->module~m_verlet module~m_interaction->module~m_connectivity module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_mpcd->module~m_interaction module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax m_relax module~m_relax->module~m_interaction program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd program~main->module~m_relax Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types itable_t Functions itbl_is_in itbl_get_val Subroutines itbl_init itbl_delete itbl_clear itbl_append itbl_set_val itbl_get_row itbl_shrink_to_fit itbl_print Derived Types type, public :: itable_t Components Type Visibility Attributes Name Initial integer, public :: num_rows = 0 type( ivector_t ), public :: buffer integer, public, dimension(:), allocatable :: row_indx Type-Bound Procedures procedure, public :: delete => itbl_delete procedure, public :: clear => itbl_clear procedure, public :: append => itbl_append procedure, public :: set_val => itbl_set_val procedure, public :: is_in => itbl_is_in procedure, public :: get_val => itbl_get_val procedure, public :: get_row => itbl_get_row procedure, public :: shrink_to_fit => itbl_shrink_to_fit procedure, public :: print => itbl_print Functions private function itbl_is_in (this, irow, val) result(res) Returns .true. if val is in row irow , .false. otherwise. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: val Return Value logical private function itbl_get_val (this, irow, j) result(res) Returns the j th element of row irow Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this integer, intent(in) :: irow integer, intent(in) :: j Return Value integer Subroutines public subroutine itbl_init (this, num_rows, ierr) Creates an empty itable_t with num_rows rows and all rows having\n zero elements. Arguments Type Intent Optional Attributes Name type( itable_t ), intent(inout) :: this integer, intent(in) :: num_rows Must be > 0 integer, intent(out), optional :: ierr private subroutine itbl_delete (this) Deletes an itable_t . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this private subroutine itbl_clear (this) Clears all rows. Does not deallocate memory. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this private subroutine itbl_append (this, irow, val) Appends an element val to row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: val private subroutine itbl_set_val (this, irow, j, val) Sets the value of the j th element of row irow . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(in) :: irow integer, intent(in) :: j integer, intent(in) :: val private subroutine itbl_get_row (this, irow, res) Returns a pointer to the row data of irow . No bounds checking is performed. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in), target :: this integer, intent(in) :: irow integer, intent(out), dimension(:), pointer :: res private subroutine itbl_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data. Arguments Type Intent Optional Attributes Name class( itable_t ), intent(inout) :: this integer, intent(out), optional :: ierr private subroutine itbl_print (this) Prints an itable_t . Arguments Type Intent Optional Attributes Name class( itable_t ), intent(in) :: this","tags":"","loc":"module/m_table.html"},{"title":"m_trajectory – BROWNPAK","text":"Routines for reading and writing frames from a trajectory file. Uses m_precision m_logger module~~m_trajectory~~UsesGraph module~m_trajectory m_trajectory module~m_logger m_logger module~m_trajectory->module~m_logger module~m_precision m_precision module~m_trajectory->module~m_precision iso_fortran_env iso_fortran_env module~m_logger->iso_fortran_env module~m_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_trajectory~~UsedByGraph module~m_trajectory m_trajectory module~m_globals m_globals module~m_globals->module~m_trajectory module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_globals module~m_interaction m_interaction module~m_bd_solver->module~m_interaction module~m_config_io m_config_io module~m_bd_solver->module~m_config_io module~m_stats_io m_stats_io module~m_bd_solver->module~m_stats_io module~m_interaction->module~m_globals module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_cell_list m_cell_list module~m_interaction->module~m_cell_list module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_ia_dihedral->module~m_globals module~m_setup m_setup module~m_setup->module~m_globals module~m_setup->module~m_bd_solver module~m_setup->module~m_interaction module~m_setup->module~m_config_io module~m_setup->module~m_stats_io module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_config_io->module~m_globals module~m_stats_io->module~m_globals module~m_ia_angle->module~m_globals program~main main program~main->module~m_globals program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd module~m_control_io m_control_io program~main->module~m_control_io module~m_relax m_relax program~main->module~m_relax module~m_verlet->module~m_globals module~m_cell_list->module~m_globals module~m_connectivity->module~m_globals module~m_ia_external->module~m_globals module~m_ia_tether->module~m_globals module~m_kmc m_kmc module~m_kmc->module~m_globals module~m_kmc->module~m_interaction module~m_mpcd->module~m_globals module~m_mpcd->module~m_interaction module~m_mpcd->module~m_config_io module~m_mpcd->module~m_stats_io module~m_mpcd->module~m_cell_list module~m_control_io->module~m_globals module~m_ia_bond->module~m_globals module~m_relax->module~m_globals module~m_relax->module~m_interaction module~m_relax->module~m_config_io module~m_relax->module~m_stats_io module~m_ia_vdw->module~m_globals var panmodulem_trajectoryUsedByGraph = svgPanZoom('#modulem_trajectoryUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types trajectory_t Subroutines traj_create traj_open traj_clear traj_close traj_read traj_append_frame traj_write_frame Derived Types type, public :: trajectory_t Components Type Visibility Attributes Name Initial integer, public :: header_size = 0 integer, public :: frame_size = 0 integer, public :: num_atoms = 0 integer, public :: num_mpcd_atoms = 0 integer, public :: num_atoms_tot = 0 integer, public, dimension(4) :: frmcmp = 0 character(len=:), public, allocatable :: fn integer, public :: file_id = 0 integer, public :: num_frames = 0 logical, public :: isopen = .false. Type-Bound Procedures procedure, public :: create => traj_create procedure, public :: open => traj_open procedure, public :: clear => traj_clear procedure, public :: close => traj_close procedure, public :: read => traj_read procedure, public :: append_frame => traj_append_frame procedure, public :: write_frame => traj_write_frame generic, public :: init => create, open Subroutines public subroutine traj_create (this, fn, na, nam, frmcmp) Creates a trajectory_t object with a new underlying file named fn .  If fn already exists, it will be truncated.  The file fn is opened for both\n  reading and writing. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this trajectory_t instance. character(len=*), intent(in) :: fn Name of the underlying trajectory file. integer, intent(in) :: na Number of non-MPCD atoms integer, intent(in) :: nam Number of MPCD atoms, pass zero to indicate no data from MPCD\n particles are present. integer, intent(in), dimension(4) :: frmcmp Binary flags indicating whether that component is present in a frame.\n frmcmp(1): coordinates, frmcmp(2): velocities, frmcmp(3): forces,\n frmcmp(4): charges public subroutine traj_open (this, fn, mode, ierr) Creates a trajectory_t object with a prexisting underlying file named fn .  If fn does not exist, an error will be generated. If mode == 'rw', the file fn is opened for both reading and writing.\n  If mode == 'r', the file fn is opened only for reading. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(out) :: this character(len=*), intent(in) :: fn character(len=*), intent(in) :: mode integer, intent(out) :: ierr public subroutine traj_clear (this) After a call to this subroutine, all memory within this is deallocated,\n all components of this are reset to zero, and the underlying file is\n closed (if open). Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this public subroutine traj_close (this) Closes the underlying file of a trajectory_t . Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this public subroutine traj_read (this, iframe, nts, ierr, mflag, coordinates, velocities, forces, charge) Read from an open trajectory. Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(in) :: this integer, intent(in) :: iframe Frame number integer(kind=ip_long), intent(out) :: nts Time step counter integer, intent(out) :: ierr Error flag integer, intent(in), optional :: mflag 1: Only non-MPCD data, 2: Only MPCD data, 3: All data real(kind=rp), intent(out), optional dimension(:,:) :: coordinates real(kind=rp), intent(out), optional dimension(:,:) :: velocities real(kind=rp), intent(out), optional dimension(:,:) :: forces real(kind=rp), intent(out), optional dimension(:) :: charge public subroutine traj_append_frame (this, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge public subroutine traj_write_frame (this, iframe, nts, coordinates, velocities, forces, charge) Write a frame to an open trajectory Arguments Type Intent Optional Attributes Name class( trajectory_t ), intent(inout) :: this integer, intent(in) :: iframe integer(kind=ip_long), intent(in) :: nts real(kind=rp), intent(in), dimension(:,:) :: coordinates real(kind=rp), intent(in), dimension(:,:) :: velocities real(kind=rp), intent(in), dimension(:,:) :: forces real(kind=rp), intent(in), dimension(:) :: charge","tags":"","loc":"module/m_trajectory.html"},{"title":"m_utils_math – BROWNPAK","text":"Various (mostly linear algebra) functions, particularly for use with small\nmatrices. Uses ieee_arithmetic m_constants_math m_precision module~~m_utils_math~~UsesGraph module~m_utils_math m_utils_math module~m_constants_math m_constants_math module~m_utils_math->module~m_constants_math module~m_precision m_precision module~m_utils_math->module~m_precision ieee_arithmetic ieee_arithmetic module~m_utils_math->ieee_arithmetic module~m_constants_math->module~m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_utils_math~~UsedByGraph module~m_utils_math m_utils_math module~m_mpcd m_mpcd module~m_mpcd->module~m_utils_math program~main main program~main->module~m_mpcd module~m_setup m_setup program~main->module~m_setup module~m_setup->module~m_mpcd Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces allclose swap Functions scalar_triple_product det trace isclose allclose_rank1 allclose_rank2 allclose_rank3 get_quad_form Subroutines rad2deg deg2rad cross cross_mat outer vector_triple_product swap_integer swap_real swap_complex unitize linspace logspace identity get_diagonal add_transpose subtract_transpose multiply_transpose orth invert_mat33 eigval_33rsym dsyevc3 Interfaces public interface allclose Checks if two arrays are elementwise close within tolerance public function allclose_rank1 (a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank2 (a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank3 (a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public interface swap Swaps two arrays public elemental subroutine swap_integer (a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b public elemental subroutine swap_real (a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b public elemental subroutine swap_complex (a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b Functions public function scalar_triple_product (a, b, c) result(res) Returns the scalar triple product a .( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c Return Value real(kind=rp) public function det (A) result(res) Returns the determinant of an (N x N) matrix, where N = 2, 3, or 4. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (N,N) array, where N = 2, 3, or 4. Return Value real(kind=rp) public function trace (mat) result(res) Returns the trace of a square matrix Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mat (:,:) (N,N) array Return Value real(kind=rp) public elemental function isclose (a, b, rel_tol, abs_tol) Checks if two floating point numbers of type double are close within\n  tolerance. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b real(kind=rp), intent(in), optional :: rel_tol Relative tolerance, rel_tol >= 0, default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance, abs_tol >= 0, default 0.0 Return Value logical public function allclose_rank1 (a, b, rel_tol, abs_tol) Checks if two rank-1 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (m,) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank2 (a, b, rel_tol, abs_tol) Checks if two rank-2 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: a (m,n) array real(kind=rp), intent(in), dimension(:,:) :: b (m,n) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function allclose_rank3 (a, b, rel_tol, abs_tol) Checks if two rank-3 floating point arrays of type double are close within\n  tolerance. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:,:) :: a (m,n,p) array real(kind=rp), intent(in), dimension(:,:,:) :: b (m,n,p) array real(kind=rp), intent(in), optional :: rel_tol Relative tolerance; default 1e-10 real(kind=rp), intent(in), optional :: abs_tol Absolute tolerance; default 0.0 Return Value logical public function get_quad_form (A, x) result(res) Calculates the quadratic form x&#94;T A x , where A is an n x n matrix and x is a\n  vector of length n Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (n,n) array real(kind=rp), intent(in), dimension(:) :: x (n,) array Return Value real(kind=rp) Subroutines public elemental subroutine rad2deg (rad, deg) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rad real(kind=rp), intent(out) :: deg public elemental subroutine deg2rad (deg, rad) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: deg real(kind=rp), intent(out) :: rad public subroutine cross (a, b, c) Calculates the cross product between two 3-element vectors Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(out), dimension(3) :: c Cross product of a and b ; c = a x b public subroutine cross_mat (a, mat) Calculates the cross product matrix of a 3-element vector. The cross\n product matrix A of a is defined as a x b = A . b ,\n where b is another 3-element vector. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(out), dimension(3,3) :: mat Cross product matrix of a public subroutine outer (a, b, c) Calculates the outer product of two vectors, c_{ij} = a_i  b_j . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:) :: a (m,) array real(kind=rp), intent(in), dimension(:) :: b (n,) array real(kind=rp), intent(out), dimension(:,:) :: c (m,n) array; Outer product public subroutine vector_triple_product (a, b, c, d) Returns the vector triple product d = a x ( b x c ) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3) :: a real(kind=rp), intent(in), dimension(3) :: b real(kind=rp), intent(in), dimension(3) :: c real(kind=rp), intent(out), dimension(3) :: d Vector triple product public elemental subroutine swap_integer (a, b) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b public elemental subroutine swap_real (a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a real(kind=rp), intent(inout) :: b public elemental subroutine swap_complex (a, b) Arguments Type Intent Optional Attributes Name complex(kind=rp), intent(inout) :: a complex(kind=rp), intent(inout) :: b public subroutine unitize (a) Normalizes a vector in-place. If the magnitude of the vector is nearly\n zero, no normalization takes place and the vector is returned as is with\n a warning message. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:) :: a (m,) array public subroutine linspace (start, finish, num, val, step) Generates evenly spaced numbers over a specified interval. Both end\n points are included. If start < finish , the returned step size (if step is present) will be negative. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point real(kind=rp), intent(in) :: finish Ending point, finish /= start integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(out), optional :: step Step size public subroutine logspace (start, finish, num, val, base) Generates numbers spaced evenly on a log scale.\n  In linear space, the sequence starts at base ** start ( base to the power of start ) and ends with base ** stop Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: start Starting point, base ** start is the starting value real(kind=rp), intent(in) :: finish Ending point, finish /= start , base ** start is the ending value integer, intent(in) :: num Number of values to generate, num >= 2 real(kind=rp), intent(out), dimension(:) :: val ( num ,) array; Generated values real(kind=rp), intent(in), optional :: base Base of the logspace, default 10 public subroutine identity (mat_eye) Creates an identity matrix of size n x n. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out), dimension(:,:) :: mat_eye (n,n) array public subroutine get_diagonal (mat, d) Returns the diagonal elements of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: mat (n,n) array real(kind=rp), intent(out), dimension(:) :: d (n,) array; contains the entries of the main diagonal public subroutine add_transpose (mat) Adds a square matrix and its transpose in place: A_{ij} = A_{ij } + A_{ji} Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat (n,n) array public subroutine subtract_transpose (mat) Calculates the difference of a square matrix and its transpose in place: A_{ij} = A_{ij } - A_{ji} Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: mat public subroutine multiply_transpose (A, B) Multiplies a matrix with its transpose: \\mathbf{\\mathrm{B}} = \\mathbf{\\mathrm{A}} \\cdot \\mathbf{\\mathrm{A}}&#94;T Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(:,:) :: A (m,n) array real(kind=rp), intent(out), dimension(:,:) :: B (m,m) array public subroutine orth (a) Orthogonalizes a set of vectors in-place using Gram-Schmidt orthonormalization Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), dimension(:,:) :: a (m,n) array, where m <= n. The first m columns of the matrix are\n  overwritten with the orthogonal basis vectors. public subroutine invert_mat33 (a, inv_a) Inverts a 3x3 matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3,3) :: inv_a public subroutine eigval_33rsym (a, ev) Calculates the eigenvalues of a 3 x 3 real symmetric matrix. The\n eigenvalues calculated are in decreasing order. Only the diagonal and\n lower triangular part of the matrix is accessed. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), dimension(3,3) :: a real(kind=rp), intent(out), dimension(3) :: ev public subroutine dsyevc3 (A, W) Author Joachim Kopp Date 2006 Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's\n analytical algorithm.\n Only the diagonal and upper triangular parts of A are accessed. The access\n is read-only. Read more… Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), DIMENSION(3,3) :: A real(kind=RP), intent(out), DIMENSION(3) :: W (3)","tags":"","loc":"module/m_utils_math.html"},{"title":"m_vector – BROWNPAK","text":"Implements a vector as an extendable array. Uses m_precision m_qsort module~~m_vector~~UsesGraph module~m_vector m_vector module~m_qsort m_qsort module~m_vector->module~m_qsort module~m_precision m_precision module~m_vector->module~m_precision module~m_qsort->module~m_precision iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_vector~~UsedByGraph module~m_vector m_vector module~m_verlet m_verlet module~m_verlet->module~m_vector module~m_table m_table module~m_verlet->module~m_table module~m_cell_list m_cell_list module~m_cell_list->module~m_vector module~m_connectivity m_connectivity module~m_connectivity->module~m_vector module~m_connectivity->module~m_table module~m_table->module~m_vector module~m_interaction m_interaction module~m_interaction->module~m_verlet module~m_interaction->module~m_cell_list module~m_interaction->module~m_connectivity module~m_mpcd m_mpcd module~m_mpcd->module~m_cell_list module~m_mpcd->module~m_interaction module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_mpcd module~m_setup->module~m_bd_solver program~main main program~main->module~m_mpcd program~main->module~m_bd_solver program~main->module~m_setup module~m_relax m_relax program~main->module~m_relax module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax->module~m_interaction var panmodulem_vectorUsedByGraph = svgPanZoom('#modulem_vectorUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces assignment(=) Derived Types ivector_t dvector_t Functions ivector_get_len dvector_get_len ivector_get_val dvector_get_val Subroutines ivector_init dvector_init ivector_from_array dvector_from_array ivector_delete dvector_delete ivector_clear dvector_clear ivector_assign dvector_assign i_dvector_assign ivector_set_val dvector_set_val ivector_append dvector_append ivector_get_data dvector_get_data ivector_shrink_to_fit dvector_shrink_to_fit ivector_sort dvector_sort ivector_unique dvector_unique ivector_print dvector_print Interfaces public interface assignment(=) public subroutine ivector_assign (this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine dvector_assign (this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other public subroutine i_dvector_assign (this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other Derived Types type, public :: ivector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 integer, public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => ivector_delete procedure, public :: clear => ivector_clear procedure, public :: get_val => ivector_get_val procedure, public :: set_val => ivector_set_val procedure, public :: get_data => ivector_get_data procedure, public :: append => ivector_append procedure, public :: shrink_to_fit => ivector_shrink_to_fit procedure, public :: sort => ivector_sort procedure, public :: unique => ivector_unique procedure, public :: print => ivector_print type, public :: dvector_t Components Type Visibility Attributes Name Initial integer, public :: len_init = 8 integer, public :: len = 0 integer, public :: len_max = 16 real(kind=rp), public, dimension(:), allocatable :: buffer Type-Bound Procedures procedure, public :: delete => dvector_delete procedure, public :: clear => dvector_clear procedure, public :: get_val => dvector_get_val procedure, public :: set_val => dvector_set_val procedure, public :: get_data => dvector_get_data procedure, public :: append => dvector_append procedure, public :: shrink_to_fit => dvector_shrink_to_fit procedure, public :: sort => dvector_sort procedure, public :: unique => dvector_unique procedure, public :: print => dvector_print Functions public function ivector_get_len (this) result(res) Returns the length of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this Return Value integer public function dvector_get_len (this) result(res) Returns the length of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this Return Value integer public function ivector_get_val (this, i) result(res) Returns the ith element of an ivector . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this integer, intent(in) :: i Return Value integer public function dvector_get_val (this, i) result(res) Returns the ith element of a dvector . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rp) Subroutines public subroutine ivector_init (this, len_init, ierr) Creates an empty ivector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr public subroutine dvector_init (this, len_init, ierr) Creates an empty dvector with all elements equal to zero. Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this integer, intent(in), optional :: len_init Must be > 0 integer, intent(out), optional :: ierr public subroutine ivector_from_array (this, x) Creates an ivector with all elements from an array Arguments Type Intent Optional Attributes Name type( ivector_t ), intent(inout) :: this integer, intent(in), dimension(:) :: x public subroutine dvector_from_array (this, x) Creates a dvector with all elements from an array Arguments Type Intent Optional Attributes Name type( dvector_t ), intent(inout) :: this real(kind=rp), intent(in), dimension(:) :: x public subroutine ivector_delete (this) Deletes an ivector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this public subroutine dvector_delete (this) Deletes a dvector . No access is allowed to this object after this call. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this public subroutine ivector_clear (this) Clears an ivector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this public subroutine dvector_clear (this) Clears a dvector . Access allowed after a call to clear. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this public subroutine ivector_assign (this, other) Copies the contents of ivector other to ivector this Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine dvector_assign (this, other) Copies the contents of dvector other to dvector this Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( dvector_t ), intent(in) :: other public subroutine i_dvector_assign (this, other) Copies the contents of ivector other to dvector this . Integers\n  are cast to reals. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this class( ivector_t ), intent(in) :: other public subroutine ivector_set_val (this, i, val) Sets the value of the ith element of an ivector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: val public subroutine dvector_set_val (this, i, val) Sets the value of the ith element of a dvector . No bounds check is performed. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(in) :: i real(kind=rp), intent(in) :: val public subroutine ivector_append (this, val) Adds an element to the end of an ivector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(in) :: val public subroutine dvector_append (this, val) Adds an element to the end of a dvector . Reallocation will take place if required. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this real(kind=rp), intent(in) :: val public subroutine ivector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in), target :: this integer, intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend public subroutine dvector_get_data (this, res, ibeg, iend) Returns a pointer to the underlying data of a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in), target :: this real(kind=rp), intent(out), dimension(:), pointer :: res integer, intent(in), optional :: ibeg integer, intent(in), optional :: iend public subroutine ivector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of an ivector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional :: ierr public subroutine dvector_shrink_to_fit (this, ierr) Releases additional memory to fit underlying data of a dvector to a size\n this%len_init. Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional :: ierr public subroutine ivector_sort (this, order) Sorts an ivector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order public subroutine dvector_sort (this, order) Sorts a dvector in ascending order. If order is provided, it will contain\n  the sorted indices.  The size of order must be at least this%len . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this integer, intent(out), optional dimension(:) :: order public subroutine ivector_unique (this) Sorts and removes all duplicate entries of an ivector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call ivector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(inout) :: this public subroutine dvector_unique (this) Sorts and removes all duplicate entries of a dvector . Note that the internal\n buffer size remains unchanged. To reduce the buffer size, call dvector_shrink_to_fit . Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(inout) :: this public subroutine ivector_print (this) Prints an ivector Arguments Type Intent Optional Attributes Name class( ivector_t ), intent(in) :: this public subroutine dvector_print (this) Prints a dvector Arguments Type Intent Optional Attributes Name class( dvector_t ), intent(in) :: this","tags":"","loc":"module/m_vector.html"},{"title":"m_verlet – BROWNPAK","text":"Routines for building Verlet neighbor table. Uses m_precision m_vector m_table m_globals module~~m_verlet~~UsesGraph module~m_verlet m_verlet module~m_vector m_vector module~m_verlet->module~m_vector module~m_precision m_precision module~m_verlet->module~m_precision module~m_table m_table module~m_verlet->module~m_table module~m_globals m_globals module~m_verlet->module~m_globals module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort iso_fortran_env iso_fortran_env module~m_precision->iso_fortran_env module~m_table->module~m_vector module~m_table->module~m_precision module~m_globals->module~m_precision module~m_simbox m_simbox module~m_globals->module~m_simbox module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_qsort->module~m_precision module~m_simbox->module~m_precision module~m_constants_math m_constants_math module~m_simbox->module~m_constants_math module~m_ran_num m_ran_num module~m_simbox->module~m_ran_num module~m_trajectory->module~m_precision module~m_logger m_logger module~m_trajectory->module~m_logger module~m_constants_math->module~m_precision module~m_logger->iso_fortran_env module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~m_verlet~~UsedByGraph module~m_verlet m_verlet module~m_interaction m_interaction module~m_interaction->module~m_verlet module~m_bd_solver m_bd_solver module~m_bd_solver->module~m_interaction module~m_setup m_setup module~m_setup->module~m_interaction module~m_setup->module~m_bd_solver module~m_mpcd m_mpcd module~m_setup->module~m_mpcd module~m_mpcd->module~m_interaction module~m_kmc m_kmc module~m_kmc->module~m_interaction module~m_relax m_relax module~m_relax->module~m_interaction program~main main program~main->module~m_bd_solver program~main->module~m_setup program~main->module~m_mpcd program~main->module~m_relax Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables verlet_tab coordinates_save coordinates_dr rskin_sq tskin_sq Subroutines verlet_init verlet_delete verlet_build Variables Type Visibility Attributes Name Initial type( itable_t ), public :: verlet_tab Verlet table real(kind=rp), private, dimension(:,:), allocatable :: coordinates_save (3, num_atoms ) array real(kind=rp), private, dimension(:,:), allocatable :: coordinates_dr (3, num_atoms ) array real(kind=rp), private :: rskin_sq = 0.0_rp real(kind=rp), private :: tskin_sq = 0.0_rp Subroutines public subroutine verlet_init (rskin, tskin) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: rskin real(kind=rp), intent(in) :: tskin public subroutine verlet_delete () Arguments None public subroutine verlet_build () Arguments None","tags":"","loc":"module/m_verlet.html"},{"title":"main – BROWNPAK","text":"Uses m_precision m_strings m_logger m_globals m_control_io m_setup m_relax m_bd_solver m_mpcd program~~main~~UsesGraph program~main main module~m_bd_solver m_bd_solver program~main->module~m_bd_solver module~m_logger m_logger program~main->module~m_logger module~m_setup m_setup program~main->module~m_setup module~m_precision m_precision program~main->module~m_precision module~m_strings m_strings program~main->module~m_strings module~m_globals m_globals program~main->module~m_globals module~m_mpcd m_mpcd program~main->module~m_mpcd module~m_control_io m_control_io program~main->module~m_control_io module~m_relax m_relax program~main->module~m_relax module~m_bd_solver->module~m_logger module~m_bd_solver->module~m_precision module~m_bd_solver->module~m_strings module~m_bd_solver->module~m_globals module~m_constants_math m_constants_math module~m_bd_solver->module~m_constants_math module~m_interaction m_interaction module~m_bd_solver->module~m_interaction lapack95 lapack95 module~m_bd_solver->lapack95 module~m_ran_num m_ran_num module~m_bd_solver->module~m_ran_num module~m_config_io m_config_io module~m_bd_solver->module~m_config_io f95_precision f95_precision module~m_bd_solver->f95_precision module~m_stats_io m_stats_io module~m_bd_solver->module~m_stats_io blas95 blas95 module~m_bd_solver->blas95 iso_c_binding iso_c_binding module~m_bd_solver->iso_c_binding iso_fortran_env iso_fortran_env module~m_logger->iso_fortran_env module~m_setup->module~m_bd_solver module~m_setup->module~m_logger module~m_setup->module~m_precision module~m_setup->module~m_globals module~m_setup->module~m_mpcd module~m_setup->module~m_interaction module~m_setup->module~m_ran_num module~m_setup->module~m_config_io module~m_setup->module~m_stats_io module~m_simbox m_simbox module~m_setup->module~m_simbox module~m_precision->iso_fortran_env module~m_strings->module~m_precision module~m_globals->module~m_precision module~m_trajectory m_trajectory module~m_globals->module~m_trajectory module~m_globals->module~m_simbox module~m_mpcd->module~m_logger module~m_mpcd->module~m_precision module~m_mpcd->module~m_strings module~m_mpcd->module~m_globals module~m_mpcd->module~m_constants_math module~m_mpcd->module~m_interaction module~m_mpcd->lapack95 module~m_utils_math m_utils_math module~m_mpcd->module~m_utils_math module~m_mpcd->module~m_ran_num module~m_mpcd->module~m_config_io module~m_mpcd->f95_precision module~m_mpcd->module~m_stats_io module~m_cell_list m_cell_list module~m_mpcd->module~m_cell_list module~m_control_io->module~m_precision module~m_control_io->module~m_strings module~m_control_io->module~m_globals module~m_relax->module~m_logger module~m_relax->module~m_precision module~m_relax->module~m_strings module~m_relax->module~m_globals module~m_relax->module~m_interaction module~m_relax->module~m_ran_num module~m_relax->module~m_config_io module~m_relax->module~m_stats_io module~m_constants_math->module~m_precision module~m_interaction->module~m_precision module~m_interaction->module~m_globals module~m_interaction->module~m_constants_math module~m_interaction->module~m_cell_list module~m_ia_dihedral m_ia_dihedral module~m_interaction->module~m_ia_dihedral module~m_ia_angle m_ia_angle module~m_interaction->module~m_ia_angle module~m_verlet m_verlet module~m_interaction->module~m_verlet module~m_connectivity m_connectivity module~m_interaction->module~m_connectivity module~m_ia_external m_ia_external module~m_interaction->module~m_ia_external module~m_ia_tether m_ia_tether module~m_interaction->module~m_ia_tether module~m_ia_bond m_ia_bond module~m_interaction->module~m_ia_bond module~m_ia_vdw m_ia_vdw module~m_interaction->module~m_ia_vdw module~m_utils_math->module~m_precision module~m_utils_math->module~m_constants_math ieee_arithmetic ieee_arithmetic module~m_utils_math->ieee_arithmetic module~m_ran_num->module~m_precision mkl_vsl_type mkl_vsl_type module~m_ran_num->mkl_vsl_type mkl_vsl mkl_vsl module~m_ran_num->mkl_vsl module~m_config_io->module~m_precision module~m_config_io->module~m_strings module~m_config_io->module~m_globals module~m_config_io->module~m_simbox module~m_stats_io->module~m_precision module~m_stats_io->module~m_strings module~m_stats_io->module~m_globals module~m_stats_io->module~m_constants_math module~m_trajectory->module~m_logger module~m_trajectory->module~m_precision module~m_simbox->module~m_precision module~m_simbox->module~m_constants_math module~m_simbox->module~m_ran_num module~m_cell_list->module~m_precision module~m_cell_list->module~m_globals module~m_vector m_vector module~m_cell_list->module~m_vector module~m_vector->module~m_precision module~m_qsort m_qsort module~m_vector->module~m_qsort module~m_ia_dihedral->module~m_precision module~m_ia_dihedral->module~m_globals module~m_ia_dihedral->module~m_constants_math module~m_ia_angle->module~m_precision module~m_ia_angle->module~m_globals module~m_ia_angle->module~m_constants_math module~m_verlet->module~m_precision module~m_verlet->module~m_globals module~m_verlet->module~m_vector module~m_table m_table module~m_verlet->module~m_table module~m_connectivity->module~m_precision module~m_connectivity->module~m_globals module~m_connectivity->module~m_vector module~m_connectivity->module~m_table module~m_ia_external->module~m_precision module~m_ia_external->module~m_globals module~m_ia_external->module~m_constants_math module~m_ia_tether->module~m_precision module~m_ia_tether->module~m_globals module~m_ia_tether->module~m_constants_math module~m_ia_bond->module~m_logger module~m_ia_bond->module~m_precision module~m_ia_bond->module~m_strings module~m_ia_bond->module~m_globals module~m_ia_bond->module~m_constants_math module~m_ia_vdw->module~m_logger module~m_ia_vdw->module~m_precision module~m_ia_vdw->module~m_globals module~m_ia_vdw->module~m_constants_math module~m_qsort->module~m_precision module~m_table->module~m_precision module~m_table->module~m_vector var panprogrammainUsesGraph = svgPanZoom('#programmainUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~main~~CallsGraph program~main main proc~read_control read_control program~main->proc~read_control proc~finish finish program~main->proc~finish proc~mpcd_run mpcd_run program~main->proc~mpcd_run proc~str_get_keyval str_get_keyval program~main->proc~str_get_keyval proc~rlx_run rlx_run program~main->proc~rlx_run proc~setup setup program~main->proc~setup proc~bds_run bds_run program~main->proc~bds_run proc~read_control->proc~str_get_keyval proc~str_to_d str_to_d proc~read_control->proc~str_to_d proc~str_to_i str_to_i proc~read_control->proc~str_to_i proc~readline readline proc~read_control->proc~readline proc~config_clear config_clear proc~finish->proc~config_clear proc~bds_finish bds_finish proc~finish->proc~bds_finish proc~mpcd_finish mpcd_finish proc~finish->proc~mpcd_finish proc~ia_finish ia_finish proc~finish->proc~ia_finish proc~stats_finish stats_finish proc~finish->proc~stats_finish proc~mpcd_stream mpcd_stream proc~mpcd_run->proc~mpcd_stream proc~mpcd_collide mpcd_collide proc~mpcd_run->proc~mpcd_collide proc~stats_write stats_write proc~mpcd_run->proc~stats_write proc~mpcd_run->proc~stats_finish interface~str_from_num str_from_num proc~mpcd_run->interface~str_from_num proc~str_strip str_strip proc~rlx_run->proc~str_strip proc~write_ldf write_ldf proc~rlx_run->proc~write_ldf proc~write_config write_config proc~rlx_run->proc~write_config proc~rlx_integrate rlx_integrate proc~rlx_run->proc~rlx_integrate proc~rlx_run->interface~str_from_num proc~ia_setup ia_setup proc~setup->proc~ia_setup proc~bds_init bds_init proc~setup->proc~bds_init proc~stats_init stats_init proc~setup->proc~stats_init proc~mpcd_init mpcd_init proc~setup->proc~mpcd_init proc~init_stream init_stream proc~setup->proc~init_stream proc~smbx_init smbx_init proc~setup->proc~smbx_init proc~bds_run->proc~stats_write proc~bds_integrate_hi bds_integrate_hi proc~bds_run->proc~bds_integrate_hi proc~bds_integrate_fd bds_integrate_fd proc~bds_run->proc~bds_integrate_fd proc~bds_run->proc~stats_finish proc~bds_run->interface~str_from_num proc~cl_set_cell_size cl_set_cell_size proc~ia_setup->proc~cl_set_cell_size proc~cl_build_cell_nbrs cl_build_cell_nbrs proc~ia_setup->proc~cl_build_cell_nbrs proc~cl_init cl_init proc~ia_setup->proc~cl_init proc~atbo_build atbo_build proc~ia_setup->proc~atbo_build proc~exat_build exat_build proc~ia_setup->proc~exat_build proc~ia_calc_forces ia_calc_forces proc~mpcd_stream->proc~ia_calc_forces proc~stats_write_hdr stats_write_hdr proc~stats_init->proc~stats_write_hdr proc~cl_build cl_build proc~mpcd_collide->proc~cl_build proc~det det proc~mpcd_collide->proc~det proc~invert_mat33 invert_mat33 proc~mpcd_collide->proc~invert_mat33 proc~mpcd_collide->proc~cl_set_cell_size proc~cl_get_contents cl_get_contents proc~mpcd_collide->proc~cl_get_contents proc~get_rv_uniform get_rv_uniform proc~mpcd_collide->proc~get_rv_uniform proc~cl_get_num_cells cl_get_num_cells proc~mpcd_collide->proc~cl_get_num_cells proc~cross cross proc~mpcd_collide->proc~cross gelsy gelsy proc~mpcd_collide->gelsy proc~stats_compute_ic1 stats_compute_ic1 proc~stats_write->proc~stats_compute_ic1 proc~stats_compute_ic0 stats_compute_ic0 proc~stats_write->proc~stats_compute_ic0 proc~bds_integrate_hi->interface~str_from_num symv symv proc~bds_integrate_hi->symv potrf potrf proc~bds_integrate_hi->potrf proc~calc_ambient_velocity calc_ambient_velocity proc~bds_integrate_hi->proc~calc_ambient_velocity proc~get_rv_gaussian get_rv_gaussian proc~bds_integrate_hi->proc~get_rv_gaussian proc~calc_rpy_tensor calc_rpy_tensor proc~bds_integrate_hi->proc~calc_rpy_tensor proc~bds_integrate_hi->proc~ia_calc_forces proc~calc_bdw_kryl calc_Bdw_kryl proc~bds_integrate_hi->proc~calc_bdw_kryl trmv trmv proc~bds_integrate_hi->trmv proc~rlx_integrate->proc~ia_calc_forces proc~bds_integrate_fd->proc~calc_ambient_velocity proc~bds_integrate_fd->proc~get_rv_gaussian proc~bds_integrate_fd->proc~ia_calc_forces vslnewstream vslnewstream proc~init_stream->vslnewstream proc~str_is_comment str_is_comment proc~readline->proc~str_is_comment proc~str_strip_comment str_strip_comment proc~readline->proc~str_strip_comment proc~str_from_inum str_from_inum interface~str_from_num->proc~str_from_inum proc~str_from_ilnum str_from_ilnum interface~str_from_num->proc~str_from_ilnum proc~str_from_dnum str_from_dnum interface~str_from_num->proc~str_from_dnum vdrnggaussian vdrnggaussian proc~get_rv_gaussian->vdrnggaussian proc~dsyevc3 dsyevc3 proc~stats_compute_ic0->proc~dsyevc3 vdrnguniform vdrnguniform proc~get_rv_uniform->vdrnguniform proc~ia_add_vdw_forces_cl ia_add_vdw_forces_cl proc~ia_calc_forces->proc~ia_add_vdw_forces_cl proc~ia_add_vdw_forces_vl ia_add_vdw_forces_vl proc~ia_calc_forces->proc~ia_add_vdw_forces_vl proc~ia_add_external_forces ia_add_external_forces proc~ia_calc_forces->proc~ia_add_external_forces proc~ia_add_bond_forces ia_add_bond_forces proc~ia_calc_forces->proc~ia_add_bond_forces proc~ia_add_vdw_forces ia_add_vdw_forces proc~ia_calc_forces->proc~ia_add_vdw_forces proc~ia_add_tether_forces ia_add_tether_forces proc~ia_calc_forces->proc~ia_add_tether_forces proc~str_trimzero str_trimzero proc~str_from_dnum->proc~str_trimzero proc~ivector_init ivector_init proc~cl_init->proc~ivector_init proc~itbl_init itbl_init proc~atbo_build->proc~itbl_init proc~exat_build->proc~ivector_init proc~exat_build->proc~itbl_init proc~atat_build atat_build proc~exat_build->proc~atat_build proc~ia_add_vdw_forces_cl->proc~cl_get_contents proc~ia_add_vdw_forces_cl->proc~cl_get_num_cells proc~ia_get_vdw_force ia_get_vdw_force proc~ia_add_vdw_forces_cl->proc~ia_get_vdw_force proc~cl_get_nbr_cells cl_get_nbr_cells proc~ia_add_vdw_forces_cl->proc~cl_get_nbr_cells proc~verlet_build verlet_build proc~ia_add_vdw_forces_vl->proc~verlet_build proc~ia_add_vdw_forces_vl->proc~ia_get_vdw_force proc~ia_get_bond_force ia_get_bond_force proc~ia_add_bond_forces->proc~ia_get_bond_force proc~itbl_init->proc~ivector_init proc~atat_build->proc~ivector_init proc~atat_build->proc~itbl_init proc~ia_add_vdw_forces->proc~ia_get_vdw_force proc~ia_get_tether_force ia_get_tether_force proc~ia_add_tether_forces->proc~ia_get_tether_force var panprogrammainCallsGraph = svgPanZoom('#programmainCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cla key val fn_control msg t_start t_end ierr icla ncla Variables Type Attributes Name Initial character(len=64) :: cla character(len=:), allocatable :: key character(len=:), allocatable :: val character(len=:), allocatable :: fn_control character(len=512) :: msg real(kind=rp) :: t_start real(kind=rp) :: t_end integer :: ierr integer :: icla integer :: ncla","tags":"","loc":"program/main.html"},{"title":"User Guide – BROWNPAK","text":"This is BROWNPAK. It can perform the following kinds of simulations: Energy minimization (also called structure relaxation) via steepest\n  descent. Brownian dynamics (BD) Multiparticle collision dynamics (MPCD) The source code is written in F2008 compliant fortran. There is a dependency on\nthe Intel Math Kernel Library (MKL). I have compiled the code with gfortran-8.3\ncompiler and MKL 2019 Update 4. Getting the source files The simplest way is to clone using git . Of course, this requires git to be\ninstalled on your system. If you do not want to clone, it is possible to\ndownload a zip file containing the source. Let's say you want to clone. Create a directory where you want the files to live. Say this directory is foo . mkdir foo cd foo Then clone the repo from GitHub thus: git clone https://github.com/saridut/BROWNPAK.git . That's it. Directory structure The directory structure is as follows: src contains the Fortran source files. There are some unused (not required/buggy?)\n source files in src/extra . bin contains the compiled executable, named brownpak . The executable can\n  be run directly from here, or from some other location with appropriately\n  specified path to the executable. It is best not to move around the\nexecutable, rather invoke the executable from the directory where you want to\nrun it. build is the build directory. It contains a makefile. It is necessary to\n  update the paths in the makefile to suit the local system. utils contains several utilities. There are python scripts the generate\n  initial configuration, fortran routines to extract configurations, etc. tests contains testing routines for development purposes. This need not be\n  necessarily present. docs contain files for generating autogenerated Fortran documentation (using FORD . To read the\n documentation, see here . Input and output files BROWNPAK reads several input files and produces several output files. The input\nfiles are: fn_control : This file contains various directives on what simulation to run,\n  time steps, etc. The directives are provided as a list of key-value pairs. The default name\n for this file is control.txt . fn_config : This file specifies the configuration of the system of be\n  simulated, i.e. atom positions, interactions, etc. The extension for this file\n  is .cfg , though it is not mandatory. The output files are: fn_traj : This is a binary file containing the trajectory data. These have\n  extension of .bin , though not mandatory. fn_stats : This is a text file containing a minimal set of statistics.\n  Further statistics may be obtained by post processing fn_traj . During\n  equilibration, the statistics will be written to a file called fn_stats.eq . brownpak.log : Log file. Check this for progress and error messsages For energy-minimization, two other files with -rlx in their names will be\n  produced. The file fn_config-rlx.cfg contains the minimized configuration,\nand the file fn_config-rlx.txt contains the same configuration in LAMMPS data\nformat for visualization in Ovito. Compilation and running There is a makefile in build . In the makefile, the DEBUG flag should be set\nto false for production builds. For testing purposes, set DEBUG = true . The compiler name is specified via the variable FC . e.g. for intel it will be\nappropriate to use FC = ifort . I use fortran95 wrappers to MKL as well. If one\nis using a non-Intel compiler, these wrappers need to be built (see the MKL\ndocumentation on how to do this). Anyways, since I am using gfortran, I specify the location of the\nwrappers through the variable MKL_INTRFC . Furthermore, MKLROOT is the root\ndirectory of the MKL installation. For an Intel compiler, MKL_INTRFC is not\nnecessary, but MKLROOT must be specified. It may be helpful to use the Intel\nLink Line Advisor for looking up appropriate flags. Appropriate compilation flags must be\nspecified via FCFLAGS . The current flags pertain to gfortran. For debug\nbuilds, the flags should turn off optimization, raise all warnings, check\nbounds, etc.; for production builds do turn on necessary optimization (without\nbeing too aggressive), loop unrolling, interprocedural optimizations, inlining,\netc. make To clean all .o and .mod files, do make clean To remove all .o , .mod , and the executable, do make clobber To run, the simplest way is to go to bin and ./brownpak fn_control = controlfile.txt job_tag = some_number Both the arguments fn_control and job_tag are optional.\nIf you do not specify the name of the control file, it will be assumed to be control.txt . The job_tag argument is there to help running array jobs on a\ncluster. For example, with SGE job scheduler I can request array jobs numbered\nfrom 1-16 and specify job_tag=$SGE_TASK_ID . Then all output files will have\nthe numbers 1-16 appended to their file names, like traj.bin.1, traj.bin.2, etc. Instead to running the executable from bin , you can run it from some other\ndirectory as path_to_bin/brownpak fn_control = controlfile.txt job_tag = some_number The above is more convenient with running multiple jobs on a cluster. Note that once compiled, if you change the source files a recompilation is\nnecessary. Unlike some codes that you may be familiar with, changing input files\ndo not require recompilation. Structure of the control file Here is a sample control file. It is called `control.txt. sim_style 2 use_verlet_tab F rcutoff 5 . 25 D0 tskin 2 . 1 D0 use_cell_list T excluded_atoms 1 lvdw T lhdia F mob_fctr KRYL lelectrostatics F tim_stp 1 . 0 D - 2 nts_md 100 nts_eql 0 . 0 D0 nts_eql_samp 10 nts_sim 2 . 0 D3 nts_samp 10 nts_dump 10 nts_log 10 fn_cfg sample . cfg fn_revive revive . bin fn_stats stats . txt fn_traj traj . bin lrevive F read_seed F write_seed T write_eql_stats T write_traj T traj_frmcmp 1 0 0 1 traj_wmpcd F As you can see, it lists a number of keywords and their corresponding values\nseparated by whitespace. The maximum length of a line is as specified in mxrdln . Note Each of the keywords in the control file is a variable listed in m_globals . Please look up the detailed description and possible set\nof allowed values there. Warning There are no checks performed on the consistency of the values provided\nin the control file. If you use unphysical values, your results may be incorrect\nor the program may crash. There can be blank lines between the keywords. Comments begin with # . If the # character is found on any line the rest of the line after # will be\ndiscarded. The keywords and the values must be separated by one or more whitespaces. I will elaborate on some specific aspects of the value format: Strings need not be quoted Booleans may be simply given as T or F instead of .true. or .false. Floats are always double precision, so please use *.D* fortran format. For\n  example, a value of 2.1 is single precision; instead specify it at 2.1D0 .\n  Other exponents are similar, e.g., 1.0D-2 for 0.01 . Values requiring uppercase letters must be given in that form, e.g. KRYL is\n  not the same a kryl . All the keywords starting with nts except nts_md are long ints. For\n  convenience these values may be given in *.D* format. Internally they will\n  be cast as long ints. mts_md is not a long int because it does not make\n  sense for it to be a large number, else the simulation will never complete. traj_frmcmp : See traj_frmcmp for details. Each element of the\n  sequence can be either 0 or 1 (separated by whitespaces), e.g. 1 1 1 1 or 1 0 0 1.\n  All four being zero is allowed, but makes no sense. Choosing nts_dump <= nts_samp is a good idea, but do not dump too frequently\n  either. Structure of the trajectory file The trajectory file is a binary file, i.e. it is a stream of bytes. The byte\norder is native. It can be read back in python (using struct to unpack), in\nfortran (opening the file with form='unformatted, access='stream' ), or in any\nother language. Warning If traj_wmpcd = T in the control file, the trajectory file can be\nextremely large. Explicit data for the position and velocities of MPCD atoms are\nrarely needed. MPCD atoms do not have forces or charge on them. I will call the trajectory file as traj.bin . It contains a header, followed by\na sequence of frames. The structure of the header is: header_size : 1 int (32 bits) frame_size : 1 int (32 bits) num_atoms : 1 int (32 bits). Number of non-MPCD atoms in the trajectory. num_mpcd_atoms : 1 int (32 bits). Number of MPCD atoms in the trajectory. frmcmp : 4 ints (32 bits each). Components of each frame, as specified by traj_frmcmp in the control file. During creation of a trajectory, num_atoms and num_mpcd_atoms are given\nto traj_create . Depending on traj_wmpcd , it is\npossible for an MPCD simulation to not write any MPCD data to traj.bin . This\nshould be the commonly used case. For BD/energy-minimization the value of traj_wmpcd does not matter. Following the header, there is a sequence of frame data, written according to traj_wmpcd and traj_frmcmp . Structure of the revive file The revive file is a binary dump. It contains enough information to restart the\nsimulation if lrevive = T in the control file. To see what gets dumped, please\nexamine the source for write_dump . Interactions The following kinds of interactions are available (or can be made available with\nminimal effort): Bonds All bonds have a type called bond_type . bond_type s are assigned\nby the user. For example, in a A-B diblock polymer, the user may choose A-A bonds\nas type 1, B-B bonds as type 2, and the A-B bond as type 3. Each bond_type is completely determined by a style , called bond_style ,\nand a set of parameters, called bond_params . bond_style s are chosen from the\nlist of available styles, as specified in m_ia_bond . The number of required\nparameters depend on the chosen style. The maximum number of parameters is mxparam .  For example, in our A-B diblock, the A-A bonds can be\nof type 1, with style 3 (corresponding to Kremer-Grest bond), and a set of four\nparameters; the B-B bonds can be of type 2, and also of style 3, with a set\nof four parameters, same as or different from the parameters of A-A bonds. Angles Similar to bonds, angles have types and styles as well. See m_ia_angle .\nOnly one non-trivial style is available, as this is the most commonly used\nstyle for polymers. However, more styles can be added if necessary. Dihedrals Dihedrals are not typically used in the kind of polymer models I deal with.\nSo, only the trivial style is present. In case you need a dihedral, add the\nappropriate routines to m_ia_dihedral . Tethers Tethers are pointwise restraints on one or more atoms. There can be multiple\ntethers, see m_ia_tether . Pairwise : See m_ia_vdw for a list. External : There is no working implementation of external interactions. The\n  idea is this: I do not know what kind of external interactions you need, but I\ndo not want to restrict you into a set of predefined interactions. So, please\nmodify the module m_ia_external to your choice, while keeping the interface\nintact. I assume you are a competent Fortran programmer, so that you will\nimmediately get it when you look at m_ia_external . A guiding principle is\nthat external interactions are generally fields that act on all the atoms in the\nsytem, but in some sense this covers everything. Remember to update the\nstress as you add external interactions. Structure of the config file Here is an extremely basic config file for a bunch of MPCD atoms. Sample SIMBOX 20 0 . 0 0 . 0 0 . 0 20 0 . 0 0 . 0 0 . 0 20 IMCON 1 ATOM_TYPES 0 MPCD_ATOMS 40000 5 ATOMS 0 MOLECULE_TYPES 0 MOLECULES 0 Please see the other examples in utils/models . It is best to use the python\nscripts to generate your config files. These scripts are self-explanatory. Restarting a simulation To restart a simulation, set nts_sim to a higher value in the control file\nand start the simulations. Note that an unusual situation may happen if you are\nrestarting after your job got killed/you deliberately killed it. In this case,\nit is possible that the data written in fn_stats and fn_traj are a few time\nsteps ahead of what is in fn_dump . This is most annoying; to get rid of such\nunwanted annoyances, I have written a small python script called sync.py that\nlives at utils/sync . This script basically compares both fn_traj and fn_stats with fn_dump and shaves off the extra records. You can run it\nbefore resubmitting a killed job. Use it with care, you may lose data. Workflow: Energy minimization Create an intial configuration. Say it is in file sample.cfg . Run the programme with sim_style = 0 . Monitor fn_stats , here the output energies will be written. The minimized\n   configuration will be written to sample-rlx.cfg . Moreover sample-rlx.txt (in LAMMPS data format) will be created, which you can visualize in Ovito. If\nnecessary, rerun by setting nts_sim to a higher value. Workflow: BD/MPCD Create an initial configuration. Minimize energy if you think this will be useful. It is usually useful. Use\n   the minimized configuration as the stating configuration for BD/MPCD\nsimulation. Set sim_style = 1 (for BD) or sim_style = 2 (for MPCD) and run. Rerun if necessary. Updating documentation (for developers) API documentation (Fortran files) is generated using FORD . As required by FORD,\nthe documentation is written in Markdown. All versions of Markdown may not be\nsupported, please experiment to see what works. Whole of GFM definitely doesn't. FORD also processes a User's Guide page, also written in Markdown. The source\nfor this is index.md in docs/pages . This may change in future, as I would\nprefer this to be in reStructuredText. The html pages generated by FORD is hosted on GitHub Pages for this\n  repository. For a number of reasons, pushing newly generated html pages is\nnot straightforward. These pages are pushed to the gh-pages branch, not to master . Assume that you have cloned the repo as usual, worked on it, and now you wish to update \nthe documentation. This will be done via git worktree. Commit your current work and push. From the root of the repo, first create a\nlinked worktree as follows: cd docs\ngit worktree add html gh-pages cd html This will create a linked worktree in the directory docs/html and enter it. If\nyou do git branch now, you will see the current branch to be gh-pages . docs/html is where the html pages will finally live. Now, clean it. git rm -rf . Next, create an empty file .nojekyll . This prevents Jekyll from fiddling\n  with stuff inside html . touch .nojekyll Change directory to docs . cd ../docs Create a temporary directory called docs/tmp . FORD will generate the html files here, which will be copied to docs/html . This is necessary because\nFORD deletes everything inside its output directory, including .git . mkdir tmp Run FORD. Move the html pages to html . Delete tmp . ford -o tmp brownpak.md\nmv tmp/* html/\nrm -r tmp Go in html , add, commit, and push to gh-pages . cd html\ngit add --all\ngit commit -a --allow-empty-message -m '' git push origin gh-pages Get back to docs . Then get rid of the worktree. cd ../docs\ngit worktree remove html","tags":"","loc":"page//index.html"}]}